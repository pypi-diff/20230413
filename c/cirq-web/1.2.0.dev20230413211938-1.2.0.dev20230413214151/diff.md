# Comparing `tmp/cirq_web-1.2.0.dev20230413211938-py3-none-any.whl.zip` & `tmp/cirq_web-1.2.0.dev20230413214151-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 594754 bytes, number of entries: 22
--rw-r--r--  2.0 unx      584 b- defN 23-Apr-13 21:19 cirq_ts/__init__.py
--rw-r--r--  2.0 unx       40 b- defN 23-Apr-13 21:19 cirq_ts/_version.py
--rw-r--r--  2.0 unx  1182664 b- defN 23-Apr-13 21:19 cirq_ts/dist/bloch_sphere.bundle.js
--rw-r--r--  2.0 unx  1182481 b- defN 23-Apr-13 21:19 cirq_ts/dist/circuit.bundle.js
--rw-r--r--  2.0 unx      751 b- defN 23-Apr-13 21:19 cirq_web/__init__.py
--rw-r--r--  2.0 unx       40 b- defN 23-Apr-13 21:19 cirq_web/_version.py
--rw-r--r--  2.0 unx      141 b- defN 23-Apr-13 21:19 cirq_web/_version_test.py
--rw-r--r--  2.0 unx     4006 b- defN 23-Apr-13 21:19 cirq_web/widget.py
--rw-r--r--  2.0 unx     2251 b- defN 23-Apr-13 21:19 cirq_web/widget_test.py
--rw-r--r--  2.0 unx      644 b- defN 23-Apr-13 21:19 cirq_web/bloch_sphere/__init__.py
--rw-r--r--  2.0 unx     2078 b- defN 23-Apr-13 21:19 cirq_web/bloch_sphere/bloch_sphere.py
--rw-r--r--  2.0 unx     2720 b- defN 23-Apr-13 21:19 cirq_web/bloch_sphere/bloch_sphere_test.py
--rw-r--r--  2.0 unx      689 b- defN 23-Apr-13 21:19 cirq_web/circuits/__init__.py
--rw-r--r--  2.0 unx     3762 b- defN 23-Apr-13 21:19 cirq_web/circuits/circuit.py
--rw-r--r--  2.0 unx     2752 b- defN 23-Apr-13 21:19 cirq_web/circuits/circuit_test.py
--rw-r--r--  2.0 unx     5383 b- defN 23-Apr-13 21:19 cirq_web/circuits/symbols.py
--rw-r--r--  2.0 unx     3128 b- defN 23-Apr-13 21:19 cirq_web/circuits/symbols_test.py
--rw-r--r--  2.0 unx    11357 b- defN 23-Apr-13 21:19 cirq_web-1.2.0.dev20230413211938.dist-info/LICENSE
--rw-r--r--  2.0 unx     2776 b- defN 23-Apr-13 21:19 cirq_web-1.2.0.dev20230413211938.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-13 21:19 cirq_web-1.2.0.dev20230413211938.dist-info/WHEEL
--rw-r--r--  2.0 unx       17 b- defN 23-Apr-13 21:19 cirq_web-1.2.0.dev20230413211938.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1920 b- defN 23-Apr-13 21:19 cirq_web-1.2.0.dev20230413211938.dist-info/RECORD
-22 files, 2410276 bytes uncompressed, 591608 bytes compressed:  75.5%
+Zip file size: 596503 bytes, number of entries: 22
+-rw-r--r--  2.0 unx      584 b- defN 23-Apr-13 21:41 cirq_ts/__init__.py
+-rw-r--r--  2.0 unx       40 b- defN 23-Apr-13 21:41 cirq_ts/_version.py
+-rw-r--r--  2.0 unx  1184321 b- defN 23-Apr-13 21:41 cirq_ts/dist/bloch_sphere.bundle.js
+-rw-r--r--  2.0 unx  1184138 b- defN 23-Apr-13 21:41 cirq_ts/dist/circuit.bundle.js
+-rw-r--r--  2.0 unx      751 b- defN 23-Apr-13 21:41 cirq_web/__init__.py
+-rw-r--r--  2.0 unx       40 b- defN 23-Apr-13 21:41 cirq_web/_version.py
+-rw-r--r--  2.0 unx      141 b- defN 23-Apr-13 21:41 cirq_web/_version_test.py
+-rw-r--r--  2.0 unx     4006 b- defN 23-Apr-13 21:41 cirq_web/widget.py
+-rw-r--r--  2.0 unx     2251 b- defN 23-Apr-13 21:41 cirq_web/widget_test.py
+-rw-r--r--  2.0 unx      644 b- defN 23-Apr-13 21:41 cirq_web/bloch_sphere/__init__.py
+-rw-r--r--  2.0 unx     2078 b- defN 23-Apr-13 21:41 cirq_web/bloch_sphere/bloch_sphere.py
+-rw-r--r--  2.0 unx     2720 b- defN 23-Apr-13 21:41 cirq_web/bloch_sphere/bloch_sphere_test.py
+-rw-r--r--  2.0 unx      689 b- defN 23-Apr-13 21:41 cirq_web/circuits/__init__.py
+-rw-r--r--  2.0 unx     3762 b- defN 23-Apr-13 21:41 cirq_web/circuits/circuit.py
+-rw-r--r--  2.0 unx     2752 b- defN 23-Apr-13 21:41 cirq_web/circuits/circuit_test.py
+-rw-r--r--  2.0 unx     5383 b- defN 23-Apr-13 21:41 cirq_web/circuits/symbols.py
+-rw-r--r--  2.0 unx     3128 b- defN 23-Apr-13 21:41 cirq_web/circuits/symbols_test.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-Apr-13 21:41 cirq_web-1.2.0.dev20230413214151.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2776 b- defN 23-Apr-13 21:41 cirq_web-1.2.0.dev20230413214151.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-13 21:41 cirq_web-1.2.0.dev20230413214151.dist-info/WHEEL
+-rw-r--r--  2.0 unx       17 b- defN 23-Apr-13 21:41 cirq_web-1.2.0.dev20230413214151.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1920 b- defN 23-Apr-13 21:41 cirq_web-1.2.0.dev20230413214151.dist-info/RECORD
+22 files, 2413590 bytes uncompressed, 593357 bytes compressed:  75.4%
```

## zipnote {}

```diff
@@ -45,23 +45,23 @@
 
 Filename: cirq_web/circuits/symbols.py
 Comment: 
 
 Filename: cirq_web/circuits/symbols_test.py
 Comment: 
 
-Filename: cirq_web-1.2.0.dev20230413211938.dist-info/LICENSE
+Filename: cirq_web-1.2.0.dev20230413214151.dist-info/LICENSE
 Comment: 
 
-Filename: cirq_web-1.2.0.dev20230413211938.dist-info/METADATA
+Filename: cirq_web-1.2.0.dev20230413214151.dist-info/METADATA
 Comment: 
 
-Filename: cirq_web-1.2.0.dev20230413211938.dist-info/WHEEL
+Filename: cirq_web-1.2.0.dev20230413214151.dist-info/WHEEL
 Comment: 
 
-Filename: cirq_web-1.2.0.dev20230413211938.dist-info/top_level.txt
+Filename: cirq_web-1.2.0.dev20230413214151.dist-info/top_level.txt
 Comment: 
 
-Filename: cirq_web-1.2.0.dev20230413211938.dist-info/RECORD
+Filename: cirq_web-1.2.0.dev20230413214151.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cirq_ts/_version.py

```diff
@@ -1 +1 @@
-__version__ = "1.2.0.dev20230413211938"
+__version__ = "1.2.0.dev20230413214151"
```

## cirq_ts/dist/bloch_sphere.bundle.js

### js-beautify {}

```diff
@@ -1,82 +1,444 @@
 /*! For license information please see bloch_sphere.bundle.js.LICENSE.txt */
 (() => {
     "use strict";
     var t = {
-            691: (t, e) => {
+            908: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.BlochSphere = void 0;
+                const i = n(78),
+                    r = n(429),
+                    s = n(510),
+                    a = n(649),
+                    o = n(692),
+                    l = n(69),
+                    c = n(232);
+                class h extends c.Group {
+                    constructor(t = 5, e = 7, n = 4) {
+                        return super(), this.radius = t, this.hMeridians = e, this.vMeridians = n, this.addSphere(), this.addHorizontalMeridians(), this.addVerticalMeridians(), this.addAxes(), this.addLabels(), this
+                    }
+                    addVector(t, e, n) {
+                        const i = new l.StateVector(t, e, n, this.radius);
+                        this.add(i)
+                    }
+                    addSphere() {
+                        const t = new r.Sphere(this.radius);
+                        this.add(t)
+                    }
+                    addAxes() {
+                        const t = new s.Axes(this.radius);
+                        this.add(t)
+                    }
+                    addHorizontalMeridians() {
+                        const t = new a.Meridians(this.radius, this.hMeridians, i.Orientation.HORIZONTAL);
+                        this.add(t)
+                    }
+                    addVerticalMeridians() {
+                        const t = new a.Meridians(this.radius, this.vMeridians, i.Orientation.VERTICAL);
+                        this.add(t)
+                    }
+                    addLabels() {
+                        const t = .5,
+                            e = {
+                                "|+⟩": new c.Vector3(this.radius + t, 0, 0),
+                                "|-⟩": new c.Vector3(-this.radius - t, 0, 0),
+                                "|i⟩": new c.Vector3(0, 0, -this.radius - t),
+                                "|-i⟩": new c.Vector3(0, 0, this.radius + t),
+                                "|0⟩": new c.Vector3(0, this.radius + t, 0),
+                                "|1⟩": new c.Vector3(0, -this.radius - t, 0)
+                            },
+                            n = new o.Labels(e);
+                        this.add(n)
+                    }
+                }
+                e.BlochSphere = h
+            },
+            510: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.Axes = void 0;
+                const i = n(232);
+                class r extends i.Group {
+                    constructor(t) {
+                        return super(), this.xAxisColor = "#1f51ff", this.yAxisColor = "#ff3131", this.zAxisColor = "#39ff14", this.halfLength = t, this.generateAxes(), this
+                    }
+                    generateAxes() {
+                        const t = [new i.Vector3(-this.halfLength, 0, 0), new i.Vector3(this.halfLength, 0, 0)],
+                            e = [new i.Vector3(0, 0, -this.halfLength), new i.Vector3(0, 0, this.halfLength)],
+                            n = [new i.Vector3(0, -this.halfLength, 0), new i.Vector3(0, this.halfLength, 0)],
+                            r = {
+                                x: this.asLine({
+                                    points: t,
+                                    hexColor: this.xAxisColor,
+                                    lineWidth: 1.5
+                                }),
+                                y: this.asLine({
+                                    points: e,
+                                    hexColor: this.yAxisColor,
+                                    lineWidth: 1.5
+                                }),
+                                z: this.asLine({
+                                    points: n,
+                                    hexColor: this.zAxisColor,
+                                    lineWidth: 1.5
+                                })
+                            };
+                        this.add(r.x), this.add(r.y), this.add(r.z)
+                    }
+                    asLine(t) {
+                        return new i.Line((new i.BufferGeometry).setFromPoints(t.points), new i.LineDashedMaterial({
+                            color: t.hexColor,
+                            linewidth: t.lineWidth,
+                            scale: 1,
+                            dashSize: .1,
+                            gapSize: .1
+                        })).computeLineDistances()
+                    }
+                }
+                e.Axes = r
+            },
+            78: (t, e) => {
+                var n;
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.Orientation = void 0, (n = e.Orientation || (e.Orientation = {}))[n.HORIZONTAL = 0] = "HORIZONTAL", n[n.VERTICAL = 1] = "VERTICAL"
+            },
+            649: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.Meridians = void 0;
+                const i = n(232),
+                    r = n(78);
+                class s extends i.Group {
+                    constructor(t, e, n) {
+                        switch (super(), this.color = "gray", this.radius = t, this.orientation = n, n) {
+                            case r.Orientation.HORIZONTAL:
+                                return this.numCircles = this.sanitizeCircleInput(e), this.createHorizontalChordMeridians(this.radius, this.numCircles), this;
+                            case r.Orientation.VERTICAL:
+                                return this.numCircles = this.sanitizeCircleInput(e), this.createVerticalMeridians(this.radius, this.numCircles), this;
+                            default:
+                                throw new Error("Invalid orientation input in Meridians constructor")
+                        }
+                    }
+                    createHorizontalChordMeridians(t, e) {
+                        if (0 === e) return;
+                        let n;
+                        n = e % 2 != 0 ? e - 1 : e;
+                        const i = n / 2;
+                        let s;
+                        s = 1 === e ? 0 : t - .5 * t / 5;
+                        const a = [0];
+                        for (let t = s; t > 0; t -= s / i) a.push(t), a.push(-t);
+                        for (const e of a) {
+                            const n = Math.pow(t, 2),
+                                i = Math.pow(e, 2),
+                                s = Math.sqrt(n - i),
+                                a = this.curveDataWithRadius(s),
+                                o = this.createMeridianCurve(a),
+                                l = this.createMeridianLine(o, Math.PI / 2, r.Orientation.HORIZONTAL, e);
+                            this.add(l)
+                        }
+                    }
+                    createVerticalMeridians(t, e) {
+                        if (0 === e) return;
+                        const n = {
+                            anchorX: 0,
+                            anchorY: 0,
+                            radius: t,
+                            startAngle: 0,
+                            endAngle: 2 * Math.PI,
+                            isClockwise: !1,
+                            rotation: 0
+                        };
+                        for (let t = 0; t < Math.PI; t += Math.PI / e) {
+                            const e = this.createMeridianCurve(n),
+                                i = this.createMeridianLine(e, t, r.Orientation.VERTICAL);
+                            this.add(i)
+                        }
+                    }
+                    createMeridianLine(t, e, n, s) {
+                        const a = t.getSpacedPoints(128),
+                            o = (new i.BufferGeometry).setFromPoints(a);
+                        switch (n) {
+                            case r.Orientation.HORIZONTAL:
+                                o.rotateX(e);
+                                break;
+                            case r.Orientation.VERTICAL:
+                                o.rotateY(e)
+                        }
+                        const l = new i.Line(o, new i.LineBasicMaterial({
+                            color: "gray"
+                        }));
+                        return s && (l.position.y = s), l
+                    }
+                    createMeridianCurve(t) {
+                        return new i.EllipseCurve(t.anchorX, t.anchorY, t.radius, t.radius, t.startAngle, t.endAngle, t.isClockwise, t.rotation)
+                    }
+                    curveDataWithRadius(t) {
+                        return {
+                            anchorX: 0,
+                            anchorY: 0,
+                            radius: t,
+                            startAngle: 0,
+                            endAngle: 2 * Math.PI,
+                            isClockwise: !1,
+                            rotation: 0
+                        }
+                    }
+                    sanitizeCircleInput(t) {
+                        if (t < 0) throw new Error("A negative number of meridians are not supported");
+                        if (t > 300) throw new Error("Over 300 meridians are not supported");
+                        return Math.floor(t)
+                    }
+                }
+                e.Meridians = s
+            },
+            643: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.BlochSphereScene = void 0;
+                const i = n(232),
+                    r = n(379);
+                class s extends i.Scene {
+                    constructor(t = 75, e = s.VIZ_HEIGHT / s.VIZ_WIDTH, n = .1, a = 1e3) {
+                        return super(), this.camera = new i.PerspectiveCamera(t, e, n, a), this.renderer = new i.WebGLRenderer({
+                            alpha: !0
+                        }), this.renderer.setSize(s.VIZ_WIDTH, s.VIZ_HEIGHT), this.controls = new r.OrbitControls(this.camera, this.renderer.domElement), this.init(), this
+                    }
+                    addSceneToHTMLContainer(t) {
+                        document.getElementById(t).appendChild(this.renderer.domElement)
+                    }
+                    init() {
+                        this.camera.position.x = 6, this.camera.position.y = 2, this.camera.position.z = 2, this.setUpControls(), this.setRenderSize(s.VIZ_WIDTH, s.VIZ_HEIGHT), this.animate()
+                    }
+                    setUpControls() {
+                        this.controls.enableDamping = !0, this.controls.dampingFactor = .05, this.controls.screenSpacePanning = !1, this.controls.minDistance = 10, this.controls.maxDistance = 50, this.controls.maxPolarAngle = Math.PI
+                    }
+                    setRenderSize(t, e) {
+                        this.renderer.setSize(t, e)
+                    }
+                    animate() {
+                        requestAnimationFrame(this.animate.bind(this)), this.controls.update(), this.renderer.render(this, this.camera)
+                    }
+                }
+                e.BlochSphereScene = s, s.VIZ_WIDTH = 500, s.VIZ_HEIGHT = 500
+            },
+            429: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.Sphere = void 0;
+                const i = n(232);
+                class r extends i.Group {
+                    constructor(t) {
+                        if (super(), t < 1) throw new Error("The radius of a Sphere must be greater than or equal to 1");
+                        return this.radius = t, this.createSphere(this.radius), this
+                    }
+                    createSphere(t) {
+                        const e = new i.SphereGeometry(t, 32, 32),
+                            n = new i.MeshNormalMaterial({
+                                opacity: .6,
+                                transparent: !0
+                            }),
+                            r = new i.Mesh(e, n);
+                        r.geometry.computeVertexNormals(), this.add(r)
+                    }
+                }
+                e.Sphere = r
+            },
+            69: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.StateVector = void 0;
+                const i = n(232);
+                class r extends i.Group {
+                    constructor(t, e, n, i) {
+                        return super(), this.x = t, this.y = e, this.z = n, this.blochSphereRadius = i, this.generateVector(this.x, this.y, this.z, this.blochSphereRadius), this
+                    }
+                    generateVector(t, e, n, r) {
+                        const s = new i.Vector3(t, e, n),
+                            a = new i.Vector3(1, 0, 0),
+                            o = -Math.PI / 2;
+                        s.applyAxisAngle(a, o);
+                        const l = new i.Vector3(0, 0, 0),
+                            c = l.distanceTo(s) * r,
+                            h = new i.ArrowHelper(s, l, c, "#800080", void 0, 1);
+                        h.line.material.linewidth = 20, this.add(h)
+                    }
+                }
+                e.StateVector = r
+            },
+            692: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.Label = e.Labels = void 0;
+                const i = n(232);
+                class r extends i.Group {
+                    constructor(t) {
+                        return super(), this.labels = t, this.generateLabels(this.labels), this
+                    }
+                    generateLabels(t) {
+                        for (const [e, n] of Object.entries(t)) this.add(new s(e, n))
+                    }
+                }
+                e.Labels = r;
+                class s extends i.Sprite {
+                    constructor(t, e) {
+                        const n = function(t) {
+                            const e = 256,
+                                n = document.createElement("canvas");
+                            n.width = e, n.height = e, n.textContent = t;
+                            const r = n.getContext("2d");
+                            r.fillStyle = "#000000", r.textAlign = "center", r.font = "120px Arial", r.fillText(t, 128, 128);
+                            const s = new i.Texture(n);
+                            return s.needsUpdate = !0, new i.SpriteMaterial({
+                                map: s,
+                                transparent: !0
+                            })
+                        }(t);
+                        return super(n), this.text = t, this.position.copy(e), this
+                    }
+                }
+                e.Label = s
+            },
+            232: (t, e) => {
                 Object.defineProperty(e, "__esModule", {
                     value: !0
                 });
                 const n = "137",
-                    i = 100,
-                    r = 300,
-                    s = 301,
-                    a = 302,
-                    o = 303,
-                    l = 304,
-                    c = 306,
-                    h = 307,
-                    u = 1e3,
-                    d = 1001,
-                    p = 1002,
-                    m = 1003,
-                    f = 1004,
-                    g = 1005,
-                    v = 1006,
-                    x = 1007,
-                    y = 1008,
-                    _ = 1009,
-                    M = 1012,
-                    b = 1014,
-                    w = 1015,
-                    S = 1016,
-                    E = 1020,
-                    T = 1023,
-                    A = 1026,
-                    R = 1027,
-                    L = 33776,
-                    C = 33777,
-                    P = 33778,
-                    D = 33779,
-                    I = 35840,
-                    N = 35841,
-                    O = 35842,
-                    U = 35843,
-                    B = 37492,
-                    F = 37496,
-                    z = 37808,
-                    H = 37809,
-                    G = 37810,
-                    V = 37811,
-                    k = 37812,
-                    W = 37813,
-                    j = 37814,
-                    X = 37815,
-                    q = 37816,
-                    Y = 37817,
-                    Z = 37818,
-                    J = 37819,
-                    K = 37820,
-                    Q = 37821,
-                    $ = 36492,
-                    tt = 2300,
-                    et = 2301,
-                    nt = 2302,
-                    it = 2400,
-                    rt = 2401,
-                    st = 2402,
-                    at = 2501,
-                    ot = 3e3,
-                    lt = 3001,
-                    ct = 7680,
-                    ht = 35044,
-                    ut = 35048,
-                    dt = "300 es",
-                    pt = 1035;
-                class mt {
+                    i = 0,
+                    r = 1,
+                    s = 2,
+                    a = 1,
+                    o = 2,
+                    l = 3,
+                    c = 0,
+                    h = 1,
+                    u = 2,
+                    d = 0,
+                    p = 1,
+                    m = 2,
+                    f = 3,
+                    g = 4,
+                    v = 5,
+                    x = 100,
+                    y = 101,
+                    _ = 102,
+                    M = 103,
+                    b = 104,
+                    w = 200,
+                    S = 201,
+                    E = 202,
+                    T = 203,
+                    A = 204,
+                    R = 205,
+                    L = 206,
+                    C = 207,
+                    P = 208,
+                    D = 209,
+                    I = 210,
+                    N = 0,
+                    O = 1,
+                    U = 2,
+                    B = 3,
+                    F = 4,
+                    z = 5,
+                    H = 6,
+                    G = 7,
+                    V = 0,
+                    k = 1,
+                    W = 2,
+                    j = 0,
+                    X = 1,
+                    q = 2,
+                    Y = 3,
+                    Z = 4,
+                    J = 5,
+                    K = 300,
+                    Q = 301,
+                    $ = 302,
+                    tt = 303,
+                    et = 304,
+                    nt = 306,
+                    it = 307,
+                    rt = 1e3,
+                    st = 1001,
+                    at = 1002,
+                    ot = 1003,
+                    lt = 1004,
+                    ct = 1005,
+                    ht = 1006,
+                    ut = 1007,
+                    dt = 1008,
+                    pt = 1009,
+                    mt = 1010,
+                    ft = 1011,
+                    gt = 1012,
+                    vt = 1013,
+                    xt = 1014,
+                    yt = 1015,
+                    _t = 1016,
+                    Mt = 1017,
+                    bt = 1018,
+                    wt = 1020,
+                    St = 1021,
+                    Et = 1023,
+                    Tt = 1024,
+                    At = 1025,
+                    Rt = 1026,
+                    Lt = 1027,
+                    Ct = 1028,
+                    Pt = 1029,
+                    Dt = 1030,
+                    It = 1031,
+                    Nt = 1033,
+                    Ot = 33776,
+                    Ut = 33777,
+                    Bt = 33778,
+                    Ft = 33779,
+                    zt = 35840,
+                    Ht = 35841,
+                    Gt = 35842,
+                    Vt = 35843,
+                    kt = 36196,
+                    Wt = 37492,
+                    jt = 37496,
+                    Xt = 37808,
+                    qt = 37809,
+                    Yt = 37810,
+                    Zt = 37811,
+                    Jt = 37812,
+                    Kt = 37813,
+                    Qt = 37814,
+                    $t = 37815,
+                    te = 37816,
+                    ee = 37817,
+                    ne = 37818,
+                    ie = 37819,
+                    re = 37820,
+                    se = 37821,
+                    ae = 36492,
+                    oe = 2300,
+                    le = 2301,
+                    ce = 2302,
+                    he = 2400,
+                    ue = 2401,
+                    de = 2402,
+                    pe = 2501,
+                    me = 3e3,
+                    fe = 3001,
+                    ge = 3201,
+                    ve = 0,
+                    xe = 1,
+                    ye = 7680,
+                    _e = 35044,
+                    Me = 35048,
+                    be = "300 es",
+                    we = 1035;
+                class Se {
                     addEventListener(t, e) {
                         void 0 === this._listeners && (this._listeners = {});
                         const n = this._listeners;
                         void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                     }
                     hasEventListener(t, e) {
                         if (void 0 === this._listeners) return !1;
@@ -97,70 +459,70 @@
                             t.target = this;
                             const n = e.slice(0);
                             for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                             t.target = null
                         }
                     }
                 }
-                const ft = [];
-                for (let t = 0; t < 256; t++) ft[t] = (t < 16 ? "0" : "") + t.toString(16);
-                let gt = 1234567;
-                const vt = Math.PI / 180,
-                    xt = 180 / Math.PI;
+                const Ee = [];
+                for (let t = 0; t < 256; t++) Ee[t] = (t < 16 ? "0" : "") + t.toString(16);
+                let Te = 1234567;
+                const Ae = Math.PI / 180,
+                    Re = 180 / Math.PI;
 
-                function yt() {
+                function Le() {
                     const t = 4294967295 * Math.random() | 0,
                         e = 4294967295 * Math.random() | 0,
                         n = 4294967295 * Math.random() | 0,
                         i = 4294967295 * Math.random() | 0;
-                    return (ft[255 & t] + ft[t >> 8 & 255] + ft[t >> 16 & 255] + ft[t >> 24 & 255] + "-" + ft[255 & e] + ft[e >> 8 & 255] + "-" + ft[e >> 16 & 15 | 64] + ft[e >> 24 & 255] + "-" + ft[63 & n | 128] + ft[n >> 8 & 255] + "-" + ft[n >> 16 & 255] + ft[n >> 24 & 255] + ft[255 & i] + ft[i >> 8 & 255] + ft[i >> 16 & 255] + ft[i >> 24 & 255]).toUpperCase()
+                    return (Ee[255 & t] + Ee[t >> 8 & 255] + Ee[t >> 16 & 255] + Ee[t >> 24 & 255] + "-" + Ee[255 & e] + Ee[e >> 8 & 255] + "-" + Ee[e >> 16 & 15 | 64] + Ee[e >> 24 & 255] + "-" + Ee[63 & n | 128] + Ee[n >> 8 & 255] + "-" + Ee[n >> 16 & 255] + Ee[n >> 24 & 255] + Ee[255 & i] + Ee[i >> 8 & 255] + Ee[i >> 16 & 255] + Ee[i >> 24 & 255]).toUpperCase()
                 }
 
-                function _t(t, e, n) {
+                function Ce(t, e, n) {
                     return Math.max(e, Math.min(n, t))
                 }
 
-                function Mt(t, e) {
+                function Pe(t, e) {
                     return (t % e + e) % e
                 }
 
-                function bt(t, e, n) {
+                function De(t, e, n) {
                     return (1 - n) * t + n * e
                 }
 
-                function wt(t) {
+                function Ie(t) {
                     return 0 == (t & t - 1) && 0 !== t
                 }
 
-                function St(t) {
+                function Ne(t) {
                     return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                 }
 
-                function Et(t) {
+                function Oe(t) {
                     return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                 }
-                var Tt = Object.freeze({
+                var Ue = Object.freeze({
                     __proto__: null,
-                    DEG2RAD: vt,
-                    RAD2DEG: xt,
-                    generateUUID: yt,
-                    clamp: _t,
-                    euclideanModulo: Mt,
+                    DEG2RAD: Ae,
+                    RAD2DEG: Re,
+                    generateUUID: Le,
+                    clamp: Ce,
+                    euclideanModulo: Pe,
                     mapLinear: function(t, e, n, i, r) {
                         return i + (t - e) * (r - i) / (n - e)
                     },
                     inverseLerp: function(t, e, n) {
                         return t !== e ? (n - t) / (e - t) : 0
                     },
-                    lerp: bt,
+                    lerp: De,
                     damp: function(t, e, n, i) {
-                        return bt(t, e, 1 - Math.exp(-n * i))
+                        return De(t, e, 1 - Math.exp(-n * i))
                     },
                     pingpong: function(t, e = 1) {
-                        return e - Math.abs(Mt(t, 2 * e) - e)
+                        return e - Math.abs(Pe(t, 2 * e) - e)
                     },
                     smoothstep: function(t, e, n) {
                         return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                     },
                     smootherstep: function(t, e, n) {
                         return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                     },
@@ -170,25 +532,25 @@
                     randFloat: function(t, e) {
                         return t + Math.random() * (e - t)
                     },
                     randFloatSpread: function(t) {
                         return t * (.5 - Math.random())
                     },
                     seededRandom: function(t) {
-                        return void 0 !== t && (gt = t % 2147483647), gt = 16807 * gt % 2147483647, (gt - 1) / 2147483646
+                        return void 0 !== t && (Te = t % 2147483647), Te = 16807 * Te % 2147483647, (Te - 1) / 2147483646
                     },
                     degToRad: function(t) {
-                        return t * vt
+                        return t * Ae
                     },
                     radToDeg: function(t) {
-                        return t * xt
+                        return t * Re
                     },
-                    isPowerOfTwo: wt,
-                    ceilPowerOfTwo: St,
-                    floorPowerOfTwo: Et,
+                    isPowerOfTwo: Ie,
+                    ceilPowerOfTwo: Ne,
+                    floorPowerOfTwo: Oe,
                     setQuaternionFromProperEuler: function(t, e, n, i, r) {
                         const s = Math.cos,
                             a = Math.sin,
                             o = s(n / 2),
                             l = a(n / 2),
                             c = s((e + i) / 2),
                             h = a((e + i) / 2),
@@ -216,15 +578,15 @@
                                 t.set(l * m, l * p, o * h, o * c);
                                 break;
                             default:
                                 console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                         }
                     }
                 });
-                class At {
+                class Be {
                     constructor(t = 0, e = 0) {
                         this.x = t, this.y = e
                     }
                     get width() {
                         return this.x
                     }
                     set width(t) {
@@ -409,16 +771,16 @@
                     }
                     random() {
                         return this.x = Math.random(), this.y = Math.random(), this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y
                     }
                 }
-                At.prototype.isVector2 = !0;
-                class Rt {
+                Be.prototype.isVector2 = !0;
+                class Fe {
                     constructor() {
                         this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                     }
                     set(t, e, n, i, r, s, a, o, l) {
                         const c = this.elements;
                         return c[0] = t, c[1] = i, c[2] = a, c[3] = e, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this
                     }
@@ -556,40 +918,40 @@
                         return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                     }
                     clone() {
                         return (new this.constructor).fromArray(this.elements)
                     }
                 }
 
-                function Lt(t) {
+                function ze(t) {
                     for (let e = t.length - 1; e >= 0; --e)
                         if (t[e] > 65535) return !0;
                     return !1
                 }
-                Rt.prototype.isMatrix3 = !0;
-                const Ct = {
+                Fe.prototype.isMatrix3 = !0;
+                const He = {
                     Int8Array,
                     Uint8Array,
                     Uint8ClampedArray,
                     Int16Array,
                     Uint16Array,
                     Int32Array,
                     Uint32Array,
                     Float32Array,
                     Float64Array
                 };
 
-                function Pt(t, e) {
-                    return new Ct[t](e)
+                function Ge(t, e) {
+                    return new He[t](e)
                 }
 
-                function Dt(t) {
+                function Ve(t) {
                     return document.createElementNS("http://www.w3.org/1999/xhtml", t)
                 }
-                const It = {
+                const ke = {
                         aliceblue: 15792383,
                         antiquewhite: 16444375,
                         aqua: 65535,
                         aquamarine: 8388564,
                         azure: 15794175,
                         beige: 16119260,
                         bisque: 16770244,
@@ -731,37 +1093,37 @@
                         violet: 15631086,
                         wheat: 16113331,
                         white: 16777215,
                         whitesmoke: 16119285,
                         yellow: 16776960,
                         yellowgreen: 10145074
                     },
-                    Nt = {
+                    We = {
                         h: 0,
                         s: 0,
                         l: 0
                     },
-                    Ot = {
+                    je = {
                         h: 0,
                         s: 0,
                         l: 0
                     };
 
-                function Ut(t, e, n) {
+                function Xe(t, e, n) {
                     return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                 }
 
-                function Bt(t) {
+                function qe(t) {
                     return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                 }
 
-                function Ft(t) {
+                function Ye(t) {
                     return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                 }
-                class zt {
+                class Ze {
                     constructor(t, e, n) {
                         return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
                     }
                     set(t) {
                         return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                     }
                     setScalar(t) {
@@ -770,19 +1132,19 @@
                     setHex(t) {
                         return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                     }
                     setRGB(t, e, n) {
                         return this.r = t, this.g = e, this.b = n, this
                     }
                     setHSL(t, e, n) {
-                        if (t = Mt(t, 1), e = _t(e, 0, 1), n = _t(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
+                        if (t = Pe(t, 1), e = Ce(e, 0, 1), n = Ce(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                         else {
                             const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                                 r = 2 * n - i;
-                            this.r = Ut(r, i, t + 1 / 3), this.g = Ut(r, i, t), this.b = Ut(r, i, t - 1 / 3)
+                            this.r = Xe(r, i, t + 1 / 3), this.g = Xe(r, i, t), this.b = Xe(r, i, t - 1 / 3)
                         }
                         return this
                     }
                     setStyle(t) {
                         function e(e) {
                             void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                         }
@@ -811,28 +1173,28 @@
                                 e = t.length;
                             if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                             if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                         }
                         return t && t.length > 0 ? this.setColorName(t) : this
                     }
                     setColorName(t) {
-                        const e = It[t.toLowerCase()];
+                        const e = ke[t.toLowerCase()];
                         return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
                     }
                     clone() {
                         return new this.constructor(this.r, this.g, this.b)
                     }
                     copy(t) {
                         return this.r = t.r, this.g = t.g, this.b = t.b, this
                     }
                     copySRGBToLinear(t) {
-                        return this.r = Bt(t.r), this.g = Bt(t.g), this.b = Bt(t.b), this
+                        return this.r = qe(t.r), this.g = qe(t.g), this.b = qe(t.b), this
                     }
                     copyLinearToSRGB(t) {
-                        return this.r = Ft(t.r), this.g = Ft(t.g), this.b = Ft(t.b), this
+                        return this.r = Ye(t.r), this.g = Ye(t.g), this.b = Ye(t.b), this
                     }
                     convertSRGBToLinear() {
                         return this.copySRGBToLinear(this), this
                     }
                     convertLinearToSRGB() {
                         return this.copyLinearToSRGB(this), this
                     }
@@ -867,15 +1229,15 @@
                         }
                         return t.h = a, t.s = o, t.l = l, t
                     }
                     getStyle() {
                         return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                     }
                     offsetHSL(t, e, n) {
-                        return this.getHSL(Nt), Nt.h += t, Nt.s += e, Nt.l += n, this.setHSL(Nt.h, Nt.s, Nt.l), this
+                        return this.getHSL(We), We.h += t, We.s += e, We.l += n, this.setHSL(We.h, We.s, We.l), this
                     }
                     add(t) {
                         return this.r += t.r, this.g += t.g, this.b += t.b, this
                     }
                     addColors(t, e) {
                         return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                     }
@@ -894,18 +1256,18 @@
                     lerp(t, e) {
                         return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                     }
                     lerpColors(t, e, n) {
                         return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
                     }
                     lerpHSL(t, e) {
-                        this.getHSL(Nt), t.getHSL(Ot);
-                        const n = bt(Nt.h, Ot.h, e),
-                            i = bt(Nt.s, Ot.s, e),
-                            r = bt(Nt.l, Ot.l, e);
+                        this.getHSL(We), t.getHSL(je);
+                        const n = De(We.h, je.h, e),
+                            i = De(We.s, je.s, e),
+                            r = De(We.l, je.l, e);
                         return this.setHSL(n, i, r), this
                     }
                     equals(t) {
                         return t.r === this.r && t.g === this.g && t.b === this.b
                     }
                     fromArray(t, e = 0) {
                         return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
@@ -916,58 +1278,58 @@
                     fromBufferAttribute(t, e) {
                         return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                     }
                     toJSON() {
                         return this.getHex()
                     }
                 }
-                let Ht;
-                zt.NAMES = It, zt.prototype.isColor = !0, zt.prototype.r = 1, zt.prototype.g = 1, zt.prototype.b = 1;
-                class Gt {
+                let Je;
+                Ze.NAMES = ke, Ze.prototype.isColor = !0, Ze.prototype.r = 1, Ze.prototype.g = 1, Ze.prototype.b = 1;
+                class Ke {
                     static getDataURL(t) {
                         if (/^data:/i.test(t.src)) return t.src;
                         if ("undefined" == typeof HTMLCanvasElement) return t.src;
                         let e;
                         if (t instanceof HTMLCanvasElement) e = t;
                         else {
-                            void 0 === Ht && (Ht = Dt("canvas")), Ht.width = t.width, Ht.height = t.height;
-                            const n = Ht.getContext("2d");
-                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Ht
+                            void 0 === Je && (Je = Ve("canvas")), Je.width = t.width, Je.height = t.height;
+                            const n = Je.getContext("2d");
+                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Je
                         }
                         return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                     }
                     static sRGBToLinear(t) {
                         if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
-                            const e = Dt("canvas");
+                            const e = Ve("canvas");
                             e.width = t.width, e.height = t.height;
                             const n = e.getContext("2d");
                             n.drawImage(t, 0, 0, t.width, t.height);
                             const i = n.getImageData(0, 0, t.width, t.height),
                                 r = i.data;
-                            for (let t = 0; t < r.length; t++) r[t] = 255 * Bt(r[t] / 255);
+                            for (let t = 0; t < r.length; t++) r[t] = 255 * qe(r[t] / 255);
                             return n.putImageData(i, 0, 0), e
                         }
                         if (t.data) {
                             const e = t.data.slice(0);
-                            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * Bt(e[t] / 255)) : e[t] = Bt(e[t]);
+                            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * qe(e[t] / 255)) : e[t] = qe(e[t]);
                             return {
                                 data: e,
                                 width: t.width,
                                 height: t.height
                             }
                         }
                         return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
                     }
                 }
-                let Vt = 0;
-                class kt extends mt {
-                    constructor(t = kt.DEFAULT_IMAGE, e = kt.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = 1, c = 3e3) {
+                let Qe = 0;
+                class $e extends Se {
+                    constructor(t = $e.DEFAULT_IMAGE, e = $e.DEFAULT_MAPPING, n = st, i = st, r = ht, s = dt, a = Et, o = pt, l = 1, c = me) {
                         super(), Object.defineProperty(this, "id", {
-                            value: Vt++
-                        }), this.uuid = yt(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new At(0, 0), this.repeat = new At(1, 1), this.center = new At(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Rt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
+                            value: Qe++
+                        }), this.uuid = Le(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new Be(0, 0), this.repeat = new Be(1, 1), this.center = new Be(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Fe, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                     }
                     updateMatrix() {
                         this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
@@ -999,20 +1361,20 @@
                             anisotropy: this.anisotropy,
                             flipY: this.flipY,
                             premultiplyAlpha: this.premultiplyAlpha,
                             unpackAlignment: this.unpackAlignment
                         };
                         if (void 0 !== this.image) {
                             const i = this.image;
-                            if (void 0 === i.uuid && (i.uuid = yt()), !e && void 0 === t.images[i.uuid]) {
+                            if (void 0 === i.uuid && (i.uuid = Le()), !e && void 0 === t.images[i.uuid]) {
                                 let e;
                                 if (Array.isArray(i)) {
                                     e = [];
-                                    for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(Wt(i[t].image)) : e.push(Wt(i[t]))
-                                } else e = Wt(i);
+                                    for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(tn(i[t].image)) : e.push(tn(i[t]))
+                                } else e = tn(i);
                                 t.images[i.uuid] = {
                                     uuid: i.uuid,
                                     url: e
                                 }
                             }
                             n.image = i.uuid
                         }
@@ -1020,52 +1382,52 @@
                     }
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                     transformUv(t) {
-                        if (this.mapping !== r) return t;
+                        if (this.mapping !== K) return t;
                         if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
-                            case u:
+                            case rt:
                                 t.x = t.x - Math.floor(t.x);
                                 break;
-                            case d:
+                            case st:
                                 t.x = t.x < 0 ? 0 : 1;
                                 break;
-                            case p:
+                            case at:
                                 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                         }
                         if (t.y < 0 || t.y > 1) switch (this.wrapT) {
-                            case u:
+                            case rt:
                                 t.y = t.y - Math.floor(t.y);
                                 break;
-                            case d:
+                            case st:
                                 t.y = t.y < 0 ? 0 : 1;
                                 break;
-                            case p:
+                            case at:
                                 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                         }
                         return this.flipY && (t.y = 1 - t.y), t
                     }
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                 }
 
-                function Wt(t) {
-                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Gt.getDataURL(t) : t.data ? {
+                function tn(t) {
+                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Ke.getDataURL(t) : t.data ? {
                         data: Array.prototype.slice.call(t.data),
                         width: t.width,
                         height: t.height,
                         type: t.data.constructor.name
                     } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
                 }
-                kt.DEFAULT_IMAGE = void 0, kt.DEFAULT_MAPPING = r, kt.prototype.isTexture = !0;
-                class jt {
+                $e.DEFAULT_IMAGE = void 0, $e.DEFAULT_MAPPING = K, $e.prototype.isTexture = !0;
+                class en {
                     constructor(t = 0, e = 0, n = 0, i = 1) {
                         this.x = t, this.y = e, this.z = n, this.w = i
                     }
                     get width() {
                         return this.z
                     }
                     set width(t) {
@@ -1274,22 +1636,22 @@
                     }
                     random() {
                         return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y, yield this.z, yield this.w
                     }
                 }
-                jt.prototype.isVector4 = !0;
-                class Xt extends mt {
+                en.prototype.isVector4 = !0;
+                class nn extends Se {
                     constructor(t, e, n = {}) {
-                        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new jt(0, 0, t, e), this.scissorTest = !1, this.viewport = new jt(0, 0, t, e), this.texture = new kt(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
+                        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new en(0, 0, t, e), this.scissorTest = !1, this.viewport = new en(0, 0, t, e), this.texture = new $e(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                             width: t,
                             height: e,
                             depth: 1
-                        }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : v, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
+                        }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ht, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
                     }
                     setTexture(t) {
                         t.image = {
                             width: this.width,
                             height: this.height,
                             depth: this.depth
                         }, this.texture = t
@@ -1305,16 +1667,16 @@
                     }
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }
-                Xt.prototype.isWebGLRenderTarget = !0;
-                class qt extends Xt {
+                nn.prototype.isWebGLRenderTarget = !0;
+                class rn extends nn {
                     constructor(t, e, n) {
                         super(t, e);
                         const i = this.texture;
                         this.texture = [];
                         for (let t = 0; t < n; t++) this.texture[t] = i.clone()
                     }
                     setSize(t, e, n = 1) {
@@ -1327,25 +1689,25 @@
                     }
                     copy(t) {
                         this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
                         for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
                         return this
                     }
                 }
-                qt.prototype.isWebGLMultipleRenderTargets = !0;
-                class Yt extends Xt {
+                rn.prototype.isWebGLMultipleRenderTargets = !0;
+                class sn extends nn {
                     constructor(t, e, n = {}) {
                         super(t, e, n), this.samples = 4, this.ignoreDepthForMultisampleCopy = void 0 === n.ignoreDepth || n.ignoreDepth, this.useRenderToTexture = void 0 !== n.useRenderToTexture && n.useRenderToTexture, this.useRenderbuffer = !1 === this.useRenderToTexture
                     }
                     copy(t) {
                         return super.copy.call(this, t), this.samples = t.samples, this.useRenderToTexture = t.useRenderToTexture, this.useRenderbuffer = t.useRenderbuffer, this
                     }
                 }
-                Yt.prototype.isWebGLMultisampleRenderTarget = !0;
-                class Zt {
+                sn.prototype.isWebGLMultisampleRenderTarget = !0;
+                class an {
                     constructor(t = 0, e = 0, n = 0, i = 1) {
                         this._x = t, this._y = e, this._z = n, this._w = i
                     }
                     static slerp(t, e, n, i) {
                         return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i)
                     }
                     static slerpFlat(t, e, n, i, r, s, a) {
@@ -1492,15 +1854,15 @@
                         return this._onChangeCallback(), this
                     }
                     setFromUnitVectors(t, e) {
                         let n = t.dot(e) + 1;
                         return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                     }
                     angleTo(t) {
-                        return 2 * Math.acos(Math.abs(_t(this.dot(t), -1, 1)))
+                        return 2 * Math.acos(Math.abs(Ce(this.dot(t), -1, 1)))
                     }
                     rotateTowards(t, e) {
                         const n = this.angleTo(t);
                         if (0 === n) return this;
                         const i = Math.min(1, e / n);
                         return this.slerp(t, i), this
                     }
@@ -1587,16 +1949,16 @@
                         return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                     }
                     _onChange(t) {
                         return this._onChangeCallback = t, this
                     }
                     _onChangeCallback() {}
                 }
-                Zt.prototype.isQuaternion = !0;
-                class Jt {
+                an.prototype.isQuaternion = !0;
+                class on {
                     constructor(t = 0, e = 0, n = 0) {
                         this.x = t, this.y = e, this.z = n
                     }
                     set(t, e, n) {
                         return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
                     }
                     setScalar(t) {
@@ -1672,18 +2034,18 @@
                     multiplyScalar(t) {
                         return this.x *= t, this.y *= t, this.z *= t, this
                     }
                     multiplyVectors(t, e) {
                         return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                     }
                     applyEuler(t) {
-                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Qt.setFromEuler(t))
+                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(cn.setFromEuler(t))
                     }
                     applyAxisAngle(t, e) {
-                        return this.applyQuaternion(Qt.setFromAxisAngle(t, e))
+                        return this.applyQuaternion(cn.setFromAxisAngle(t, e))
                     }
                     applyMatrix3(t) {
                         const e = this.x,
                             n = this.y,
                             i = this.z,
                             r = t.elements;
                         return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
@@ -1802,24 +2164,24 @@
                     projectOnVector(t) {
                         const e = t.lengthSq();
                         if (0 === e) return this.set(0, 0, 0);
                         const n = t.dot(this) / e;
                         return this.copy(t).multiplyScalar(n)
                     }
                     projectOnPlane(t) {
-                        return Kt.copy(this).projectOnVector(t), this.sub(Kt)
+                        return ln.copy(this).projectOnVector(t), this.sub(ln)
                     }
                     reflect(t) {
-                        return this.sub(Kt.copy(t).multiplyScalar(2 * this.dot(t)))
+                        return this.sub(ln.copy(t).multiplyScalar(2 * this.dot(t)))
                     }
                     angleTo(t) {
                         const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                         if (0 === e) return Math.PI / 2;
                         const n = this.dot(t) / e;
-                        return Math.acos(_t(n, -1, 1))
+                        return Math.acos(Ce(n, -1, 1))
                     }
                     distanceTo(t) {
                         return Math.sqrt(this.distanceToSquared(t))
                     }
                     distanceToSquared(t) {
                         const e = this.x - t.x,
                             n = this.y - t.y,
@@ -1878,19 +2240,19 @@
                             e = Math.random() * Math.PI * 2,
                             n = Math.sqrt(1 - t ** 2);
                         return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y, yield this.z
                     }
                 }
-                Jt.prototype.isVector3 = !0;
-                const Kt = new Jt,
-                    Qt = new Zt;
-                class $t {
-                    constructor(t = new Jt(1 / 0, 1 / 0, 1 / 0), e = new Jt(-1 / 0, -1 / 0, -1 / 0)) {
+                on.prototype.isVector3 = !0;
+                const ln = new on,
+                    cn = new an;
+                class hn {
+                    constructor(t = new on(1 / 0, 1 / 0, 1 / 0), e = new on(-1 / 0, -1 / 0, -1 / 0)) {
                         this.min = t, this.max = e
                     }
                     set(t, e) {
                         return this.min.copy(t), this.max.copy(e), this
                     }
                     setFromArray(t) {
                         let e = 1 / 0,
@@ -1924,15 +2286,15 @@
                     }
                     setFromPoints(t) {
                         this.makeEmpty();
                         for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                         return this
                     }
                     setFromCenterAndSize(t, e) {
-                        const n = ee.copy(e).multiplyScalar(.5);
+                        const n = dn.copy(e).multiplyScalar(.5);
                         return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                     }
                     setFromObject(t, e = !1) {
                         return this.makeEmpty(), this.expandByObject(t, e)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
@@ -1963,16 +2325,16 @@
                     }
                     expandByObject(t, e = !1) {
                         t.updateWorldMatrix(!1, !1);
                         const n = t.geometry;
                         if (void 0 !== n)
                             if (e && null != n.attributes && void 0 !== n.attributes.position) {
                                 const e = n.attributes.position;
-                                for (let n = 0, i = e.count; n < i; n++) ee.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(ee)
-                            } else null === n.boundingBox && n.computeBoundingBox(), ne.copy(n.boundingBox), ne.applyMatrix4(t.matrixWorld), this.union(ne);
+                                for (let n = 0, i = e.count; n < i; n++) dn.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(dn)
+                            } else null === n.boundingBox && n.computeBoundingBox(), pn.copy(n.boundingBox), pn.applyMatrix4(t.matrixWorld), this.union(pn);
                         const i = t.children;
                         for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
                         return this
                     }
                     containsPoint(t) {
                         return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                     }
@@ -1982,91 +2344,91 @@
                     getParameter(t, e) {
                         return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                     }
                     intersectsBox(t) {
                         return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                     }
                     intersectsSphere(t) {
-                        return this.clampPoint(t.center, ee), ee.distanceToSquared(t.center) <= t.radius * t.radius
+                        return this.clampPoint(t.center, dn), dn.distanceToSquared(t.center) <= t.radius * t.radius
                     }
                     intersectsPlane(t) {
                         let e, n;
                         return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                     }
                     intersectsTriangle(t) {
                         if (this.isEmpty()) return !1;
-                        this.getCenter(ce), he.subVectors(this.max, ce), ie.subVectors(t.a, ce), re.subVectors(t.b, ce), se.subVectors(t.c, ce), ae.subVectors(re, ie), oe.subVectors(se, re), le.subVectors(ie, se);
-                        let e = [0, -ae.z, ae.y, 0, -oe.z, oe.y, 0, -le.z, le.y, ae.z, 0, -ae.x, oe.z, 0, -oe.x, le.z, 0, -le.x, -ae.y, ae.x, 0, -oe.y, oe.x, 0, -le.y, le.x, 0];
-                        return !!pe(e, ie, re, se, he) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!pe(e, ie, re, se, he) && (ue.crossVectors(ae, oe), e = [ue.x, ue.y, ue.z], pe(e, ie, re, se, he)))
+                        this.getCenter(_n), Mn.subVectors(this.max, _n), mn.subVectors(t.a, _n), fn.subVectors(t.b, _n), gn.subVectors(t.c, _n), vn.subVectors(fn, mn), xn.subVectors(gn, fn), yn.subVectors(mn, gn);
+                        let e = [0, -vn.z, vn.y, 0, -xn.z, xn.y, 0, -yn.z, yn.y, vn.z, 0, -vn.x, xn.z, 0, -xn.x, yn.z, 0, -yn.x, -vn.y, vn.x, 0, -xn.y, xn.x, 0, -yn.y, yn.x, 0];
+                        return !!Sn(e, mn, fn, gn, Mn) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Sn(e, mn, fn, gn, Mn) && (bn.crossVectors(vn, xn), e = [bn.x, bn.y, bn.z], Sn(e, mn, fn, gn, Mn)))
                     }
                     clampPoint(t, e) {
                         return e.copy(t).clamp(this.min, this.max)
                     }
                     distanceToPoint(t) {
-                        return ee.copy(t).clamp(this.min, this.max).sub(t).length()
+                        return dn.copy(t).clamp(this.min, this.max).sub(t).length()
                     }
                     getBoundingSphere(t) {
-                        return this.getCenter(t.center), t.radius = .5 * this.getSize(ee).length(), t
+                        return this.getCenter(t.center), t.radius = .5 * this.getSize(dn).length(), t
                     }
                     intersect(t) {
                         return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                     }
                     union(t) {
                         return this.min.min(t.min), this.max.max(t.max), this
                     }
                     applyMatrix4(t) {
-                        return this.isEmpty() || (te[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), te[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), te[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), te[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), te[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), te[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), te[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), te[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(te)), this
+                        return this.isEmpty() || (un[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), un[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), un[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), un[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), un[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), un[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), un[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), un[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(un)), this
                     }
                     translate(t) {
                         return this.min.add(t), this.max.add(t), this
                     }
                     equals(t) {
                         return t.min.equals(this.min) && t.max.equals(this.max)
                     }
                 }
-                $t.prototype.isBox3 = !0;
-                const te = [new Jt, new Jt, new Jt, new Jt, new Jt, new Jt, new Jt, new Jt],
-                    ee = new Jt,
-                    ne = new $t,
-                    ie = new Jt,
-                    re = new Jt,
-                    se = new Jt,
-                    ae = new Jt,
-                    oe = new Jt,
-                    le = new Jt,
-                    ce = new Jt,
-                    he = new Jt,
-                    ue = new Jt,
-                    de = new Jt;
+                hn.prototype.isBox3 = !0;
+                const un = [new on, new on, new on, new on, new on, new on, new on, new on],
+                    dn = new on,
+                    pn = new hn,
+                    mn = new on,
+                    fn = new on,
+                    gn = new on,
+                    vn = new on,
+                    xn = new on,
+                    yn = new on,
+                    _n = new on,
+                    Mn = new on,
+                    bn = new on,
+                    wn = new on;
 
-                function pe(t, e, n, i, r) {
+                function Sn(t, e, n, i, r) {
                     for (let s = 0, a = t.length - 3; s <= a; s += 3) {
-                        de.fromArray(t, s);
-                        const a = r.x * Math.abs(de.x) + r.y * Math.abs(de.y) + r.z * Math.abs(de.z),
-                            o = e.dot(de),
-                            l = n.dot(de),
-                            c = i.dot(de);
+                        wn.fromArray(t, s);
+                        const a = r.x * Math.abs(wn.x) + r.y * Math.abs(wn.y) + r.z * Math.abs(wn.z),
+                            o = e.dot(wn),
+                            l = n.dot(wn),
+                            c = i.dot(wn);
                         if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
                     }
                     return !0
                 }
-                const me = new $t,
-                    fe = new Jt,
-                    ge = new Jt,
-                    ve = new Jt;
-                class xe {
-                    constructor(t = new Jt, e = -1) {
+                const En = new hn,
+                    Tn = new on,
+                    An = new on,
+                    Rn = new on;
+                class Ln {
+                    constructor(t = new on, e = -1) {
                         this.center = t, this.radius = e
                     }
                     set(t, e) {
                         return this.center.copy(t), this.radius = e, this
                     }
                     setFromPoints(t, e) {
                         const n = this.center;
-                        void 0 !== e ? n.copy(e) : me.setFromPoints(t).getCenter(n);
+                        void 0 !== e ? n.copy(e) : En.setFromPoints(t).getCenter(n);
                         let i = 0;
                         for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                         return this.radius = Math.sqrt(i), this
                     }
                     copy(t) {
                         return this.center.copy(t.center), this.radius = t.radius, this
                     }
@@ -2102,42 +2464,42 @@
                     applyMatrix4(t) {
                         return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                     }
                     translate(t) {
                         return this.center.add(t), this
                     }
                     expandByPoint(t) {
-                        ve.subVectors(t, this.center);
-                        const e = ve.lengthSq();
+                        Rn.subVectors(t, this.center);
+                        const e = Rn.lengthSq();
                         if (e > this.radius * this.radius) {
                             const t = Math.sqrt(e),
                                 n = .5 * (t - this.radius);
-                            this.center.add(ve.multiplyScalar(n / t)), this.radius += n
+                            this.center.add(Rn.multiplyScalar(n / t)), this.radius += n
                         }
                         return this
                     }
                     union(t) {
-                        return !0 === this.center.equals(t.center) ? ge.set(0, 0, 1).multiplyScalar(t.radius) : ge.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(fe.copy(t.center).add(ge)), this.expandByPoint(fe.copy(t.center).sub(ge)), this
+                        return !0 === this.center.equals(t.center) ? An.set(0, 0, 1).multiplyScalar(t.radius) : An.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(Tn.copy(t.center).add(An)), this.expandByPoint(Tn.copy(t.center).sub(An)), this
                     }
                     equals(t) {
                         return t.center.equals(this.center) && t.radius === this.radius
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                const ye = new Jt,
-                    _e = new Jt,
-                    Me = new Jt,
-                    be = new Jt,
-                    we = new Jt,
-                    Se = new Jt,
-                    Ee = new Jt;
-                class Te {
-                    constructor(t = new Jt, e = new Jt(0, 0, -1)) {
+                const Cn = new on,
+                    Pn = new on,
+                    Dn = new on,
+                    In = new on,
+                    Nn = new on,
+                    On = new on,
+                    Un = new on;
+                class Bn {
+                    constructor(t = new on, e = new on(0, 0, -1)) {
                         this.origin = t, this.direction = e
                     }
                     set(t, e) {
                         return this.origin.copy(t), this.direction.copy(e), this
                     }
                     copy(t) {
                         return this.origin.copy(t.origin), this.direction.copy(t.direction), this
@@ -2145,53 +2507,53 @@
                     at(t, e) {
                         return e.copy(this.direction).multiplyScalar(t).add(this.origin)
                     }
                     lookAt(t) {
                         return this.direction.copy(t).sub(this.origin).normalize(), this
                     }
                     recast(t) {
-                        return this.origin.copy(this.at(t, ye)), this
+                        return this.origin.copy(this.at(t, Cn)), this
                     }
                     closestPointToPoint(t, e) {
                         e.subVectors(t, this.origin);
                         const n = e.dot(this.direction);
                         return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                     }
                     distanceToPoint(t) {
                         return Math.sqrt(this.distanceSqToPoint(t))
                     }
                     distanceSqToPoint(t) {
-                        const e = ye.subVectors(t, this.origin).dot(this.direction);
-                        return e < 0 ? this.origin.distanceToSquared(t) : (ye.copy(this.direction).multiplyScalar(e).add(this.origin), ye.distanceToSquared(t))
+                        const e = Cn.subVectors(t, this.origin).dot(this.direction);
+                        return e < 0 ? this.origin.distanceToSquared(t) : (Cn.copy(this.direction).multiplyScalar(e).add(this.origin), Cn.distanceToSquared(t))
                     }
                     distanceSqToSegment(t, e, n, i) {
-                        _e.copy(t).add(e).multiplyScalar(.5), Me.copy(e).sub(t).normalize(), be.copy(this.origin).sub(_e);
+                        Pn.copy(t).add(e).multiplyScalar(.5), Dn.copy(e).sub(t).normalize(), In.copy(this.origin).sub(Pn);
                         const r = .5 * t.distanceTo(e),
-                            s = -this.direction.dot(Me),
-                            a = be.dot(this.direction),
-                            o = -be.dot(Me),
-                            l = be.lengthSq(),
+                            s = -this.direction.dot(Dn),
+                            a = In.dot(this.direction),
+                            o = -In.dot(Dn),
+                            l = In.lengthSq(),
                             c = Math.abs(1 - s * s);
                         let h, u, d, p;
                         if (c > 0)
                             if (h = s * o - a, u = s * a - o, p = r * c, h >= 0)
                                 if (u >= -p)
                                     if (u <= p) {
                                         const t = 1 / c;
                                         h *= t, u *= t, d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l
                                     } else u = r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                         else u = -r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                         else u <= -p ? (h = Math.max(0, -(-s * r + a)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
                         else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
-                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Me).multiplyScalar(u).add(_e), d
+                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Dn).multiplyScalar(u).add(Pn), d
                     }
                     intersectSphere(t, e) {
-                        ye.subVectors(t.center, this.origin);
-                        const n = ye.dot(this.direction),
-                            i = ye.dot(ye) - n * n,
+                        Cn.subVectors(t.center, this.origin);
+                        const n = Cn.dot(this.direction),
+                            i = Cn.dot(Cn) - n * n,
                             r = t.radius * t.radius;
                         if (i > r) return null;
                         const s = Math.sqrt(r - i),
                             a = n - s,
                             o = n + s;
                         return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
                     }
@@ -2217,58 +2579,58 @@
                         const l = 1 / this.direction.x,
                             c = 1 / this.direction.y,
                             h = 1 / this.direction.z,
                             u = this.origin;
                         return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (a = (t.min.z - u.z) * h, o = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, o = (t.min.z - u.z) * h), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                     }
                     intersectsBox(t) {
-                        return null !== this.intersectBox(t, ye)
+                        return null !== this.intersectBox(t, Cn)
                     }
                     intersectTriangle(t, e, n, i, r) {
-                        we.subVectors(e, t), Se.subVectors(n, t), Ee.crossVectors(we, Se);
-                        let s, a = this.direction.dot(Ee);
+                        Nn.subVectors(e, t), On.subVectors(n, t), Un.crossVectors(Nn, On);
+                        let s, a = this.direction.dot(Un);
                         if (a > 0) {
                             if (i) return null;
                             s = 1
                         } else {
                             if (!(a < 0)) return null;
                             s = -1, a = -a
                         }
-                        be.subVectors(this.origin, t);
-                        const o = s * this.direction.dot(Se.crossVectors(be, Se));
+                        In.subVectors(this.origin, t);
+                        const o = s * this.direction.dot(On.crossVectors(In, On));
                         if (o < 0) return null;
-                        const l = s * this.direction.dot(we.cross(be));
+                        const l = s * this.direction.dot(Nn.cross(In));
                         if (l < 0) return null;
                         if (o + l > a) return null;
-                        const c = -s * be.dot(Ee);
+                        const c = -s * In.dot(Un);
                         return c < 0 ? null : this.at(c / a, r)
                     }
                     applyMatrix4(t) {
                         return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                     }
                     equals(t) {
                         return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                class Ae {
+                class Fn {
                     constructor() {
                         this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                     }
                     set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
                         const g = this.elements;
                         return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
                     }
                     identity() {
                         return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                     }
                     clone() {
-                        return (new Ae).fromArray(this.elements)
+                        return (new Fn).fromArray(this.elements)
                     }
                     copy(t) {
                         const e = this.elements,
                             n = t.elements;
                         return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                     }
                     copyPosition(t) {
@@ -2285,17 +2647,17 @@
                     }
                     makeBasis(t, e, n) {
                         return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                     }
                     extractRotation(t) {
                         const e = this.elements,
                             n = t.elements,
-                            i = 1 / Re.setFromMatrixColumn(t, 0).length(),
-                            r = 1 / Re.setFromMatrixColumn(t, 1).length(),
-                            s = 1 / Re.setFromMatrixColumn(t, 2).length();
+                            i = 1 / zn.setFromMatrixColumn(t, 0).length(),
+                            r = 1 / zn.setFromMatrixColumn(t, 1).length(),
+                            s = 1 / zn.setFromMatrixColumn(t, 2).length();
                         return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                     }
                     makeRotationFromEuler(t) {
                         t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                         const e = this.elements,
                             n = t.x,
                             i = t.y,
@@ -2342,19 +2704,19 @@
                                 i = a * o,
                                 r = a * l;
                             e[0] = o * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = s * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = a * c, e[10] = r * h + t
                         }
                         return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                     }
                     makeRotationFromQuaternion(t) {
-                        return this.compose(Ce, t, Pe)
+                        return this.compose(Gn, t, Vn)
                     }
                     lookAt(t, e, n) {
                         const i = this.elements;
-                        return Ne.subVectors(t, e), 0 === Ne.lengthSq() && (Ne.z = 1), Ne.normalize(), De.crossVectors(n, Ne), 0 === De.lengthSq() && (1 === Math.abs(n.z) ? Ne.x += 1e-4 : Ne.z += 1e-4, Ne.normalize(), De.crossVectors(n, Ne)), De.normalize(), Ie.crossVectors(Ne, De), i[0] = De.x, i[4] = Ie.x, i[8] = Ne.x, i[1] = De.y, i[5] = Ie.y, i[9] = Ne.y, i[2] = De.z, i[6] = Ie.z, i[10] = Ne.z, this
+                        return jn.subVectors(t, e), 0 === jn.lengthSq() && (jn.z = 1), jn.normalize(), kn.crossVectors(n, jn), 0 === kn.lengthSq() && (1 === Math.abs(n.z) ? jn.x += 1e-4 : jn.z += 1e-4, jn.normalize(), kn.crossVectors(n, jn)), kn.normalize(), Wn.crossVectors(jn, kn), i[0] = kn.x, i[4] = Wn.x, i[8] = jn.x, i[1] = kn.y, i[5] = Wn.y, i[9] = jn.y, i[2] = kn.z, i[6] = Wn.z, i[10] = jn.z, this
                     }
                     multiply(t, e) {
                         return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                     }
                     premultiply(t) {
                         return this.multiplyMatrices(t, this)
                     }
@@ -2522,22 +2884,22 @@
                             _ = n.x,
                             M = n.y,
                             b = n.z;
                         return i[0] = (1 - (m + g)) * _, i[1] = (d + y) * _, i[2] = (p - x) * _, i[3] = 0, i[4] = (d - y) * M, i[5] = (1 - (u + g)) * M, i[6] = (f + v) * M, i[7] = 0, i[8] = (p + x) * b, i[9] = (f - v) * b, i[10] = (1 - (u + m)) * b, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                     }
                     decompose(t, e, n) {
                         const i = this.elements;
-                        let r = Re.set(i[0], i[1], i[2]).length();
-                        const s = Re.set(i[4], i[5], i[6]).length(),
-                            a = Re.set(i[8], i[9], i[10]).length();
-                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Le.copy(this);
+                        let r = zn.set(i[0], i[1], i[2]).length();
+                        const s = zn.set(i[4], i[5], i[6]).length(),
+                            a = zn.set(i[8], i[9], i[10]).length();
+                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Hn.copy(this);
                         const o = 1 / r,
                             l = 1 / s,
                             c = 1 / a;
-                        return Le.elements[0] *= o, Le.elements[1] *= o, Le.elements[2] *= o, Le.elements[4] *= l, Le.elements[5] *= l, Le.elements[6] *= l, Le.elements[8] *= c, Le.elements[9] *= c, Le.elements[10] *= c, e.setFromRotationMatrix(Le), n.x = r, n.y = s, n.z = a, this
+                        return Hn.elements[0] *= o, Hn.elements[1] *= o, Hn.elements[2] *= o, Hn.elements[4] *= l, Hn.elements[5] *= l, Hn.elements[6] *= l, Hn.elements[8] *= c, Hn.elements[9] *= c, Hn.elements[10] *= c, e.setFromRotationMatrix(Hn), n.x = r, n.y = s, n.z = a, this
                     }
                     makePerspective(t, e, n, i, r, s) {
                         void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                         const a = this.elements,
                             o = 2 * r / (e - t),
                             l = 2 * r / (n - i),
                             c = (e + t) / (e - t),
@@ -2568,26 +2930,26 @@
                         return this
                     }
                     toArray(t = [], e = 0) {
                         const n = this.elements;
                         return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                     }
                 }
-                Ae.prototype.isMatrix4 = !0;
-                const Re = new Jt,
-                    Le = new Ae,
-                    Ce = new Jt(0, 0, 0),
-                    Pe = new Jt(1, 1, 1),
-                    De = new Jt,
-                    Ie = new Jt,
-                    Ne = new Jt,
-                    Oe = new Ae,
-                    Ue = new Zt;
-                class Be {
-                    constructor(t = 0, e = 0, n = 0, i = Be.DefaultOrder) {
+                Fn.prototype.isMatrix4 = !0;
+                const zn = new on,
+                    Hn = new Fn,
+                    Gn = new on(0, 0, 0),
+                    Vn = new on(1, 1, 1),
+                    kn = new on,
+                    Wn = new on,
+                    jn = new on,
+                    Xn = new Fn,
+                    qn = new an;
+                class Yn {
+                    constructor(t = 0, e = 0, n = 0, i = Yn.DefaultOrder) {
                         this._x = t, this._y = e, this._z = n, this._order = i
                     }
                     get x() {
                         return this._x
                     }
                     set x(t) {
                         this._x = t, this._onChangeCallback()
@@ -2628,64 +2990,64 @@
                             l = i[5],
                             c = i[9],
                             h = i[2],
                             u = i[6],
                             d = i[10];
                         switch (e) {
                             case "XYZ":
-                                this._y = Math.asin(_t(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
+                                this._y = Math.asin(Ce(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                                 break;
                             case "YXZ":
-                                this._x = Math.asin(-_t(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
+                                this._x = Math.asin(-Ce(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                                 break;
                             case "ZXY":
-                                this._x = Math.asin(_t(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
+                                this._x = Math.asin(Ce(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                                 break;
                             case "ZYX":
-                                this._y = Math.asin(-_t(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
+                                this._y = Math.asin(-Ce(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                                 break;
                             case "YZX":
-                                this._z = Math.asin(_t(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
+                                this._z = Math.asin(Ce(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                                 break;
                             case "XZY":
-                                this._z = Math.asin(-_t(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
+                                this._z = Math.asin(-Ce(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                                 break;
                             default:
                                 console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                         }
                         return this._order = e, !0 === n && this._onChangeCallback(), this
                     }
                     setFromQuaternion(t, e, n) {
-                        return Oe.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Oe, e, n)
+                        return Xn.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Xn, e, n)
                     }
                     setFromVector3(t, e = this._order) {
                         return this.set(t.x, t.y, t.z, e)
                     }
                     reorder(t) {
-                        return Ue.setFromEuler(this), this.setFromQuaternion(Ue, t)
+                        return qn.setFromEuler(this), this.setFromQuaternion(qn, t)
                     }
                     equals(t) {
                         return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                     }
                     fromArray(t) {
                         return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                     }
                     toArray(t = [], e = 0) {
                         return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                     }
                     toVector3(t) {
-                        return t ? t.set(this._x, this._y, this._z) : new Jt(this._x, this._y, this._z)
+                        return t ? t.set(this._x, this._y, this._z) : new on(this._x, this._y, this._z)
                     }
                     _onChange(t) {
                         return this._onChangeCallback = t, this
                     }
                     _onChangeCallback() {}
                 }
-                Be.prototype.isEuler = !0, Be.DefaultOrder = "XYZ", Be.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
-                class Fe {
+                Yn.prototype.isEuler = !0, Yn.DefaultOrder = "XYZ", Yn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
+                class Zn {
                     constructor() {
                         this.mask = 1
                     }
                     set(t) {
                         this.mask = (1 << t | 0) >>> 0
                     }
                     enable(t) {
@@ -2706,40 +3068,40 @@
                     test(t) {
                         return 0 != (this.mask & t.mask)
                     }
                     isEnabled(t) {
                         return 0 != (this.mask & (1 << t | 0))
                     }
                 }
-                let ze = 0;
-                const He = new Jt,
-                    Ge = new Zt,
-                    Ve = new Ae,
-                    ke = new Jt,
-                    We = new Jt,
-                    je = new Jt,
-                    Xe = new Zt,
-                    qe = new Jt(1, 0, 0),
-                    Ye = new Jt(0, 1, 0),
-                    Ze = new Jt(0, 0, 1),
-                    Je = {
+                let Jn = 0;
+                const Kn = new on,
+                    Qn = new an,
+                    $n = new Fn,
+                    ti = new on,
+                    ei = new on,
+                    ni = new on,
+                    ii = new an,
+                    ri = new on(1, 0, 0),
+                    si = new on(0, 1, 0),
+                    ai = new on(0, 0, 1),
+                    oi = {
                         type: "added"
                     },
-                    Ke = {
+                    li = {
                         type: "removed"
                     };
-                class Qe extends mt {
+                class ci extends Se {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: ze++
-                        }), this.uuid = yt(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Qe.DefaultUp.clone();
-                        const t = new Jt,
-                            e = new Be,
-                            n = new Zt,
-                            i = new Jt(1, 1, 1);
+                            value: Jn++
+                        }), this.uuid = Le(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ci.DefaultUp.clone();
+                        const t = new on,
+                            e = new Yn,
+                            n = new an,
+                            i = new on(1, 1, 1);
                         e._onChange((function() {
                             n.setFromEuler(e, !1)
                         })), n._onChange((function() {
                             e.setFromQuaternion(n, void 0, !1)
                         })), Object.defineProperties(this, {
                             position: {
                                 configurable: !0,
@@ -2758,20 +3120,20 @@
                             },
                             scale: {
                                 configurable: !0,
                                 enumerable: !0,
                                 value: i
                             },
                             modelViewMatrix: {
-                                value: new Ae
+                                value: new Fn
                             },
                             normalMatrix: {
-                                value: new Rt
+                                value: new Fe
                             }
-                        }), this.matrix = new Ae, this.matrixWorld = new Ae, this.matrixAutoUpdate = Qe.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Fe, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
+                        }), this.matrix = new Fn, this.matrixWorld = new Fn, this.matrixAutoUpdate = ci.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Zn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                     }
                     onBeforeRender() {}
                     onAfterRender() {}
                     applyMatrix4(t) {
                         this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                     }
                     applyQuaternion(t) {
@@ -2786,79 +3148,79 @@
                     setRotationFromMatrix(t) {
                         this.quaternion.setFromRotationMatrix(t)
                     }
                     setRotationFromQuaternion(t) {
                         this.quaternion.copy(t)
                     }
                     rotateOnAxis(t, e) {
-                        return Ge.setFromAxisAngle(t, e), this.quaternion.multiply(Ge), this
+                        return Qn.setFromAxisAngle(t, e), this.quaternion.multiply(Qn), this
                     }
                     rotateOnWorldAxis(t, e) {
-                        return Ge.setFromAxisAngle(t, e), this.quaternion.premultiply(Ge), this
+                        return Qn.setFromAxisAngle(t, e), this.quaternion.premultiply(Qn), this
                     }
                     rotateX(t) {
-                        return this.rotateOnAxis(qe, t)
+                        return this.rotateOnAxis(ri, t)
                     }
                     rotateY(t) {
-                        return this.rotateOnAxis(Ye, t)
+                        return this.rotateOnAxis(si, t)
                     }
                     rotateZ(t) {
-                        return this.rotateOnAxis(Ze, t)
+                        return this.rotateOnAxis(ai, t)
                     }
                     translateOnAxis(t, e) {
-                        return He.copy(t).applyQuaternion(this.quaternion), this.position.add(He.multiplyScalar(e)), this
+                        return Kn.copy(t).applyQuaternion(this.quaternion), this.position.add(Kn.multiplyScalar(e)), this
                     }
                     translateX(t) {
-                        return this.translateOnAxis(qe, t)
+                        return this.translateOnAxis(ri, t)
                     }
                     translateY(t) {
-                        return this.translateOnAxis(Ye, t)
+                        return this.translateOnAxis(si, t)
                     }
                     translateZ(t) {
-                        return this.translateOnAxis(Ze, t)
+                        return this.translateOnAxis(ai, t)
                     }
                     localToWorld(t) {
                         return t.applyMatrix4(this.matrixWorld)
                     }
                     worldToLocal(t) {
-                        return t.applyMatrix4(Ve.copy(this.matrixWorld).invert())
+                        return t.applyMatrix4($n.copy(this.matrixWorld).invert())
                     }
                     lookAt(t, e, n) {
-                        t.isVector3 ? ke.copy(t) : ke.set(t, e, n);
+                        t.isVector3 ? ti.copy(t) : ti.set(t, e, n);
                         const i = this.parent;
-                        this.updateWorldMatrix(!0, !1), We.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ve.lookAt(We, ke, this.up) : Ve.lookAt(ke, We, this.up), this.quaternion.setFromRotationMatrix(Ve), i && (Ve.extractRotation(i.matrixWorld), Ge.setFromRotationMatrix(Ve), this.quaternion.premultiply(Ge.invert()))
+                        this.updateWorldMatrix(!0, !1), ei.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? $n.lookAt(ei, ti, this.up) : $n.lookAt(ti, ei, this.up), this.quaternion.setFromRotationMatrix($n), i && ($n.extractRotation(i.matrixWorld), Qn.setFromRotationMatrix($n), this.quaternion.premultiply(Qn.invert()))
                     }
                     add(t) {
                         if (arguments.length > 1) {
                             for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                             return this
                         }
-                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Je)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
+                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(oi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                     }
                     remove(t) {
                         if (arguments.length > 1) {
                             for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                             return this
                         }
                         const e = this.children.indexOf(t);
-                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Ke)), this
+                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(li)), this
                     }
                     removeFromParent() {
                         const t = this.parent;
                         return null !== t && t.remove(this), this
                     }
                     clear() {
                         for (let t = 0; t < this.children.length; t++) {
                             const e = this.children[t];
-                            e.parent = null, e.dispatchEvent(Ke)
+                            e.parent = null, e.dispatchEvent(li)
                         }
                         return this.children.length = 0, this
                     }
                     attach(t) {
-                        return this.updateWorldMatrix(!0, !1), Ve.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Ve.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ve), this.add(t), t.updateWorldMatrix(!1, !0), this
+                        return this.updateWorldMatrix(!0, !1), $n.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), $n.multiply(t.parent.matrixWorld)), t.applyMatrix4($n), this.add(t), t.updateWorldMatrix(!1, !0), this
                     }
                     getObjectById(t) {
                         return this.getObjectByProperty("id", t)
                     }
                     getObjectByName(t) {
                         return this.getObjectByProperty("name", t)
                     }
@@ -2869,18 +3231,18 @@
                             if (void 0 !== i) return i
                         }
                     }
                     getWorldPosition(t) {
                         return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                     }
                     getWorldQuaternion(t) {
-                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(We, t, je), t
+                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ei, t, ni), t
                     }
                     getWorldScale(t) {
-                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(We, Xe, t), t
+                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ei, ii, t), t
                     }
                     getWorldDirection(t) {
                         this.updateWorldMatrix(!0, !1);
                         const e = this.matrixWorld.elements;
                         return t.set(e[8], e[9], e[10]).normalize()
                     }
                     raycast() {}
@@ -2994,56 +3356,56 @@
                             for (let e = 0; e < t.children.length; e++) {
                                 const n = t.children[e];
                                 this.add(n.clone())
                             }
                         return this
                     }
                 }
-                Qe.DefaultUp = new Jt(0, 1, 0), Qe.DefaultMatrixAutoUpdate = !0, Qe.prototype.isObject3D = !0;
-                const $e = new Jt,
-                    tn = new Jt,
-                    en = new Jt,
-                    nn = new Jt,
-                    rn = new Jt,
-                    sn = new Jt,
-                    an = new Jt,
-                    on = new Jt,
-                    ln = new Jt,
-                    cn = new Jt;
-                class hn {
-                    constructor(t = new Jt, e = new Jt, n = new Jt) {
+                ci.DefaultUp = new on(0, 1, 0), ci.DefaultMatrixAutoUpdate = !0, ci.prototype.isObject3D = !0;
+                const hi = new on,
+                    ui = new on,
+                    di = new on,
+                    pi = new on,
+                    mi = new on,
+                    fi = new on,
+                    gi = new on,
+                    vi = new on,
+                    xi = new on,
+                    yi = new on;
+                class _i {
+                    constructor(t = new on, e = new on, n = new on) {
                         this.a = t, this.b = e, this.c = n
                     }
                     static getNormal(t, e, n, i) {
-                        i.subVectors(n, e), $e.subVectors(t, e), i.cross($e);
+                        i.subVectors(n, e), hi.subVectors(t, e), i.cross(hi);
                         const r = i.lengthSq();
                         return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                     }
                     static getBarycoord(t, e, n, i, r) {
-                        $e.subVectors(i, e), tn.subVectors(n, e), en.subVectors(t, e);
-                        const s = $e.dot($e),
-                            a = $e.dot(tn),
-                            o = $e.dot(en),
-                            l = tn.dot(tn),
-                            c = tn.dot(en),
+                        hi.subVectors(i, e), ui.subVectors(n, e), di.subVectors(t, e);
+                        const s = hi.dot(hi),
+                            a = hi.dot(ui),
+                            o = hi.dot(di),
+                            l = ui.dot(ui),
+                            c = ui.dot(di),
                             h = s * l - a * a;
                         if (0 === h) return r.set(-2, -1, -1);
                         const u = 1 / h,
                             d = (l * o - a * c) * u,
                             p = (s * c - a * o) * u;
                         return r.set(1 - d - p, p, d)
                     }
                     static containsPoint(t, e, n, i) {
-                        return this.getBarycoord(t, e, n, i, nn), nn.x >= 0 && nn.y >= 0 && nn.x + nn.y <= 1
+                        return this.getBarycoord(t, e, n, i, pi), pi.x >= 0 && pi.y >= 0 && pi.x + pi.y <= 1
                     }
                     static getUV(t, e, n, i, r, s, a, o) {
-                        return this.getBarycoord(t, e, n, i, nn), o.set(0, 0), o.addScaledVector(r, nn.x), o.addScaledVector(s, nn.y), o.addScaledVector(a, nn.z), o
+                        return this.getBarycoord(t, e, n, i, pi), o.set(0, 0), o.addScaledVector(r, pi.x), o.addScaledVector(s, pi.y), o.addScaledVector(a, pi.z), o
                     }
                     static isFrontFacing(t, e, n, i) {
-                        return $e.subVectors(n, e), tn.subVectors(t, e), $e.cross(tn).dot(i) < 0
+                        return hi.subVectors(n, e), ui.subVectors(t, e), hi.cross(ui).dot(i) < 0
                     }
                     set(t, e, n) {
                         return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                     }
                     setFromPointsAndIndices(t, e, n, i) {
                         return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                     }
@@ -3053,76 +3415,76 @@
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     copy(t) {
                         return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                     }
                     getArea() {
-                        return $e.subVectors(this.c, this.b), tn.subVectors(this.a, this.b), .5 * $e.cross(tn).length()
+                        return hi.subVectors(this.c, this.b), ui.subVectors(this.a, this.b), .5 * hi.cross(ui).length()
                     }
                     getMidpoint(t) {
                         return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                     }
                     getNormal(t) {
-                        return hn.getNormal(this.a, this.b, this.c, t)
+                        return _i.getNormal(this.a, this.b, this.c, t)
                     }
                     getPlane(t) {
                         return t.setFromCoplanarPoints(this.a, this.b, this.c)
                     }
                     getBarycoord(t, e) {
-                        return hn.getBarycoord(t, this.a, this.b, this.c, e)
+                        return _i.getBarycoord(t, this.a, this.b, this.c, e)
                     }
                     getUV(t, e, n, i, r) {
-                        return hn.getUV(t, this.a, this.b, this.c, e, n, i, r)
+                        return _i.getUV(t, this.a, this.b, this.c, e, n, i, r)
                     }
                     containsPoint(t) {
-                        return hn.containsPoint(t, this.a, this.b, this.c)
+                        return _i.containsPoint(t, this.a, this.b, this.c)
                     }
                     isFrontFacing(t) {
-                        return hn.isFrontFacing(this.a, this.b, this.c, t)
+                        return _i.isFrontFacing(this.a, this.b, this.c, t)
                     }
                     intersectsBox(t) {
                         return t.intersectsTriangle(this)
                     }
                     closestPointToPoint(t, e) {
                         const n = this.a,
                             i = this.b,
                             r = this.c;
                         let s, a;
-                        rn.subVectors(i, n), sn.subVectors(r, n), on.subVectors(t, n);
-                        const o = rn.dot(on),
-                            l = sn.dot(on);
+                        mi.subVectors(i, n), fi.subVectors(r, n), vi.subVectors(t, n);
+                        const o = mi.dot(vi),
+                            l = fi.dot(vi);
                         if (o <= 0 && l <= 0) return e.copy(n);
-                        ln.subVectors(t, i);
-                        const c = rn.dot(ln),
-                            h = sn.dot(ln);
+                        xi.subVectors(t, i);
+                        const c = mi.dot(xi),
+                            h = fi.dot(xi);
                         if (c >= 0 && h <= c) return e.copy(i);
                         const u = o * h - c * l;
-                        if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector(rn, s);
-                        cn.subVectors(t, r);
-                        const d = rn.dot(cn),
-                            p = sn.dot(cn);
+                        if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector(mi, s);
+                        yi.subVectors(t, r);
+                        const d = mi.dot(yi),
+                            p = fi.dot(yi);
                         if (p >= 0 && d <= p) return e.copy(r);
                         const m = d * l - o * p;
-                        if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(sn, a);
+                        if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(fi, a);
                         const f = c * p - d * h;
-                        if (f <= 0 && h - c >= 0 && d - p >= 0) return an.subVectors(r, i), a = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(an, a);
+                        if (f <= 0 && h - c >= 0 && d - p >= 0) return gi.subVectors(r, i), a = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(gi, a);
                         const g = 1 / (f + m + u);
-                        return s = m * g, a = u * g, e.copy(n).addScaledVector(rn, s).addScaledVector(sn, a)
+                        return s = m * g, a = u * g, e.copy(n).addScaledVector(mi, s).addScaledVector(fi, a)
                     }
                     equals(t) {
                         return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                     }
                 }
-                let un = 0;
-                class dn extends mt {
+                let Mi = 0;
+                class bi extends Se {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: un++
-                        }), this.uuid = yt(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = i, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ct, this.stencilZFail = ct, this.stencilZPass = ct, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.alphaWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
+                            value: Mi++
+                        }), this.uuid = Le(), this.name = "", this.type = "Material", this.fog = !0, this.blending = p, this.side = c, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = A, this.blendDst = R, this.blendEquation = x, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = B, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ye, this.stencilZFail = ye, this.stencilZPass = ye, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.alphaWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                     }
                     get alphaTest() {
                         return this._alphaTest
                     }
                     set alphaTest(t) {
                         this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
                     }
@@ -3166,15 +3528,15 @@
                             const e = [];
                             for (const n in t) {
                                 const i = t[n];
                                 delete i.metadata, e.push(i)
                             }
                             return e
                         }
-                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.alphaWrite = this.alphaWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
+                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== p && (n.blending = this.blending), this.side !== c && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.alphaWrite = this.alphaWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                             const e = i(t.textures),
                                 r = i(t.images);
                             e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                         }
                         return n
                     }
                     clone() {
@@ -3196,30 +3558,30 @@
                             type: "dispose"
                         })
                     }
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                 }
-                dn.prototype.isMaterial = !0;
-                class pn extends dn {
+                bi.prototype.isMaterial = !0;
+                class wi extends bi {
                     constructor(t) {
-                        super(), this.type = "MeshBasicMaterial", this.color = new zt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        super(), this.type = "MeshBasicMaterial", this.color = new Ze(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }
-                pn.prototype.isMeshBasicMaterial = !0;
-                const mn = new Jt,
-                    fn = new At;
-                class gn {
+                wi.prototype.isMeshBasicMaterial = !0;
+                const Si = new on,
+                    Ei = new Be;
+                class Ti {
                     constructor(t, e, n) {
                         if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
-                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = ht, this.updateRange = {
+                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = _e, this.updateRange = {
                             offset: 0,
                             count: -1
                         }, this.version = 0
                     }
                     onUploadCallback() {}
                     set needsUpdate(t) {
                         !0 === t && this.version++
@@ -3239,62 +3601,62 @@
                         return this.array.set(t), this
                     }
                     copyColorsArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new zt), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Ze), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                         }
                         return this
                     }
                     copyVector2sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new At), e[n++] = r.x, e[n++] = r.y
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Be), e[n++] = r.x, e[n++] = r.y
                         }
                         return this
                     }
                     copyVector3sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Jt), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new on), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                         }
                         return this
                     }
                     copyVector4sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new jt), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new en), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                         }
                         return this
                     }
                     applyMatrix3(t) {
                         if (2 === this.itemSize)
-                            for (let e = 0, n = this.count; e < n; e++) fn.fromBufferAttribute(this, e), fn.applyMatrix3(t), this.setXY(e, fn.x, fn.y);
+                            for (let e = 0, n = this.count; e < n; e++) Ei.fromBufferAttribute(this, e), Ei.applyMatrix3(t), this.setXY(e, Ei.x, Ei.y);
                         else if (3 === this.itemSize)
-                            for (let e = 0, n = this.count; e < n; e++) mn.fromBufferAttribute(this, e), mn.applyMatrix3(t), this.setXYZ(e, mn.x, mn.y, mn.z);
+                            for (let e = 0, n = this.count; e < n; e++) Si.fromBufferAttribute(this, e), Si.applyMatrix3(t), this.setXYZ(e, Si.x, Si.y, Si.z);
                         return this
                     }
                     applyMatrix4(t) {
-                        for (let e = 0, n = this.count; e < n; e++) mn.x = this.getX(e), mn.y = this.getY(e), mn.z = this.getZ(e), mn.applyMatrix4(t), this.setXYZ(e, mn.x, mn.y, mn.z);
+                        for (let e = 0, n = this.count; e < n; e++) Si.x = this.getX(e), Si.y = this.getY(e), Si.z = this.getZ(e), Si.applyMatrix4(t), this.setXYZ(e, Si.x, Si.y, Si.z);
                         return this
                     }
                     applyNormalMatrix(t) {
-                        for (let e = 0, n = this.count; e < n; e++) mn.x = this.getX(e), mn.y = this.getY(e), mn.z = this.getZ(e), mn.applyNormalMatrix(t), this.setXYZ(e, mn.x, mn.y, mn.z);
+                        for (let e = 0, n = this.count; e < n; e++) Si.x = this.getX(e), Si.y = this.getY(e), Si.z = this.getZ(e), Si.applyNormalMatrix(t), this.setXYZ(e, Si.x, Si.y, Si.z);
                         return this
                     }
                     transformDirection(t) {
-                        for (let e = 0, n = this.count; e < n; e++) mn.x = this.getX(e), mn.y = this.getY(e), mn.z = this.getZ(e), mn.transformDirection(t), this.setXYZ(e, mn.x, mn.y, mn.z);
+                        for (let e = 0, n = this.count; e < n; e++) Si.x = this.getX(e), Si.y = this.getY(e), Si.z = this.getZ(e), Si.transformDirection(t), this.setXYZ(e, Si.x, Si.y, Si.z);
                         return this
                     }
                     set(t, e = 0) {
                         return this.array.set(t, e), this
                     }
                     getX(t) {
                         return this.array[t * this.itemSize]
@@ -3338,90 +3700,90 @@
                     toJSON() {
                         const t = {
                             itemSize: this.itemSize,
                             type: this.array.constructor.name,
                             array: Array.prototype.slice.call(this.array),
                             normalized: this.normalized
                         };
-                        return "" !== this.name && (t.name = this.name), this.usage !== ht && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
+                        return "" !== this.name && (t.name = this.name), this.usage !== _e && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
                     }
                 }
-                gn.prototype.isBufferAttribute = !0;
-                class vn extends gn {
+                Ti.prototype.isBufferAttribute = !0;
+                class Ai extends Ti {
                     constructor(t, e, n) {
                         super(new Int8Array(t), e, n)
                     }
                 }
-                class xn extends gn {
+                class Ri extends Ti {
                     constructor(t, e, n) {
                         super(new Uint8Array(t), e, n)
                     }
                 }
-                class yn extends gn {
+                class Li extends Ti {
                     constructor(t, e, n) {
                         super(new Uint8ClampedArray(t), e, n)
                     }
                 }
-                class _n extends gn {
+                class Ci extends Ti {
                     constructor(t, e, n) {
                         super(new Int16Array(t), e, n)
                     }
                 }
-                class Mn extends gn {
+                class Pi extends Ti {
                     constructor(t, e, n) {
                         super(new Uint16Array(t), e, n)
                     }
                 }
-                class bn extends gn {
+                class Di extends Ti {
                     constructor(t, e, n) {
                         super(new Int32Array(t), e, n)
                     }
                 }
-                class wn extends gn {
+                class Ii extends Ti {
                     constructor(t, e, n) {
                         super(new Uint32Array(t), e, n)
                     }
                 }
-                class Sn extends gn {
+                class Ni extends Ti {
                     constructor(t, e, n) {
                         super(new Uint16Array(t), e, n)
                     }
                 }
-                Sn.prototype.isFloat16BufferAttribute = !0;
-                class En extends gn {
+                Ni.prototype.isFloat16BufferAttribute = !0;
+                class Oi extends Ti {
                     constructor(t, e, n) {
                         super(new Float32Array(t), e, n)
                     }
                 }
-                class Tn extends gn {
+                class Ui extends Ti {
                     constructor(t, e, n) {
                         super(new Float64Array(t), e, n)
                     }
                 }
-                let An = 0;
-                const Rn = new Ae,
-                    Ln = new Qe,
-                    Cn = new Jt,
-                    Pn = new $t,
-                    Dn = new $t,
-                    In = new Jt;
-                class Nn extends mt {
+                let Bi = 0;
+                const Fi = new Fn,
+                    zi = new ci,
+                    Hi = new on,
+                    Gi = new hn,
+                    Vi = new hn,
+                    ki = new on;
+                class Wi extends Se {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: An++
-                        }), this.uuid = yt(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
+                            value: Bi++
+                        }), this.uuid = Le(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                             start: 0,
                             count: 1 / 0
                         }, this.userData = {}
                     }
                     getIndex() {
                         return this.index
                     }
                     setIndex(t) {
-                        return Array.isArray(t) ? this.index = new(Lt(t) ? wn : Mn)(t, 1) : this.index = t, this
+                        return Array.isArray(t) ? this.index = new(ze(t) ? Ii : Pi)(t, 1) : this.index = t, this
                     }
                     getAttribute(t) {
                         return this.attributes[t]
                     }
                     setAttribute(t, e) {
                         return this.attributes[t] = e, this
                     }
@@ -3445,112 +3807,112 @@
                         this.drawRange.start = t, this.drawRange.count = e
                     }
                     applyMatrix4(t) {
                         const e = this.attributes.position;
                         void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                         const n = this.attributes.normal;
                         if (void 0 !== n) {
-                            const e = (new Rt).getNormalMatrix(t);
+                            const e = (new Fe).getNormalMatrix(t);
                             n.applyNormalMatrix(e), n.needsUpdate = !0
                         }
                         const i = this.attributes.tangent;
                         return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                     }
                     applyQuaternion(t) {
-                        return Rn.makeRotationFromQuaternion(t), this.applyMatrix4(Rn), this
+                        return Fi.makeRotationFromQuaternion(t), this.applyMatrix4(Fi), this
                     }
                     rotateX(t) {
-                        return Rn.makeRotationX(t), this.applyMatrix4(Rn), this
+                        return Fi.makeRotationX(t), this.applyMatrix4(Fi), this
                     }
                     rotateY(t) {
-                        return Rn.makeRotationY(t), this.applyMatrix4(Rn), this
+                        return Fi.makeRotationY(t), this.applyMatrix4(Fi), this
                     }
                     rotateZ(t) {
-                        return Rn.makeRotationZ(t), this.applyMatrix4(Rn), this
+                        return Fi.makeRotationZ(t), this.applyMatrix4(Fi), this
                     }
                     translate(t, e, n) {
-                        return Rn.makeTranslation(t, e, n), this.applyMatrix4(Rn), this
+                        return Fi.makeTranslation(t, e, n), this.applyMatrix4(Fi), this
                     }
                     scale(t, e, n) {
-                        return Rn.makeScale(t, e, n), this.applyMatrix4(Rn), this
+                        return Fi.makeScale(t, e, n), this.applyMatrix4(Fi), this
                     }
                     lookAt(t) {
-                        return Ln.lookAt(t), Ln.updateMatrix(), this.applyMatrix4(Ln.matrix), this
+                        return zi.lookAt(t), zi.updateMatrix(), this.applyMatrix4(zi.matrix), this
                     }
                     center() {
-                        return this.computeBoundingBox(), this.boundingBox.getCenter(Cn).negate(), this.translate(Cn.x, Cn.y, Cn.z), this
+                        return this.computeBoundingBox(), this.boundingBox.getCenter(Hi).negate(), this.translate(Hi.x, Hi.y, Hi.z), this
                     }
                     setFromPoints(t) {
                         const e = [];
                         for (let n = 0, i = t.length; n < i; n++) {
                             const i = t[n];
                             e.push(i.x, i.y, i.z || 0)
                         }
-                        return this.setAttribute("position", new En(e, 3)), this
+                        return this.setAttribute("position", new Oi(e, 3)), this
                     }
                     computeBoundingBox() {
-                        null === this.boundingBox && (this.boundingBox = new $t);
+                        null === this.boundingBox && (this.boundingBox = new hn);
                         const t = this.attributes.position,
                             e = this.morphAttributes.position;
-                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Jt(-1 / 0, -1 / 0, -1 / 0), new Jt(1 / 0, 1 / 0, 1 / 0));
+                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new on(-1 / 0, -1 / 0, -1 / 0), new on(1 / 0, 1 / 0, 1 / 0));
                         if (void 0 !== t) {
                             if (this.boundingBox.setFromBufferAttribute(t), e)
                                 for (let t = 0, n = e.length; t < n; t++) {
                                     const n = e[t];
-                                    Pn.setFromBufferAttribute(n), this.morphTargetsRelative ? (In.addVectors(this.boundingBox.min, Pn.min), this.boundingBox.expandByPoint(In), In.addVectors(this.boundingBox.max, Pn.max), this.boundingBox.expandByPoint(In)) : (this.boundingBox.expandByPoint(Pn.min), this.boundingBox.expandByPoint(Pn.max))
+                                    Gi.setFromBufferAttribute(n), this.morphTargetsRelative ? (ki.addVectors(this.boundingBox.min, Gi.min), this.boundingBox.expandByPoint(ki), ki.addVectors(this.boundingBox.max, Gi.max), this.boundingBox.expandByPoint(ki)) : (this.boundingBox.expandByPoint(Gi.min), this.boundingBox.expandByPoint(Gi.max))
                                 }
                         } else this.boundingBox.makeEmpty();
                         (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                     }
                     computeBoundingSphere() {
-                        null === this.boundingSphere && (this.boundingSphere = new xe);
+                        null === this.boundingSphere && (this.boundingSphere = new Ln);
                         const t = this.attributes.position,
                             e = this.morphAttributes.position;
-                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Jt, 1 / 0);
+                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new on, 1 / 0);
                         if (t) {
                             const n = this.boundingSphere.center;
-                            if (Pn.setFromBufferAttribute(t), e)
+                            if (Gi.setFromBufferAttribute(t), e)
                                 for (let t = 0, n = e.length; t < n; t++) {
                                     const n = e[t];
-                                    Dn.setFromBufferAttribute(n), this.morphTargetsRelative ? (In.addVectors(Pn.min, Dn.min), Pn.expandByPoint(In), In.addVectors(Pn.max, Dn.max), Pn.expandByPoint(In)) : (Pn.expandByPoint(Dn.min), Pn.expandByPoint(Dn.max))
+                                    Vi.setFromBufferAttribute(n), this.morphTargetsRelative ? (ki.addVectors(Gi.min, Vi.min), Gi.expandByPoint(ki), ki.addVectors(Gi.max, Vi.max), Gi.expandByPoint(ki)) : (Gi.expandByPoint(Vi.min), Gi.expandByPoint(Vi.max))
                                 }
-                            Pn.getCenter(n);
+                            Gi.getCenter(n);
                             let i = 0;
-                            for (let e = 0, r = t.count; e < r; e++) In.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(In));
+                            for (let e = 0, r = t.count; e < r; e++) ki.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(ki));
                             if (e)
                                 for (let r = 0, s = e.length; r < s; r++) {
                                     const s = e[r],
                                         a = this.morphTargetsRelative;
-                                    for (let e = 0, r = s.count; e < r; e++) In.fromBufferAttribute(s, e), a && (Cn.fromBufferAttribute(t, e), In.add(Cn)), i = Math.max(i, n.distanceToSquared(In))
+                                    for (let e = 0, r = s.count; e < r; e++) ki.fromBufferAttribute(s, e), a && (Hi.fromBufferAttribute(t, e), ki.add(Hi)), i = Math.max(i, n.distanceToSquared(ki))
                                 }
                             this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                         }
                     }
                     computeTangents() {
                         const t = this.index,
                             e = this.attributes;
                         if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                         const n = t.array,
                             i = e.position.array,
                             r = e.normal.array,
                             s = e.uv.array,
                             a = i.length / 3;
-                        void 0 === e.tangent && this.setAttribute("tangent", new gn(new Float32Array(4 * a), 4));
+                        void 0 === e.tangent && this.setAttribute("tangent", new Ti(new Float32Array(4 * a), 4));
                         const o = e.tangent.array,
                             l = [],
                             c = [];
-                        for (let t = 0; t < a; t++) l[t] = new Jt, c[t] = new Jt;
-                        const h = new Jt,
-                            u = new Jt,
-                            d = new Jt,
-                            p = new At,
-                            m = new At,
-                            f = new At,
-                            g = new Jt,
-                            v = new Jt;
+                        for (let t = 0; t < a; t++) l[t] = new on, c[t] = new on;
+                        const h = new on,
+                            u = new on,
+                            d = new on,
+                            p = new Be,
+                            m = new Be,
+                            f = new Be,
+                            g = new on,
+                            v = new on;
 
                         function x(t, e, n) {
                             h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * n), u.sub(h), d.sub(h), m.sub(p), f.sub(p);
                             const r = 1 / (m.x * f.y - f.x * m.y);
                             isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                         }
                         let y = this.groups;
@@ -3559,18 +3921,18 @@
                             count: n.length
                         }]);
                         for (let t = 0, e = y.length; t < e; ++t) {
                             const e = y[t],
                                 i = e.start;
                             for (let t = i, r = i + e.count; t < r; t += 3) x(n[t + 0], n[t + 1], n[t + 2])
                         }
-                        const _ = new Jt,
-                            M = new Jt,
-                            b = new Jt,
-                            w = new Jt;
+                        const _ = new on,
+                            M = new on,
+                            b = new on,
+                            w = new on;
 
                         function S(t) {
                             b.fromArray(r, 3 * t), w.copy(b);
                             const e = l[t];
                             _.copy(e), _.sub(b.multiplyScalar(b.dot(e))).normalize(), M.crossVectors(w, e);
                             const n = M.dot(c[t]) < 0 ? -1 : 1;
                             o[4 * t] = _.x, o[4 * t + 1] = _.y, o[4 * t + 2] = _.z, o[4 * t + 3] = n
@@ -3582,25 +3944,25 @@
                         }
                     }
                     computeVertexNormals() {
                         const t = this.index,
                             e = this.getAttribute("position");
                         if (void 0 !== e) {
                             let n = this.getAttribute("normal");
-                            if (void 0 === n) n = new gn(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
+                            if (void 0 === n) n = new Ti(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                             else
                                 for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
-                            const i = new Jt,
-                                r = new Jt,
-                                s = new Jt,
-                                a = new Jt,
-                                o = new Jt,
-                                l = new Jt,
-                                c = new Jt,
-                                h = new Jt;
+                            const i = new on,
+                                r = new on,
+                                s = new on,
+                                a = new on,
+                                o = new on,
+                                l = new on,
+                                c = new on,
+                                h = new on;
                             if (t)
                                 for (let u = 0, d = t.count; u < d; u += 3) {
                                     const d = t.getX(u + 0),
                                         p = t.getX(u + 1),
                                         m = t.getX(u + 2);
                                     i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(m, l.x, l.y, l.z)
                                 } else
@@ -3621,32 +3983,32 @@
                                 l = Math.min(a.length, r.length - o);
                             for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t]
                         }
                         return this
                     }
                     normalizeNormals() {
                         const t = this.attributes.normal;
-                        for (let e = 0, n = t.count; e < n; e++) In.fromBufferAttribute(t, e), In.normalize(), t.setXYZ(e, In.x, In.y, In.z)
+                        for (let e = 0, n = t.count; e < n; e++) ki.fromBufferAttribute(t, e), ki.normalize(), t.setXYZ(e, ki.x, ki.y, ki.z)
                     }
                     toNonIndexed() {
                         function t(t, e) {
                             const n = t.array,
                                 i = t.itemSize,
                                 r = t.normalized,
                                 s = new n.constructor(e.length * i);
                             let a = 0,
                                 o = 0;
                             for (let r = 0, l = e.length; r < l; r++) {
                                 a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                                 for (let t = 0; t < i; t++) s[o++] = n[a++]
                             }
-                            return new gn(s, i, r)
+                            return new Ti(s, i, r)
                         }
                         if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
-                        const e = new Nn,
+                        const e = new Wi,
                             n = this.index.array,
                             i = this.attributes;
                         for (const r in i) {
                             const s = t(i[r], n);
                             e.setAttribute(r, s)
                         }
                         const r = this.morphAttributes;
@@ -3747,34 +4109,34 @@
                     }
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }
-                Nn.prototype.isBufferGeometry = !0;
-                const On = new Ae,
-                    Un = new Te,
-                    Bn = new xe,
-                    Fn = new Jt,
-                    zn = new Jt,
-                    Hn = new Jt,
-                    Gn = new Jt,
-                    Vn = new Jt,
-                    kn = new Jt,
-                    Wn = new Jt,
-                    jn = new Jt,
-                    Xn = new Jt,
-                    qn = new At,
-                    Yn = new At,
-                    Zn = new At,
-                    Jn = new Jt,
-                    Kn = new Jt;
-                class Qn extends Qe {
-                    constructor(t = new Nn, e = new pn) {
+                Wi.prototype.isBufferGeometry = !0;
+                const ji = new Fn,
+                    Xi = new Bn,
+                    qi = new Ln,
+                    Yi = new on,
+                    Zi = new on,
+                    Ji = new on,
+                    Ki = new on,
+                    Qi = new on,
+                    $i = new on,
+                    tr = new on,
+                    er = new on,
+                    nr = new on,
+                    ir = new Be,
+                    rr = new Be,
+                    sr = new Be,
+                    ar = new on,
+                    or = new on;
+                class lr extends ci {
+                    constructor(t = new Wi, e = new wi) {
                         super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                     }
                     updateMorphTargets() {
                         const t = this.geometry;
@@ -3797,16 +4159,16 @@
                         }
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.material,
                             r = this.matrixWorld;
                         if (void 0 === i) return;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), Bn.copy(n.boundingSphere), Bn.applyMatrix4(r), !1 === t.ray.intersectsSphere(Bn)) return;
-                        if (On.copy(r).invert(), Un.copy(t.ray).applyMatrix4(On), null !== n.boundingBox && !1 === Un.intersectsBox(n.boundingBox)) return;
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), qi.copy(n.boundingSphere), qi.applyMatrix4(r), !1 === t.ray.intersectsSphere(qi)) return;
+                        if (ji.copy(r).invert(), Xi.copy(t.ray).applyMatrix4(ji), null !== n.boundingBox && !1 === Xi.intersectsBox(n.boundingBox)) return;
                         let s;
                         if (n.isBufferGeometry) {
                             const r = n.index,
                                 a = n.attributes.position,
                                 o = n.morphAttributes.position,
                                 l = n.morphTargetsRelative,
                                 c = n.attributes.uv,
@@ -3818,73 +4180,73 @@
                                     for (let n = 0, p = u.length; n < p; n++) {
                                         const p = u[n],
                                             m = i[p.materialIndex];
                                         for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                                             const i = r.getX(n),
                                                 u = r.getX(n + 1),
                                                 d = r.getX(n + 2);
-                                            s = $n(this, m, t, Un, a, o, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
+                                            s = cr(this, m, t, Xi, a, o, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                         }
                                     } else
                                         for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                                             const u = r.getX(n),
                                                 d = r.getX(n + 1),
                                                 p = r.getX(n + 2);
-                                            s = $n(this, i, t, Un, a, o, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
+                                            s = cr(this, i, t, Xi, a, o, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                         } else if (void 0 !== a)
                                             if (Array.isArray(i))
                                                 for (let n = 0, r = u.length; n < r; n++) {
                                                     const r = u[n],
                                                         p = i[r.materialIndex];
-                                                    for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) s = $n(this, p, t, Un, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
+                                                    for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) s = cr(this, p, t, Xi, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                                 } else
-                                                    for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) s = $n(this, i, t, Un, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
+                                                    for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) s = cr(this, i, t, Xi, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                         } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                     }
                 }
 
-                function $n(t, e, n, i, r, s, a, o, l, c, h, u) {
-                    Fn.fromBufferAttribute(r, c), zn.fromBufferAttribute(r, h), Hn.fromBufferAttribute(r, u);
-                    const d = t.morphTargetInfluences;
-                    if (s && d) {
-                        Wn.set(0, 0, 0), jn.set(0, 0, 0), Xn.set(0, 0, 0);
+                function cr(t, e, n, i, r, s, a, o, l, c, d, p) {
+                    Yi.fromBufferAttribute(r, c), Zi.fromBufferAttribute(r, d), Ji.fromBufferAttribute(r, p);
+                    const m = t.morphTargetInfluences;
+                    if (s && m) {
+                        tr.set(0, 0, 0), er.set(0, 0, 0), nr.set(0, 0, 0);
                         for (let t = 0, e = s.length; t < e; t++) {
-                            const e = d[t],
+                            const e = m[t],
                                 n = s[t];
-                            0 !== e && (Gn.fromBufferAttribute(n, c), Vn.fromBufferAttribute(n, h), kn.fromBufferAttribute(n, u), a ? (Wn.addScaledVector(Gn, e), jn.addScaledVector(Vn, e), Xn.addScaledVector(kn, e)) : (Wn.addScaledVector(Gn.sub(Fn), e), jn.addScaledVector(Vn.sub(zn), e), Xn.addScaledVector(kn.sub(Hn), e)))
+                            0 !== e && (Ki.fromBufferAttribute(n, c), Qi.fromBufferAttribute(n, d), $i.fromBufferAttribute(n, p), a ? (tr.addScaledVector(Ki, e), er.addScaledVector(Qi, e), nr.addScaledVector($i, e)) : (tr.addScaledVector(Ki.sub(Yi), e), er.addScaledVector(Qi.sub(Zi), e), nr.addScaledVector($i.sub(Ji), e)))
                         }
-                        Fn.add(Wn), zn.add(jn), Hn.add(Xn)
+                        Yi.add(tr), Zi.add(er), Ji.add(nr)
                     }
-                    t.isSkinnedMesh && (t.boneTransform(c, Fn), t.boneTransform(h, zn), t.boneTransform(u, Hn));
-                    const p = function(t, e, n, i, r, s, a, o) {
+                    t.isSkinnedMesh && (t.boneTransform(c, Yi), t.boneTransform(d, Zi), t.boneTransform(p, Ji));
+                    const f = function(t, e, n, i, r, s, a, o) {
                         let l;
-                        if (l = 1 === e.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, 2 !== e.side, o), null === l) return null;
-                        Kn.copy(o), Kn.applyMatrix4(t.matrixWorld);
-                        const c = n.ray.origin.distanceTo(Kn);
+                        if (l = e.side === h ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, e.side !== u, o), null === l) return null;
+                        or.copy(o), or.applyMatrix4(t.matrixWorld);
+                        const c = n.ray.origin.distanceTo(or);
                         return c < n.near || c > n.far ? null : {
                             distance: c,
-                            point: Kn.clone(),
+                            point: or.clone(),
                             object: t
                         }
-                    }(t, e, n, i, Fn, zn, Hn, Jn);
-                    if (p) {
-                        o && (qn.fromBufferAttribute(o, c), Yn.fromBufferAttribute(o, h), Zn.fromBufferAttribute(o, u), p.uv = hn.getUV(Jn, Fn, zn, Hn, qn, Yn, Zn, new At)), l && (qn.fromBufferAttribute(l, c), Yn.fromBufferAttribute(l, h), Zn.fromBufferAttribute(l, u), p.uv2 = hn.getUV(Jn, Fn, zn, Hn, qn, Yn, Zn, new At));
+                    }(t, e, n, i, Yi, Zi, Ji, ar);
+                    if (f) {
+                        o && (ir.fromBufferAttribute(o, c), rr.fromBufferAttribute(o, d), sr.fromBufferAttribute(o, p), f.uv = _i.getUV(ar, Yi, Zi, Ji, ir, rr, sr, new Be)), l && (ir.fromBufferAttribute(l, c), rr.fromBufferAttribute(l, d), sr.fromBufferAttribute(l, p), f.uv2 = _i.getUV(ar, Yi, Zi, Ji, ir, rr, sr, new Be));
                         const t = {
                             a: c,
-                            b: h,
-                            c: u,
-                            normal: new Jt,
+                            b: d,
+                            c: p,
+                            normal: new on,
                             materialIndex: 0
                         };
-                        hn.getNormal(Fn, zn, Hn, t.normal), p.face = t
+                        _i.getNormal(Yi, Zi, Ji, t.normal), f.face = t
                     }
-                    return p
+                    return f
                 }
-                Qn.prototype.isMesh = !0;
-                class ti extends Nn {
+                lr.prototype.isMesh = !0;
+                class hr extends Wi {
                     constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                         super(), this.type = "BoxGeometry", this.parameters = {
                             width: t,
                             height: e,
                             depth: n,
                             widthSegments: i,
                             heightSegments: r,
@@ -3905,15 +4267,15 @@
                                 _ = s / 2,
                                 M = p / 2,
                                 b = m / 2,
                                 w = f + 1,
                                 S = g + 1;
                             let E = 0,
                                 T = 0;
-                            const A = new Jt;
+                            const A = new on;
                             for (let s = 0; s < S; s++) {
                                 const a = s * y - M;
                                 for (let o = 0; o < w; o++) {
                                     const u = o * x - _;
                                     A[t] = u * i, A[e] = a * r, A[n] = b, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(o / f), h.push(1 - s / g), E += 1
                                 }
                             }
@@ -3923,60 +4285,60 @@
                                         i = u + e + w * (t + 1),
                                         r = u + (e + 1) + w * (t + 1),
                                         s = u + (e + 1) + w * t;
                                     o.push(n, i, s), o.push(i, r, s), T += 6
                                 }
                             a.addGroup(d, T, v), d += T, u += E
                         }
-                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new En(l, 3)), this.setAttribute("normal", new En(c, 3)), this.setAttribute("uv", new En(h, 2))
+                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Oi(l, 3)), this.setAttribute("normal", new Oi(c, 3)), this.setAttribute("uv", new Oi(h, 2))
                     }
                     static fromJSON(t) {
-                        return new ti(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
+                        return new hr(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
                     }
                 }
 
-                function ei(t) {
+                function ur(t) {
                     const e = {};
                     for (const n in t) {
                         e[n] = {};
                         for (const i in t[n]) {
                             const r = t[n][i];
                             r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                         }
                     }
                     return e
                 }
 
-                function ni(t) {
+                function dr(t) {
                     const e = {};
                     for (let n = 0; n < t.length; n++) {
-                        const i = ei(t[n]);
+                        const i = ur(t[n]);
                         for (const t in i) e[t] = i[t]
                     }
                     return e
                 }
-                const ii = {
-                    clone: ei,
-                    merge: ni
+                const pr = {
+                    clone: ur,
+                    merge: dr
                 };
-                class ri extends dn {
+                class mr extends bi {
                     constructor(t) {
                         super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                             derivatives: !1,
                             fragDepth: !1,
                             drawBuffers: !1,
                             shaderTextureLOD: !1
                         }, this.defaultAttributeValues = {
                             color: [1, 1, 1],
                             uv: [0, 0],
                             uv2: [0, 0]
                         }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
                     }
                     copy(t) {
-                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = ei(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
+                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = ur(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         e.glslVersion = this.glslVersion, e.uniforms = {};
                         for (const n in this.uniforms) {
                             const i = this.uniforms[n].value;
                             i && i.isTexture ? e.uniforms[n] = {
@@ -4006,18 +4368,18 @@
                         }
                         Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                         const n = {};
                         for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                         return Object.keys(n).length > 0 && (e.extensions = n), e
                     }
                 }
-                ri.prototype.isShaderMaterial = !0;
-                class si extends Qe {
+                mr.prototype.isShaderMaterial = !0;
+                class fr extends ci {
                     constructor() {
-                        super(), this.type = "Camera", this.matrixWorldInverse = new Ae, this.projectionMatrix = new Ae, this.projectionMatrixInverse = new Ae
+                        super(), this.type = "Camera", this.matrixWorldInverse = new Fn, this.projectionMatrix = new Fn, this.projectionMatrixInverse = new Fn
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                     }
                     getWorldDirection(t) {
                         this.updateWorldMatrix(!0, !1);
                         const e = this.matrixWorld.elements;
@@ -4029,32 +4391,32 @@
                     updateWorldMatrix(t, e) {
                         super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                si.prototype.isCamera = !0;
-                class ai extends si {
+                fr.prototype.isCamera = !0;
+                class gr extends fr {
                     constructor(t = 50, e = 1, n = .1, i = 2e3) {
                         super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                     }
                     setFocalLength(t) {
                         const e = .5 * this.getFilmHeight() / t;
-                        this.fov = 2 * xt * Math.atan(e), this.updateProjectionMatrix()
+                        this.fov = 2 * Re * Math.atan(e), this.updateProjectionMatrix()
                     }
                     getFocalLength() {
-                        const t = Math.tan(.5 * vt * this.fov);
+                        const t = Math.tan(.5 * Ae * this.fov);
                         return .5 * this.getFilmHeight() / t
                     }
                     getEffectiveFOV() {
-                        return 2 * xt * Math.atan(Math.tan(.5 * vt * this.fov) / this.zoom)
+                        return 2 * Re * Math.atan(Math.tan(.5 * Ae * this.fov) / this.zoom)
                     }
                     getFilmWidth() {
                         return this.filmGauge * Math.min(this.aspect, 1)
                     }
                     getFilmHeight() {
                         return this.filmGauge / Math.max(this.aspect, 1)
                     }
@@ -4070,15 +4432,15 @@
                         }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                     }
                     clearViewOffset() {
                         null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                     }
                     updateProjectionMatrix() {
                         const t = this.near;
-                        let e = t * Math.tan(.5 * vt * this.fov) / this.zoom,
+                        let e = t * Math.tan(.5 * Ae * this.fov) / this.zoom,
                             n = 2 * e,
                             i = this.aspect * n,
                             r = -.5 * i;
                         const s = this.view;
                         if (null !== this.view && this.view.enabled) {
                             const t = s.fullWidth,
                                 a = s.fullHeight;
@@ -4088,108 +4450,108 @@
                         0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                     }
                 }
-                ai.prototype.isPerspectiveCamera = !0;
-                const oi = 90;
-                class li extends Qe {
+                gr.prototype.isPerspectiveCamera = !0;
+                const vr = 90;
+                class xr extends ci {
                     constructor(t, e, n) {
                         if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                         this.renderTarget = n;
-                        const i = new ai(oi, 1, t, e);
-                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Jt(1, 0, 0)), this.add(i);
-                        const r = new ai(oi, 1, t, e);
-                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Jt(-1, 0, 0)), this.add(r);
-                        const s = new ai(oi, 1, t, e);
-                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Jt(0, 1, 0)), this.add(s);
-                        const a = new ai(oi, 1, t, e);
-                        a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new Jt(0, -1, 0)), this.add(a);
-                        const o = new ai(oi, 1, t, e);
-                        o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Jt(0, 0, 1)), this.add(o);
-                        const l = new ai(oi, 1, t, e);
-                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Jt(0, 0, -1)), this.add(l)
+                        const i = new gr(vr, 1, t, e);
+                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new on(1, 0, 0)), this.add(i);
+                        const r = new gr(vr, 1, t, e);
+                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new on(-1, 0, 0)), this.add(r);
+                        const s = new gr(vr, 1, t, e);
+                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new on(0, 1, 0)), this.add(s);
+                        const a = new gr(vr, 1, t, e);
+                        a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new on(0, -1, 0)), this.add(a);
+                        const o = new gr(vr, 1, t, e);
+                        o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new on(0, 0, 1)), this.add(o);
+                        const l = new gr(vr, 1, t, e);
+                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new on(0, 0, -1)), this.add(l)
                     }
                     update(t, e) {
                         null === this.parent && this.updateMatrixWorld();
                         const n = this.renderTarget,
                             [i, r, s, a, o, l] = this.children,
                             c = t.xr.enabled,
                             h = t.getRenderTarget();
                         t.xr.enabled = !1;
                         const u = n.texture.generateMipmaps;
                         n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, a), t.setRenderTarget(n, 4), t.render(e, o), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c, n.texture.needsPMREMUpdate = !0
                     }
                 }
-                class ci extends kt {
-                    constructor(t, e, n, i, r, a, o, l, c, h) {
-                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : s, n, i, r, a, o, l, c, h), this.flipY = !1
+                class yr extends $e {
+                    constructor(t, e, n, i, r, s, a, o, l, c) {
+                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : Q, n, i, r, s, a, o, l, c), this.flipY = !1
                     }
                     get images() {
                         return this.image
                     }
                     set images(t) {
                         this.image = t
                     }
                 }
-                ci.prototype.isCubeTexture = !0;
-                class hi extends Xt {
+                yr.prototype.isCubeTexture = !0;
+                class _r extends nn {
                     constructor(t, e, n) {
-                        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new ci(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : v
+                        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new yr(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : ht
                     }
                     fromEquirectangularTexture(t, e) {
-                        this.texture.type = e.type, this.texture.format = T, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
+                        this.texture.type = e.type, this.texture.format = Et, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                         const n = {
                                 tEquirect: {
                                     value: null
                                 }
                             },
                             i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                             r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
-                            s = new ti(5, 5, 5),
-                            a = new ri({
+                            s = new hr(5, 5, 5),
+                            a = new mr({
                                 name: "CubemapFromEquirect",
-                                uniforms: ei(n),
+                                uniforms: ur(n),
                                 vertexShader: i,
                                 fragmentShader: r,
-                                side: 1,
-                                blending: 0
+                                side: h,
+                                blending: d
                             });
                         a.uniforms.tEquirect.value = e;
-                        const o = new Qn(s, a),
+                        const o = new lr(s, a),
                             l = e.minFilter;
-                        return e.minFilter === y && (e.minFilter = v), new li(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
+                        return e.minFilter === dt && (e.minFilter = ht), new xr(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
                     }
                     clear(t, e, n, i) {
                         const r = t.getRenderTarget();
                         for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                         t.setRenderTarget(r)
                     }
                 }
-                hi.prototype.isWebGLCubeRenderTarget = !0;
-                const ui = new Jt,
-                    di = new Jt,
-                    pi = new Rt;
-                class mi {
-                    constructor(t = new Jt(1, 0, 0), e = 0) {
+                _r.prototype.isWebGLCubeRenderTarget = !0;
+                const Mr = new on,
+                    br = new on,
+                    wr = new Fe;
+                class Sr {
+                    constructor(t = new on(1, 0, 0), e = 0) {
                         this.normal = t, this.constant = e
                     }
                     set(t, e) {
                         return this.normal.copy(t), this.constant = e, this
                     }
                     setComponents(t, e, n, i) {
                         return this.normal.set(t, e, n), this.constant = i, this
                     }
                     setFromNormalAndCoplanarPoint(t, e) {
                         return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                     }
                     setFromCoplanarPoints(t, e, n) {
-                        const i = ui.subVectors(n, e).cross(di.subVectors(t, e)).normalize();
+                        const i = Mr.subVectors(n, e).cross(br.subVectors(t, e)).normalize();
                         return this.setFromNormalAndCoplanarPoint(i, t), this
                     }
                     copy(t) {
                         return this.normal.copy(t.normal), this.constant = t.constant, this
                     }
                     normalize() {
                         const t = 1 / this.normal.length();
@@ -4204,15 +4566,15 @@
                     distanceToSphere(t) {
                         return this.distanceToPoint(t.center) - t.radius
                     }
                     projectPoint(t, e) {
                         return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                     }
                     intersectLine(t, e) {
-                        const n = t.delta(ui),
+                        const n = t.delta(Mr),
                             i = this.normal.dot(n);
                         if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                         const r = -(t.start.dot(this.normal) + this.constant) / i;
                         return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
                     }
                     intersectsLine(t) {
                         const e = this.distanceToPoint(t.start),
@@ -4225,34 +4587,34 @@
                     intersectsSphere(t) {
                         return t.intersectsPlane(this)
                     }
                     coplanarPoint(t) {
                         return t.copy(this.normal).multiplyScalar(-this.constant)
                     }
                     applyMatrix4(t, e) {
-                        const n = e || pi.getNormalMatrix(t),
-                            i = this.coplanarPoint(ui).applyMatrix4(t),
+                        const n = e || wr.getNormalMatrix(t),
+                            i = this.coplanarPoint(Mr).applyMatrix4(t),
                             r = this.normal.applyMatrix3(n).normalize();
                         return this.constant = -i.dot(r), this
                     }
                     translate(t) {
                         return this.constant -= t.dot(this.normal), this
                     }
                     equals(t) {
                         return t.normal.equals(this.normal) && t.constant === this.constant
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                mi.prototype.isPlane = !0;
-                const fi = new xe,
-                    gi = new Jt;
-                class vi {
-                    constructor(t = new mi, e = new mi, n = new mi, i = new mi, r = new mi, s = new mi) {
+                Sr.prototype.isPlane = !0;
+                const Er = new Ln,
+                    Tr = new on;
+                class Ar {
+                    constructor(t = new Sr, e = new Sr, n = new Sr, i = new Sr, r = new Sr, s = new Sr) {
                         this.planes = [t, e, n, i, r, s]
                     }
                     set(t, e, n, i, r, s) {
                         const a = this.planes;
                         return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this
                     }
                     copy(t) {
@@ -4279,47 +4641,47 @@
                             g = n[13],
                             v = n[14],
                             x = n[15];
                         return e[0].setComponents(a - i, h - o, m - u, x - f).normalize(), e[1].setComponents(a + i, h + o, m + u, x + f).normalize(), e[2].setComponents(a + r, h + l, m + d, x + g).normalize(), e[3].setComponents(a - r, h - l, m - d, x - g).normalize(), e[4].setComponents(a - s, h - c, m - p, x - v).normalize(), e[5].setComponents(a + s, h + c, m + p, x + v).normalize(), this
                     }
                     intersectsObject(t) {
                         const e = t.geometry;
-                        return null === e.boundingSphere && e.computeBoundingSphere(), fi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(fi)
+                        return null === e.boundingSphere && e.computeBoundingSphere(), Er.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Er)
                     }
                     intersectsSprite(t) {
-                        return fi.center.set(0, 0, 0), fi.radius = .7071067811865476, fi.applyMatrix4(t.matrixWorld), this.intersectsSphere(fi)
+                        return Er.center.set(0, 0, 0), Er.radius = .7071067811865476, Er.applyMatrix4(t.matrixWorld), this.intersectsSphere(Er)
                     }
                     intersectsSphere(t) {
                         const e = this.planes,
                             n = t.center,
                             i = -t.radius;
                         for (let t = 0; t < 6; t++)
                             if (e[t].distanceToPoint(n) < i) return !1;
                         return !0
                     }
                     intersectsBox(t) {
                         const e = this.planes;
                         for (let n = 0; n < 6; n++) {
                             const i = e[n];
-                            if (gi.x = i.normal.x > 0 ? t.max.x : t.min.x, gi.y = i.normal.y > 0 ? t.max.y : t.min.y, gi.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(gi) < 0) return !1
+                            if (Tr.x = i.normal.x > 0 ? t.max.x : t.min.x, Tr.y = i.normal.y > 0 ? t.max.y : t.min.y, Tr.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Tr) < 0) return !1
                         }
                         return !0
                     }
                     containsPoint(t) {
                         const e = this.planes;
                         for (let n = 0; n < 6; n++)
                             if (e[n].distanceToPoint(t) < 0) return !1;
                         return !0
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
 
-                function xi() {
+                function Rr() {
                     let t = null,
                         e = !1,
                         n = null,
                         i = null;
 
                     function r(e, s) {
                         n(e, s), i = t.requestAnimationFrame(r)
@@ -4336,15 +4698,15 @@
                         },
                         setContext: function(e) {
                             t = e
                         }
                     }
                 }
 
-                function yi(t, e) {
+                function Lr(t, e) {
                     const n = e.isWebGL2,
                         i = new WeakMap;
                     return {
                         get: function(t) {
                             return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                         },
                         remove: function(e) {
@@ -4380,15 +4742,15 @@
                                 const s = i.array,
                                     a = i.updateRange;
                                 t.bindBuffer(r, e), -1 === a.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1)
                             }(s.buffer, e, r), s.version = e.version)
                         }
                     }
                 }
-                class _i extends Nn {
+                class Cr extends Wi {
                     constructor(t = 1, e = 1, n = 1, i = 1) {
                         super(), this.type = "PlaneGeometry", this.parameters = {
                             width: t,
                             height: e,
                             widthSegments: n,
                             heightSegments: i
                         };
@@ -4415,21 +4777,21 @@
                             for (let e = 0; e < a; e++) {
                                 const n = e + l * t,
                                     i = e + l * (t + 1),
                                     r = e + 1 + l * (t + 1),
                                     s = e + 1 + l * t;
                                 d.push(n, i, s), d.push(i, r, s)
                             }
-                        this.setIndex(d), this.setAttribute("position", new En(p, 3)), this.setAttribute("normal", new En(m, 3)), this.setAttribute("uv", new En(f, 2))
+                        this.setIndex(d), this.setAttribute("position", new Oi(p, 3)), this.setAttribute("normal", new Oi(m, 3)), this.setAttribute("uv", new Oi(f, 2))
                     }
                     static fromJSON(t) {
-                        return new _i(t.width, t.height, t.widthSegments, t.heightSegments)
+                        return new Cr(t.width, t.height, t.widthSegments, t.heightSegments)
                     }
                 }
-                const Mi = {
+                const Pr = {
                         alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                         alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                         alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                         alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                         aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                         aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                         begin_vertex: "vec3 transformed = vec3( position );",
@@ -4557,30 +4919,30 @@
                         points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                         points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                         shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                         shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                         sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                         sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
                     },
-                    bi = {
+                    Dr = {
                         common: {
                             diffuse: {
-                                value: new zt(16777215)
+                                value: new Ze(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             map: {
                                 value: null
                             },
                             uvTransform: {
-                                value: new Rt
+                                value: new Fe
                             },
                             uv2Transform: {
-                                value: new Rt
+                                value: new Fe
                             },
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             }
@@ -4637,15 +4999,15 @@
                             }
                         },
                         normalmap: {
                             normalMap: {
                                 value: null
                             },
                             normalScale: {
-                                value: new At(1, 1)
+                                value: new Be(1, 1)
                             }
                         },
                         displacementmap: {
                             displacementMap: {
                                 value: null
                             },
                             displacementScale: {
@@ -4677,15 +5039,15 @@
                             fogNear: {
                                 value: 1
                             },
                             fogFar: {
                                 value: 2e3
                             },
                             fogColor: {
-                                value: new zt(16777215)
+                                value: new Ze(16777215)
                             }
                         },
                         lights: {
                             ambientLightColor: {
                                 value: []
                             },
                             lightProbe: {
@@ -4788,15 +5150,15 @@
                             },
                             ltc_2: {
                                 value: null
                             }
                         },
                         points: {
                             diffuse: {
-                                value: new zt(16777215)
+                                value: new Ze(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             size: {
                                 value: 1
                             },
@@ -4809,271 +5171,271 @@
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             },
                             uvTransform: {
-                                value: new Rt
+                                value: new Fe
                             }
                         },
                         sprite: {
                             diffuse: {
-                                value: new zt(16777215)
+                                value: new Ze(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             center: {
-                                value: new At(.5, .5)
+                                value: new Be(.5, .5)
                             },
                             rotation: {
                                 value: 0
                             },
                             map: {
                                 value: null
                             },
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             },
                             uvTransform: {
-                                value: new Rt
+                                value: new Fe
                             }
                         }
                     },
-                    wi = {
+                    Ir = {
                         basic: {
-                            uniforms: ni([bi.common, bi.specularmap, bi.envmap, bi.aomap, bi.lightmap, bi.fog]),
-                            vertexShader: Mi.meshbasic_vert,
-                            fragmentShader: Mi.meshbasic_frag
+                            uniforms: dr([Dr.common, Dr.specularmap, Dr.envmap, Dr.aomap, Dr.lightmap, Dr.fog]),
+                            vertexShader: Pr.meshbasic_vert,
+                            fragmentShader: Pr.meshbasic_frag
                         },
                         lambert: {
-                            uniforms: ni([bi.common, bi.specularmap, bi.envmap, bi.aomap, bi.lightmap, bi.emissivemap, bi.fog, bi.lights, {
+                            uniforms: dr([Dr.common, Dr.specularmap, Dr.envmap, Dr.aomap, Dr.lightmap, Dr.emissivemap, Dr.fog, Dr.lights, {
                                 emissive: {
-                                    value: new zt(0)
+                                    value: new Ze(0)
                                 }
                             }]),
-                            vertexShader: Mi.meshlambert_vert,
-                            fragmentShader: Mi.meshlambert_frag
+                            vertexShader: Pr.meshlambert_vert,
+                            fragmentShader: Pr.meshlambert_frag
                         },
                         phong: {
-                            uniforms: ni([bi.common, bi.specularmap, bi.envmap, bi.aomap, bi.lightmap, bi.emissivemap, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.fog, bi.lights, {
+                            uniforms: dr([Dr.common, Dr.specularmap, Dr.envmap, Dr.aomap, Dr.lightmap, Dr.emissivemap, Dr.bumpmap, Dr.normalmap, Dr.displacementmap, Dr.fog, Dr.lights, {
                                 emissive: {
-                                    value: new zt(0)
+                                    value: new Ze(0)
                                 },
                                 specular: {
-                                    value: new zt(1118481)
+                                    value: new Ze(1118481)
                                 },
                                 shininess: {
                                     value: 30
                                 }
                             }]),
-                            vertexShader: Mi.meshphong_vert,
-                            fragmentShader: Mi.meshphong_frag
+                            vertexShader: Pr.meshphong_vert,
+                            fragmentShader: Pr.meshphong_frag
                         },
                         standard: {
-                            uniforms: ni([bi.common, bi.envmap, bi.aomap, bi.lightmap, bi.emissivemap, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.roughnessmap, bi.metalnessmap, bi.fog, bi.lights, {
+                            uniforms: dr([Dr.common, Dr.envmap, Dr.aomap, Dr.lightmap, Dr.emissivemap, Dr.bumpmap, Dr.normalmap, Dr.displacementmap, Dr.roughnessmap, Dr.metalnessmap, Dr.fog, Dr.lights, {
                                 emissive: {
-                                    value: new zt(0)
+                                    value: new Ze(0)
                                 },
                                 roughness: {
                                     value: 1
                                 },
                                 metalness: {
                                     value: 0
                                 },
                                 envMapIntensity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Mi.meshphysical_vert,
-                            fragmentShader: Mi.meshphysical_frag
+                            vertexShader: Pr.meshphysical_vert,
+                            fragmentShader: Pr.meshphysical_frag
                         },
                         toon: {
-                            uniforms: ni([bi.common, bi.aomap, bi.lightmap, bi.emissivemap, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.gradientmap, bi.fog, bi.lights, {
+                            uniforms: dr([Dr.common, Dr.aomap, Dr.lightmap, Dr.emissivemap, Dr.bumpmap, Dr.normalmap, Dr.displacementmap, Dr.gradientmap, Dr.fog, Dr.lights, {
                                 emissive: {
-                                    value: new zt(0)
+                                    value: new Ze(0)
                                 }
                             }]),
-                            vertexShader: Mi.meshtoon_vert,
-                            fragmentShader: Mi.meshtoon_frag
+                            vertexShader: Pr.meshtoon_vert,
+                            fragmentShader: Pr.meshtoon_frag
                         },
                         matcap: {
-                            uniforms: ni([bi.common, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.fog, {
+                            uniforms: dr([Dr.common, Dr.bumpmap, Dr.normalmap, Dr.displacementmap, Dr.fog, {
                                 matcap: {
                                     value: null
                                 }
                             }]),
-                            vertexShader: Mi.meshmatcap_vert,
-                            fragmentShader: Mi.meshmatcap_frag
+                            vertexShader: Pr.meshmatcap_vert,
+                            fragmentShader: Pr.meshmatcap_frag
                         },
                         points: {
-                            uniforms: ni([bi.points, bi.fog]),
-                            vertexShader: Mi.points_vert,
-                            fragmentShader: Mi.points_frag
+                            uniforms: dr([Dr.points, Dr.fog]),
+                            vertexShader: Pr.points_vert,
+                            fragmentShader: Pr.points_frag
                         },
                         dashed: {
-                            uniforms: ni([bi.common, bi.fog, {
+                            uniforms: dr([Dr.common, Dr.fog, {
                                 scale: {
                                     value: 1
                                 },
                                 dashSize: {
                                     value: 1
                                 },
                                 totalSize: {
                                     value: 2
                                 }
                             }]),
-                            vertexShader: Mi.linedashed_vert,
-                            fragmentShader: Mi.linedashed_frag
+                            vertexShader: Pr.linedashed_vert,
+                            fragmentShader: Pr.linedashed_frag
                         },
                         depth: {
-                            uniforms: ni([bi.common, bi.displacementmap]),
-                            vertexShader: Mi.depth_vert,
-                            fragmentShader: Mi.depth_frag
+                            uniforms: dr([Dr.common, Dr.displacementmap]),
+                            vertexShader: Pr.depth_vert,
+                            fragmentShader: Pr.depth_frag
                         },
                         normal: {
-                            uniforms: ni([bi.common, bi.bumpmap, bi.normalmap, bi.displacementmap, {
+                            uniforms: dr([Dr.common, Dr.bumpmap, Dr.normalmap, Dr.displacementmap, {
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Mi.meshnormal_vert,
-                            fragmentShader: Mi.meshnormal_frag
+                            vertexShader: Pr.meshnormal_vert,
+                            fragmentShader: Pr.meshnormal_frag
                         },
                         sprite: {
-                            uniforms: ni([bi.sprite, bi.fog]),
-                            vertexShader: Mi.sprite_vert,
-                            fragmentShader: Mi.sprite_frag
+                            uniforms: dr([Dr.sprite, Dr.fog]),
+                            vertexShader: Pr.sprite_vert,
+                            fragmentShader: Pr.sprite_frag
                         },
                         background: {
                             uniforms: {
                                 uvTransform: {
-                                    value: new Rt
+                                    value: new Fe
                                 },
                                 t2D: {
                                     value: null
                                 }
                             },
-                            vertexShader: Mi.background_vert,
-                            fragmentShader: Mi.background_frag
+                            vertexShader: Pr.background_vert,
+                            fragmentShader: Pr.background_frag
                         },
                         cube: {
-                            uniforms: ni([bi.envmap, {
+                            uniforms: dr([Dr.envmap, {
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Mi.cube_vert,
-                            fragmentShader: Mi.cube_frag
+                            vertexShader: Pr.cube_vert,
+                            fragmentShader: Pr.cube_frag
                         },
                         equirect: {
                             uniforms: {
                                 tEquirect: {
                                     value: null
                                 }
                             },
-                            vertexShader: Mi.equirect_vert,
-                            fragmentShader: Mi.equirect_frag
+                            vertexShader: Pr.equirect_vert,
+                            fragmentShader: Pr.equirect_frag
                         },
                         distanceRGBA: {
-                            uniforms: ni([bi.common, bi.displacementmap, {
+                            uniforms: dr([Dr.common, Dr.displacementmap, {
                                 referencePosition: {
-                                    value: new Jt
+                                    value: new on
                                 },
                                 nearDistance: {
                                     value: 1
                                 },
                                 farDistance: {
                                     value: 1e3
                                 }
                             }]),
-                            vertexShader: Mi.distanceRGBA_vert,
-                            fragmentShader: Mi.distanceRGBA_frag
+                            vertexShader: Pr.distanceRGBA_vert,
+                            fragmentShader: Pr.distanceRGBA_frag
                         },
                         shadow: {
-                            uniforms: ni([bi.lights, bi.fog, {
+                            uniforms: dr([Dr.lights, Dr.fog, {
                                 color: {
-                                    value: new zt(0)
+                                    value: new Ze(0)
                                 },
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Mi.shadow_vert,
-                            fragmentShader: Mi.shadow_frag
+                            vertexShader: Pr.shadow_vert,
+                            fragmentShader: Pr.shadow_frag
                         }
                     };
 
-                function Si(t, e, n, i, r, s) {
-                    const a = new zt(0);
-                    let o, l, h = !0 === r ? 0 : 1,
-                        u = null,
-                        d = 0,
-                        p = null;
+                function Nr(t, e, n, i, r, s) {
+                    const a = new Ze(0);
+                    let o, l, u = !0 === r ? 0 : 1,
+                        d = null,
+                        p = 0,
+                        m = null;
 
-                    function m(t, e) {
+                    function f(t, e) {
                         n.buffers.color.setClear(t.r, t.g, t.b, e, s)
                     }
                     return {
                         getClearColor: function() {
                             return a
                         },
                         setClearColor: function(t, e = 1) {
-                            a.set(t), h = e, m(a, h)
+                            a.set(t), u = e, f(a, u)
                         },
                         getClearAlpha: function() {
-                            return h
+                            return u
                         },
                         setClearAlpha: function(t) {
-                            h = t, m(a, h)
+                            u = t, f(a, u)
                         },
                         render: function(n, r) {
                             let s = !1,
-                                f = !0 === r.isScene ? r.background : null;
-                            f && f.isTexture && (f = e.get(f));
-                            const g = t.xr,
-                                v = g.getSession && g.getSession();
-                            v && "additive" === v.environmentBlendMode && (f = null), null === f ? m(a, h) : f && f.isColor && (m(f, 1), s = !0), (t.autoClear || s) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.mapping === c) ? (void 0 === l && (l = new Qn(new ti(1, 1, 1), new ri({
+                                g = !0 === r.isScene ? r.background : null;
+                            g && g.isTexture && (g = e.get(g));
+                            const v = t.xr,
+                                x = v.getSession && v.getSession();
+                            x && "additive" === x.environmentBlendMode && (g = null), null === g ? f(a, u) : g && g.isColor && (f(g, 1), s = !0), (t.autoClear || s) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.mapping === nt) ? (void 0 === l && (l = new lr(new hr(1, 1, 1), new mr({
                                 name: "BackgroundCubeMaterial",
-                                uniforms: ei(wi.cube.uniforms),
-                                vertexShader: wi.cube.vertexShader,
-                                fragmentShader: wi.cube.fragmentShader,
-                                side: 1,
+                                uniforms: ur(Ir.cube.uniforms),
+                                vertexShader: Ir.cube.vertexShader,
+                                fragmentShader: Ir.cube.fragmentShader,
+                                side: h,
                                 depthTest: !1,
                                 depthWrite: !1,
                                 fog: !1
                             })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(t, e, n) {
                                 this.matrixWorld.copyPosition(n.matrixWorld)
                             }, Object.defineProperty(l.material, "envMap", {
                                 get: function() {
                                     return this.uniforms.envMap.value
                                 }
-                            }), i.update(l)), l.material.uniforms.envMap.value = f, l.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, u === f && d === f.version && p === t.toneMapping || (l.material.needsUpdate = !0, u = f, d = f.version, p = t.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && (o = new Qn(new _i(2, 2), new ri({
+                            }), i.update(l)), l.material.uniforms.envMap.value = g, l.material.uniforms.flipEnvMap.value = g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1, d === g && p === g.version && m === t.toneMapping || (l.material.needsUpdate = !0, d = g, p = g.version, m = t.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null)) : g && g.isTexture && (void 0 === o && (o = new lr(new Cr(2, 2), new mr({
                                 name: "BackgroundMaterial",
-                                uniforms: ei(wi.background.uniforms),
-                                vertexShader: wi.background.vertexShader,
-                                fragmentShader: wi.background.fragmentShader,
-                                side: 0,
+                                uniforms: ur(Ir.background.uniforms),
+                                vertexShader: Ir.background.vertexShader,
+                                fragmentShader: Ir.background.fragmentShader,
+                                side: c,
                                 depthTest: !1,
                                 depthWrite: !1,
                                 fog: !1
                             })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                                 get: function() {
                                     return this.uniforms.t2D.value
                                 }
-                            }), i.update(o)), o.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), o.material.uniforms.uvTransform.value.copy(f.matrix), u === f && d === f.version && p === t.toneMapping || (o.material.needsUpdate = !0, u = f, d = f.version, p = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
+                            }), i.update(o)), o.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), o.material.uniforms.uvTransform.value.copy(g.matrix), d === g && p === g.version && m === t.toneMapping || (o.material.needsUpdate = !0, d = g, p = g.version, m = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                         }
                     }
                 }
 
-                function Ei(t, e, n, i) {
+                function Or(t, e, n, i) {
                     const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                         s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                         a = i.isWebGL2 || null !== s,
                         o = {},
                         l = d(null);
                     let c = l;
 
@@ -5270,15 +5632,15 @@
                         },
                         initAttributes: p,
                         enableAttribute: m,
                         disableUnusedAttributes: g
                     }
                 }
 
-                function Ti(t, e, n, i) {
+                function Ur(t, e, n, i) {
                     const r = i.isWebGL2;
                     let s;
                     this.setMode = function(t) {
                         s = t
                     }, this.render = function(e, i) {
                         t.drawArrays(s, e, i), n.update(i, s, 1)
                     }, this.renderInstances = function(i, a, o) {
@@ -5286,15 +5648,15 @@
                         let l, c;
                         if (r) l = t, c = "drawArraysInstanced";
                         else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                         l[c](s, i, a, o), n.update(a, s, o)
                     }
                 }
 
-                function Ai(t, e, n) {
+                function Br(t, e, n) {
                     let i;
 
                     function r(e) {
                         if ("highp" === e) {
                             if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                             e = "mediump"
                         }
@@ -5341,22 +5703,22 @@
                         vertexTextures: x,
                         floatFragmentTextures: y,
                         floatVertexTextures: x && y,
                         maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0
                     }
                 }
 
-                function Ri(t) {
+                function Fr(t) {
                     const e = this;
                     let n = null,
                         i = 0,
                         r = !1,
                         s = !1;
-                    const a = new mi,
-                        o = new Rt,
+                    const a = new Sr,
+                        o = new Fe,
                         l = {
                             value: null,
                             needsUpdate: !1
                         };
 
                     function c() {
                         l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
@@ -5396,74 +5758,74 @@
                             l.value = r, r = h(u, a, e, o);
                             for (let t = 0; t !== e; ++t) r[t] = n[t];
                             m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                         }
                     }
                 }
 
-                function Li(t) {
+                function zr(t) {
                     let e = new WeakMap;
 
                     function n(t, e) {
-                        return e === o ? t.mapping = s : e === l && (t.mapping = a), t
+                        return e === tt ? t.mapping = Q : e === et && (t.mapping = $), t
                     }
 
                     function i(t) {
                         const n = t.target;
                         n.removeEventListener("dispose", i);
                         const r = e.get(n);
                         void 0 !== r && (e.delete(n), r.dispose())
                     }
                     return {
                         get: function(r) {
                             if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                                 const s = r.mapping;
-                                if (s === o || s === l) {
+                                if (s === tt || s === et) {
                                     if (e.has(r)) return n(e.get(r).texture, r.mapping); {
                                         const s = r.image;
                                         if (s && s.height > 0) {
-                                            const a = new hi(s.height / 2);
+                                            const a = new _r(s.height / 2);
                                             return a.fromEquirectangularTexture(t, r), e.set(r, a), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                         }
                                         return null
                                     }
                                 }
                             }
                             return r
                         },
                         dispose: function() {
                             e = new WeakMap
                         }
                     }
                 }
-                wi.physical = {
-                    uniforms: ni([wi.standard.uniforms, {
+                Ir.physical = {
+                    uniforms: dr([Ir.standard.uniforms, {
                         clearcoat: {
                             value: 0
                         },
                         clearcoatMap: {
                             value: null
                         },
                         clearcoatRoughness: {
                             value: 0
                         },
                         clearcoatRoughnessMap: {
                             value: null
                         },
                         clearcoatNormalScale: {
-                            value: new At(1, 1)
+                            value: new Be(1, 1)
                         },
                         clearcoatNormalMap: {
                             value: null
                         },
                         sheen: {
                             value: 0
                         },
                         sheenColor: {
-                            value: new zt(0)
+                            value: new Ze(0)
                         },
                         sheenColorMap: {
                             value: null
                         },
                         sheenRoughness: {
                             value: 1
                         },
@@ -5473,48 +5835,48 @@
                         transmission: {
                             value: 0
                         },
                         transmissionMap: {
                             value: null
                         },
                         transmissionSamplerSize: {
-                            value: new At
+                            value: new Be
                         },
                         transmissionSamplerMap: {
                             value: null
                         },
                         thickness: {
                             value: 0
                         },
                         thicknessMap: {
                             value: null
                         },
                         attenuationDistance: {
                             value: 0
                         },
                         attenuationColor: {
-                            value: new zt(0)
+                            value: new Ze(0)
                         },
                         specularIntensity: {
                             value: 1
                         },
                         specularIntensityMap: {
                             value: null
                         },
                         specularColor: {
-                            value: new zt(1, 1, 1)
+                            value: new Ze(1, 1, 1)
                         },
                         specularColorMap: {
                             value: null
                         }
                     }]),
-                    vertexShader: Mi.meshphysical_vert,
-                    fragmentShader: Mi.meshphysical_frag
+                    vertexShader: Pr.meshphysical_vert,
+                    fragmentShader: Pr.meshphysical_frag
                 };
-                class Ci extends si {
+                class Hr extends fr {
                     constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) {
                         super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                     }
                     setViewOffset(t, e, n, i, r, s) {
@@ -5548,41 +5910,43 @@
                         this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                     }
                 }
-                Ci.prototype.isOrthographicCamera = !0;
-                class Pi extends ri {
+                Hr.prototype.isOrthographicCamera = !0;
+                class Gr extends mr {
                     constructor(t) {
                         super(t), this.type = "RawShaderMaterial"
                     }
                 }
-                Pi.prototype.isRawShaderMaterial = !0;
-                const Di = Math.pow(2, 8),
-                    Ii = [.125, .215, .35, .446, .526, .582],
-                    Ni = 5 + Ii.length,
-                    Oi = new Ci,
+                Gr.prototype.isRawShaderMaterial = !0;
+                const Vr = 4,
+                    kr = 8,
+                    Wr = Math.pow(2, kr),
+                    jr = [.125, .215, .35, .446, .526, .582],
+                    Xr = kr - Vr + 1 + jr.length,
+                    qr = new Hr,
                     {
-                        _lodPlanes: Ui,
-                        _sizeLods: Bi,
-                        _sigmas: Fi
-                    } = ji(),
-                    zi = new zt;
-                let Hi = null;
-                const Gi = (1 + Math.sqrt(5)) / 2,
-                    Vi = 1 / Gi,
-                    ki = [new Jt(1, 1, 1), new Jt(-1, 1, 1), new Jt(1, 1, -1), new Jt(-1, 1, -1), new Jt(0, Gi, Vi), new Jt(0, Gi, -Vi), new Jt(Vi, 0, Gi), new Jt(-Vi, 0, Gi), new Jt(Gi, Vi, 0), new Jt(-Gi, Vi, 0)];
-                class Wi {
+                        _lodPlanes: Yr,
+                        _sizeLods: Zr,
+                        _sigmas: Jr
+                    } = is(),
+                    Kr = new Ze;
+                let Qr = null;
+                const $r = (1 + Math.sqrt(5)) / 2,
+                    ts = 1 / $r,
+                    es = [new on(1, 1, 1), new on(-1, 1, 1), new on(1, 1, -1), new on(-1, 1, -1), new on(0, $r, ts), new on(0, $r, -ts), new on(ts, 0, $r), new on(-ts, 0, $r), new on($r, ts, 0), new on(-$r, ts, 0)];
+                class ns {
                     constructor(t) {
                         this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
                             const e = new Float32Array(20),
-                                n = new Jt(0, 1, 0);
-                            return new Pi({
+                                n = new on(0, 1, 0);
+                            return new Gr({
                                 name: "SphericalGaussianBlur",
                                 defines: {
                                     n: 20
                                 },
                                 uniforms: {
                                     envMap: {
                                         value: null
@@ -5604,149 +5968,149 @@
                                     },
                                     poleAxis: {
                                         value: n
                                     }
                                 },
                                 vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                 fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
-                                blending: 0,
+                                blending: d,
                                 depthTest: !1,
                                 depthWrite: !1
                             })
                         }(), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                     }
                     fromScene(t, e = 0, n = .1, i = 100) {
-                        Hi = this._renderer.getRenderTarget();
+                        Qr = this._renderer.getRenderTarget();
                         const r = this._allocateTargets();
                         return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
                     }
                     fromEquirectangular(t, e = null) {
                         return this._fromTexture(t, e)
                     }
                     fromCubemap(t, e = null) {
                         return this._fromTexture(t, e)
                     }
                     compileCubemapShader() {
-                        null === this._cubemapShader && (this._cubemapShader = Zi(), this._compileMaterial(this._cubemapShader))
+                        null === this._cubemapShader && (this._cubemapShader = os(), this._compileMaterial(this._cubemapShader))
                     }
                     compileEquirectangularShader() {
-                        null === this._equirectShader && (this._equirectShader = Yi(), this._compileMaterial(this._equirectShader))
+                        null === this._equirectShader && (this._equirectShader = as(), this._compileMaterial(this._equirectShader))
                     }
                     dispose() {
                         this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
-                        for (let t = 0; t < Ui.length; t++) Ui[t].dispose()
+                        for (let t = 0; t < Yr.length; t++) Yr[t].dispose()
                     }
                     _cleanup(t) {
-                        this._renderer.setRenderTarget(Hi), t.scissorTest = !1, qi(t, 0, 0, t.width, t.height)
+                        this._renderer.setRenderTarget(Qr), t.scissorTest = !1, ss(t, 0, 0, t.width, t.height)
                     }
                     _fromTexture(t, e) {
-                        Hi = this._renderer.getRenderTarget();
+                        Qr = this._renderer.getRenderTarget();
                         const n = e || this._allocateTargets(t);
                         return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
                     }
                     _allocateTargets(t) {
                         const e = {
-                                magFilter: v,
-                                minFilter: v,
+                                magFilter: ht,
+                                minFilter: ht,
                                 generateMipmaps: !1,
-                                type: S,
-                                format: T,
-                                encoding: ot,
+                                type: _t,
+                                format: Et,
+                                encoding: me,
                                 depthBuffer: !1
                             },
-                            n = Xi(e);
-                        return n.depthBuffer = !t, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = Xi(e)), n
+                            n = rs(e);
+                        return n.depthBuffer = !t, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = rs(e)), n
                     }
                     _compileMaterial(t) {
-                        const e = new Qn(Ui[0], t);
-                        this._renderer.compile(e, Oi)
+                        const e = new lr(Yr[0], t);
+                        this._renderer.compile(e, qr)
                     }
                     _sceneToCubeUV(t, e, n, i) {
-                        const r = new ai(90, 1, e, n),
+                        const r = new gr(90, 1, e, n),
                             s = [1, -1, 1, 1, 1, 1],
                             a = [1, 1, 1, -1, -1, -1],
                             o = this._renderer,
                             l = o.autoClear,
                             c = o.toneMapping;
-                        o.getClearColor(zi), o.toneMapping = 0, o.autoClear = !1;
-                        const h = new pn({
+                        o.getClearColor(Kr), o.toneMapping = j, o.autoClear = !1;
+                        const u = new wi({
                                 name: "PMREM.Background",
-                                side: 1,
+                                side: h,
                                 depthWrite: !1,
                                 depthTest: !1
                             }),
-                            u = new Qn(new ti, h);
-                        let d = !1;
-                        const p = t.background;
-                        p ? p.isColor && (h.color.copy(p), t.background = null, d = !0) : (h.color.copy(zi), d = !0);
+                            d = new lr(new hr, u);
+                        let p = !1;
+                        const m = t.background;
+                        m ? m.isColor && (u.color.copy(m), t.background = null, p = !0) : (u.color.copy(Kr), p = !0);
                         for (let e = 0; e < 6; e++) {
                             const n = e % 3;
-                            0 === n ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])), qi(i, n * Di, e > 2 ? Di : 0, Di, Di), o.setRenderTarget(i), d && o.render(u, r), o.render(t, r)
+                            0 === n ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])), ss(i, n * Wr, e > 2 ? Wr : 0, Wr, Wr), o.setRenderTarget(i), p && o.render(d, r), o.render(t, r)
                         }
-                        u.geometry.dispose(), u.material.dispose(), o.toneMapping = c, o.autoClear = l, t.background = p
+                        d.geometry.dispose(), d.material.dispose(), o.toneMapping = c, o.autoClear = l, t.background = m
                     }
                     _textureToCubeUV(t, e) {
                         const n = this._renderer,
-                            i = t.mapping === s || t.mapping === a;
-                        i ? (null === this._cubemapShader && (this._cubemapShader = Zi()), this._cubemapShader.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = Yi());
+                            i = t.mapping === Q || t.mapping === $;
+                        i ? (null === this._cubemapShader && (this._cubemapShader = os()), this._cubemapShader.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = as());
                         const r = i ? this._cubemapShader : this._equirectShader,
-                            o = new Qn(Ui[0], r),
-                            l = r.uniforms;
-                        l.envMap.value = t, i || l.texelSize.value.set(1 / t.image.width, 1 / t.image.height), qi(e, 0, 0, 3 * Di, 2 * Di), n.setRenderTarget(e), n.render(o, Oi)
+                            s = new lr(Yr[0], r),
+                            a = r.uniforms;
+                        a.envMap.value = t, i || a.texelSize.value.set(1 / t.image.width, 1 / t.image.height), ss(e, 0, 0, 3 * Wr, 2 * Wr), n.setRenderTarget(e), n.render(s, qr)
                     }
                     _applyPMREM(t) {
                         const e = this._renderer,
                             n = e.autoClear;
                         e.autoClear = !1;
-                        for (let e = 1; e < Ni; e++) {
-                            const n = Math.sqrt(Fi[e] * Fi[e] - Fi[e - 1] * Fi[e - 1]),
-                                i = ki[(e - 1) % ki.length];
+                        for (let e = 1; e < Xr; e++) {
+                            const n = Math.sqrt(Jr[e] * Jr[e] - Jr[e - 1] * Jr[e - 1]),
+                                i = es[(e - 1) % es.length];
                             this._blur(t, e - 1, e, n, i)
                         }
                         e.autoClear = n
                     }
                     _blur(t, e, n, i, r) {
                         const s = this._pingPongRenderTarget;
                         this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r)
                     }
                     _halfBlur(t, e, n, i, r, s, a) {
                         const o = this._renderer,
                             l = this._blurMaterial;
                         "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
-                        const c = new Qn(Ui[i], l),
+                        const c = new lr(Yr[i], l),
                             h = l.uniforms,
-                            u = Bi[n] - 1,
+                            u = Zr[n] - 1,
                             d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                             p = r / d,
                             m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                         m > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
                         const f = [];
                         let g = 0;
                         for (let t = 0; t < 20; ++t) {
                             const e = t / p,
                                 n = Math.exp(-e * e / 2);
                             f.push(n), 0 === t ? g += n : t < m && (g += 2 * n)
                         }
                         for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
-                        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = 8 - n;
-                        const v = Bi[i];
-                        qi(e, 3 * Math.max(0, Di - 2 * v), (0 === i ? 0 : 2 * Di) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), o.setRenderTarget(e), o.render(c, Oi)
+                        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = kr - n;
+                        const v = Zr[i];
+                        ss(e, 3 * Math.max(0, Wr - 2 * v), (0 === i ? 0 : 2 * Wr) + 2 * v * (i > kr - Vr ? i - kr + Vr : 0), 3 * v, 2 * v), o.setRenderTarget(e), o.render(c, qr)
                     }
                 }
 
-                function ji() {
+                function is() {
                     const t = [],
                         e = [],
                         n = [];
-                    let i = 8;
-                    for (let r = 0; r < Ni; r++) {
+                    let i = kr;
+                    for (let r = 0; r < Xr; r++) {
                         const s = Math.pow(2, i);
                         e.push(s);
                         let a = 1 / s;
-                        r > 4 ? a = Ii[r - 8 + 4 - 1] : 0 === r && (a = 0), n.push(a);
+                        r > kr - Vr ? a = jr[r - kr + Vr - 1] : 0 === r && (a = 0), n.push(a);
                         const o = 1 / (s - 1),
                             l = -o / 2,
                             c = 1 + o / 2,
                             h = [l, l, c, l, c, c, l, l, c, c, l, c],
                             u = 6,
                             d = 6,
                             p = 3,
@@ -5759,118 +6123,118 @@
                             const e = t % 3 * 2 / 3 - 1,
                                 n = t > 2 ? 0 : -1,
                                 i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                             g.set(i, p * d * t), v.set(h, m * d * t);
                             const r = [t, t, t, t, t, t];
                             x.set(r, f * d * t)
                         }
-                        const y = new Nn;
-                        y.setAttribute("position", new gn(g, p)), y.setAttribute("uv", new gn(v, m)), y.setAttribute("faceIndex", new gn(x, f)), t.push(y), i > 4 && i--
+                        const y = new Wi;
+                        y.setAttribute("position", new Ti(g, p)), y.setAttribute("uv", new Ti(v, m)), y.setAttribute("faceIndex", new Ti(x, f)), t.push(y), i > Vr && i--
                     }
                     return {
                         _lodPlanes: t,
                         _sizeLods: e,
                         _sigmas: n
                     }
                 }
 
-                function Xi(t) {
-                    const e = new Xt(3 * Di, 3 * Di, t);
-                    return e.texture.mapping = c, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
+                function rs(t) {
+                    const e = new nn(3 * Wr, 3 * Wr, t);
+                    return e.texture.mapping = nt, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
                 }
 
-                function qi(t, e, n, i, r) {
+                function ss(t, e, n, i, r) {
                     t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
                 }
 
-                function Yi() {
-                    const t = new At(1, 1);
-                    return new Pi({
+                function as() {
+                    const t = new Be(1, 1);
+                    return new Gr({
                         name: "EquirectangularToCubeUV",
                         uniforms: {
                             envMap: {
                                 value: null
                             },
                             texelSize: {
                                 value: t
                             }
                         },
                         vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                         fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",
-                        blending: 0,
+                        blending: d,
                         depthTest: !1,
                         depthWrite: !1
                     })
                 }
 
-                function Zi() {
-                    return new Pi({
+                function os() {
+                    return new Gr({
                         name: "CubemapToCubeUV",
                         uniforms: {
                             envMap: {
                                 value: null
                             },
                             flipEnvMap: {
                                 value: -1
                             }
                         },
                         vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                         fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
-                        blending: 0,
+                        blending: d,
                         depthTest: !1,
                         depthWrite: !1
                     })
                 }
 
-                function Ji(t) {
+                function ls(t) {
                     let e = new WeakMap,
                         n = null;
 
                     function i(t) {
                         const n = t.target;
                         n.removeEventListener("dispose", i);
                         const r = e.get(n);
                         void 0 !== r && (e.delete(n), r.dispose())
                     }
                     return {
                         get: function(r) {
                             if (r && r.isTexture) {
-                                const c = r.mapping,
-                                    h = c === o || c === l,
-                                    u = c === s || c === a;
-                                if (h || u) {
+                                const s = r.mapping,
+                                    a = s === tt || s === et,
+                                    o = s === Q || s === $;
+                                if (a || o) {
                                     if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                         r.needsPMREMUpdate = !1;
                                         let i = e.get(r);
-                                        return null === n && (n = new Wi(t)), i = h ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture
+                                        return null === n && (n = new ns(t)), i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture
                                     }
                                     if (e.has(r)) return e.get(r).texture; {
                                         const s = r.image;
-                                        if (h && s && s.height > 0 || u && s && function(t) {
+                                        if (a && s && s.height > 0 || o && s && function(t) {
                                                 let e = 0;
                                                 for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                                 return 6 === e
                                             }(s)) {
-                                            null === n && (n = new Wi(t));
-                                            const s = h ? n.fromEquirectangular(r) : n.fromCubemap(r);
+                                            null === n && (n = new ns(t));
+                                            const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                             return e.set(r, s), r.addEventListener("dispose", i), s.texture
                                         }
                                         return null
                                     }
                                 }
                             }
                             return r
                         },
                         dispose: function() {
                             e = new WeakMap, null !== n && (n.dispose(), n = null)
                         }
                     }
                 }
 
-                function Ki(t) {
+                function cs(t) {
                     const e = {};
 
                     function n(n) {
                         if (void 0 !== e[n]) return e[n];
                         let i;
                         switch (n) {
                             case "WEBGL_depth_texture":
@@ -5900,15 +6264,15 @@
                         get: function(t) {
                             const e = n(t);
                             return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                         }
                     }
                 }
 
-                function Qi(t, e, n, i) {
+                function hs(t, e, n, i) {
                     const r = {},
                         s = new WeakMap;
 
                     function a(t) {
                         const o = t.target;
                         null !== o.index && e.remove(o.index);
                         for (const t in o.attributes) e.remove(o.attributes[t]);
@@ -5937,15 +6301,15 @@
                             for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                                 const t = e + 0,
                                     i = e + 1,
                                     r = e + 2;
                                 n.push(t, i, i, r, r, t)
                             }
                         }
-                        const o = new(Lt(n) ? wn : Mn)(n, 1);
+                        const o = new(ze(n) ? Ii : Pi)(n, 1);
                         o.version = a;
                         const l = s.get(t);
                         l && e.remove(l), s.set(t, o)
                     }
                     return {
                         get: function(t, e) {
                             return !0 === r[e.id] || (e.addEventListener("dispose", a), r[e.id] = !0, n.memory.geometries++), e
@@ -5966,15 +6330,15 @@
                                 null !== n && e.version < n.version && o(t)
                             } else o(t);
                             return s.get(t)
                         }
                     }
                 }
 
-                function $i(t, e, n, i) {
+                function us(t, e, n, i) {
                     const r = i.isWebGL2;
                     let s, a, o;
                     this.setMode = function(t) {
                         s = t
                     }, this.setIndex = function(t) {
                         a = t.type, o = t.bytesPerElement
                     }, this.render = function(e, i) {
@@ -5984,15 +6348,15 @@
                         let h, u;
                         if (r) h = t, u = "drawElementsInstanced";
                         else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                         h[u](s, l, a, i * o, c), n.update(l, s, c)
                     }
                 }
 
-                function tr(t) {
+                function ds(t) {
                     const e = {
                         frame: 0,
                         calls: 0,
                         triangles: 0,
                         points: 0,
                         lines: 0
                     };
@@ -6026,44 +6390,44 @@
                                     break;
                                 default:
                                     console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                             }
                         }
                     }
                 }
-                class er extends kt {
+                class ps extends $e {
                     constructor(t = null, e = 1, n = 1, i = 1) {
                         super(null), this.image = {
                             data: t,
                             width: e,
                             height: n,
                             depth: i
-                        }, this.magFilter = m, this.minFilter = m, this.wrapR = d, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
+                        }, this.magFilter = ot, this.minFilter = ot, this.wrapR = st, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }
 
-                function nr(t, e) {
+                function ms(t, e) {
                     return t[0] - e[0]
                 }
 
-                function ir(t, e) {
+                function fs(t, e) {
                     return Math.abs(e[1]) - Math.abs(t[1])
                 }
 
-                function rr(t, e) {
+                function gs(t, e) {
                     let n = 1;
                     const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
                     i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), t.divideScalar(n)
                 }
 
-                function sr(t, e, n) {
+                function vs(t, e, n) {
                     const i = {},
                         r = new Float32Array(8),
                         s = new WeakMap,
-                        a = new Jt,
+                        a = new on,
                         o = [];
                     for (let t = 0; t < 8; t++) o[t] = [t, 0];
                     return {
                         update: function(l, c, h, u) {
                             const d = l.morphTargetInfluences;
                             if (!0 === e.isWebGL2) {
                                 const p = c.morphAttributes.position.length;
@@ -6073,74 +6437,74 @@
                                     const v = void 0 !== c.morphAttributes.normal,
                                         x = c.morphAttributes.position,
                                         y = c.morphAttributes.normal || [],
                                         _ = !0 === v ? 2 : 1;
                                     let M = c.attributes.position.count * _,
                                         b = 1;
                                     M > e.maxTextureSize && (b = Math.ceil(M / e.maxTextureSize), M = e.maxTextureSize);
-                                    const S = new Float32Array(M * b * 4 * p),
-                                        E = new er(S, M, b, p);
-                                    E.format = T, E.type = w, E.needsUpdate = !0;
-                                    const A = 4 * _;
-                                    for (let L = 0; L < p; L++) {
-                                        const C = x[L],
-                                            P = y[L],
-                                            D = M * b * 4 * L;
-                                        for (let I = 0; I < C.count; I++) {
-                                            a.fromBufferAttribute(C, I), !0 === C.normalized && rr(a, C);
-                                            const N = I * A;
-                                            S[D + N + 0] = a.x, S[D + N + 1] = a.y, S[D + N + 2] = a.z, S[D + N + 3] = 0, !0 === v && (a.fromBufferAttribute(P, I), !0 === P.normalized && rr(a, P), S[D + N + 4] = a.x, S[D + N + 5] = a.y, S[D + N + 6] = a.z, S[D + N + 7] = 0)
+                                    const w = new Float32Array(M * b * 4 * p),
+                                        S = new ps(w, M, b, p);
+                                    S.format = Et, S.type = yt, S.needsUpdate = !0;
+                                    const E = 4 * _;
+                                    for (let A = 0; A < p; A++) {
+                                        const R = x[A],
+                                            L = y[A],
+                                            C = M * b * 4 * A;
+                                        for (let P = 0; P < R.count; P++) {
+                                            a.fromBufferAttribute(R, P), !0 === R.normalized && gs(a, R);
+                                            const D = P * E;
+                                            w[C + D + 0] = a.x, w[C + D + 1] = a.y, w[C + D + 2] = a.z, w[C + D + 3] = 0, !0 === v && (a.fromBufferAttribute(L, P), !0 === L.normalized && gs(a, L), w[C + D + 4] = a.x, w[C + D + 5] = a.y, w[C + D + 6] = a.z, w[C + D + 7] = 0)
                                         }
                                     }
 
-                                    function R() {
-                                        E.dispose(), s.delete(c), c.removeEventListener("dispose", R)
+                                    function T() {
+                                        S.dispose(), s.delete(c), c.removeEventListener("dispose", T)
                                     }
                                     m = {
                                         count: p,
-                                        texture: E,
-                                        size: new At(M, b)
-                                    }, s.set(c, m), c.addEventListener("dispose", R)
+                                        texture: S,
+                                        size: new Be(M, b)
+                                    }, s.set(c, m), c.addEventListener("dispose", T)
                                 }
                                 let f = 0;
-                                for (let O = 0; O < d.length; O++) f += d[O];
+                                for (let I = 0; I < d.length; I++) f += d[I];
                                 const g = c.morphTargetsRelative ? 1 : 1 - f;
                                 u.getUniforms().setValue(t, "morphTargetBaseInfluence", g), u.getUniforms().setValue(t, "morphTargetInfluences", d), u.getUniforms().setValue(t, "morphTargetsTexture", m.texture, n), u.getUniforms().setValue(t, "morphTargetsTextureSize", m.size)
                             } else {
-                                const U = void 0 === d ? 0 : d.length;
-                                let B = i[c.id];
-                                if (void 0 === B || B.length !== U) {
-                                    B = [];
-                                    for (let V = 0; V < U; V++) B[V] = [V, 0];
-                                    i[c.id] = B
+                                const N = void 0 === d ? 0 : d.length;
+                                let O = i[c.id];
+                                if (void 0 === O || O.length !== N) {
+                                    O = [];
+                                    for (let H = 0; H < N; H++) O[H] = [H, 0];
+                                    i[c.id] = O
                                 }
-                                for (let k = 0; k < U; k++) {
-                                    const W = B[k];
-                                    W[0] = k, W[1] = d[k]
+                                for (let G = 0; G < N; G++) {
+                                    const V = O[G];
+                                    V[0] = G, V[1] = d[G]
                                 }
-                                B.sort(ir);
-                                for (let j = 0; j < 8; j++) j < U && B[j][1] ? (o[j][0] = B[j][0], o[j][1] = B[j][1]) : (o[j][0] = Number.MAX_SAFE_INTEGER, o[j][1] = 0);
-                                o.sort(nr);
-                                const F = c.morphAttributes.position,
-                                    z = c.morphAttributes.normal;
-                                let H = 0;
-                                for (let X = 0; X < 8; X++) {
-                                    const q = o[X],
-                                        Y = q[0],
-                                        Z = q[1];
-                                    Y !== Number.MAX_SAFE_INTEGER && Z ? (F && c.getAttribute("morphTarget" + X) !== F[Y] && c.setAttribute("morphTarget" + X, F[Y]), z && c.getAttribute("morphNormal" + X) !== z[Y] && c.setAttribute("morphNormal" + X, z[Y]), r[X] = Z, H += Z) : (F && !0 === c.hasAttribute("morphTarget" + X) && c.deleteAttribute("morphTarget" + X), z && !0 === c.hasAttribute("morphNormal" + X) && c.deleteAttribute("morphNormal" + X), r[X] = 0)
+                                O.sort(fs);
+                                for (let k = 0; k < 8; k++) k < N && O[k][1] ? (o[k][0] = O[k][0], o[k][1] = O[k][1]) : (o[k][0] = Number.MAX_SAFE_INTEGER, o[k][1] = 0);
+                                o.sort(ms);
+                                const U = c.morphAttributes.position,
+                                    B = c.morphAttributes.normal;
+                                let F = 0;
+                                for (let W = 0; W < 8; W++) {
+                                    const j = o[W],
+                                        X = j[0],
+                                        q = j[1];
+                                    X !== Number.MAX_SAFE_INTEGER && q ? (U && c.getAttribute("morphTarget" + W) !== U[X] && c.setAttribute("morphTarget" + W, U[X]), B && c.getAttribute("morphNormal" + W) !== B[X] && c.setAttribute("morphNormal" + W, B[X]), r[W] = q, F += q) : (U && !0 === c.hasAttribute("morphTarget" + W) && c.deleteAttribute("morphTarget" + W), B && !0 === c.hasAttribute("morphNormal" + W) && c.deleteAttribute("morphNormal" + W), r[W] = 0)
                                 }
-                                const G = c.morphTargetsRelative ? 1 : 1 - H;
-                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", G), u.getUniforms().setValue(t, "morphTargetInfluences", r)
+                                const z = c.morphTargetsRelative ? 1 : 1 - F;
+                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", z), u.getUniforms().setValue(t, "morphTargetInfluences", r)
                             }
                         }
                     }
                 }
 
-                function ar(t, e, n, i) {
+                function xs(t, e, n, i) {
                     let r = new WeakMap;
 
                     function s(t) {
                         const e = t.target;
                         e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                     }
                     return {
@@ -6151,693 +6515,693 @@
                             return r.get(c) !== o && (e.update(c), r.set(c, o)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s), n.update(a.instanceMatrix, t.ARRAY_BUFFER), null !== a.instanceColor && n.update(a.instanceColor, t.ARRAY_BUFFER)), c
                         },
                         dispose: function() {
                             r = new WeakMap
                         }
                     }
                 }
-                er.prototype.isDataTexture2DArray = !0;
-                class or extends kt {
+                ps.prototype.isDataTexture2DArray = !0;
+                class ys extends $e {
                     constructor(t = null, e = 1, n = 1, i = 1) {
                         super(null), this.image = {
                             data: t,
                             width: e,
                             height: n,
                             depth: i
-                        }, this.magFilter = m, this.minFilter = m, this.wrapR = d, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
+                        }, this.magFilter = ot, this.minFilter = ot, this.wrapR = st, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }
-                or.prototype.isDataTexture3D = !0;
-                const lr = new kt,
-                    cr = new er,
-                    hr = new or,
-                    ur = new ci,
-                    dr = [],
-                    pr = [],
-                    mr = new Float32Array(16),
-                    fr = new Float32Array(9),
-                    gr = new Float32Array(4);
+                ys.prototype.isDataTexture3D = !0;
+                const _s = new $e,
+                    Ms = new ps,
+                    bs = new ys,
+                    ws = new yr,
+                    Ss = [],
+                    Es = [],
+                    Ts = new Float32Array(16),
+                    As = new Float32Array(9),
+                    Rs = new Float32Array(4);
 
-                function vr(t, e, n) {
+                function Ls(t, e, n) {
                     const i = t[0];
                     if (i <= 0 || i > 0) return t;
                     const r = e * n;
-                    let s = dr[r];
-                    if (void 0 === s && (s = new Float32Array(r), dr[r] = s), 0 !== e) {
+                    let s = Ss[r];
+                    if (void 0 === s && (s = new Float32Array(r), Ss[r] = s), 0 !== e) {
                         i.toArray(s, 0);
                         for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r)
                     }
                     return s
                 }
 
-                function xr(t, e) {
+                function Cs(t, e) {
                     if (t.length !== e.length) return !1;
                     for (let n = 0, i = t.length; n < i; n++)
                         if (t[n] !== e[n]) return !1;
                     return !0
                 }
 
-                function yr(t, e) {
+                function Ps(t, e) {
                     for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
                 }
 
-                function _r(t, e) {
-                    let n = pr[e];
-                    void 0 === n && (n = new Int32Array(e), pr[e] = n);
+                function Ds(t, e) {
+                    let n = Es[e];
+                    void 0 === n && (n = new Int32Array(e), Es[e] = n);
                     for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                     return n
                 }
 
-                function Mr(t, e) {
+                function Is(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
                 }
 
-                function br(t, e) {
+                function Ns(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                     else {
-                        if (xr(n, e)) return;
-                        t.uniform2fv(this.addr, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniform2fv(this.addr, e), Ps(n, e)
                     }
                 }
 
-                function wr(t, e) {
+                function Os(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                     else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                     else {
-                        if (xr(n, e)) return;
-                        t.uniform3fv(this.addr, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniform3fv(this.addr, e), Ps(n, e)
                     }
                 }
 
-                function Sr(t, e) {
+                function Us(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                     else {
-                        if (xr(n, e)) return;
-                        t.uniform4fv(this.addr, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniform4fv(this.addr, e), Ps(n, e)
                     }
                 }
 
-                function Er(t, e) {
+                function Bs(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (xr(n, e)) return;
-                        t.uniformMatrix2fv(this.addr, !1, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniformMatrix2fv(this.addr, !1, e), Ps(n, e)
                     } else {
-                        if (xr(n, i)) return;
-                        gr.set(i), t.uniformMatrix2fv(this.addr, !1, gr), yr(n, i)
+                        if (Cs(n, i)) return;
+                        Rs.set(i), t.uniformMatrix2fv(this.addr, !1, Rs), Ps(n, i)
                     }
                 }
 
-                function Tr(t, e) {
+                function Fs(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (xr(n, e)) return;
-                        t.uniformMatrix3fv(this.addr, !1, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniformMatrix3fv(this.addr, !1, e), Ps(n, e)
                     } else {
-                        if (xr(n, i)) return;
-                        fr.set(i), t.uniformMatrix3fv(this.addr, !1, fr), yr(n, i)
+                        if (Cs(n, i)) return;
+                        As.set(i), t.uniformMatrix3fv(this.addr, !1, As), Ps(n, i)
                     }
                 }
 
-                function Ar(t, e) {
+                function zs(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (xr(n, e)) return;
-                        t.uniformMatrix4fv(this.addr, !1, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniformMatrix4fv(this.addr, !1, e), Ps(n, e)
                     } else {
-                        if (xr(n, i)) return;
-                        mr.set(i), t.uniformMatrix4fv(this.addr, !1, mr), yr(n, i)
+                        if (Cs(n, i)) return;
+                        Ts.set(i), t.uniformMatrix4fv(this.addr, !1, Ts), Ps(n, i)
                     }
                 }
 
-                function Rr(t, e) {
+                function Hs(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
                 }
 
-                function Lr(t, e) {
+                function Gs(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform2iv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform2iv(this.addr, e), Ps(n, e))
                 }
 
-                function Cr(t, e) {
+                function Vs(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform3iv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform3iv(this.addr, e), Ps(n, e))
                 }
 
-                function Pr(t, e) {
+                function ks(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform4iv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform4iv(this.addr, e), Ps(n, e))
                 }
 
-                function Dr(t, e) {
+                function Ws(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
                 }
 
-                function Ir(t, e) {
+                function js(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform2uiv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform2uiv(this.addr, e), Ps(n, e))
                 }
 
-                function Nr(t, e) {
+                function Xs(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform3uiv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform3uiv(this.addr, e), Ps(n, e))
                 }
 
-                function Or(t, e) {
+                function qs(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform4uiv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform4uiv(this.addr, e), Ps(n, e))
                 }
 
-                function Ur(t, e, n) {
+                function Ys(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || lr, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || _s, r)
                 }
 
-                function Br(t, e, n) {
+                function Zs(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || hr, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || bs, r)
                 }
 
-                function Fr(t, e, n) {
+                function Js(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || ur, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || ws, r)
                 }
 
-                function zr(t, e, n) {
+                function Ks(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || cr, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || Ms, r)
                 }
 
-                function Hr(t, e) {
+                function Qs(t, e) {
                     t.uniform1fv(this.addr, e)
                 }
 
-                function Gr(t, e) {
-                    const n = vr(e, this.size, 2);
+                function $s(t, e) {
+                    const n = Ls(e, this.size, 2);
                     t.uniform2fv(this.addr, n)
                 }
 
-                function Vr(t, e) {
-                    const n = vr(e, this.size, 3);
+                function ta(t, e) {
+                    const n = Ls(e, this.size, 3);
                     t.uniform3fv(this.addr, n)
                 }
 
-                function kr(t, e) {
-                    const n = vr(e, this.size, 4);
+                function ea(t, e) {
+                    const n = Ls(e, this.size, 4);
                     t.uniform4fv(this.addr, n)
                 }
 
-                function Wr(t, e) {
-                    const n = vr(e, this.size, 4);
+                function na(t, e) {
+                    const n = Ls(e, this.size, 4);
                     t.uniformMatrix2fv(this.addr, !1, n)
                 }
 
-                function jr(t, e) {
-                    const n = vr(e, this.size, 9);
+                function ia(t, e) {
+                    const n = Ls(e, this.size, 9);
                     t.uniformMatrix3fv(this.addr, !1, n)
                 }
 
-                function Xr(t, e) {
-                    const n = vr(e, this.size, 16);
+                function ra(t, e) {
+                    const n = Ls(e, this.size, 16);
                     t.uniformMatrix4fv(this.addr, !1, n)
                 }
 
-                function qr(t, e) {
+                function sa(t, e) {
                     t.uniform1iv(this.addr, e)
                 }
 
-                function Yr(t, e) {
+                function aa(t, e) {
                     t.uniform2iv(this.addr, e)
                 }
 
-                function Zr(t, e) {
+                function oa(t, e) {
                     t.uniform3iv(this.addr, e)
                 }
 
-                function Jr(t, e) {
+                function la(t, e) {
                     t.uniform4iv(this.addr, e)
                 }
 
-                function Kr(t, e) {
+                function ca(t, e) {
                     t.uniform1uiv(this.addr, e)
                 }
 
-                function Qr(t, e) {
+                function ha(t, e) {
                     t.uniform2uiv(this.addr, e)
                 }
 
-                function $r(t, e) {
+                function ua(t, e) {
                     t.uniform3uiv(this.addr, e)
                 }
 
-                function ts(t, e) {
+                function da(t, e) {
                     t.uniform4uiv(this.addr, e)
                 }
 
-                function es(t, e, n) {
+                function pa(t, e, n) {
                     const i = e.length,
-                        r = _r(n, i);
+                        r = Ds(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || lr, r[t])
+                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || _s, r[t])
                 }
 
-                function ns(t, e, n) {
+                function ma(t, e, n) {
                     const i = e.length,
-                        r = _r(n, i);
+                        r = Ds(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || hr, r[t])
+                    for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || bs, r[t])
                 }
 
-                function is(t, e, n) {
+                function fa(t, e, n) {
                     const i = e.length,
-                        r = _r(n, i);
+                        r = Ds(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || ur, r[t])
+                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || ws, r[t])
                 }
 
-                function rs(t, e, n) {
+                function ga(t, e, n) {
                     const i = e.length,
-                        r = _r(n, i);
+                        r = Ds(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || cr, r[t])
+                    for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || Ms, r[t])
                 }
 
-                function ss(t, e, n) {
+                function va(t, e, n) {
                     this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                         switch (t) {
                             case 5126:
-                                return Mr;
+                                return Is;
                             case 35664:
-                                return br;
+                                return Ns;
                             case 35665:
-                                return wr;
+                                return Os;
                             case 35666:
-                                return Sr;
+                                return Us;
                             case 35674:
-                                return Er;
+                                return Bs;
                             case 35675:
-                                return Tr;
+                                return Fs;
                             case 35676:
-                                return Ar;
+                                return zs;
                             case 5124:
                             case 35670:
-                                return Rr;
+                                return Hs;
                             case 35667:
                             case 35671:
-                                return Lr;
+                                return Gs;
                             case 35668:
                             case 35672:
-                                return Cr;
+                                return Vs;
                             case 35669:
                             case 35673:
-                                return Pr;
+                                return ks;
                             case 5125:
-                                return Dr;
+                                return Ws;
                             case 36294:
-                                return Ir;
+                                return js;
                             case 36295:
-                                return Nr;
+                                return Xs;
                             case 36296:
-                                return Or;
+                                return qs;
                             case 35678:
                             case 36198:
                             case 36298:
                             case 36306:
                             case 35682:
-                                return Ur;
+                                return Ys;
                             case 35679:
                             case 36299:
                             case 36307:
-                                return Br;
+                                return Zs;
                             case 35680:
                             case 36300:
                             case 36308:
                             case 36293:
-                                return Fr;
+                                return Js;
                             case 36289:
                             case 36303:
                             case 36311:
                             case 36292:
-                                return zr
+                                return Ks
                         }
                     }(e.type)
                 }
 
-                function as(t, e, n) {
+                function xa(t, e, n) {
                     this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                         switch (t) {
                             case 5126:
-                                return Hr;
+                                return Qs;
                             case 35664:
-                                return Gr;
+                                return $s;
                             case 35665:
-                                return Vr;
+                                return ta;
                             case 35666:
-                                return kr;
+                                return ea;
                             case 35674:
-                                return Wr;
+                                return na;
                             case 35675:
-                                return jr;
+                                return ia;
                             case 35676:
-                                return Xr;
+                                return ra;
                             case 5124:
                             case 35670:
-                                return qr;
+                                return sa;
                             case 35667:
                             case 35671:
-                                return Yr;
+                                return aa;
                             case 35668:
                             case 35672:
-                                return Zr;
+                                return oa;
                             case 35669:
                             case 35673:
-                                return Jr;
+                                return la;
                             case 5125:
-                                return Kr;
+                                return ca;
                             case 36294:
-                                return Qr;
+                                return ha;
                             case 36295:
-                                return $r;
+                                return ua;
                             case 36296:
-                                return ts;
+                                return da;
                             case 35678:
                             case 36198:
                             case 36298:
                             case 36306:
                             case 35682:
-                                return es;
+                                return pa;
                             case 35679:
                             case 36299:
                             case 36307:
-                                return ns;
+                                return ma;
                             case 35680:
                             case 36300:
                             case 36308:
                             case 36293:
-                                return is;
+                                return fa;
                             case 36289:
                             case 36303:
                             case 36311:
                             case 36292:
-                                return rs
+                                return ga
                         }
                     }(e.type)
                 }
 
-                function os(t) {
+                function ya(t) {
                     this.id = t, this.seq = [], this.map = {}
                 }
-                as.prototype.updateCache = function(t) {
+                xa.prototype.updateCache = function(t) {
                     const e = this.cache;
-                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), yr(e, t)
-                }, os.prototype.setValue = function(t, e, n) {
+                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Ps(e, t)
+                }, ya.prototype.setValue = function(t, e, n) {
                     const i = this.seq;
                     for (let r = 0, s = i.length; r !== s; ++r) {
                         const s = i[r];
                         s.setValue(t, e[s.id], n)
                     }
                 };
-                const ls = /(\w+)(\])?(\[|\.)?/g;
+                const _a = /(\w+)(\])?(\[|\.)?/g;
 
-                function cs(t, e) {
+                function Ma(t, e) {
                     t.seq.push(e), t.map[e.id] = e
                 }
 
-                function hs(t, e, n) {
+                function ba(t, e, n) {
                     const i = t.name,
                         r = i.length;
-                    for (ls.lastIndex = 0;;) {
-                        const s = ls.exec(i),
-                            a = ls.lastIndex;
+                    for (_a.lastIndex = 0;;) {
+                        const s = _a.exec(i),
+                            a = _a.lastIndex;
                         let o = s[1];
                         const l = "]" === s[2],
                             c = s[3];
                         if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === r) {
-                            cs(n, void 0 === c ? new ss(o, t, e) : new as(o, t, e));
+                            Ma(n, void 0 === c ? new va(o, t, e) : new xa(o, t, e));
                             break
                         } {
                             let t = n.map[o];
-                            void 0 === t && (t = new os(o), cs(n, t)), n = t
+                            void 0 === t && (t = new ya(o), Ma(n, t)), n = t
                         }
                     }
                 }
 
-                function us(t, e) {
+                function wa(t, e) {
                     this.seq = [], this.map = {};
                     const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                     for (let i = 0; i < n; ++i) {
                         const n = t.getActiveUniform(e, i);
-                        hs(n, t.getUniformLocation(e, n.name), this)
+                        ba(n, t.getUniformLocation(e, n.name), this)
                     }
                 }
 
-                function ds(t, e, n) {
+                function Sa(t, e, n) {
                     const i = t.createShader(e);
                     return t.shaderSource(i, n), t.compileShader(i), i
                 }
-                us.prototype.setValue = function(t, e, n, i) {
+                wa.prototype.setValue = function(t, e, n, i) {
                     const r = this.map[e];
                     void 0 !== r && r.setValue(t, n, i)
-                }, us.prototype.setOptional = function(t, e, n) {
+                }, wa.prototype.setOptional = function(t, e, n) {
                     const i = e[n];
                     void 0 !== i && this.setValue(t, n, i)
-                }, us.upload = function(t, e, n, i) {
+                }, wa.upload = function(t, e, n, i) {
                     for (let r = 0, s = e.length; r !== s; ++r) {
                         const s = e[r],
                             a = n[s.id];
                         !1 !== a.needsUpdate && s.setValue(t, a.value, i)
                     }
-                }, us.seqWithValue = function(t, e) {
+                }, wa.seqWithValue = function(t, e) {
                     const n = [];
                     for (let i = 0, r = t.length; i !== r; ++i) {
                         const r = t[i];
                         r.id in e && n.push(r)
                     }
                     return n
                 };
-                let ps = 0;
+                let Ea = 0;
 
-                function ms(t, e, n) {
+                function Ta(t, e, n) {
                     const i = t.getShaderParameter(e, t.COMPILE_STATUS),
                         r = t.getShaderInfoLog(e).trim();
                     return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function(t) {
                         const e = t.split("\n");
                         for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                         return e.join("\n")
                     }(t.getShaderSource(e))
                 }
 
-                function fs(t, e) {
+                function Aa(t, e) {
                     const n = function(t) {
                         switch (t) {
-                            case ot:
+                            case me:
                                 return ["Linear", "( value )"];
-                            case lt:
+                            case fe:
                                 return ["sRGB", "( value )"];
                             default:
                                 return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                         }
                     }(e);
                     return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                 }
 
-                function gs(t, e) {
+                function Ra(t, e) {
                     let n;
                     switch (e) {
-                        case 1:
+                        case X:
                             n = "Linear";
                             break;
-                        case 2:
+                        case q:
                             n = "Reinhard";
                             break;
-                        case 3:
+                        case Y:
                             n = "OptimizedCineon";
                             break;
-                        case 4:
+                        case Z:
                             n = "ACESFilmic";
                             break;
-                        case 5:
+                        case J:
                             n = "Custom";
                             break;
                         default:
                             console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                     }
                     return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                 }
 
-                function vs(t) {
+                function La(t) {
                     return "" !== t
                 }
 
-                function xs(t, e) {
+                function Ca(t, e) {
                     return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
                 }
 
-                function ys(t, e) {
+                function Pa(t, e) {
                     return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
                 }
-                const _s = /^[ \t]*#include +<([\w\d./]+)>/gm;
+                const Da = /^[ \t]*#include +<([\w\d./]+)>/gm;
 
-                function Ms(t) {
-                    return t.replace(_s, bs)
+                function Ia(t) {
+                    return t.replace(Da, Na)
                 }
 
-                function bs(t, e) {
-                    const n = Mi[e];
+                function Na(t, e) {
+                    const n = Pr[e];
                     if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
-                    return Ms(n)
+                    return Ia(n)
                 }
-                const ws = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
-                    Ss = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
+                const Oa = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
+                    Ua = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
 
-                function Es(t) {
-                    return t.replace(Ss, As).replace(ws, Ts)
+                function Ba(t) {
+                    return t.replace(Ua, za).replace(Oa, Fa)
                 }
 
-                function Ts(t, e, n, i) {
-                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), As(0, e, n, i)
+                function Fa(t, e, n, i) {
+                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), za(0, e, n, i)
                 }
 
-                function As(t, e, n, i) {
+                function za(t, e, n, i) {
                     let r = "";
                     for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
                     return r
                 }
 
-                function Rs(t) {
+                function Ha(t) {
                     let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                     return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
                 }
 
-                function Ls(t, e, n, i) {
+                function Ga(t, e, n, i) {
                     const r = t.getContext(),
-                        o = n.defines;
-                    let l = n.vertexShader,
-                        u = n.fragmentShader;
-                    const d = function(t) {
+                        s = n.defines;
+                    let c = n.vertexShader,
+                        h = n.fragmentShader;
+                    const u = function(t) {
                             let e = "SHADOWMAP_TYPE_BASIC";
-                            return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
+                            return t.shadowMapType === a ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === o ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === l && (e = "SHADOWMAP_TYPE_VSM"), e
                         }(n),
-                        p = function(t) {
+                        d = function(t) {
                             let e = "ENVMAP_TYPE_CUBE";
                             if (t.envMap) switch (t.envMapMode) {
-                                case s:
-                                case a:
+                                case Q:
+                                case $:
                                     e = "ENVMAP_TYPE_CUBE";
                                     break;
-                                case c:
-                                case h:
+                                case nt:
+                                case it:
                                     e = "ENVMAP_TYPE_CUBE_UV"
                             }
                             return e
                         }(n),
-                        m = function(t) {
+                        p = function(t) {
                             let e = "ENVMAP_MODE_REFLECTION";
                             if (t.envMap) switch (t.envMapMode) {
-                                case a:
-                                case h:
+                                case $:
+                                case it:
                                     e = "ENVMAP_MODE_REFRACTION"
                             }
                             return e
                         }(n),
-                        f = function(t) {
+                        m = function(t) {
                             let e = "ENVMAP_BLENDING_NONE";
                             if (t.envMap) switch (t.combine) {
-                                case 0:
+                                case V:
                                     e = "ENVMAP_BLENDING_MULTIPLY";
                                     break;
-                                case 1:
+                                case k:
                                     e = "ENVMAP_BLENDING_MIX";
                                     break;
-                                case 2:
+                                case W:
                                     e = "ENVMAP_BLENDING_ADD"
                             }
                             return e
                         }(n),
-                        g = n.isWebGL2 ? "" : function(t) {
-                            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(vs).join("\n")
+                        f = n.isWebGL2 ? "" : function(t) {
+                            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(La).join("\n")
                         }(n),
-                        v = function(t) {
+                        g = function(t) {
                             const e = [];
                             for (const n in t) {
                                 const i = t[n];
                                 !1 !== i && e.push("#define " + n + " " + i)
                             }
                             return e.join("\n")
-                        }(o),
-                        x = r.createProgram();
-                    let y, _, M = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
-                    n.isRawShaderMaterial ? (y = [v].filter(vs).join("\n"), y.length > 0 && (y += "\n"), _ = [g, v].filter(vs).join("\n"), _.length > 0 && (_ += "\n")) : (y = [Rs(n), "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(vs).join("\n"), _ = [g, Rs(n), "#define SHADER_NAME " + n.shaderName, v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Mi.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? gs("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.alphaWrite ? "" : "#define OPAQUE", Mi.encodings_pars_fragment, fs("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(vs).join("\n")), l = Ms(l), l = xs(l, n), l = ys(l, n), u = Ms(u), u = xs(u, n), u = ys(u, n), l = Es(l), u = Es(u), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (M = "#version 300 es\n", y = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, _ = ["#define varying in", n.glslVersion === dt ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === dt ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _);
-                    const b = M + y + l,
-                        w = M + _ + u,
-                        S = ds(r, r.VERTEX_SHADER, b),
-                        E = ds(r, r.FRAGMENT_SHADER, w);
-                    if (r.attachShader(x, S), r.attachShader(x, E), void 0 !== n.index0AttributeName ? r.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(x, 0, "position"), r.linkProgram(x), t.debug.checkShaderErrors) {
-                        const t = r.getProgramInfoLog(x).trim(),
-                            e = r.getShaderInfoLog(S).trim(),
-                            n = r.getShaderInfoLog(E).trim();
+                        }(s),
+                        v = r.createProgram();
+                    let x, y, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
+                    n.isRawShaderMaterial ? (x = [g].filter(La).join("\n"), x.length > 0 && (x += "\n"), y = [f, g].filter(La).join("\n"), y.length > 0 && (y += "\n")) : (x = [Ha(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(La).join("\n"), y = [f, Ha(n), "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== j ? "#define TONE_MAPPING" : "", n.toneMapping !== j ? Pr.tonemapping_pars_fragment : "", n.toneMapping !== j ? Ra("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.alphaWrite ? "" : "#define OPAQUE", Pr.encodings_pars_fragment, Aa("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(La).join("\n")), c = Ia(c), c = Ca(c, n), c = Pa(c, n), h = Ia(h), h = Ca(h, n), h = Pa(h, n), c = Ba(c), h = Ba(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, y = ["#define varying in", n.glslVersion === be ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === be ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
+                    const M = _ + x + c,
+                        b = _ + y + h,
+                        w = Sa(r, r.VERTEX_SHADER, M),
+                        S = Sa(r, r.FRAGMENT_SHADER, b);
+                    if (r.attachShader(v, w), r.attachShader(v, S), void 0 !== n.index0AttributeName ? r.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(v, 0, "position"), r.linkProgram(v), t.debug.checkShaderErrors) {
+                        const t = r.getProgramInfoLog(v).trim(),
+                            e = r.getShaderInfoLog(w).trim(),
+                            n = r.getShaderInfoLog(S).trim();
                         let i = !0,
                             s = !0;
-                        if (!1 === r.getProgramParameter(x, r.LINK_STATUS)) {
+                        if (!1 === r.getProgramParameter(v, r.LINK_STATUS)) {
                             i = !1;
-                            const e = ms(r, S, "vertex"),
-                                n = ms(r, E, "fragment");
-                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(x, r.VALIDATE_STATUS) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
+                            const e = Ta(r, w, "vertex"),
+                                n = Ta(r, S, "fragment");
+                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(v, r.VALIDATE_STATUS) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
                         } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (s = !1);
                         s && (this.diagnostics = {
                             runnable: i,
                             programLog: t,
                             vertexShader: {
                                 log: e,
-                                prefix: y
+                                prefix: x
                             },
                             fragmentShader: {
                                 log: n,
-                                prefix: _
+                                prefix: y
                             }
                         })
                     }
-                    let T, A;
-                    return r.deleteShader(S), r.deleteShader(E), this.getUniforms = function() {
-                        return void 0 === T && (T = new us(r, x)), T
+                    let E, T;
+                    return r.deleteShader(w), r.deleteShader(S), this.getUniforms = function() {
+                        return void 0 === E && (E = new wa(r, v)), E
                     }, this.getAttributes = function() {
-                        return void 0 === A && (A = function(t, e) {
+                        return void 0 === T && (T = function(t, e) {
                             const n = {},
                                 i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                             for (let r = 0; r < i; r++) {
                                 const i = t.getActiveAttrib(e, r),
                                     s = i.name;
                                 let a = 1;
                                 i.type === t.FLOAT_MAT2 && (a = 2), i.type === t.FLOAT_MAT3 && (a = 3), i.type === t.FLOAT_MAT4 && (a = 4), n[s] = {
                                     type: i.type,
                                     location: t.getAttribLocation(e, s),
                                     locationSize: a
                                 }
                             }
                             return n
-                        }(r, x)), A
+                        }(r, v)), T
                     }, this.destroy = function() {
-                        i.releaseStatesOfProgram(this), r.deleteProgram(x), this.program = void 0
-                    }, this.name = n.shaderName, this.id = ps++, this.cacheKey = e, this.usedTimes = 1, this.program = x, this.vertexShader = S, this.fragmentShader = E, this
+                        i.releaseStatesOfProgram(this), r.deleteProgram(v), this.program = void 0
+                    }, this.name = n.shaderName, this.id = Ea++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = w, this.fragmentShader = S, this
                 }
-                let Cs = 0;
-                class Ps {
+                let Va = 0;
+                class ka {
                     constructor() {
                         this.shaderCache = new Map, this.materialCache = new Map
                     }
                     update(t) {
                         const e = t.vertexShader,
                             n = t.fragmentShader,
                             i = this._getShaderStage(e),
@@ -6862,30 +7226,30 @@
                     _getShaderCacheForMaterial(t) {
                         const e = this.materialCache;
                         return !1 === e.has(t) && e.set(t, new Set), e.get(t)
                     }
                     _getShaderStage(t) {
                         const e = this.shaderCache;
                         if (!1 === e.has(t)) {
-                            const n = new Ds;
+                            const n = new Wa;
                             e.set(t, n)
                         }
                         return e.get(t)
                     }
                 }
-                class Ds {
+                class Wa {
                     constructor() {
-                        this.id = Cs++, this.usedTimes = 0
+                        this.id = Va++, this.usedTimes = 0
                     }
                 }
 
-                function Is(t, e, n, i, r, s, a) {
-                    const o = new Fe,
-                        l = new Ps,
-                        u = [],
+                function ja(t, e, n, i, r, s, a) {
+                    const o = new Zn,
+                        l = new ka,
+                        c = [],
                         d = r.isWebGL2,
                         p = r.logarithmicDepthBuffer,
                         m = r.floatVertexTextures,
                         f = r.maxVertexUniforms,
                         g = r.vertexTextures;
                     let v = r.precision;
                     const x = {
@@ -6902,15 +7266,15 @@
                         LineBasicMaterial: "basic",
                         LineDashedMaterial: "dashed",
                         PointsMaterial: "points",
                         ShadowMaterial: "shadow",
                         SpriteMaterial: "sprite"
                     };
                     return {
-                        getParameters: function(s, o, u, y, _) {
+                        getParameters: function(s, o, c, y, _) {
                             const M = y.fog,
                                 b = s.isMeshStandardMaterial ? y.environment : null,
                                 w = (s.isMeshStandardMaterial ? n : e).get(s.envMap || b),
                                 S = x[s.type],
                                 E = _.isSkinnedMesh ? function(t) {
                                     const e = t.skeleton.bones;
                                     if (m) return 1024; {
@@ -6918,15 +7282,15 @@
                                             n = Math.floor((t - 20) / 4),
                                             i = Math.min(n, e.length);
                                         return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                                     }
                                 }(_) : 0;
                             let T, A, R, L;
                             if (null !== s.precision && (v = r.getMaxPrecision(s.precision), v !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", v, "instead.")), S) {
-                                const t = wi[S];
+                                const t = Ir[S];
                                 T = t.vertexShader, A = t.fragmentShader
                             } else T = s.vertexShader, A = s.fragmentShader, l.update(s), R = l.getVertexShaderID(s), L = l.getFragmentShaderID(s);
                             const C = t.getRenderTarget(),
                                 P = s.alphaTest > 0,
                                 D = s.clearcoat > 0;
                             return {
                                 isWebGL2: d,
@@ -6939,28 +7303,28 @@
                                 customFragmentShaderID: L,
                                 isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                                 glslVersion: s.glslVersion,
                                 precision: v,
                                 instancing: !0 === _.isInstancedMesh,
                                 instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
                                 supportsVertexTextures: g,
-                                outputEncoding: null === C ? t.outputEncoding : !0 === C.isXRRenderTarget ? C.texture.encoding : ot,
+                                outputEncoding: null === C ? t.outputEncoding : !0 === C.isXRRenderTarget ? C.texture.encoding : me,
                                 map: !!s.map,
                                 matcap: !!s.matcap,
                                 envMap: !!w,
                                 envMapMode: w && w.mapping,
-                                envMapCubeUV: !!w && (w.mapping === c || w.mapping === h),
+                                envMapCubeUV: !!w && (w.mapping === nt || w.mapping === it),
                                 lightMap: !!s.lightMap,
                                 aoMap: !!s.aoMap,
                                 emissiveMap: !!s.emissiveMap,
                                 bumpMap: !!s.bumpMap,
                                 normalMap: !!s.normalMap,
-                                objectSpaceNormalMap: 1 === s.normalMapType,
-                                tangentSpaceNormalMap: 0 === s.normalMapType,
-                                decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === lt,
+                                objectSpaceNormalMap: s.normalMapType === xe,
+                                tangentSpaceNormalMap: s.normalMapType === ve,
+                                decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === fe,
                                 clearcoat: D,
                                 clearcoatMap: D && !!s.clearcoatMap,
                                 clearcoatRoughnessMap: D && !!s.clearcoatRoughnessMap,
                                 clearcoatNormalMap: D && !!s.clearcoatNormalMap,
                                 displacementMap: !!s.displacementMap,
                                 roughnessMap: !!s.roughnessMap,
                                 metalnessMap: !!s.metalnessMap,
@@ -7002,21 +7366,21 @@
                                 numHemiLights: o.hemi.length,
                                 numDirLightShadows: o.directionalShadowMap.length,
                                 numPointLightShadows: o.pointShadowMap.length,
                                 numSpotLightShadows: o.spotShadowMap.length,
                                 numClippingPlanes: a.numPlanes,
                                 numClipIntersection: a.numIntersection,
                                 dithering: s.dithering,
-                                shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
+                                shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                                 shadowMapType: t.shadowMap.type,
-                                toneMapping: s.toneMapped ? t.toneMapping : 0,
+                                toneMapping: s.toneMapped ? t.toneMapping : j,
                                 physicallyCorrectLights: t.physicallyCorrectLights,
                                 premultipliedAlpha: s.premultipliedAlpha,
-                                doubleSided: 2 === s.side,
-                                flipSided: 1 === s.side,
+                                doubleSided: s.side === u,
+                                flipSided: s.side === h,
                                 depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                                 index0AttributeName: s.index0AttributeName,
                                 extensionDerivatives: s.extensions && s.extensions.derivatives,
                                 extensionFragDepth: s.extensions && s.extensions.fragDepth,
                                 extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                                 extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                                 rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
@@ -7035,47 +7399,47 @@
                                 o.disableAll(), e.isWebGL2 && o.enable(0), e.supportsVertexTextures && o.enable(1), e.instancing && o.enable(2), e.instancingColor && o.enable(3), e.map && o.enable(4), e.matcap && o.enable(5), e.envMap && o.enable(6), e.envMapCubeUV && o.enable(7), e.lightMap && o.enable(8), e.aoMap && o.enable(9), e.emissiveMap && o.enable(10), e.bumpMap && o.enable(11), e.normalMap && o.enable(12), e.objectSpaceNormalMap && o.enable(13), e.tangentSpaceNormalMap && o.enable(14), e.clearcoat && o.enable(15), e.clearcoatMap && o.enable(16), e.clearcoatRoughnessMap && o.enable(17), e.clearcoatNormalMap && o.enable(18), e.displacementMap && o.enable(19), e.specularMap && o.enable(20), e.roughnessMap && o.enable(21), e.metalnessMap && o.enable(22), e.gradientMap && o.enable(23), e.alphaMap && o.enable(24), e.alphaTest && o.enable(25), e.vertexColors && o.enable(26), e.vertexAlphas && o.enable(27), e.vertexUvs && o.enable(28), e.vertexTangents && o.enable(29), e.uvsVertexOnly && o.enable(30), e.fog && o.enable(31), t.push(o.mask), o.disableAll(), e.useFog && o.enable(0), e.flatShading && o.enable(1), e.logarithmicDepthBuffer && o.enable(2), e.skinning && o.enable(3), e.useVertexTexture && o.enable(4), e.morphTargets && o.enable(5), e.morphNormals && o.enable(6), e.premultipliedAlpha && o.enable(7), e.shadowMapEnabled && o.enable(8), e.physicallyCorrectLights && o.enable(9), e.doubleSided && o.enable(10), e.flipSided && o.enable(11), e.depthPacking && o.enable(12), e.dithering && o.enable(13), e.specularIntensityMap && o.enable(14), e.specularColorMap && o.enable(15), e.transmission && o.enable(16), e.transmissionMap && o.enable(17), e.thicknessMap && o.enable(18), e.sheen && o.enable(19), e.sheenColorMap && o.enable(20), e.sheenRoughnessMap && o.enable(21), e.decodeVideoTexture && o.enable(22), t.push(o.mask)
                             }(n, e), n.push(t.outputEncoding)), n.push(e.customProgramCacheKey), n.join()
                         },
                         getUniforms: function(t) {
                             const e = x[t.type];
                             let n;
                             if (e) {
-                                const t = wi[e];
-                                n = ii.clone(t.uniforms)
+                                const t = Ir[e];
+                                n = pr.clone(t.uniforms)
                             } else n = t.uniforms;
                             return n
                         },
                         acquireProgram: function(e, n) {
                             let i;
-                            for (let t = 0, e = u.length; t < e; t++) {
-                                const e = u[t];
+                            for (let t = 0, e = c.length; t < e; t++) {
+                                const e = c[t];
                                 if (e.cacheKey === n) {
                                     i = e, ++i.usedTimes;
                                     break
                                 }
                             }
-                            return void 0 === i && (i = new Ls(t, n, e, s), u.push(i)), i
+                            return void 0 === i && (i = new Ga(t, n, e, s), c.push(i)), i
                         },
                         releaseProgram: function(t) {
                             if (0 == --t.usedTimes) {
-                                const e = u.indexOf(t);
-                                u[e] = u[u.length - 1], u.pop(), t.destroy()
+                                const e = c.indexOf(t);
+                                c[e] = c[c.length - 1], c.pop(), t.destroy()
                             }
                         },
                         releaseShaderCache: function(t) {
                             l.remove(t)
                         },
-                        programs: u,
+                        programs: c,
                         dispose: function() {
                             l.dispose()
                         }
                     }
                 }
 
-                function Ns() {
+                function Xa() {
                     let t = new WeakMap;
                     return {
                         get: function(e) {
                             let n = t.get(e);
                             return void 0 === n && (n = {}, t.set(e, n)), n
                         },
                         remove: function(e) {
@@ -7086,23 +7450,23 @@
                         },
                         dispose: function() {
                             t = new WeakMap
                         }
                     }
                 }
 
-                function Os(t, e) {
+                function qa(t, e) {
                     return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                 }
 
-                function Us(t, e) {
+                function Ya(t, e) {
                     return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                 }
 
-                function Bs() {
+                function Za() {
                     const t = [];
                     let e = 0;
                     const n = [],
                         i = [],
                         r = [];
 
                     function s(n, i, r, s, a, o) {
@@ -7137,113 +7501,113 @@
                             for (let n = e, i = t.length; n < i; n++) {
                                 const e = t[n];
                                 if (null === e.id) break;
                                 e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                             }
                         },
                         sort: function(t, e) {
-                            n.length > 1 && n.sort(t || Os), i.length > 1 && i.sort(e || Us), r.length > 1 && r.sort(e || Us)
+                            n.length > 1 && n.sort(t || qa), i.length > 1 && i.sort(e || Ya), r.length > 1 && r.sort(e || Ya)
                         }
                     }
                 }
 
-                function Fs() {
+                function Ja() {
                     let t = new WeakMap;
                     return {
                         get: function(e, n) {
                             let i;
-                            return !1 === t.has(e) ? (i = new Bs, t.set(e, [i])) : n >= t.get(e).length ? (i = new Bs, t.get(e).push(i)) : i = t.get(e)[n], i
+                            return !1 === t.has(e) ? (i = new Za, t.set(e, [i])) : n >= t.get(e).length ? (i = new Za, t.get(e).push(i)) : i = t.get(e)[n], i
                         },
                         dispose: function() {
                             t = new WeakMap
                         }
                     }
                 }
 
-                function zs() {
+                function Ka() {
                     const t = {};
                     return {
                         get: function(e) {
                             if (void 0 !== t[e.id]) return t[e.id];
                             let n;
                             switch (e.type) {
                                 case "DirectionalLight":
                                     n = {
-                                        direction: new Jt,
-                                        color: new zt
+                                        direction: new on,
+                                        color: new Ze
                                     };
                                     break;
                                 case "SpotLight":
                                     n = {
-                                        position: new Jt,
-                                        direction: new Jt,
-                                        color: new zt,
+                                        position: new on,
+                                        direction: new on,
+                                        color: new Ze,
                                         distance: 0,
                                         coneCos: 0,
                                         penumbraCos: 0,
                                         decay: 0
                                     };
                                     break;
                                 case "PointLight":
                                     n = {
-                                        position: new Jt,
-                                        color: new zt,
+                                        position: new on,
+                                        color: new Ze,
                                         distance: 0,
                                         decay: 0
                                     };
                                     break;
                                 case "HemisphereLight":
                                     n = {
-                                        direction: new Jt,
-                                        skyColor: new zt,
-                                        groundColor: new zt
+                                        direction: new on,
+                                        skyColor: new Ze,
+                                        groundColor: new Ze
                                     };
                                     break;
                                 case "RectAreaLight":
                                     n = {
-                                        color: new zt,
-                                        position: new Jt,
-                                        halfWidth: new Jt,
-                                        halfHeight: new Jt
+                                        color: new Ze,
+                                        position: new on,
+                                        halfWidth: new on,
+                                        halfHeight: new on
                                     }
                             }
                             return t[e.id] = n, n
                         }
                     }
                 }
-                let Hs = 0;
+                let Qa = 0;
 
-                function Gs(t, e) {
+                function $a(t, e) {
                     return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
                 }
 
-                function Vs(t, e) {
-                    const n = new zs,
+                function to(t, e) {
+                    const n = new Ka,
                         i = function() {
                             const t = {};
                             return {
                                 get: function(e) {
                                     if (void 0 !== t[e.id]) return t[e.id];
                                     let n;
                                     switch (e.type) {
                                         case "DirectionalLight":
                                         case "SpotLight":
                                             n = {
                                                 shadowBias: 0,
                                                 shadowNormalBias: 0,
                                                 shadowRadius: 1,
-                                                shadowMapSize: new At
+                                                shadowMapSize: new Be
                                             };
                                             break;
                                         case "PointLight":
                                             n = {
                                                 shadowBias: 0,
                                                 shadowNormalBias: 0,
                                                 shadowRadius: 1,
-                                                shadowMapSize: new At,
+                                                shadowMapSize: new Be,
                                                 shadowCameraNear: 1,
                                                 shadowCameraFar: 1e3
                                             }
                                     }
                                     return t[e.id] = n, n
                                 }
                             }
@@ -7275,33 +7639,33 @@
                             rectAreaLTC2: null,
                             point: [],
                             pointShadow: [],
                             pointShadowMap: [],
                             pointShadowMatrix: [],
                             hemi: []
                         };
-                    for (let t = 0; t < 9; t++) r.probe.push(new Jt);
-                    const s = new Jt,
-                        a = new Ae,
-                        o = new Ae;
+                    for (let t = 0; t < 9; t++) r.probe.push(new on);
+                    const s = new on,
+                        a = new Fn,
+                        o = new Fn;
                     return {
                         setup: function(s, a) {
                             let o = 0,
                                 l = 0,
                                 c = 0;
                             for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                             let h = 0,
                                 u = 0,
                                 d = 0,
                                 p = 0,
                                 m = 0,
                                 f = 0,
                                 g = 0,
                                 v = 0;
-                            s.sort(Gs);
+                            s.sort($a);
                             const x = !0 !== a ? Math.PI : 1;
                             for (let t = 0, e = s.length; t < e; t++) {
                                 const e = s[t],
                                     a = e.color,
                                     y = e.intensity,
                                     _ = e.distance,
                                     M = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
@@ -7336,17 +7700,17 @@
                                     }
                                     r.point[u] = t, u++
                                 } else if (e.isHemisphereLight) {
                                     const t = n.get(e);
                                     t.skyColor.copy(e.color).multiplyScalar(y * x), t.groundColor.copy(e.groundColor).multiplyScalar(y * x), r.hemi[m] = t, m++
                                 }
                             }
-                            p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = bi.LTC_FLOAT_1, r.rectAreaLTC2 = bi.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = bi.LTC_HALF_1, r.rectAreaLTC2 = bi.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
+                            p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Dr.LTC_FLOAT_1, r.rectAreaLTC2 = Dr.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Dr.LTC_HALF_1, r.rectAreaLTC2 = Dr.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
                             const y = r.hash;
-                            y.directionalLength === h && y.pointLength === u && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === m && y.numDirectionalShadows === f && y.numPointShadows === g && y.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, y.directionalLength = h, y.pointLength = u, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = m, y.numDirectionalShadows = f, y.numPointShadows = g, y.numSpotShadows = v, r.version = Hs++)
+                            y.directionalLength === h && y.pointLength === u && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === m && y.numDirectionalShadows === f && y.numPointShadows === g && y.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, y.directionalLength = h, y.pointLength = u, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = m, y.numDirectionalShadows = f, y.numPointShadows = g, y.numSpotShadows = v, r.version = Qa++)
                         },
                         setupView: function(t, e) {
                             let n = 0,
                                 i = 0,
                                 l = 0,
                                 c = 0,
                                 h = 0;
@@ -7371,16 +7735,16 @@
                                 }
                             }
                         },
                         state: r
                     }
                 }
 
-                function ks(t, e) {
-                    const n = new Vs(t, e),
+                function eo(t, e) {
+                    const n = new to(t, e),
                         i = [],
                         r = [];
                     return {
                         init: function() {
                             i.length = 0, r.length = 0
                         },
                         state: {
@@ -7399,182 +7763,185 @@
                         },
                         pushShadow: function(t) {
                             r.push(t)
                         }
                     }
                 }
 
-                function Ws(t, e) {
+                function no(t, e) {
                     let n = new WeakMap;
                     return {
                         get: function(i, r = 0) {
                             let s;
-                            return !1 === n.has(i) ? (s = new ks(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new ks(t, e), n.get(i).push(s)) : s = n.get(i)[r], s
+                            return !1 === n.has(i) ? (s = new eo(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new eo(t, e), n.get(i).push(s)) : s = n.get(i)[r], s
                         },
                         dispose: function() {
                             n = new WeakMap
                         }
                     }
                 }
-                class js extends dn {
+                class io extends bi {
                     constructor(t) {
                         super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                     }
                 }
-                js.prototype.isMeshDepthMaterial = !0;
-                class Xs extends dn {
+                io.prototype.isMeshDepthMaterial = !0;
+                class ro extends bi {
                     constructor(t) {
-                        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Jt, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
+                        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new on, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                     }
                 }
-
-                function qs(t, e, n) {
-                    let i = new vi;
-                    const r = new At,
-                        s = new At,
-                        a = new jt,
-                        o = new js({
-                            depthPacking: 3201
+                ro.prototype.isMeshDistanceMaterial = !0;
+                const so = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
+                    ao = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
+
+                function oo(t, e, n) {
+                    let i = new Ar;
+                    const r = new Be,
+                        s = new Be,
+                        o = new en,
+                        p = new io({
+                            depthPacking: ge
                         }),
-                        l = new Xs,
-                        c = {},
-                        h = n.maxTextureSize,
-                        u = {
-                            0: 1,
-                            1: 0,
-                            2: 2
+                        m = new ro,
+                        f = {},
+                        g = n.maxTextureSize,
+                        v = {
+                            0: h,
+                            1: c,
+                            2: u
                         },
-                        d = new ri({
+                        x = new mr({
                             defines: {
                                 VSM_SAMPLES: 8
                             },
                             uniforms: {
                                 shadow_pass: {
                                     value: null
                                 },
                                 resolution: {
-                                    value: new At
+                                    value: new Be
                                 },
                                 radius: {
                                     value: 4
                                 }
                             },
-                            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
-                            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
+                            vertexShader: so,
+                            fragmentShader: ao
                         }),
-                        p = d.clone();
-                    p.defines.HORIZONTAL_PASS = 1;
-                    const f = new Nn;
-                    f.setAttribute("position", new gn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
-                    const g = new Qn(f, d),
-                        x = this;
-
-                    function y(n, i) {
-                        const r = e.update(g);
-                        d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, d, g, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, p, g, null)
-                    }
-
-                    function _(e, n, i, r, s, a, h) {
-                        let d = null;
-                        const p = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
-                        if (d = void 0 !== p ? p : !0 === r.isPointLight ? l : o, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
-                            const t = d.uuid,
+                        y = x.clone();
+                    y.defines.HORIZONTAL_PASS = 1;
+                    const _ = new Wi;
+                    _.setAttribute("position", new Ti(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
+                    const M = new lr(_, x),
+                        b = this;
+
+                    function w(n, i) {
+                        const r = e.update(M);
+                        x.defines.VSM_SAMPLES !== n.blurSamples && (x.defines.VSM_SAMPLES = n.blurSamples, y.defines.VSM_SAMPLES = n.blurSamples, x.needsUpdate = !0, y.needsUpdate = !0), x.uniforms.shadow_pass.value = n.map.texture, x.uniforms.resolution.value = n.mapSize, x.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, x, M, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, y, M, null)
+                    }
+
+                    function S(e, n, i, r, s, a, o) {
+                        let c = null;
+                        const h = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
+                        if (c = void 0 !== h ? h : !0 === r.isPointLight ? m : p, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
+                            const t = c.uuid,
                                 e = i.uuid;
-                            let n = c[t];
-                            void 0 === n && (n = {}, c[t] = n);
+                            let n = f[t];
+                            void 0 === n && (n = {}, f[t] = n);
                             let r = n[e];
-                            void 0 === r && (r = d.clone(), n[e] = r), d = r
+                            void 0 === r && (r = c.clone(), n[e] = r), c = r
                         }
-                        return d.visible = i.visible, d.wireframe = i.wireframe, d.side = 3 === h ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], d.alphaMap = i.alphaMap, d.alphaTest = i.alphaTest, d.clipShadows = i.clipShadows, d.clippingPlanes = i.clippingPlanes, d.clipIntersection = i.clipIntersection, d.displacementMap = i.displacementMap, d.displacementScale = i.displacementScale, d.displacementBias = i.displacementBias, d.wireframeLinewidth = i.wireframeLinewidth, d.linewidth = i.linewidth, !0 === r.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(r.matrixWorld), d.nearDistance = s, d.farDistance = a), d
+                        return c.visible = i.visible, c.wireframe = i.wireframe, c.side = o === l ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : v[i.side], c.alphaMap = i.alphaMap, c.alphaTest = i.alphaTest, c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.displacementMap = i.displacementMap, c.displacementScale = i.displacementScale, c.displacementBias = i.displacementBias, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld), c.nearDistance = s, c.farDistance = a), c
                     }
 
-                    function M(n, r, s, a, o) {
+                    function E(n, r, s, a, o) {
                         if (!1 === n.visible) return;
-                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
+                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && o === l) && (!n.frustumCulled || i.intersectsObject(n))) {
                             n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                             const i = e.update(n),
                                 r = n.material;
                             if (Array.isArray(r)) {
                                 const e = i.groups;
                                 for (let l = 0, c = e.length; l < c; l++) {
                                     const c = e[l],
                                         h = r[c.materialIndex];
                                     if (h && h.visible) {
-                                        const e = _(n, 0, h, a, s.near, s.far, o);
+                                        const e = S(n, 0, h, a, s.near, s.far, o);
                                         t.renderBufferDirect(s, null, i, e, n, c)
                                     }
                                 }
                             } else if (r.visible) {
-                                const e = _(n, 0, r, a, s.near, s.far, o);
+                                const e = S(n, 0, r, a, s.near, s.far, o);
                                 t.renderBufferDirect(s, null, i, e, n, null)
                             }
                         }
-                        const l = n.children;
-                        for (let t = 0, e = l.length; t < e; t++) M(l[t], r, s, a, o)
+                        const c = n.children;
+                        for (let t = 0, e = c.length; t < e; t++) E(c[t], r, s, a, o)
                     }
-                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, n, o) {
-                        if (!1 === x.enabled) return;
-                        if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
+                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = a, this.render = function(e, n, a) {
+                        if (!1 === b.enabled) return;
+                        if (!1 === b.autoUpdate && !1 === b.needsUpdate) return;
                         if (0 === e.length) return;
-                        const l = t.getRenderTarget(),
-                            c = t.getActiveCubeFace(),
+                        const c = t.getRenderTarget(),
+                            h = t.getActiveCubeFace(),
                             u = t.getActiveMipmapLevel(),
-                            d = t.state;
-                        d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
-                        for (let l = 0, c = e.length; l < c; l++) {
-                            const c = e[l],
-                                u = c.shadow;
+                            p = t.state;
+                        p.setBlending(d), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
+                        for (let c = 0, h = e.length; c < h; c++) {
+                            const h = e[c],
+                                u = h.shadow;
                             if (void 0 === u) {
-                                console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
+                                console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
                                 continue
                             }
                             if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                             r.copy(u.mapSize);
-                            const p = u.getFrameExtents();
-                            if (r.multiply(p), s.copy(u.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / p.x), r.x = s.x * p.x, u.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / p.y), r.y = s.y * p.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && 3 === this.type) {
+                            const d = u.getFrameExtents();
+                            if (r.multiply(d), s.copy(u.mapSize), (r.x > g || r.y > g) && (r.x > g && (s.x = Math.floor(g / d.x), r.x = s.x * d.x, u.mapSize.x = s.x), r.y > g && (s.y = Math.floor(g / d.y), r.y = s.y * d.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && this.type === l) {
                                 const t = {
-                                    minFilter: v,
-                                    magFilter: v,
-                                    format: T
+                                    minFilter: ht,
+                                    magFilter: ht,
+                                    format: Et
                                 };
-                                u.map = new Xt(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new Xt(r.x, r.y, t), u.camera.updateProjectionMatrix()
+                                u.map = new nn(r.x, r.y, t), u.map.texture.name = h.name + ".shadowMap", u.mapPass = new nn(r.x, r.y, t), u.camera.updateProjectionMatrix()
                             }
                             if (null === u.map) {
                                 const t = {
-                                    minFilter: m,
-                                    magFilter: m,
-                                    format: T
+                                    minFilter: ot,
+                                    magFilter: ot,
+                                    format: Et
                                 };
-                                u.map = new Xt(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix()
+                                u.map = new nn(r.x, r.y, t), u.map.texture.name = h.name + ".shadowMap", u.camera.updateProjectionMatrix()
                             }
                             t.setRenderTarget(u.map), t.clear();
-                            const f = u.getViewportCount();
-                            for (let t = 0; t < f; t++) {
+                            const m = u.getViewportCount();
+                            for (let t = 0; t < m; t++) {
                                 const e = u.getViewport(t);
-                                a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(a), u.updateMatrices(c, t), i = u.getFrustum(), M(n, o, u.camera, c, this.type)
+                                o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), p.viewport(o), u.updateMatrices(h, t), i = u.getFrustum(), E(n, a, u.camera, h, this.type)
                             }
-                            u.isPointLightShadow || 3 !== this.type || y(u, o), u.needsUpdate = !1
+                            u.isPointLightShadow || this.type !== l || w(u, a), u.needsUpdate = !1
                         }
-                        x.needsUpdate = !1, t.setRenderTarget(l, c, u)
+                        b.needsUpdate = !1, t.setRenderTarget(c, h, u)
                     }
                 }
 
-                function Ys(t, e, n) {
-                    const r = n.isWebGL2,
-                        s = new function() {
+                function lo(t, e, n) {
+                    const a = n.isWebGL2,
+                        o = new function() {
                             let e = !1;
-                            const n = new jt;
+                            const n = new en;
                             let i = null;
-                            const r = new jt(0, 0, 0, 0);
+                            const r = new en(0, 0, 0, 0);
                             return {
                                 setMask: function(n) {
                                     i === n || e || (t.colorMask(n, n, n, n), i = n)
                                 },
                                 setLocked: function(t) {
                                     e = t
                                 },
@@ -7582,53 +7949,55 @@
                                     !0 === o && (e *= a, i *= a, s *= a), n.set(e, i, s, a), !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n))
                                 },
                                 reset: function() {
                                     e = !1, i = null, r.set(-1, 0, 0, 0)
                                 }
                             }
                         },
-                        a = new function() {
+                        l = new function() {
                             let e = !1,
                                 n = null,
                                 i = null,
                                 r = null;
                             return {
                                 setTest: function(e) {
-                                    e ? z(t.DEPTH_TEST) : H(t.DEPTH_TEST)
+                                    e ? yt(t.DEPTH_TEST) : _t(t.DEPTH_TEST)
                                 },
                                 setMask: function(i) {
                                     n === i || e || (t.depthMask(i), n = i)
                                 },
                                 setFunc: function(e) {
                                     if (i !== e) {
                                         if (e) switch (e) {
-                                            case 0:
+                                            case N:
                                                 t.depthFunc(t.NEVER);
                                                 break;
-                                            case 1:
+                                            case O:
                                                 t.depthFunc(t.ALWAYS);
                                                 break;
-                                            case 2:
+                                            case U:
                                                 t.depthFunc(t.LESS);
                                                 break;
-                                            case 3:
-                                            default:
+                                            case B:
                                                 t.depthFunc(t.LEQUAL);
                                                 break;
-                                            case 4:
+                                            case F:
                                                 t.depthFunc(t.EQUAL);
                                                 break;
-                                            case 5:
+                                            case z:
                                                 t.depthFunc(t.GEQUAL);
                                                 break;
-                                            case 6:
+                                            case H:
                                                 t.depthFunc(t.GREATER);
                                                 break;
-                                            case 7:
-                                                t.depthFunc(t.NOTEQUAL)
+                                            case G:
+                                                t.depthFunc(t.NOTEQUAL);
+                                                break;
+                                            default:
+                                                t.depthFunc(t.LEQUAL)
                                         } else t.depthFunc(t.LEQUAL);
                                         i = e
                                     }
                                 },
                                 setLocked: function(t) {
                                     e = t
                                 },
@@ -7636,27 +8005,27 @@
                                     r !== e && (t.clearDepth(e), r = e)
                                 },
                                 reset: function() {
                                     e = !1, n = null, i = null, r = null
                                 }
                             }
                         },
-                        o = new function() {
+                        c = new function() {
                             let e = !1,
                                 n = null,
                                 i = null,
                                 r = null,
                                 s = null,
                                 a = null,
                                 o = null,
                                 l = null,
                                 c = null;
                             return {
                                 setTest: function(n) {
-                                    e || (n ? z(t.STENCIL_TEST) : H(t.STENCIL_TEST))
+                                    e || (n ? yt(t.STENCIL_TEST) : _t(t.STENCIL_TEST))
                                 },
                                 setMask: function(i) {
                                     n === i || e || (t.stencilMask(i), n = i)
                                 },
                                 setFunc: function(e, n, a) {
                                     i === e && r === n && s === a || (t.stencilFunc(e, n, a), i = e, r = n, s = a)
                                 },
@@ -7670,196 +8039,196 @@
                                     c !== e && (t.clearStencil(e), c = e)
                                 },
                                 reset: function() {
                                     e = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null
                                 }
                             }
                         };
-                    let l = {},
-                        c = {},
-                        h = new WeakMap,
-                        u = [],
-                        d = null,
-                        p = !1,
-                        m = null,
-                        f = null,
-                        g = null,
-                        v = null,
-                        x = null,
-                        y = null,
-                        _ = null,
-                        M = !1,
-                        b = null,
-                        w = null,
-                        S = null,
-                        E = null,
-                        T = null;
-                    const A = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
-                    let R = !1,
-                        L = 0;
-                    const C = t.getParameter(t.VERSION); - 1 !== C.indexOf("WebGL") ? (L = parseFloat(/^WebGL (\d)/.exec(C)[1]), R = L >= 1) : -1 !== C.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL ES (\d)/.exec(C)[1]), R = L >= 2);
-                    let P = null,
-                        D = {};
-                    const I = t.getParameter(t.SCISSOR_BOX),
-                        N = t.getParameter(t.VIEWPORT),
-                        O = (new jt).fromArray(I),
-                        U = (new jt).fromArray(N);
+                    let V = {},
+                        k = {},
+                        W = new WeakMap,
+                        j = [],
+                        X = null,
+                        q = !1,
+                        Y = null,
+                        Z = null,
+                        J = null,
+                        K = null,
+                        Q = null,
+                        $ = null,
+                        tt = null,
+                        et = !1,
+                        nt = null,
+                        it = null,
+                        rt = null,
+                        st = null,
+                        at = null;
+                    const ot = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
+                    let lt = !1,
+                        ct = 0;
+                    const ht = t.getParameter(t.VERSION); - 1 !== ht.indexOf("WebGL") ? (ct = parseFloat(/^WebGL (\d)/.exec(ht)[1]), lt = ct >= 1) : -1 !== ht.indexOf("OpenGL ES") && (ct = parseFloat(/^OpenGL ES (\d)/.exec(ht)[1]), lt = ct >= 2);
+                    let ut = null,
+                        dt = {};
+                    const pt = t.getParameter(t.SCISSOR_BOX),
+                        mt = t.getParameter(t.VIEWPORT),
+                        ft = (new en).fromArray(pt),
+                        gt = (new en).fromArray(mt);
 
-                    function B(e, n, i) {
+                    function vt(e, n, i) {
                         const r = new Uint8Array(4),
                             s = t.createTexture();
                         t.bindTexture(e, s), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                         for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
                         return s
                     }
-                    const F = {};
+                    const xt = {};
 
-                    function z(e) {
-                        !0 !== l[e] && (t.enable(e), l[e] = !0)
+                    function yt(e) {
+                        !0 !== V[e] && (t.enable(e), V[e] = !0)
                     }
 
-                    function H(e) {
-                        !1 !== l[e] && (t.disable(e), l[e] = !1)
+                    function _t(e) {
+                        !1 !== V[e] && (t.disable(e), V[e] = !1)
                     }
-                    F[t.TEXTURE_2D] = B(t.TEXTURE_2D, t.TEXTURE_2D, 1), F[t.TEXTURE_CUBE_MAP] = B(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), s.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), z(t.DEPTH_TEST), a.setFunc(3), W(!1), j(1), z(t.CULL_FACE), k(0);
-                    const G = {
-                        [i]: t.FUNC_ADD,
-                        101: t.FUNC_SUBTRACT,
-                        102: t.FUNC_REVERSE_SUBTRACT
+                    xt[t.TEXTURE_2D] = vt(t.TEXTURE_2D, t.TEXTURE_2D, 1), xt[t.TEXTURE_CUBE_MAP] = vt(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), o.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), yt(t.DEPTH_TEST), l.setFunc(B), St(!1), Et(r), yt(t.CULL_FACE), wt(d);
+                    const Mt = {
+                        [x]: t.FUNC_ADD,
+                        [y]: t.FUNC_SUBTRACT,
+                        [_]: t.FUNC_REVERSE_SUBTRACT
                     };
-                    if (r) G[103] = t.MIN, G[104] = t.MAX;
+                    if (a) Mt[M] = t.MIN, Mt[b] = t.MAX;
                     else {
                         const t = e.get("EXT_blend_minmax");
-                        null !== t && (G[103] = t.MIN_EXT, G[104] = t.MAX_EXT)
+                        null !== t && (Mt[M] = t.MIN_EXT, Mt[b] = t.MAX_EXT)
                     }
-                    const V = {
-                        200: t.ZERO,
-                        201: t.ONE,
-                        202: t.SRC_COLOR,
-                        204: t.SRC_ALPHA,
-                        210: t.SRC_ALPHA_SATURATE,
-                        208: t.DST_COLOR,
-                        206: t.DST_ALPHA,
-                        203: t.ONE_MINUS_SRC_COLOR,
-                        205: t.ONE_MINUS_SRC_ALPHA,
-                        209: t.ONE_MINUS_DST_COLOR,
-                        207: t.ONE_MINUS_DST_ALPHA
+                    const bt = {
+                        [w]: t.ZERO,
+                        [S]: t.ONE,
+                        [E]: t.SRC_COLOR,
+                        [A]: t.SRC_ALPHA,
+                        [I]: t.SRC_ALPHA_SATURATE,
+                        [P]: t.DST_COLOR,
+                        [L]: t.DST_ALPHA,
+                        [T]: t.ONE_MINUS_SRC_COLOR,
+                        [R]: t.ONE_MINUS_SRC_ALPHA,
+                        [D]: t.ONE_MINUS_DST_COLOR,
+                        [C]: t.ONE_MINUS_DST_ALPHA
                     };
 
-                    function k(e, n, r, s, a, o, l, c) {
-                        if (0 !== e) {
-                            if (!1 === p && (z(t.BLEND), p = !0), 5 === e) a = a || n, o = o || r, l = l || s, n === f && a === x || (t.blendEquationSeparate(G[n], G[a]), f = n, x = a), r === g && s === v && o === y && l === _ || (t.blendFuncSeparate(V[r], V[s], V[o], V[l]), g = r, v = s, y = o, _ = l), m = e, M = null;
-                            else if (e !== m || c !== M) {
-                                if (f === i && x === i || (t.blendEquation(t.FUNC_ADD), f = i, x = i), c) switch (e) {
-                                    case 1:
+                    function wt(e, n, i, r, s, a, o, l) {
+                        if (e !== d) {
+                            if (!1 === q && (yt(t.BLEND), q = !0), e === v) s = s || n, a = a || i, o = o || r, n === Z && s === Q || (t.blendEquationSeparate(Mt[n], Mt[s]), Z = n, Q = s), i === J && r === K && a === $ && o === tt || (t.blendFuncSeparate(bt[i], bt[r], bt[a], bt[o]), J = i, K = r, $ = a, tt = o), Y = e, et = null;
+                            else if (e !== Y || l !== et) {
+                                if (Z === x && Q === x || (t.blendEquation(t.FUNC_ADD), Z = x, Q = x), l) switch (e) {
+                                    case p:
                                         t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                         break;
-                                    case 2:
+                                    case m:
                                         t.blendFunc(t.ONE, t.ONE);
                                         break;
-                                    case 3:
+                                    case f:
                                         t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                         break;
-                                    case 4:
+                                    case g:
                                         t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                         break;
                                     default:
                                         console.error("THREE.WebGLState: Invalid blending: ", e)
                                 } else switch (e) {
-                                    case 1:
+                                    case p:
                                         t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                         break;
-                                    case 2:
+                                    case m:
                                         t.blendFunc(t.SRC_ALPHA, t.ONE);
                                         break;
-                                    case 3:
+                                    case f:
                                         t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                         break;
-                                    case 4:
+                                    case g:
                                         t.blendFunc(t.ZERO, t.SRC_COLOR);
                                         break;
                                     default:
                                         console.error("THREE.WebGLState: Invalid blending: ", e)
                                 }
-                                g = null, v = null, y = null, _ = null, m = e, M = c
+                                J = null, K = null, $ = null, tt = null, Y = e, et = l
                             }
-                        } else !0 === p && (H(t.BLEND), p = !1)
+                        } else !0 === q && (_t(t.BLEND), q = !1)
                     }
 
-                    function W(e) {
-                        b !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), b = e)
+                    function St(e) {
+                        nt !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), nt = e)
                     }
 
-                    function j(e) {
-                        0 !== e ? (z(t.CULL_FACE), e !== w && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : H(t.CULL_FACE), w = e
+                    function Et(e) {
+                        e !== i ? (yt(t.CULL_FACE), e !== it && (e === r ? t.cullFace(t.BACK) : e === s ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : _t(t.CULL_FACE), it = e
                     }
 
-                    function X(e, n, i) {
-                        e ? (z(t.POLYGON_OFFSET_FILL), E === n && T === i || (t.polygonOffset(n, i), E = n, T = i)) : H(t.POLYGON_OFFSET_FILL)
+                    function Tt(e, n, i) {
+                        e ? (yt(t.POLYGON_OFFSET_FILL), st === n && at === i || (t.polygonOffset(n, i), st = n, at = i)) : _t(t.POLYGON_OFFSET_FILL)
                     }
 
-                    function q(e) {
-                        void 0 === e && (e = t.TEXTURE0 + A - 1), P !== e && (t.activeTexture(e), P = e)
+                    function At(e) {
+                        void 0 === e && (e = t.TEXTURE0 + ot - 1), ut !== e && (t.activeTexture(e), ut = e)
                     }
                     return {
                         buffers: {
-                            color: s,
-                            depth: a,
-                            stencil: o
+                            color: o,
+                            depth: l,
+                            stencil: c
                         },
-                        enable: z,
-                        disable: H,
+                        enable: yt,
+                        disable: _t,
                         bindFramebuffer: function(e, n) {
-                            return c[e] !== n && (t.bindFramebuffer(e, n), c[e] = n, r && (e === t.DRAW_FRAMEBUFFER && (c[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (c[t.DRAW_FRAMEBUFFER] = n)), !0)
+                            return k[e] !== n && (t.bindFramebuffer(e, n), k[e] = n, a && (e === t.DRAW_FRAMEBUFFER && (k[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (k[t.DRAW_FRAMEBUFFER] = n)), !0)
                         },
                         drawBuffers: function(i, r) {
-                            let s = u,
+                            let s = j,
                                 a = !1;
                             if (i)
-                                if (s = h.get(r), void 0 === s && (s = [], h.set(r, s)), i.isWebGLMultipleRenderTargets) {
+                                if (s = W.get(r), void 0 === s && (s = [], W.set(r, s)), i.isWebGLMultipleRenderTargets) {
                                     const e = i.texture;
                                     if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
                                         for (let n = 0, i = e.length; n < i; n++) s[n] = t.COLOR_ATTACHMENT0 + n;
                                         s.length = e.length, a = !0
                                     }
                                 } else s[0] !== t.COLOR_ATTACHMENT0 && (s[0] = t.COLOR_ATTACHMENT0, a = !0);
                             else s[0] !== t.BACK && (s[0] = t.BACK, a = !0);
                             a && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                         },
                         useProgram: function(e) {
-                            return d !== e && (t.useProgram(e), d = e, !0)
+                            return X !== e && (t.useProgram(e), X = e, !0)
                         },
-                        setBlending: k,
+                        setBlending: wt,
                         setMaterial: function(e, n) {
-                            2 === e.side ? H(t.CULL_FACE) : z(t.CULL_FACE);
-                            let i = 1 === e.side;
-                            n && (i = !i), W(i), 1 === e.blending && !1 === e.transparent ? k(0) : k(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), s.setMask(e.colorWrite);
+                            e.side === u ? _t(t.CULL_FACE) : yt(t.CULL_FACE);
+                            let i = e.side === h;
+                            n && (i = !i), St(i), e.blending === p && !1 === e.transparent ? wt(d) : wt(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), l.setFunc(e.depthFunc), l.setTest(e.depthTest), l.setMask(e.depthWrite), o.setMask(e.colorWrite);
                             const r = e.stencilWrite;
-                            o.setTest(r), r && (o.setMask(e.stencilWriteMask), o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), X(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? z(t.SAMPLE_ALPHA_TO_COVERAGE) : H(t.SAMPLE_ALPHA_TO_COVERAGE)
+                            c.setTest(r), r && (c.setMask(e.stencilWriteMask), c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Tt(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? yt(t.SAMPLE_ALPHA_TO_COVERAGE) : _t(t.SAMPLE_ALPHA_TO_COVERAGE)
                         },
-                        setFlipSided: W,
-                        setCullFace: j,
+                        setFlipSided: St,
+                        setCullFace: Et,
                         setLineWidth: function(e) {
-                            e !== S && (R && t.lineWidth(e), S = e)
+                            e !== rt && (lt && t.lineWidth(e), rt = e)
                         },
-                        setPolygonOffset: X,
+                        setPolygonOffset: Tt,
                         setScissorTest: function(e) {
-                            e ? z(t.SCISSOR_TEST) : H(t.SCISSOR_TEST)
+                            e ? yt(t.SCISSOR_TEST) : _t(t.SCISSOR_TEST)
                         },
-                        activeTexture: q,
+                        activeTexture: At,
                         bindTexture: function(e, n) {
-                            null === P && q();
-                            let i = D[P];
+                            null === ut && At();
+                            let i = dt[ut];
                             void 0 === i && (i = {
                                 type: void 0,
                                 texture: void 0
-                            }, D[P] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || F[e]), i.type = e, i.texture = n)
+                            }, dt[ut] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || xt[e]), i.type = e, i.texture = n)
                         },
                         unbindTexture: function() {
-                            const e = D[P];
+                            const e = dt[ut];
                             void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                         },
                         compressedTexImage2D: function() {
                             try {
                                 t.compressedTexImage2D.apply(t, arguments)
                             } catch (t) {
                                 console.error("THREE.WebGLState:", t)
@@ -7911,100 +8280,100 @@
                             try {
                                 t.compressedTexSubImage2D.apply(t, arguments)
                             } catch (t) {
                                 console.error("THREE.WebGLState:", t)
                             }
                         },
                         scissor: function(e) {
-                            !1 === O.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), O.copy(e))
+                            !1 === ft.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ft.copy(e))
                         },
                         viewport: function(e) {
-                            !1 === U.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), U.copy(e))
+                            !1 === gt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), gt.copy(e))
                         },
                         reset: function() {
-                            t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), !0 === r && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), l = {}, P = null, D = {}, c = {}, h = new WeakMap, u = [], d = null, p = !1, m = null, f = null, g = null, v = null, x = null, y = null, _ = null, M = !1, b = null, w = null, S = null, E = null, T = null, O.set(0, 0, t.canvas.width, t.canvas.height), U.set(0, 0, t.canvas.width, t.canvas.height), s.reset(), a.reset(), o.reset()
+                            t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), !0 === a && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), V = {}, ut = null, dt = {}, k = {}, W = new WeakMap, j = [], X = null, q = !1, Y = null, Z = null, J = null, K = null, Q = null, $ = null, tt = null, et = !1, nt = null, it = null, rt = null, st = null, at = null, ft.set(0, 0, t.canvas.width, t.canvas.height), gt.set(0, 0, t.canvas.width, t.canvas.height), o.reset(), l.reset(), c.reset()
                         }
                     }
                 }
 
-                function Zs(t, e, n, i, r, s, a) {
+                function co(t, e, n, i, r, s, a) {
                     const o = r.isWebGL2,
                         l = r.maxTextures,
                         c = r.maxCubemapSize,
                         h = r.maxTextureSize,
-                        L = r.maxSamples,
-                        C = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
-                        P = new WeakMap;
-                    let D, I = !1;
+                        u = r.maxSamples,
+                        d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
+                        p = new WeakMap;
+                    let m, f = !1;
                     try {
-                        I = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
+                        f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                     } catch (t) {}
 
-                    function N(t, e) {
-                        return I ? new OffscreenCanvas(t, e) : Dt("canvas")
+                    function g(t, e) {
+                        return f ? new OffscreenCanvas(t, e) : Ve("canvas")
                     }
 
-                    function O(t, e, n, i) {
+                    function v(t, e, n, i) {
                         let r = 1;
                         if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                             if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
-                                const i = e ? Et : Math.floor,
+                                const i = e ? Oe : Math.floor,
                                     s = i(r * t.width),
                                     a = i(r * t.height);
-                                void 0 === D && (D = N(s, a));
-                                const o = n ? N(s, a) : D;
+                                void 0 === m && (m = g(s, a));
+                                const o = n ? g(s, a) : m;
                                 return o.width = s, o.height = a, o.getContext("2d").drawImage(t, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."), o
                             }
                             return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                         }
                         return t
                     }
 
-                    function U(t) {
-                        return wt(t.width) && wt(t.height)
+                    function x(t) {
+                        return Ie(t.width) && Ie(t.height)
                     }
 
-                    function B(t, e) {
-                        return t.generateMipmaps && e && t.minFilter !== m && t.minFilter !== v
+                    function y(t, e) {
+                        return t.generateMipmaps && e && t.minFilter !== ot && t.minFilter !== ht
                     }
 
-                    function F(e) {
+                    function _(e) {
                         t.generateMipmap(e)
                     }
 
-                    function z(n, i, r, s, a = !1) {
+                    function M(n, i, r, s, a = !1) {
                         if (!1 === o) return i;
                         if (null !== n) {
                             if (void 0 !== t[n]) return t[n];
                             console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                         }
                         let l = i;
-                        return i === t.RED && (r === t.FLOAT && (l = t.R32F), r === t.HALF_FLOAT && (l = t.R16F), r === t.UNSIGNED_BYTE && (l = t.R8)), i === t.RG && (r === t.FLOAT && (l = t.RG32F), r === t.HALF_FLOAT && (l = t.RG16F), r === t.UNSIGNED_BYTE && (l = t.RG8)), i === t.RGBA && (r === t.FLOAT && (l = t.RGBA32F), r === t.HALF_FLOAT && (l = t.RGBA16F), r === t.UNSIGNED_BYTE && (l = s === lt && !1 === a ? t.SRGB8_ALPHA8 : t.RGBA8), r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4), r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)), l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"), l
+                        return i === t.RED && (r === t.FLOAT && (l = t.R32F), r === t.HALF_FLOAT && (l = t.R16F), r === t.UNSIGNED_BYTE && (l = t.R8)), i === t.RG && (r === t.FLOAT && (l = t.RG32F), r === t.HALF_FLOAT && (l = t.RG16F), r === t.UNSIGNED_BYTE && (l = t.RG8)), i === t.RGBA && (r === t.FLOAT && (l = t.RGBA32F), r === t.HALF_FLOAT && (l = t.RGBA16F), r === t.UNSIGNED_BYTE && (l = s === fe && !1 === a ? t.SRGB8_ALPHA8 : t.RGBA8), r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4), r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)), l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"), l
                     }
 
-                    function H(t, e, n) {
-                        return !0 === B(t, n) || t.isFramebufferTexture && t.minFilter !== m && t.minFilter !== v ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
+                    function b(t, e, n) {
+                        return !0 === y(t, n) || t.isFramebufferTexture && t.minFilter !== ot && t.minFilter !== ht ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
                     }
 
-                    function G(e) {
-                        return e === m || e === f || e === g ? t.NEAREST : t.LINEAR
+                    function w(e) {
+                        return e === ot || e === lt || e === ct ? t.NEAREST : t.LINEAR
                     }
 
-                    function V(e) {
+                    function S(e) {
                         const n = e.target;
-                        n.removeEventListener("dispose", V),
+                        n.removeEventListener("dispose", S),
                             function(e) {
                                 const n = i.get(e);
                                 void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e))
-                            }(n), n.isVideoTexture && P.delete(n), a.memory.textures--
+                            }(n), n.isVideoTexture && p.delete(n), a.memory.textures--
                     }
 
-                    function k(e) {
+                    function E(e) {
                         const n = e.target;
-                        n.removeEventListener("dispose", k),
+                        n.removeEventListener("dispose", E),
                             function(e) {
                                 const n = e.texture,
                                     r = i.get(e),
                                     s = i.get(n);
                                 if (e) {
                                     if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), a.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                         for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
@@ -8014,233 +8383,233 @@
                                             const r = i.get(n[e]);
                                             r.__webglTexture && (t.deleteTexture(r.__webglTexture), a.memory.textures--), i.remove(n[e])
                                         }
                                     i.remove(n), i.remove(e)
                                 }
                             }(n)
                     }
-                    let W = 0;
+                    let T = 0;
 
-                    function j(e, r) {
+                    function A(e, r) {
                         const s = i.get(e);
                         if (e.isVideoTexture && function(t) {
                                 const e = a.render.frame;
-                                P.get(t) !== e && (P.set(t, e), t.update())
+                                p.get(t) !== e && (p.set(t, e), t.update())
                             }(e), e.version > 0 && s.__version !== e.version) {
                             const t = e.image;
                             if (void 0 === t) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                             else {
-                                if (!1 !== t.complete) return void K(s, e, r);
+                                if (!1 !== t.complete) return void I(s, e, r);
                                 console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                             }
                         }
                         n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D, s.__webglTexture)
                     }
 
-                    function X(e, r) {
+                    function R(e, r) {
                         const a = i.get(e);
                         e.version > 0 && a.__version !== e.version ? function(e, i, r) {
                             if (6 !== i.image.length) return;
-                            J(e, i), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
+                            D(e, i), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                             const a = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                                 l = i.image[0] && i.image[0].isDataTexture,
                                 h = [];
-                            for (let t = 0; t < 6; t++) h[t] = a || l ? l ? i.image[t].image : i.image[t] : O(i.image[t], !1, !0, c), h[t] = nt(i, h[t]);
+                            for (let t = 0; t < 6; t++) h[t] = a || l ? l ? i.image[t].image : i.image[t] : v(i.image[t], !1, !0, c), h[t] = F(i, h[t]);
                             const u = h[0],
-                                d = U(u) || o,
+                                d = x(u) || o,
                                 p = s.convert(i.format, i.encoding),
                                 m = s.convert(i.type),
-                                f = z(i.internalFormat, p, m, i.encoding),
+                                f = M(i.internalFormat, p, m, i.encoding),
                                 g = o && !0 !== i.isVideoTexture,
-                                v = void 0 === e.__version;
-                            let x, y = H(i, u, d);
-                            if (Z(t.TEXTURE_CUBE_MAP, i, d), a) {
-                                g && v && n.texStorage2D(t.TEXTURE_CUBE_MAP, y, f, u.width, u.height);
+                                w = void 0 === e.__version;
+                            let S, E = b(i, u, d);
+                            if (P(t.TEXTURE_CUBE_MAP, i, d), a) {
+                                g && w && n.texStorage2D(t.TEXTURE_CUBE_MAP, E, f, u.width, u.height);
                                 for (let e = 0; e < 6; e++) {
-                                    x = h[e].mipmaps;
-                                    for (let r = 0; r < x.length; r++) {
-                                        const s = x[r];
-                                        i.format !== T ? null !== p ? g ? n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, s.width, s.height, p, s.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, f, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, s.width, s.height, p, m, s.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, f, s.width, s.height, 0, p, m, s.data)
+                                    S = h[e].mipmaps;
+                                    for (let r = 0; r < S.length; r++) {
+                                        const s = S[r];
+                                        i.format !== Et ? null !== p ? g ? n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, s.width, s.height, p, s.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, f, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, s.width, s.height, p, m, s.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, f, s.width, s.height, 0, p, m, s.data)
                                     }
                                 }
                             } else {
-                                x = i.mipmaps, g && v && (x.length > 0 && y++, n.texStorage2D(t.TEXTURE_CUBE_MAP, y, f, h[0].width, h[0].height));
+                                S = i.mipmaps, g && w && (S.length > 0 && E++, n.texStorage2D(t.TEXTURE_CUBE_MAP, E, f, h[0].width, h[0].height));
                                 for (let e = 0; e < 6; e++)
                                     if (l) {
                                         g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, h[e].width, h[e].height, p, m, h[e].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, f, h[e].width, h[e].height, 0, p, m, h[e].data);
-                                        for (let i = 0; i < x.length; i++) {
-                                            const r = x[i].image[e].image;
+                                        for (let i = 0; i < S.length; i++) {
+                                            const r = S[i].image[e].image;
                                             g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, r.width, r.height, p, m, r.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, f, r.width, r.height, 0, p, m, r.data)
                                         }
                                     } else {
                                         g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, p, m, h[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, f, p, m, h[e]);
-                                        for (let i = 0; i < x.length; i++) {
-                                            const r = x[i];
+                                        for (let i = 0; i < S.length; i++) {
+                                            const r = S[i];
                                             g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, p, m, r.image[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, f, p, m, r.image[e])
                                         }
                                     }
                             }
-                            B(i, d) && F(t.TEXTURE_CUBE_MAP), e.__version = i.version, i.onUpdate && i.onUpdate(i)
+                            y(i, d) && _(t.TEXTURE_CUBE_MAP), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                         }(a, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture))
                     }
-                    const q = {
-                            [u]: t.REPEAT,
-                            [d]: t.CLAMP_TO_EDGE,
-                            [p]: t.MIRRORED_REPEAT
-                        },
-                        Y = {
-                            [m]: t.NEAREST,
-                            [f]: t.NEAREST_MIPMAP_NEAREST,
-                            [g]: t.NEAREST_MIPMAP_LINEAR,
-                            [v]: t.LINEAR,
-                            [x]: t.LINEAR_MIPMAP_NEAREST,
-                            [y]: t.LINEAR_MIPMAP_LINEAR
+                    const L = {
+                            [rt]: t.REPEAT,
+                            [st]: t.CLAMP_TO_EDGE,
+                            [at]: t.MIRRORED_REPEAT
+                        },
+                        C = {
+                            [ot]: t.NEAREST,
+                            [lt]: t.NEAREST_MIPMAP_NEAREST,
+                            [ct]: t.NEAREST_MIPMAP_LINEAR,
+                            [ht]: t.LINEAR,
+                            [ut]: t.LINEAR_MIPMAP_NEAREST,
+                            [dt]: t.LINEAR_MIPMAP_LINEAR
                         };
 
-                    function Z(n, s, a) {
-                        if (a ? (t.texParameteri(n, t.TEXTURE_WRAP_S, q[s.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, q[s.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, q[s.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, Y[s.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, Y[s.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), s.wrapS === d && s.wrapT === d || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, G(s.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, G(s.minFilter)), s.minFilter !== m && s.minFilter !== v && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
+                    function P(n, s, a) {
+                        if (a ? (t.texParameteri(n, t.TEXTURE_WRAP_S, L[s.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, L[s.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, L[s.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, C[s.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, C[s.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), s.wrapS === st && s.wrapT === st || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, w(s.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, w(s.minFilter)), s.minFilter !== ot && s.minFilter !== ht && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                             const a = e.get("EXT_texture_filter_anisotropic");
-                            if (s.type === w && !1 === e.has("OES_texture_float_linear")) return;
-                            if (!1 === o && s.type === S && !1 === e.has("OES_texture_half_float_linear")) return;
+                            if (s.type === yt && !1 === e.has("OES_texture_float_linear")) return;
+                            if (!1 === o && s.type === _t && !1 === e.has("OES_texture_half_float_linear")) return;
                             (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                         }
                     }
 
-                    function J(e, n) {
-                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", V), e.__webglTexture = t.createTexture(), a.memory.textures++)
+                    function D(e, n) {
+                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", S), e.__webglTexture = t.createTexture(), a.memory.textures++)
                     }
 
-                    function K(e, i, r) {
+                    function I(e, i, r) {
                         let a = t.TEXTURE_2D;
-                        i.isDataTexture2DArray && (a = t.TEXTURE_2D_ARRAY), i.isDataTexture3D && (a = t.TEXTURE_3D), J(e, i), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(a, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
+                        i.isDataTexture2DArray && (a = t.TEXTURE_2D_ARRAY), i.isDataTexture3D && (a = t.TEXTURE_3D), D(e, i), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(a, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                         const l = function(t) {
-                            return !o && (t.wrapS !== d || t.wrapT !== d || t.minFilter !== m && t.minFilter !== v)
-                        }(i) && !1 === U(i.image);
-                        let c = O(i.image, l, !1, h);
-                        c = nt(i, c);
-                        const u = U(c) || o,
-                            p = s.convert(i.format, i.encoding);
-                        let f, g = s.convert(i.type),
-                            x = z(i.internalFormat, p, g, i.encoding, i.isVideoTexture);
-                        Z(a, i, u);
-                        const y = i.mipmaps,
-                            _ = o && !0 !== i.isVideoTexture,
+                            return !o && (t.wrapS !== st || t.wrapT !== st || t.minFilter !== ot && t.minFilter !== ht)
+                        }(i) && !1 === x(i.image);
+                        let c = v(i.image, l, !1, h);
+                        c = F(i, c);
+                        const u = x(c) || o,
+                            d = s.convert(i.format, i.encoding);
+                        let p, m = s.convert(i.type),
+                            f = M(i.internalFormat, d, m, i.encoding, i.isVideoTexture);
+                        P(a, i, u);
+                        const g = i.mipmaps,
+                            w = o && !0 !== i.isVideoTexture,
                             S = void 0 === e.__version,
-                            L = H(i, c, u);
-                        if (i.isDepthTexture) x = t.DEPTH_COMPONENT, o ? x = i.type === w ? t.DEPTH_COMPONENT32F : i.type === b ? t.DEPTH_COMPONENT24 : i.type === E ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : i.type === w && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === A && x === t.DEPTH_COMPONENT && i.type !== M && i.type !== b && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = M, g = s.convert(i.type)), i.format === R && x === t.DEPTH_COMPONENT && (x = t.DEPTH_STENCIL, i.type !== E && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = E, g = s.convert(i.type))), _ && S ? n.texStorage2D(t.TEXTURE_2D, 1, x, c.width, c.height) : n.texImage2D(t.TEXTURE_2D, 0, x, c.width, c.height, 0, p, g, null);
+                            E = b(i, c, u);
+                        if (i.isDepthTexture) f = t.DEPTH_COMPONENT, o ? f = i.type === yt ? t.DEPTH_COMPONENT32F : i.type === xt ? t.DEPTH_COMPONENT24 : i.type === wt ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : i.type === yt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Rt && f === t.DEPTH_COMPONENT && i.type !== gt && i.type !== xt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = gt, m = s.convert(i.type)), i.format === Lt && f === t.DEPTH_COMPONENT && (f = t.DEPTH_STENCIL, i.type !== wt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = wt, m = s.convert(i.type))), w && S ? n.texStorage2D(t.TEXTURE_2D, 1, f, c.width, c.height) : n.texImage2D(t.TEXTURE_2D, 0, f, c.width, c.height, 0, d, m, null);
                         else if (i.isDataTexture)
-                            if (y.length > 0 && u) {
-                                _ && S && n.texStorage2D(t.TEXTURE_2D, L, x, y[0].width, y[0].height);
-                                for (let e = 0, i = y.length; e < i; e++) f = y[e], _ ? n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, f.width, f.height, p, g, f.data) : n.texImage2D(t.TEXTURE_2D, e, x, f.width, f.height, 0, p, g, f.data);
+                            if (g.length > 0 && u) {
+                                w && S && n.texStorage2D(t.TEXTURE_2D, E, f, g[0].width, g[0].height);
+                                for (let e = 0, i = g.length; e < i; e++) p = g[e], w ? n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, p.width, p.height, d, m, p.data) : n.texImage2D(t.TEXTURE_2D, e, f, p.width, p.height, 0, d, m, p.data);
                                 i.generateMipmaps = !1
-                            } else _ ? (S && n.texStorage2D(t.TEXTURE_2D, L, x, c.width, c.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, c.width, c.height, p, g, c.data)) : n.texImage2D(t.TEXTURE_2D, 0, x, c.width, c.height, 0, p, g, c.data);
+                            } else w ? (S && n.texStorage2D(t.TEXTURE_2D, E, f, c.width, c.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, c.width, c.height, d, m, c.data)) : n.texImage2D(t.TEXTURE_2D, 0, f, c.width, c.height, 0, d, m, c.data);
                         else if (i.isCompressedTexture) {
-                            _ && S && n.texStorage2D(t.TEXTURE_2D, L, x, y[0].width, y[0].height);
-                            for (let e = 0, r = y.length; e < r; e++) f = y[e], i.format !== T ? null !== p ? _ ? n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, f.width, f.height, p, f.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, x, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _ ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, f.width, f.height, p, g, f.data) : n.texImage2D(t.TEXTURE_2D, e, x, f.width, f.height, 0, p, g, f.data)
-                        } else if (i.isDataTexture2DArray) _ ? (S && n.texStorage3D(t.TEXTURE_2D_ARRAY, L, x, c.width, c.height, c.depth), n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, c.width, c.height, c.depth, p, g, c.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, x, c.width, c.height, c.depth, 0, p, g, c.data);
-                        else if (i.isDataTexture3D) _ ? (S && n.texStorage3D(t.TEXTURE_3D, L, x, c.width, c.height, c.depth), n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, c.width, c.height, c.depth, p, g, c.data)) : n.texImage3D(t.TEXTURE_3D, 0, x, c.width, c.height, c.depth, 0, p, g, c.data);
-                        else if (i.isFramebufferTexture) _ && S ? n.texStorage2D(t.TEXTURE_2D, L, x, c.width, c.height) : n.texImage2D(t.TEXTURE_2D, 0, x, c.width, c.height, 0, p, g, null);
-                        else if (y.length > 0 && u) {
-                            _ && S && n.texStorage2D(t.TEXTURE_2D, L, x, y[0].width, y[0].height);
-                            for (let e = 0, i = y.length; e < i; e++) f = y[e], _ ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, p, g, f) : n.texImage2D(t.TEXTURE_2D, e, x, p, g, f);
+                            w && S && n.texStorage2D(t.TEXTURE_2D, E, f, g[0].width, g[0].height);
+                            for (let e = 0, r = g.length; e < r; e++) p = g[e], i.format !== Et ? null !== d ? w ? n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, p.width, p.height, d, p.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : w ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, p.width, p.height, d, m, p.data) : n.texImage2D(t.TEXTURE_2D, e, f, p.width, p.height, 0, d, m, p.data)
+                        } else if (i.isDataTexture2DArray) w ? (S && n.texStorage3D(t.TEXTURE_2D_ARRAY, E, f, c.width, c.height, c.depth), n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, c.width, c.height, c.depth, d, m, c.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, f, c.width, c.height, c.depth, 0, d, m, c.data);
+                        else if (i.isDataTexture3D) w ? (S && n.texStorage3D(t.TEXTURE_3D, E, f, c.width, c.height, c.depth), n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, c.width, c.height, c.depth, d, m, c.data)) : n.texImage3D(t.TEXTURE_3D, 0, f, c.width, c.height, c.depth, 0, d, m, c.data);
+                        else if (i.isFramebufferTexture) w && S ? n.texStorage2D(t.TEXTURE_2D, E, f, c.width, c.height) : n.texImage2D(t.TEXTURE_2D, 0, f, c.width, c.height, 0, d, m, null);
+                        else if (g.length > 0 && u) {
+                            w && S && n.texStorage2D(t.TEXTURE_2D, E, f, g[0].width, g[0].height);
+                            for (let e = 0, i = g.length; e < i; e++) p = g[e], w ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, d, m, p) : n.texImage2D(t.TEXTURE_2D, e, f, d, m, p);
                             i.generateMipmaps = !1
-                        } else _ ? (S && n.texStorage2D(t.TEXTURE_2D, L, x, c.width, c.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, p, g, c)) : n.texImage2D(t.TEXTURE_2D, 0, x, p, g, c);
-                        B(i, u) && F(a), e.__version = i.version, i.onUpdate && i.onUpdate(i)
+                        } else w ? (S && n.texStorage2D(t.TEXTURE_2D, E, f, c.width, c.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, d, m, c)) : n.texImage2D(t.TEXTURE_2D, 0, f, d, m, c);
+                        y(i, u) && _(a), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                     }
 
-                    function Q(e, r, a, o, l) {
+                    function N(e, r, a, o, l) {
                         const c = s.convert(a.format, a.encoding),
                             h = s.convert(a.type),
-                            u = z(a.internalFormat, c, h, a.encoding);
-                        i.get(r).__hasExternalTextures || (l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(t.FRAMEBUFFER, e), r.useRenderToTexture ? C.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, o, l, i.get(a).__webglTexture, 0, et(r)) : t.framebufferTexture2D(t.FRAMEBUFFER, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(t.FRAMEBUFFER, null)
+                            u = M(a.internalFormat, c, h, a.encoding);
+                        i.get(r).__hasExternalTextures || (l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(t.FRAMEBUFFER, e), r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, o, l, i.get(a).__webglTexture, 0, B(r)) : t.framebufferTexture2D(t.FRAMEBUFFER, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(t.FRAMEBUFFER, null)
                     }
 
-                    function $(e, n, i) {
+                    function O(e, n, i) {
                         if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
                             let r = t.DEPTH_COMPONENT16;
                             if (i || n.useRenderToTexture) {
                                 const e = n.depthTexture;
-                                e && e.isDepthTexture && (e.type === w ? r = t.DEPTH_COMPONENT32F : e.type === b && (r = t.DEPTH_COMPONENT24));
-                                const i = et(n);
-                                n.useRenderToTexture ? C.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height)
+                                e && e.isDepthTexture && (e.type === yt ? r = t.DEPTH_COMPONENT32F : e.type === xt && (r = t.DEPTH_COMPONENT24));
+                                const i = B(n);
+                                n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height)
                             } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
                             t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
                         } else if (n.depthBuffer && n.stencilBuffer) {
-                            const r = et(n);
-                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : n.useRenderToTexture ? C.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
+                            const r = B(n);
+                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
                         } else {
                             const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                                 r = s.convert(e.format, e.encoding),
                                 a = s.convert(e.type),
-                                o = z(e.internalFormat, r, a, e.encoding),
-                                l = et(n);
-                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, l, o, n.width, n.height) : n.useRenderToTexture ? C.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, l, o, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, o, n.width, n.height)
+                                o = M(e.internalFormat, r, a, e.encoding),
+                                l = B(n);
+                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, l, o, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, l, o, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, o, n.width, n.height)
                         }
                         t.bindRenderbuffer(t.RENDERBUFFER, null)
                     }
 
-                    function tt(e) {
+                    function U(e) {
                         const r = i.get(e),
                             s = !0 === e.isWebGLCubeRenderTarget;
                         if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                             if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                             ! function(e, r) {
                                 if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                 if (n.bindFramebuffer(t.FRAMEBUFFER, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
-                                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), j(r.depthTexture, 0);
+                                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), A(r.depthTexture, 0);
                                 const s = i.get(r.depthTexture).__webglTexture,
-                                    a = et(r);
-                                if (r.depthTexture.format === A) r.useRenderToTexture ? C.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);
+                                    a = B(r);
+                                if (r.depthTexture.format === Rt) r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);
                                 else {
-                                    if (r.depthTexture.format !== R) throw new Error("Unknown depthTexture format");
-                                    r.useRenderToTexture ? C.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0)
+                                    if (r.depthTexture.format !== Lt) throw new Error("Unknown depthTexture format");
+                                    r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0)
                                 }
                             }(r.__webglFramebuffer, e)
                         } else if (s) {
                             r.__webglDepthbuffer = [];
-                            for (let i = 0; i < 6; i++) n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), $(r.__webglDepthbuffer[i], e, !1)
-                        } else n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), $(r.__webglDepthbuffer, e, !1);
+                            for (let i = 0; i < 6; i++) n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), O(r.__webglDepthbuffer[i], e, !1)
+                        } else n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), O(r.__webglDepthbuffer, e, !1);
                         n.bindFramebuffer(t.FRAMEBUFFER, null)
                     }
 
-                    function et(t) {
-                        return o && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(L, t.samples) : 0
+                    function B(t) {
+                        return o && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(u, t.samples) : 0
                     }
 
-                    function nt(t, n) {
+                    function F(t, n) {
                         const i = t.encoding,
                             r = t.format,
                             s = t.type;
-                        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === pt || i !== ot && (i === lt ? !1 === o ? !0 === e.has("EXT_sRGB") && r === T ? (t.format = pt, t.minFilter = v, t.generateMipmaps = !1) : n = Gt.sRGBToLinear(n) : r === T && s === _ || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n
+                        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === we || i !== me && (i === fe ? !1 === o ? !0 === e.has("EXT_sRGB") && r === Et ? (t.format = we, t.minFilter = ht, t.generateMipmaps = !1) : n = Ke.sRGBToLinear(n) : r === Et && s === pt || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n
                     }
-                    let it = !1,
-                        rt = !1;
+                    let z = !1,
+                        H = !1;
                     this.allocateTextureUnit = function() {
-                        const t = W;
-                        return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), W += 1, t
+                        const t = T;
+                        return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), T += 1, t
                     }, this.resetTextureUnits = function() {
-                        W = 0
-                    }, this.setTexture2D = j, this.setTexture2DArray = function(e, r) {
+                        T = 0
+                    }, this.setTexture2D = A, this.setTexture2DArray = function(e, r) {
                         const s = i.get(e);
-                        e.version > 0 && s.__version !== e.version ? K(s, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture))
+                        e.version > 0 && s.__version !== e.version ? I(s, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture))
                     }, this.setTexture3D = function(e, r) {
                         const s = i.get(e);
-                        e.version > 0 && s.__version !== e.version ? K(s, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_3D, s.__webglTexture))
-                    }, this.setTextureCube = X, this.rebindTextures = function(e, n, r) {
+                        e.version > 0 && s.__version !== e.version ? I(s, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_3D, s.__webglTexture))
+                    }, this.setTextureCube = R, this.rebindTextures = function(e, n, r) {
                         const s = i.get(e);
-                        void 0 !== n && Q(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), void 0 !== r && tt(e)
+                        void 0 !== n && N(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), void 0 !== r && U(e)
                     }, this.setupRenderTarget = function(e) {
                         const l = e.texture,
                             c = i.get(e),
                             h = i.get(l);
-                        e.addEventListener("dispose", k), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()), h.__version = l.version, a.memory.textures++);
+                        e.addEventListener("dispose", E), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()), h.__version = l.version, a.memory.textures++);
                         const u = !0 === e.isWebGLCubeRenderTarget,
                             d = !0 === e.isWebGLMultipleRenderTargets,
                             p = l.isDataTexture3D || l.isDataTexture2DArray,
-                            m = U(e) || o;
+                            m = x(e) || o;
                         if (u) {
                             c.__webglFramebuffer = [];
                             for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
                         } else if (c.__webglFramebuffer = t.createFramebuffer(), d)
                             if (r.drawBuffers) {
                                 const n = e.texture;
                                 for (let e = 0, r = n.length; e < r; e++) {
@@ -8249,173 +8618,172 @@
                                 }
                             } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                         else if (e.useRenderbuffer)
                             if (o) {
                                 c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, c.__webglColorRenderbuffer);
                                 const i = s.convert(l.format, l.encoding),
                                     r = s.convert(l.type),
-                                    a = z(l.internalFormat, i, r, l.encoding),
-                                    o = et(e);
-                                t.renderbufferStorageMultisample(t.RENDERBUFFER, o, a, e.width, e.height), n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, c.__webglColorRenderbuffer), t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), $(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
+                                    a = M(l.internalFormat, i, r, l.encoding),
+                                    o = B(e);
+                                t.renderbufferStorageMultisample(t.RENDERBUFFER, o, a, e.width, e.height), n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, c.__webglColorRenderbuffer), t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), O(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
                             } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                         if (u) {
-                            n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture), Z(t.TEXTURE_CUBE_MAP, l, m);
-                            for (let n = 0; n < 6; n++) Q(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n);
-                            B(l, m) && F(t.TEXTURE_CUBE_MAP), n.unbindTexture()
+                            n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture), P(t.TEXTURE_CUBE_MAP, l, m);
+                            for (let n = 0; n < 6; n++) N(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n);
+                            y(l, m) && _(t.TEXTURE_CUBE_MAP), n.unbindTexture()
                         } else if (d) {
                             const r = e.texture;
                             for (let s = 0, a = r.length; s < a; s++) {
                                 const a = r[s],
                                     o = i.get(a);
-                                n.bindTexture(t.TEXTURE_2D, o.__webglTexture), Z(t.TEXTURE_2D, a, m), Q(c.__webglFramebuffer, e, a, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D), B(a, m) && F(t.TEXTURE_2D)
+                                n.bindTexture(t.TEXTURE_2D, o.__webglTexture), P(t.TEXTURE_2D, a, m), N(c.__webglFramebuffer, e, a, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D), y(a, m) && _(t.TEXTURE_2D)
                             }
                             n.unbindTexture()
                         } else {
                             let i = t.TEXTURE_2D;
-                            p && (o ? i = l.isDataTexture3D ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(i, h.__webglTexture), Z(i, l, m), Q(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i), B(l, m) && F(i), n.unbindTexture()
+                            p && (o ? i = l.isDataTexture3D ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(i, h.__webglTexture), P(i, l, m), N(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i), y(l, m) && _(i), n.unbindTexture()
                         }
-                        e.depthBuffer && tt(e)
+                        e.depthBuffer && U(e)
                     }, this.updateRenderTargetMipmap = function(e) {
-                        const r = U(e) || o,
+                        const r = x(e) || o,
                             s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                         for (let a = 0, o = s.length; a < o; a++) {
                             const o = s[a];
-                            if (B(o, r)) {
+                            if (y(o, r)) {
                                 const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                                     s = i.get(o).__webglTexture;
-                                n.bindTexture(r, s), F(r), n.unbindTexture()
+                                n.bindTexture(r, s), _(r), n.unbindTexture()
                             }
                         }
                     }, this.updateMultisampleRenderTarget = function(e) {
                         if (e.useRenderbuffer)
                             if (o) {
                                 const r = e.width,
                                     s = e.height;
                                 let a = t.COLOR_BUFFER_BIT;
                                 const o = [t.COLOR_ATTACHMENT0],
                                     l = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                                 e.depthBuffer && o.push(l), e.ignoreDepthForMultisampleCopy || (e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && (a |= t.STENCIL_BUFFER_BIT));
                                 const c = i.get(e);
                                 n.bindFramebuffer(t.READ_FRAMEBUFFER, c.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, c.__webglFramebuffer), e.ignoreDepthForMultisampleCopy && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [l]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [l])), t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, t.NEAREST), t.invalidateFramebuffer(t.READ_FRAMEBUFFER, o), n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, c.__webglMultisampledFramebuffer)
                             } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
-                    }, this.setupDepthRenderbuffer = tt, this.setupFrameBufferTexture = Q, this.safeSetTexture2D = function(t, e) {
-                        t && t.isWebGLRenderTarget && (!1 === it && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), it = !0), t = t.texture), j(t, e)
+                    }, this.setupDepthRenderbuffer = U, this.setupFrameBufferTexture = N, this.safeSetTexture2D = function(t, e) {
+                        t && t.isWebGLRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), z = !0), t = t.texture), A(t, e)
                     }, this.safeSetTextureCube = function(t, e) {
-                        t && t.isWebGLCubeRenderTarget && (!1 === rt && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), rt = !0), t = t.texture), X(t, e)
+                        t && t.isWebGLCubeRenderTarget && (!1 === H && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), H = !0), t = t.texture), R(t, e)
                     }
                 }
 
-                function Js(t, e, n) {
+                function ho(t, e, n) {
                     const i = n.isWebGL2;
                     return {
                         convert: function(n, r = null) {
                             let s;
-                            if (n === _) return t.UNSIGNED_BYTE;
-                            if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
-                            if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
-                            if (1010 === n) return t.BYTE;
-                            if (1011 === n) return t.SHORT;
-                            if (n === M) return t.UNSIGNED_SHORT;
-                            if (1013 === n) return t.INT;
-                            if (n === b) return t.UNSIGNED_INT;
-                            if (n === w) return t.FLOAT;
-                            if (n === S) return i ? t.HALF_FLOAT : (s = e.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
-                            if (1021 === n) return t.ALPHA;
-                            if (n === T) return t.RGBA;
-                            if (1024 === n) return t.LUMINANCE;
-                            if (1025 === n) return t.LUMINANCE_ALPHA;
-                            if (n === A) return t.DEPTH_COMPONENT;
-                            if (n === R) return t.DEPTH_STENCIL;
-                            if (1028 === n) return t.RED;
-                            if (n === pt) return s = e.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
-                            if (1029 === n) return t.RED_INTEGER;
-                            if (1030 === n) return t.RG;
-                            if (1031 === n) return t.RG_INTEGER;
-                            if (1033 === n) return t.RGBA_INTEGER;
-                            if (n === L || n === C || n === P || n === D)
-                                if (r === lt) {
+                            if (n === pt) return t.UNSIGNED_BYTE;
+                            if (n === Mt) return t.UNSIGNED_SHORT_4_4_4_4;
+                            if (n === bt) return t.UNSIGNED_SHORT_5_5_5_1;
+                            if (n === mt) return t.BYTE;
+                            if (n === ft) return t.SHORT;
+                            if (n === gt) return t.UNSIGNED_SHORT;
+                            if (n === vt) return t.INT;
+                            if (n === xt) return t.UNSIGNED_INT;
+                            if (n === yt) return t.FLOAT;
+                            if (n === _t) return i ? t.HALF_FLOAT : (s = e.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
+                            if (n === St) return t.ALPHA;
+                            if (n === Et) return t.RGBA;
+                            if (n === Tt) return t.LUMINANCE;
+                            if (n === At) return t.LUMINANCE_ALPHA;
+                            if (n === Rt) return t.DEPTH_COMPONENT;
+                            if (n === Lt) return t.DEPTH_STENCIL;
+                            if (n === Ct) return t.RED;
+                            if (n === we) return s = e.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
+                            if (n === Pt) return t.RED_INTEGER;
+                            if (n === Dt) return t.RG;
+                            if (n === It) return t.RG_INTEGER;
+                            if (n === Nt) return t.RGBA_INTEGER;
+                            if (n === Ot || n === Ut || n === Bt || n === Ft)
+                                if (r === fe) {
                                     if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
-                                    if (n === L) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
-                                    if (n === C) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
-                                    if (n === P) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
-                                    if (n === D) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
+                                    if (n === Ot) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
+                                    if (n === Ut) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
+                                    if (n === Bt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
+                                    if (n === Ft) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                 } else {
                                     if (s = e.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
-                                    if (n === L) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
-                                    if (n === C) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
-                                    if (n === P) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
-                                    if (n === D) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
-                                } if (n === I || n === N || n === O || n === U) {
+                                    if (n === Ot) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
+                                    if (n === Ut) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
+                                    if (n === Bt) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
+                                    if (n === Ft) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
+                                } if (n === zt || n === Ht || n === Gt || n === Vt) {
                                 if (s = e.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
-                                if (n === I) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
-                                if (n === N) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
-                                if (n === O) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
-                                if (n === U) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
+                                if (n === zt) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
+                                if (n === Ht) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
+                                if (n === Gt) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
+                                if (n === Vt) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                             }
-                            if (36196 === n) return s = e.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
-                            if (n === B || n === F) {
+                            if (n === kt) return s = e.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
+                            if (n === Wt || n === jt) {
                                 if (s = e.get("WEBGL_compressed_texture_etc"), null === s) return null;
-                                if (n === B) return r === lt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
-                                if (n === F) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
+                                if (n === Wt) return r === fe ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
+                                if (n === jt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
                             }
-                            if (n === z || n === H || n === G || n === V || n === k || n === W || n === j || n === X || n === q || n === Y || n === Z || n === J || n === K || n === Q) {
+                            if (n === Xt || n === qt || n === Yt || n === Zt || n === Jt || n === Kt || n === Qt || n === $t || n === te || n === ee || n === ne || n === ie || n === re || n === se) {
                                 if (s = e.get("WEBGL_compressed_texture_astc"), null === s) return null;
-                                if (n === z) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
-                                if (n === H) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
-                                if (n === G) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
-                                if (n === V) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
-                                if (n === k) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
-                                if (n === W) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
-                                if (n === j) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
-                                if (n === X) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
-                                if (n === q) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
-                                if (n === Y) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
-                                if (n === Z) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
-                                if (n === J) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
-                                if (n === K) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
-                                if (n === Q) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
+                                if (n === Xt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
+                                if (n === qt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
+                                if (n === Yt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
+                                if (n === Zt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
+                                if (n === Jt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
+                                if (n === Kt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
+                                if (n === Qt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
+                                if (n === $t) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
+                                if (n === te) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
+                                if (n === ee) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
+                                if (n === ne) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
+                                if (n === ie) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
+                                if (n === re) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
+                                if (n === se) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
                             }
-                            if (n === $) {
+                            if (n === ae) {
                                 if (s = e.get("EXT_texture_compression_bptc"), null === s) return null;
-                                if (n === $) return r === lt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
+                                if (n === ae) return r === fe ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
                             }
-                            return n === E ? i ? t.UNSIGNED_INT_24_8 : (s = e.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0
+                            return n === wt ? i ? t.UNSIGNED_INT_24_8 : (s = e.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                         }
                     }
                 }
-                Xs.prototype.isMeshDistanceMaterial = !0;
-                class Ks extends ai {
+                class uo extends gr {
                     constructor(t = []) {
                         super(), this.cameras = t
                     }
                 }
-                Ks.prototype.isArrayCamera = !0;
-                class Qs extends Qe {
+                uo.prototype.isArrayCamera = !0;
+                class po extends ci {
                     constructor() {
                         super(), this.type = "Group"
                     }
                 }
-                Qs.prototype.isGroup = !0;
-                const $s = {
+                po.prototype.isGroup = !0;
+                const mo = {
                     type: "move"
                 };
-                class ta {
+                class fo {
                     constructor() {
                         this._targetRay = null, this._grip = null, this._hand = null
                     }
                     getHandSpace() {
-                        return null === this._hand && (this._hand = new Qs, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
+                        return null === this._hand && (this._hand = new po, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                             pinching: !1
                         }), this._hand
                     }
                     getTargetRaySpace() {
-                        return null === this._targetRay && (this._targetRay = new Qs, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Jt, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Jt), this._targetRay
+                        return null === this._targetRay && (this._targetRay = new po, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new on, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new on), this._targetRay
                     }
                     getGripSpace() {
-                        return null === this._grip && (this._grip = new Qs, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Jt, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Jt), this._grip
+                        return null === this._grip && (this._grip = new po, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new on, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new on), this._grip
                     }
                     dispatchEvent(t) {
                         return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                     }
                     disconnect(t) {
                         return this.dispatchEvent({
                             type: "disconnected",
@@ -8426,20 +8794,20 @@
                         let i = null,
                             r = null,
                             s = null;
                         const a = this._targetRay,
                             o = this._grip,
                             l = this._hand;
                         if (t && "visible-blurred" !== e.session.visibilityState)
-                            if (null !== a && (i = e.getPose(t.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent($s))), l && t.hand) {
+                            if (null !== a && (i = e.getPose(t.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(mo))), l && t.hand) {
                                 s = !0;
                                 for (const i of t.hand.values()) {
                                     const t = e.getJointPose(i, n);
                                     if (void 0 === l.joints[i.jointName]) {
-                                        const t = new Qs;
+                                        const t = new po;
                                         t.matrixAutoUpdate = !1, t.visible = !1, l.joints[i.jointName] = t, l.add(t)
                                     }
                                     const r = l.joints[i.jointName];
                                     null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
                                 }
                                 const i = l.joints["index-finger-tip"],
                                     r = l.joints["thumb-tip"],
@@ -8455,25 +8823,25 @@
                                     handedness: t.handedness,
                                     target: this
                                 }))
                             } else null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                         return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
                     }
                 }
-                class ea extends kt {
+                class go extends $e {
                     constructor(t, e, n, i, r, s, a, o, l, c) {
-                        if ((c = void 0 !== c ? c : A) !== A && c !== R) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
-                        void 0 === n && c === A && (n = M), void 0 === n && c === R && (n = E), super(null, i, r, s, a, o, c, n, l), this.image = {
+                        if ((c = void 0 !== c ? c : Rt) !== Rt && c !== Lt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
+                        void 0 === n && c === Rt && (n = gt), void 0 === n && c === Lt && (n = wt), super(null, i, r, s, a, o, c, n, l), this.image = {
                             width: t,
                             height: e
-                        }, this.magFilter = void 0 !== a ? a : m, this.minFilter = void 0 !== o ? o : m, this.flipY = !1, this.generateMipmaps = !1
+                        }, this.magFilter = void 0 !== a ? a : ot, this.minFilter = void 0 !== o ? o : ot, this.flipY = !1, this.generateMipmaps = !1
                     }
                 }
-                ea.prototype.isDepthTexture = !0;
-                class na extends mt {
+                go.prototype.isDepthTexture = !0;
+                class vo extends Se {
                     constructor(t, e) {
                         super();
                         const n = this;
                         let i = null,
                             r = 1,
                             s = null,
                             a = "local-floor";
@@ -8485,41 +8853,41 @@
                             d = !1,
                             p = null;
                         const m = e.getContextAttributes();
                         let f = null,
                             g = null;
                         const v = [],
                             x = new Map,
-                            y = new ai;
-                        y.layers.enable(1), y.viewport = new jt;
-                        const b = new ai;
-                        b.layers.enable(2), b.viewport = new jt;
-                        const w = [y, b],
-                            S = new Ks;
-                        S.layers.enable(1), S.layers.enable(2);
-                        let L = null,
-                            C = null;
+                            y = new gr;
+                        y.layers.enable(1), y.viewport = new en;
+                        const _ = new gr;
+                        _.layers.enable(2), _.viewport = new en;
+                        const M = [y, _],
+                            b = new uo;
+                        b.layers.enable(1), b.layers.enable(2);
+                        let w = null,
+                            S = null;
 
-                        function P(t) {
+                        function E(t) {
                             const e = x.get(t.inputSource);
                             e && e.dispatchEvent({
                                 type: t.type,
                                 data: t.inputSource
                             })
                         }
 
-                        function D() {
+                        function T() {
                             x.forEach((function(t, e) {
                                 t.disconnect(e)
-                            })), x.clear(), L = null, C = null, t.setRenderTarget(f), u = null, h = null, c = null, i = null, g = null, F.stop(), n.isPresenting = !1, n.dispatchEvent({
+                            })), x.clear(), w = null, S = null, t.setRenderTarget(f), u = null, h = null, c = null, i = null, g = null, D.stop(), n.isPresenting = !1, n.dispatchEvent({
                                 type: "sessionend"
                             })
                         }
 
-                        function I(t) {
+                        function A(t) {
                             const e = i.inputSources;
                             for (let t = 0; t < v.length; t++) x.set(e[t], v[t]);
                             for (let e = 0; e < t.removed.length; e++) {
                                 const n = t.removed[e],
                                     i = x.get(n);
                                 i && (i.dispatchEvent({
                                     type: "disconnected",
@@ -8533,21 +8901,21 @@
                                     type: "connected",
                                     data: n
                                 })
                             }
                         }
                         this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                             let e = v[t];
-                            return void 0 === e && (e = new ta, v[t] = e), e.getTargetRaySpace()
+                            return void 0 === e && (e = new fo, v[t] = e), e.getTargetRaySpace()
                         }, this.getControllerGrip = function(t) {
                             let e = v[t];
-                            return void 0 === e && (e = new ta, v[t] = e), e.getGripSpace()
+                            return void 0 === e && (e = new fo, v[t] = e), e.getGripSpace()
                         }, this.getHand = function(t) {
                             let e = v[t];
-                            return void 0 === e && (e = new ta, v[t] = e), e.getHandSpace()
+                            return void 0 === e && (e = new fo, v[t] = e), e.getHandSpace()
                         }, this.setFramebufferScaleFactor = function(t) {
                             r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                         }, this.setReferenceSpaceType = function(t) {
                             a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                         }, this.getReferenceSpace = function() {
                             return s
                         }, this.getBaseLayer = function() {
@@ -8556,86 +8924,86 @@
                             return c
                         }, this.getFrame = function() {
                             return p
                         }, this.getSession = function() {
                             return i
                         }, this.setSession = async function(l) {
                             if (i = l, null !== i) {
-                                if (f = t.getRenderTarget(), i.addEventListener("select", P), i.addEventListener("selectstart", P), i.addEventListener("selectend", P), i.addEventListener("squeeze", P), i.addEventListener("squeezestart", P), i.addEventListener("squeezeend", P), i.addEventListener("end", D), i.addEventListener("inputsourceschange", I), !0 !== m.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
+                                if (f = t.getRenderTarget(), i.addEventListener("select", E), i.addEventListener("selectstart", E), i.addEventListener("selectend", E), i.addEventListener("squeeze", E), i.addEventListener("squeezestart", E), i.addEventListener("squeezeend", E), i.addEventListener("end", T), i.addEventListener("inputsourceschange", A), !0 !== m.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                                     const n = {
                                         antialias: void 0 !== i.renderState.layers || m.antialias,
                                         alpha: m.alpha,
                                         depth: m.depth,
                                         stencil: m.stencil,
                                         framebufferScaleFactor: r
                                     };
                                     u = new XRWebGLLayer(i, e, n), i.updateRenderState({
                                         baseLayer: u
-                                    }), g = new Xt(u.framebufferWidth, u.framebufferHeight, {
-                                        format: T,
-                                        type: _,
+                                    }), g = new nn(u.framebufferWidth, u.framebufferHeight, {
+                                        format: Et,
+                                        type: pt,
                                         encoding: t.outputEncoding
                                     })
                                 } else {
                                     d = m.antialias;
                                     let n = null,
                                         s = null,
                                         a = null;
-                                    m.depth && (a = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, n = m.stencil ? R : A, s = m.stencil ? E : M);
+                                    m.depth && (a = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, n = m.stencil ? Lt : Rt, s = m.stencil ? wt : gt);
                                     const l = {
-                                        colorFormat: t.outputEncoding === lt ? e.SRGB8_ALPHA8 : e.RGBA8,
+                                        colorFormat: t.outputEncoding === fe ? e.SRGB8_ALPHA8 : e.RGBA8,
                                         depthFormat: a,
                                         scaleFactor: r
                                     };
                                     c = new XRWebGLBinding(i, e), h = c.createProjectionLayer(l), i.updateRenderState({
                                         layers: [h]
-                                    }), g = d ? new Yt(h.textureWidth, h.textureHeight, {
-                                        format: T,
-                                        type: _,
-                                        depthTexture: new ea(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
+                                    }), g = d ? new sn(h.textureWidth, h.textureHeight, {
+                                        format: Et,
+                                        type: pt,
+                                        depthTexture: new go(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                         stencilBuffer: m.stencil,
                                         ignoreDepth: h.ignoreDepthValues,
                                         useRenderToTexture: o,
                                         encoding: t.outputEncoding
-                                    }) : new Xt(h.textureWidth, h.textureHeight, {
-                                        format: T,
-                                        type: _,
-                                        depthTexture: new ea(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
+                                    }) : new nn(h.textureWidth, h.textureHeight, {
+                                        format: Et,
+                                        type: pt,
+                                        depthTexture: new go(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                         stencilBuffer: m.stencil,
                                         ignoreDepth: h.ignoreDepthValues,
                                         encoding: t.outputEncoding
                                     })
                                 }
-                                g.isXRRenderTarget = !0, this.setFoveation(1), s = await i.requestReferenceSpace(a), F.setContext(i), F.start(), n.isPresenting = !0, n.dispatchEvent({
+                                g.isXRRenderTarget = !0, this.setFoveation(1), s = await i.requestReferenceSpace(a), D.setContext(i), D.start(), n.isPresenting = !0, n.dispatchEvent({
                                     type: "sessionstart"
                                 })
                             }
                         };
-                        const N = new Jt,
-                            O = new Jt;
+                        const R = new on,
+                            L = new on;
 
-                        function U(t, e) {
+                        function C(t, e) {
                             null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                         }
                         this.updateCamera = function(t) {
                             if (null === i) return;
-                            S.near = b.near = y.near = t.near, S.far = b.far = y.far = t.far, L === S.near && C === S.far || (i.updateRenderState({
-                                depthNear: S.near,
-                                depthFar: S.far
-                            }), L = S.near, C = S.far);
+                            b.near = _.near = y.near = t.near, b.far = _.far = y.far = t.far, w === b.near && S === b.far || (i.updateRenderState({
+                                depthNear: b.near,
+                                depthFar: b.far
+                            }), w = b.near, S = b.far);
                             const e = t.parent,
-                                n = S.cameras;
-                            U(S, e);
-                            for (let t = 0; t < n.length; t++) U(n[t], e);
-                            S.matrixWorld.decompose(S.position, S.quaternion, S.scale), t.position.copy(S.position), t.quaternion.copy(S.quaternion), t.scale.copy(S.scale), t.matrix.copy(S.matrix), t.matrixWorld.copy(S.matrixWorld);
+                                n = b.cameras;
+                            C(b, e);
+                            for (let t = 0; t < n.length; t++) C(n[t], e);
+                            b.matrixWorld.decompose(b.position, b.quaternion, b.scale), t.position.copy(b.position), t.quaternion.copy(b.quaternion), t.scale.copy(b.scale), t.matrix.copy(b.matrix), t.matrixWorld.copy(b.matrixWorld);
                             const r = t.children;
                             for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
                             2 === n.length ? function(t, e, n) {
-                                N.setFromMatrixPosition(e.matrixWorld), O.setFromMatrixPosition(n.matrixWorld);
-                                const i = N.distanceTo(O),
+                                R.setFromMatrixPosition(e.matrixWorld), L.setFromMatrixPosition(n.matrixWorld);
+                                const i = R.distanceTo(L),
                                     r = e.projectionMatrix.elements,
                                     s = n.projectionMatrix.elements,
                                     a = r[14] / (r[10] - 1),
                                     o = r[14] / (r[10] + 1),
                                     l = (r[9] + 1) / r[5],
                                     c = (r[9] - 1) / r[5],
                                     h = (r[8] - 1) / r[0],
@@ -8648,87 +9016,87 @@
                                 const g = a + m,
                                     v = o + m,
                                     x = d - f,
                                     y = p + (i - f),
                                     _ = l * o / v * g,
                                     M = c * o / v * g;
                                 t.projectionMatrix.makePerspective(x, y, _, M, g, v)
-                            }(S, y, b) : S.projectionMatrix.copy(y.projectionMatrix)
+                            }(b, y, _) : b.projectionMatrix.copy(y.projectionMatrix)
                         }, this.getCamera = function() {
-                            return S
+                            return b
                         }, this.getFoveation = function() {
                             return null !== h ? h.fixedFoveation : null !== u ? u.fixedFoveation : void 0
                         }, this.setFoveation = function(t) {
                             null !== h && (h.fixedFoveation = t), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = t)
                         };
-                        let B = null;
-                        const F = new xi;
-                        F.setAnimationLoop((function(e, n) {
+                        let P = null;
+                        const D = new Rr;
+                        D.setAnimationLoop((function(e, n) {
                             if (l = n.getViewerPose(s), p = n, null !== l) {
                                 const e = l.views;
                                 null !== u && (t.setRenderTargetFramebuffer(g, u.framebuffer), t.setRenderTarget(g));
                                 let n = !1;
-                                e.length !== S.cameras.length && (S.cameras.length = 0, n = !0);
+                                e.length !== b.cameras.length && (b.cameras.length = 0, n = !0);
                                 for (let i = 0; i < e.length; i++) {
                                     const r = e[i];
                                     let s = null;
                                     if (null !== u) s = u.getViewport(r);
                                     else {
                                         const e = c.getViewSubImage(h, r);
                                         s = e.viewport, 0 === i && (t.setRenderTargetTextures(g, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(g))
                                     }
-                                    const a = w[i];
-                                    a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && S.matrix.copy(a.matrix), !0 === n && S.cameras.push(a)
+                                    const a = M[i];
+                                    a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && b.matrix.copy(a.matrix), !0 === n && b.cameras.push(a)
                                 }
                             }
                             const r = i.inputSources;
                             for (let t = 0; t < v.length; t++) {
                                 const e = v[t],
                                     i = r[t];
                                 e.update(i, n, s)
                             }
-                            B && B(e, n), p = null
+                            P && P(e, n), p = null
                         })), this.setAnimationLoop = function(t) {
-                            B = t
+                            P = t
                         }, this.dispose = function() {}
                     }
                 }
 
-                function ia(t) {
+                function xo(t) {
                     function e(e, n) {
                         e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
                         const i = t.get(n).envMap;
                         let r, s;
                         i && (e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.ior.value = n.ior, e.refractionRatio.value = n.refractionRatio), n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
                     }
 
                     function n(e, n) {
-                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
+                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === h && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === h && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
                     }
                     return {
                         refreshFogUniforms: function(t, e) {
                             t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                         },
                         refreshMaterialUniforms: function(t, i, r, s, a) {
                             i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) {
                                 e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                             }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) {
-                                e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) {
-                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function(t, e, i) {
-                                n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
+                                n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === h && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                             }(t, i, a) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) {
-                                e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) {
                                 e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) {
                                 e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                             }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) {
-                                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                             }(t, i), i.isLineDashedMaterial && function(t, e) {
                                 t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                             }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                                 let r;
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
@@ -8736,561 +9104,561 @@
                                 let n;
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                             }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                         }
                     }
                 }
 
-                function ra(t = {}) {
+                function yo(t = {}) {
                     const e = void 0 !== t.canvas ? t.canvas : function() {
-                            const t = Dt("canvas");
+                            const t = Ve("canvas");
                             return t.style.display = "block", t
                         }(),
-                        n = void 0 !== t.context ? t.context : null,
-                        i = void 0 !== t.alpha && t.alpha,
-                        r = void 0 === t.depth || t.depth,
-                        s = void 0 === t.stencil || t.stencil,
-                        a = void 0 !== t.antialias && t.antialias,
-                        o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
-                        l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
-                        c = void 0 !== t.powerPreference ? t.powerPreference : "default",
-                        h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
-                    let u = null,
-                        p = null;
-                    const f = [],
-                        g = [];
+                        i = void 0 !== t.context ? t.context : null,
+                        r = void 0 !== t.alpha && t.alpha,
+                        s = void 0 === t.depth || t.depth,
+                        a = void 0 === t.stencil || t.stencil,
+                        o = void 0 !== t.antialias && t.antialias,
+                        l = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
+                        d = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
+                        p = void 0 !== t.powerPreference ? t.powerPreference : "default",
+                        m = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
+                    let f = null,
+                        g = null;
+                    const v = [],
+                        x = [];
                     this.domElement = e, this.debug = {
                         checkShaderErrors: !0
-                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = ot, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
-                    const v = this;
-                    let x = !1,
+                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = me, this.physicallyCorrectLights = !1, this.toneMapping = j, this.toneMappingExposure = 1;
+                    const y = this;
+                    let _ = !1,
                         M = 0,
                         b = 0,
-                        E = null,
-                        A = -1,
-                        R = null;
-                    const L = new jt,
-                        C = new jt;
-                    let P = null,
-                        D = e.width,
-                        I = e.height,
-                        N = 1,
-                        O = null,
-                        U = null;
-                    const B = new jt(0, 0, D, I),
-                        F = new jt(0, 0, D, I);
-                    let z = !1;
-                    const H = new vi;
-                    let G = !1,
-                        V = !1,
-                        k = null;
-                    const W = new Ae,
-                        j = new Jt,
-                        X = {
+                        w = null,
+                        S = -1,
+                        E = null;
+                    const T = new en,
+                        A = new en;
+                    let R = null,
+                        L = e.width,
+                        C = e.height,
+                        P = 1,
+                        D = null,
+                        I = null;
+                    const N = new en(0, 0, L, C),
+                        O = new en(0, 0, L, C);
+                    let U = !1;
+                    const B = new Ar;
+                    let F = !1,
+                        z = !1,
+                        H = null;
+                    const G = new Fn,
+                        V = new on,
+                        k = {
                             background: null,
                             fog: null,
                             environment: null,
                             overrideMaterial: null,
                             isScene: !0
                         };
 
-                    function q() {
-                        return null === E ? N : 1
+                    function W() {
+                        return null === w ? P : 1
                     }
-                    let Y, Z, J, K, Q, $, tt, et, nt, it, rt, st, at, lt, ct, ht, ut, dt, pt, mt, ft, gt, vt, xt = n;
+                    let X, q, Y, Z, J, K, Q, $, tt, et, nt, it, rt, at, lt, ct, ht, ut, mt, ft, gt, vt, xt, Mt = i;
 
-                    function yt(t, n) {
+                    function bt(t, n) {
                         for (let i = 0; i < t.length; i++) {
                             const r = t[i],
                                 s = e.getContext(r, n);
                             if (null !== s) return s
                         }
                         return null
                     }
                     try {
                         const t = {
                             alpha: !0,
-                            depth: r,
-                            stencil: s,
-                            antialias: a,
-                            premultipliedAlpha: o,
-                            preserveDrawingBuffer: l,
-                            powerPreference: c,
-                            failIfMajorPerformanceCaveat: h
+                            depth: s,
+                            stencil: a,
+                            antialias: o,
+                            premultipliedAlpha: l,
+                            preserveDrawingBuffer: d,
+                            powerPreference: p,
+                            failIfMajorPerformanceCaveat: m
                         };
-                        if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r137"), e.addEventListener("webglcontextlost", bt, !1), e.addEventListener("webglcontextrestored", wt, !1), null === xt) {
+                        if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${n}`), e.addEventListener("webglcontextlost", Tt, !1), e.addEventListener("webglcontextrestored", At, !1), null === Mt) {
                             const e = ["webgl2", "webgl", "experimental-webgl"];
-                            if (!0 === v.isWebGL1Renderer && e.shift(), xt = yt(e, t), null === xt) throw yt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
+                            if (!0 === y.isWebGL1Renderer && e.shift(), Mt = bt(e, t), null === Mt) throw bt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                         }
-                        void 0 === xt.getShaderPrecisionFormat && (xt.getShaderPrecisionFormat = function() {
+                        void 0 === Mt.getShaderPrecisionFormat && (Mt.getShaderPrecisionFormat = function() {
                             return {
                                 rangeMin: 1,
                                 rangeMax: 1,
                                 precision: 1
                             }
                         })
                     } catch (t) {
                         throw console.error("THREE.WebGLRenderer: " + t.message), t
                     }
 
-                    function _t() {
-                        Y = new Ki(xt), Z = new Ai(xt, Y, t), Y.init(Z), gt = new Js(xt, Y, Z), J = new Ys(xt, Y, Z), K = new tr(xt), Q = new Ns, $ = new Zs(xt, Y, J, Q, Z, gt, K), tt = new Li(v), et = new Ji(v), nt = new yi(xt, Z), vt = new Ei(xt, Y, nt, Z), it = new Qi(xt, nt, K, vt), rt = new ar(xt, it, nt, K), pt = new sr(xt, Z, $), ht = new Ri(Q), st = new Is(v, tt, et, Y, Z, vt, ht), at = new ia(Q), lt = new Fs, ct = new Ws(Y, Z), dt = new Si(v, tt, J, rt, i, o), ut = new qs(v, rt, Z), mt = new Ti(xt, Y, K, Z), ft = new $i(xt, Y, K, Z), K.programs = st.programs, v.capabilities = Z, v.extensions = Y, v.properties = Q, v.renderLists = lt, v.shadowMap = ut, v.state = J, v.info = K
+                    function wt() {
+                        X = new cs(Mt), q = new Br(Mt, X, t), X.init(q), vt = new ho(Mt, X, q), Y = new lo(Mt, X, q), Z = new ds(Mt), J = new Xa, K = new co(Mt, X, Y, J, q, vt, Z), Q = new zr(y), $ = new ls(y), tt = new Lr(Mt, q), xt = new Or(Mt, X, tt, q), et = new hs(Mt, tt, Z, xt), nt = new xs(Mt, et, tt, Z), mt = new vs(Mt, q, K), ct = new Fr(J), it = new ja(y, Q, $, X, q, xt, ct), rt = new xo(J), at = new Ja, lt = new no(X, q), ut = new Nr(y, Q, Y, nt, r, l), ht = new oo(y, nt, q), ft = new Ur(Mt, X, Z, q), gt = new us(Mt, X, Z, q), Z.programs = it.programs, y.capabilities = q, y.extensions = X, y.properties = J, y.renderLists = at, y.shadowMap = ht, y.state = Y, y.info = Z
                     }
-                    _t();
-                    const Mt = new na(v, xt);
+                    wt();
+                    const St = new vo(y, Mt);
 
-                    function bt(t) {
-                        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0
+                    function Tt(t) {
+                        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0
                     }
 
-                    function wt() {
-                        console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
-                        const t = K.autoReset,
-                            e = ut.enabled,
-                            n = ut.autoUpdate,
-                            i = ut.needsUpdate,
-                            r = ut.type;
-                        _t(), K.autoReset = t, ut.enabled = e, ut.autoUpdate = n, ut.needsUpdate = i, ut.type = r
+                    function At() {
+                        console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
+                        const t = Z.autoReset,
+                            e = ht.enabled,
+                            n = ht.autoUpdate,
+                            i = ht.needsUpdate,
+                            r = ht.type;
+                        wt(), Z.autoReset = t, ht.enabled = e, ht.autoUpdate = n, ht.needsUpdate = i, ht.type = r
                     }
 
-                    function St(t) {
+                    function Rt(t) {
                         const e = t.target;
-                        e.removeEventListener("dispose", St),
+                        e.removeEventListener("dispose", Rt),
                             function(t) {
                                 (function(t) {
-                                    const e = Q.get(t).programs;
+                                    const e = J.get(t).programs;
                                     void 0 !== e && (e.forEach((function(t) {
-                                        st.releaseProgram(t)
-                                    })), t.isShaderMaterial && st.releaseShaderCache(t))
-                                })(t), Q.remove(t)
+                                        it.releaseProgram(t)
+                                    })), t.isShaderMaterial && it.releaseShaderCache(t))
+                                })(t), J.remove(t)
                             }(e)
                     }
-                    this.xr = Mt, this.getContext = function() {
-                        return xt
+                    this.xr = St, this.getContext = function() {
+                        return Mt
                     }, this.getContextAttributes = function() {
-                        return xt.getContextAttributes()
+                        return Mt.getContextAttributes()
                     }, this.forceContextLoss = function() {
-                        const t = Y.get("WEBGL_lose_context");
+                        const t = X.get("WEBGL_lose_context");
                         t && t.loseContext()
                     }, this.forceContextRestore = function() {
-                        const t = Y.get("WEBGL_lose_context");
+                        const t = X.get("WEBGL_lose_context");
                         t && t.restoreContext()
                     }, this.getPixelRatio = function() {
-                        return N
+                        return P
                     }, this.setPixelRatio = function(t) {
-                        void 0 !== t && (N = t, this.setSize(D, I, !1))
+                        void 0 !== t && (P = t, this.setSize(L, C, !1))
                     }, this.getSize = function(t) {
-                        return t.set(D, I)
+                        return t.set(L, C)
                     }, this.setSize = function(t, n, i) {
-                        Mt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (D = t, I = n, e.width = Math.floor(t * N), e.height = Math.floor(n * N), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
+                        St.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (L = t, C = n, e.width = Math.floor(t * P), e.height = Math.floor(n * P), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                     }, this.getDrawingBufferSize = function(t) {
-                        return t.set(D * N, I * N).floor()
+                        return t.set(L * P, C * P).floor()
                     }, this.setDrawingBufferSize = function(t, n, i) {
-                        D = t, I = n, N = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
+                        L = t, C = n, P = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
                     }, this.getCurrentViewport = function(t) {
-                        return t.copy(L)
+                        return t.copy(T)
                     }, this.getViewport = function(t) {
-                        return t.copy(B)
+                        return t.copy(N)
                     }, this.setViewport = function(t, e, n, i) {
-                        t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, i), J.viewport(L.copy(B).multiplyScalar(N).floor())
+                        t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i), Y.viewport(T.copy(N).multiplyScalar(P).floor())
                     }, this.getScissor = function(t) {
-                        return t.copy(F)
+                        return t.copy(O)
                     }, this.setScissor = function(t, e, n, i) {
-                        t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i), J.scissor(C.copy(F).multiplyScalar(N).floor())
+                        t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i), Y.scissor(A.copy(O).multiplyScalar(P).floor())
                     }, this.getScissorTest = function() {
-                        return z
+                        return U
                     }, this.setScissorTest = function(t) {
-                        J.setScissorTest(z = t)
+                        Y.setScissorTest(U = t)
                     }, this.setOpaqueSort = function(t) {
-                        O = t
+                        D = t
                     }, this.setTransparentSort = function(t) {
-                        U = t
+                        I = t
                     }, this.getClearColor = function(t) {
-                        return t.copy(dt.getClearColor())
+                        return t.copy(ut.getClearColor())
                     }, this.setClearColor = function() {
-                        dt.setClearColor.apply(dt, arguments)
+                        ut.setClearColor.apply(ut, arguments)
                     }, this.getClearAlpha = function() {
-                        return dt.getClearAlpha()
+                        return ut.getClearAlpha()
                     }, this.setClearAlpha = function() {
-                        dt.setClearAlpha.apply(dt, arguments)
+                        ut.setClearAlpha.apply(ut, arguments)
                     }, this.clear = function(t, e, n) {
                         let i = 0;
-                        (void 0 === t || t) && (i |= xt.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= xt.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= xt.STENCIL_BUFFER_BIT), xt.clear(i)
+                        (void 0 === t || t) && (i |= Mt.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= Mt.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= Mt.STENCIL_BUFFER_BIT), Mt.clear(i)
                     }, this.clearColor = function() {
                         this.clear(!0, !1, !1)
                     }, this.clearDepth = function() {
                         this.clear(!1, !0, !1)
                     }, this.clearStencil = function() {
                         this.clear(!1, !1, !0)
                     }, this.dispose = function() {
-                        e.removeEventListener("webglcontextlost", bt, !1), e.removeEventListener("webglcontextrestored", wt, !1), lt.dispose(), ct.dispose(), Q.dispose(), tt.dispose(), et.dispose(), rt.dispose(), vt.dispose(), st.dispose(), Mt.dispose(), Mt.removeEventListener("sessionstart", Tt), Mt.removeEventListener("sessionend", At), k && (k.dispose(), k = null), Rt.stop()
+                        e.removeEventListener("webglcontextlost", Tt, !1), e.removeEventListener("webglcontextrestored", At, !1), at.dispose(), lt.dispose(), J.dispose(), Q.dispose(), $.dispose(), nt.dispose(), xt.dispose(), it.dispose(), St.dispose(), St.removeEventListener("sessionstart", Ct), St.removeEventListener("sessionend", Pt), H && (H.dispose(), H = null), Dt.stop()
                     }, this.renderBufferDirect = function(t, e, n, i, r, s) {
-                        null === e && (e = X);
+                        null === e && (e = k);
                         const a = r.isMesh && r.matrixWorld.determinant() < 0,
                             o = function(t, e, n, i, r) {
-                                !0 !== e.isScene && (e = X), $.resetTextureUnits();
+                                !0 !== e.isScene && (e = k), K.resetTextureUnits();
                                 const s = e.fog,
                                     a = i.isMeshStandardMaterial ? e.environment : null,
-                                    o = null === E ? v.outputEncoding : !0 === E.isXRRenderTarget ? E.texture.encoding : ot,
-                                    l = (i.isMeshStandardMaterial ? et : tt).get(i.envMap || a),
+                                    o = null === w ? y.outputEncoding : !0 === w.isXRRenderTarget ? w.texture.encoding : me,
+                                    l = (i.isMeshStandardMaterial ? $ : Q).get(i.envMap || a),
                                     c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                     h = !!i.normalMap && !!n.attributes.tangent,
                                     u = !!n.morphAttributes.position,
                                     d = !!n.morphAttributes.normal,
-                                    m = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
-                                    f = i.toneMapped ? v.toneMapping : 0,
-                                    g = Q.get(i),
-                                    x = p.state.lights;
-                                if (!0 === G && (!0 === V || t !== R)) {
-                                    const e = t === R && i.id === A;
-                                    ht.setState(i, t, e)
-                                }
-                                let y = !1;
-                                i.version === g.__version ? g.needsLights && g.lightsStateVersion !== x.state.version || g.outputEncoding !== o || r.isInstancedMesh && !1 === g.instancing ? y = !0 : r.isInstancedMesh || !0 !== g.instancing ? r.isSkinnedMesh && !1 === g.skinning ? y = !0 : r.isSkinnedMesh || !0 !== g.skinning ? g.envMap !== l || i.fog && g.fog !== s ? y = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === ht.numPlanes && g.numIntersection === ht.numIntersection ? (g.vertexAlphas !== c || g.vertexTangents !== h || g.morphTargets !== u || g.morphNormals !== d || g.toneMapping !== f || !0 === Z.isWebGL2 && g.morphTargetsCount !== m) && (y = !0) : y = !0 : y = !0 : y = !0 : (y = !0, g.__version = i.version);
-                                let _ = g.currentProgram;
-                                !0 === y && (_ = Nt(i, e, r));
+                                    p = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
+                                    m = i.toneMapped ? y.toneMapping : j,
+                                    f = J.get(i),
+                                    v = g.state.lights;
+                                if (!0 === F && (!0 === z || t !== E)) {
+                                    const e = t === E && i.id === S;
+                                    ct.setState(i, t, e)
+                                }
+                                let x = !1;
+                                i.version === f.__version ? f.needsLights && f.lightsStateVersion !== v.state.version || f.outputEncoding !== o || r.isInstancedMesh && !1 === f.instancing ? x = !0 : r.isInstancedMesh || !0 !== f.instancing ? r.isSkinnedMesh && !1 === f.skinning ? x = !0 : r.isSkinnedMesh || !0 !== f.skinning ? f.envMap !== l || i.fog && f.fog !== s ? x = !0 : void 0 === f.numClippingPlanes || f.numClippingPlanes === ct.numPlanes && f.numIntersection === ct.numIntersection ? (f.vertexAlphas !== c || f.vertexTangents !== h || f.morphTargets !== u || f.morphNormals !== d || f.toneMapping !== m || !0 === q.isWebGL2 && f.morphTargetsCount !== p) && (x = !0) : x = !0 : x = !0 : x = !0 : (x = !0, f.__version = i.version);
+                                let _ = f.currentProgram;
+                                !0 === x && (_ = Bt(i, e, r));
                                 let M = !1,
                                     b = !1,
-                                    w = !1;
-                                const S = _.getUniforms(),
-                                    T = g.uniforms;
-                                if (J.useProgram(_.program) && (M = !0, b = !0, w = !0), i.id !== A && (A = i.id, b = !0), M || R !== t) {
-                                    if (S.setValue(xt, "projectionMatrix", t.projectionMatrix), Z.logarithmicDepthBuffer && S.setValue(xt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), R !== t && (R = t, b = !0, w = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
-                                        const e = S.map.cameraPosition;
-                                        void 0 !== e && e.setValue(xt, j.setFromMatrixPosition(t.matrixWorld))
-                                    }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && S.setValue(xt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && S.setValue(xt, "viewMatrix", t.matrixWorldInverse)
+                                    T = !1;
+                                const A = _.getUniforms(),
+                                    R = f.uniforms;
+                                if (Y.useProgram(_.program) && (M = !0, b = !0, T = !0), i.id !== S && (S = i.id, b = !0), M || E !== t) {
+                                    if (A.setValue(Mt, "projectionMatrix", t.projectionMatrix), q.logarithmicDepthBuffer && A.setValue(Mt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), E !== t && (E = t, b = !0, T = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
+                                        const e = A.map.cameraPosition;
+                                        void 0 !== e && e.setValue(Mt, V.setFromMatrixPosition(t.matrixWorld))
+                                    }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && A.setValue(Mt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && A.setValue(Mt, "viewMatrix", t.matrixWorldInverse)
                                 }
                                 if (r.isSkinnedMesh) {
-                                    S.setOptional(xt, r, "bindMatrix"), S.setOptional(xt, r, "bindMatrixInverse");
+                                    A.setOptional(Mt, r, "bindMatrix"), A.setOptional(Mt, r, "bindMatrixInverse");
                                     const t = r.skeleton;
-                                    t && (Z.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), S.setValue(xt, "boneTexture", t.boneTexture, $), S.setValue(xt, "boneTextureSize", t.boneTextureSize)) : S.setOptional(xt, t, "boneMatrices"))
+                                    t && (q.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), A.setValue(Mt, "boneTexture", t.boneTexture, K), A.setValue(Mt, "boneTextureSize", t.boneTextureSize)) : A.setOptional(Mt, t, "boneMatrices"))
                                 }
-                                var L, C;
-                                return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || pt.update(r, n, i, _), (b || g.receiveShadow !== r.receiveShadow) && (g.receiveShadow = r.receiveShadow, S.setValue(xt, "receiveShadow", r.receiveShadow)), b && (S.setValue(xt, "toneMappingExposure", v.toneMappingExposure), g.needsLights && (C = w, (L = T).ambientLightColor.needsUpdate = C, L.lightProbe.needsUpdate = C, L.directionalLights.needsUpdate = C, L.directionalLightShadows.needsUpdate = C, L.pointLights.needsUpdate = C, L.pointLightShadows.needsUpdate = C, L.spotLights.needsUpdate = C, L.spotLightShadows.needsUpdate = C, L.rectAreaLights.needsUpdate = C, L.hemisphereLights.needsUpdate = C), s && i.fog && at.refreshFogUniforms(T, s), at.refreshMaterialUniforms(T, i, N, I, k), us.upload(xt, g.uniformsList, T, $)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (us.upload(xt, g.uniformsList, T, $), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && S.setValue(xt, "center", r.center), S.setValue(xt, "modelViewMatrix", r.modelViewMatrix), S.setValue(xt, "normalMatrix", r.normalMatrix), S.setValue(xt, "modelMatrix", r.matrixWorld), _
+                                var L, D;
+                                return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || mt.update(r, n, i, _), (b || f.receiveShadow !== r.receiveShadow) && (f.receiveShadow = r.receiveShadow, A.setValue(Mt, "receiveShadow", r.receiveShadow)), b && (A.setValue(Mt, "toneMappingExposure", y.toneMappingExposure), f.needsLights && (D = T, (L = R).ambientLightColor.needsUpdate = D, L.lightProbe.needsUpdate = D, L.directionalLights.needsUpdate = D, L.directionalLightShadows.needsUpdate = D, L.pointLights.needsUpdate = D, L.pointLightShadows.needsUpdate = D, L.spotLights.needsUpdate = D, L.spotLightShadows.needsUpdate = D, L.rectAreaLights.needsUpdate = D, L.hemisphereLights.needsUpdate = D), s && i.fog && rt.refreshFogUniforms(R, s), rt.refreshMaterialUniforms(R, i, P, C, H), wa.upload(Mt, f.uniformsList, R, K)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (wa.upload(Mt, f.uniformsList, R, K), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && A.setValue(Mt, "center", r.center), A.setValue(Mt, "modelViewMatrix", r.modelViewMatrix), A.setValue(Mt, "normalMatrix", r.normalMatrix), A.setValue(Mt, "modelMatrix", r.matrixWorld), _
                             }(t, e, n, i, r);
-                        J.setMaterial(i, a);
+                        Y.setMaterial(i, a);
                         let l = n.index;
                         const c = n.attributes.position;
                         if (null === l) {
                             if (void 0 === c || 0 === c.count) return
                         } else if (0 === l.count) return;
                         let h, u = 1;
-                        !0 === i.wireframe && (l = it.getWireframeAttribute(n), u = 2), vt.setup(r, i, o, n, l);
-                        let d = mt;
-                        null !== l && (h = nt.get(l), d = ft, d.setIndex(h));
-                        const m = null !== l ? l.count : c.count,
-                            f = n.drawRange.start * u,
-                            g = n.drawRange.count * u,
-                            x = null !== s ? s.start * u : 0,
-                            y = null !== s ? s.count * u : 1 / 0,
-                            _ = Math.max(f, x),
-                            M = Math.min(m, f + g, x + y) - 1,
+                        !0 === i.wireframe && (l = et.getWireframeAttribute(n), u = 2), xt.setup(r, i, o, n, l);
+                        let d = ft;
+                        null !== l && (h = tt.get(l), d = gt, d.setIndex(h));
+                        const p = null !== l ? l.count : c.count,
+                            m = n.drawRange.start * u,
+                            f = n.drawRange.count * u,
+                            v = null !== s ? s.start * u : 0,
+                            x = null !== s ? s.count * u : 1 / 0,
+                            _ = Math.max(m, v),
+                            M = Math.min(p, m + f, v + x) - 1,
                             b = Math.max(0, M - _ + 1);
                         if (0 !== b) {
-                            if (r.isMesh) !0 === i.wireframe ? (J.setLineWidth(i.wireframeLinewidth * q()), d.setMode(xt.LINES)) : d.setMode(xt.TRIANGLES);
+                            if (r.isMesh) !0 === i.wireframe ? (Y.setLineWidth(i.wireframeLinewidth * W()), d.setMode(Mt.LINES)) : d.setMode(Mt.TRIANGLES);
                             else if (r.isLine) {
                                 let t = i.linewidth;
-                                void 0 === t && (t = 1), J.setLineWidth(t * q()), r.isLineSegments ? d.setMode(xt.LINES) : r.isLineLoop ? d.setMode(xt.LINE_LOOP) : d.setMode(xt.LINE_STRIP)
-                            } else r.isPoints ? d.setMode(xt.POINTS) : r.isSprite && d.setMode(xt.TRIANGLES);
+                                void 0 === t && (t = 1), Y.setLineWidth(t * W()), r.isLineSegments ? d.setMode(Mt.LINES) : r.isLineLoop ? d.setMode(Mt.LINE_LOOP) : d.setMode(Mt.LINE_STRIP)
+                            } else r.isPoints ? d.setMode(Mt.POINTS) : r.isSprite && d.setMode(Mt.TRIANGLES);
                             if (r.isInstancedMesh) d.renderInstances(_, b, r.count);
                             else if (n.isInstancedBufferGeometry) {
                                 const t = Math.min(n.instanceCount, n._maxInstanceCount);
                                 d.renderInstances(_, b, t)
                             } else d.render(_, b)
                         }
                     }, this.compile = function(t, e) {
-                        p = ct.get(t), p.init(), g.push(p), t.traverseVisible((function(t) {
-                            t.isLight && t.layers.test(e.layers) && (p.pushLight(t), t.castShadow && p.pushShadow(t))
-                        })), p.setupLights(v.physicallyCorrectLights), t.traverse((function(e) {
+                        g = lt.get(t), g.init(), x.push(g), t.traverseVisible((function(t) {
+                            t.isLight && t.layers.test(e.layers) && (g.pushLight(t), t.castShadow && g.pushShadow(t))
+                        })), g.setupLights(y.physicallyCorrectLights), t.traverse((function(e) {
                             const n = e.material;
                             if (n)
                                 if (Array.isArray(n))
-                                    for (let i = 0; i < n.length; i++) Nt(n[i], t, e);
-                                else Nt(n, t, e)
-                        })), g.pop(), p = null
+                                    for (let i = 0; i < n.length; i++) Bt(n[i], t, e);
+                                else Bt(n, t, e)
+                        })), x.pop(), g = null
                     };
-                    let Et = null;
+                    let Lt = null;
 
-                    function Tt() {
-                        Rt.stop()
+                    function Ct() {
+                        Dt.stop()
                     }
 
-                    function At() {
-                        Rt.start()
+                    function Pt() {
+                        Dt.start()
                     }
-                    const Rt = new xi;
+                    const Dt = new Rr;
 
-                    function Lt(t, e, n, i) {
+                    function It(t, e, n, i) {
                         if (!1 === t.visible) return;
                         if (t.layers.test(e.layers))
                             if (t.isGroup) n = t.renderOrder;
                             else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
-                        else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t);
+                        else if (t.isLight) g.pushLight(t), t.castShadow && g.pushShadow(t);
                         else if (t.isSprite) {
-                            if (!t.frustumCulled || H.intersectsSprite(t)) {
-                                i && j.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W);
-                                const e = rt.update(t),
+                            if (!t.frustumCulled || B.intersectsSprite(t)) {
+                                i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
+                                const e = nt.update(t),
                                     r = t.material;
-                                r.visible && u.push(t, e, r, n, j.z, null)
+                                r.visible && f.push(t, e, r, n, V.z, null)
                             }
-                        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== K.render.frame && (t.skeleton.update(), t.skeleton.frame = K.render.frame), !t.frustumCulled || H.intersectsObject(t))) {
-                            i && j.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W);
-                            const e = rt.update(t),
+                        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Z.render.frame && (t.skeleton.update(), t.skeleton.frame = Z.render.frame), !t.frustumCulled || B.intersectsObject(t))) {
+                            i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
+                            const e = nt.update(t),
                                 r = t.material;
                             if (Array.isArray(r)) {
                                 const i = e.groups;
                                 for (let s = 0, a = i.length; s < a; s++) {
                                     const a = i[s],
                                         o = r[a.materialIndex];
-                                    o && o.visible && u.push(t, e, o, n, j.z, a)
+                                    o && o.visible && f.push(t, e, o, n, V.z, a)
                                 }
-                            } else r.visible && u.push(t, e, r, n, j.z, null)
+                            } else r.visible && f.push(t, e, r, n, V.z, null)
                         }
                         const r = t.children;
-                        for (let t = 0, s = r.length; t < s; t++) Lt(r[t], e, n, i)
+                        for (let t = 0, s = r.length; t < s; t++) It(r[t], e, n, i)
                     }
 
-                    function Ct(t, e, n, i) {
+                    function Nt(t, e, n, i) {
                         const r = t.opaque,
                             s = t.transmissive,
-                            o = t.transparent;
-                        p.setupLightsView(n), s.length > 0 && function(t, e, n) {
-                            if (null === k) {
-                                const t = !0 === a && !0 === Z.isWebGL2;
-                                k = new(t ? Yt : Xt)(1024, 1024, {
+                            a = t.transparent;
+                        g.setupLightsView(n), s.length > 0 && function(t, e, n) {
+                            if (null === H) {
+                                const t = !0 === o && !0 === q.isWebGL2;
+                                H = new(t ? sn : nn)(1024, 1024, {
                                     generateMipmaps: !0,
-                                    type: null !== gt.convert(S) ? S : _,
-                                    minFilter: y,
-                                    magFilter: m,
-                                    wrapS: d,
-                                    wrapT: d,
-                                    useRenderToTexture: Y.has("WEBGL_multisampled_render_to_texture")
+                                    type: null !== vt.convert(_t) ? _t : pt,
+                                    minFilter: dt,
+                                    magFilter: ot,
+                                    wrapS: st,
+                                    wrapT: st,
+                                    useRenderToTexture: X.has("WEBGL_multisampled_render_to_texture")
                                 })
                             }
-                            const i = v.getRenderTarget();
-                            v.setRenderTarget(k), v.clear();
-                            const r = v.toneMapping;
-                            v.toneMapping = 0, Pt(t, e, n), v.toneMapping = r, $.updateMultisampleRenderTarget(k), $.updateRenderTargetMipmap(k), v.setRenderTarget(i)
-                        }(r, e, n), i && J.viewport(L.copy(i)), r.length > 0 && Pt(r, e, n), s.length > 0 && Pt(s, e, n), o.length > 0 && Pt(o, e, n)
+                            const i = y.getRenderTarget();
+                            y.setRenderTarget(H), y.clear();
+                            const r = y.toneMapping;
+                            y.toneMapping = j, Ot(t, e, n), y.toneMapping = r, K.updateMultisampleRenderTarget(H), K.updateRenderTargetMipmap(H), y.setRenderTarget(i)
+                        }(r, e, n), i && Y.viewport(T.copy(i)), r.length > 0 && Ot(r, e, n), s.length > 0 && Ot(s, e, n), a.length > 0 && Ot(a, e, n)
                     }
 
-                    function Pt(t, e, n) {
+                    function Ot(t, e, n) {
                         const i = !0 === e.isScene ? e.overrideMaterial : null;
                         for (let r = 0, s = t.length; r < s; r++) {
                             const s = t[r],
                                 a = s.object,
                                 o = s.geometry,
                                 l = null === i ? s.material : i,
                                 c = s.group;
-                            a.layers.test(n.layers) && It(a, e, n, o, l, c)
+                            a.layers.test(n.layers) && Ut(a, e, n, o, l, c)
                         }
                     }
 
-                    function It(t, e, n, i, r, s) {
-                        t.onBeforeRender(v, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(v, e, n, i, t, s), !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, v.renderBufferDirect(n, e, i, r, t, s), r.side = 0, r.needsUpdate = !0, v.renderBufferDirect(n, e, i, r, t, s), r.side = 2) : v.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(v, e, n, i, r, s)
+                    function Ut(t, e, n, i, r, s) {
+                        t.onBeforeRender(y, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(y, e, n, i, t, s), !0 === r.transparent && r.side === u ? (r.side = h, r.needsUpdate = !0, y.renderBufferDirect(n, e, i, r, t, s), r.side = c, r.needsUpdate = !0, y.renderBufferDirect(n, e, i, r, t, s), r.side = u) : y.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(y, e, n, i, r, s)
                     }
 
-                    function Nt(t, e, n) {
-                        !0 !== e.isScene && (e = X);
-                        const i = Q.get(t),
-                            r = p.state.lights,
-                            s = p.state.shadowsArray,
+                    function Bt(t, e, n) {
+                        !0 !== e.isScene && (e = k);
+                        const i = J.get(t),
+                            r = g.state.lights,
+                            s = g.state.shadowsArray,
                             a = r.state.version,
-                            o = st.getParameters(t, r.state, s, e, n),
-                            l = st.getProgramCacheKey(o);
+                            o = it.getParameters(t, r.state, s, e, n),
+                            l = it.getProgramCacheKey(o);
                         let c = i.programs;
-                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? et : tt).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", St), c = new Map, i.programs = c);
+                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? $ : Q).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", Rt), c = new Map, i.programs = c);
                         let h = c.get(l);
                         if (void 0 !== h) {
-                            if (i.currentProgram === h && i.lightsStateVersion === a) return Ot(t, o), h
-                        } else o.uniforms = st.getUniforms(t), t.onBuild(n, o, v), t.onBeforeCompile(o, v), h = st.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
+                            if (i.currentProgram === h && i.lightsStateVersion === a) return Ft(t, o), h
+                        } else o.uniforms = it.getUniforms(t), t.onBuild(n, o, y), t.onBeforeCompile(o, y), h = it.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
                         const u = i.uniforms;
-                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = ht.uniform), Ot(t, o), i.needsLights = function(t) {
+                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = ct.uniform), Ft(t, o), i.needsLights = function(t) {
                             return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                         }(t), i.lightsStateVersion = a, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                         const d = h.getUniforms(),
-                            m = us.seqWithValue(d.seq, u);
-                        return i.currentProgram = h, i.uniformsList = m, h
+                            p = wa.seqWithValue(d.seq, u);
+                        return i.currentProgram = h, i.uniformsList = p, h
                     }
 
-                    function Ot(t, e) {
-                        const n = Q.get(t);
+                    function Ft(t, e) {
+                        const n = J.get(t);
                         n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
                     }
-                    Rt.setAnimationLoop((function(t) {
-                        Et && Et(t)
-                    })), "undefined" != typeof window && Rt.setContext(window), this.setAnimationLoop = function(t) {
-                        Et = t, Mt.setAnimationLoop(t), null === t ? Rt.stop() : Rt.start()
-                    }, Mt.addEventListener("sessionstart", Tt), Mt.addEventListener("sessionend", At), this.render = function(t, e) {
+                    Dt.setAnimationLoop((function(t) {
+                        Lt && Lt(t)
+                    })), "undefined" != typeof window && Dt.setContext(window), this.setAnimationLoop = function(t) {
+                        Lt = t, St.setAnimationLoop(t), null === t ? Dt.stop() : Dt.start()
+                    }, St.addEventListener("sessionstart", Ct), St.addEventListener("sessionend", Pt), this.render = function(t, e) {
                         if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
-                        if (!0 === x) return;
-                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === Mt.enabled && !0 === Mt.isPresenting && (!0 === Mt.cameraAutoUpdate && Mt.updateCamera(e), e = Mt.getCamera()), !0 === t.isScene && t.onBeforeRender(v, t, e, E), p = ct.get(t, g.length), p.init(), g.push(p), W.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), H.setFromProjectionMatrix(W), V = this.localClippingEnabled, G = ht.init(this.clippingPlanes, V, e), u = lt.get(t, f.length), u.init(), f.push(u), Lt(t, e, 0, v.sortObjects), u.finish(), !0 === v.sortObjects && u.sort(O, U), !0 === G && ht.beginShadows();
-                        const n = p.state.shadowsArray;
-                        if (ut.render(n, t, e), !0 === G && ht.endShadows(), !0 === this.info.autoReset && this.info.reset(), dt.render(u, t), p.setupLights(v.physicallyCorrectLights), e.isArrayCamera) {
+                        if (!0 === _) return;
+                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === St.enabled && !0 === St.isPresenting && (!0 === St.cameraAutoUpdate && St.updateCamera(e), e = St.getCamera()), !0 === t.isScene && t.onBeforeRender(y, t, e, w), g = lt.get(t, x.length), g.init(), x.push(g), G.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), B.setFromProjectionMatrix(G), z = this.localClippingEnabled, F = ct.init(this.clippingPlanes, z, e), f = at.get(t, v.length), f.init(), v.push(f), It(t, e, 0, y.sortObjects), f.finish(), !0 === y.sortObjects && f.sort(D, I), !0 === F && ct.beginShadows();
+                        const n = g.state.shadowsArray;
+                        if (ht.render(n, t, e), !0 === F && ct.endShadows(), !0 === this.info.autoReset && this.info.reset(), ut.render(f, t), g.setupLights(y.physicallyCorrectLights), e.isArrayCamera) {
                             const n = e.cameras;
                             for (let e = 0, i = n.length; e < i; e++) {
                                 const i = n[e];
-                                Ct(u, t, i, i.viewport)
+                                Nt(f, t, i, i.viewport)
                             }
-                        } else Ct(u, t, e);
-                        null !== E && ($.updateMultisampleRenderTarget(E), $.updateRenderTargetMipmap(E)), !0 === t.isScene && t.onAfterRender(v, t, e), J.buffers.depth.setTest(!0), J.buffers.depth.setMask(!0), J.buffers.color.setMask(!0), J.setPolygonOffset(!1), vt.resetDefaultState(), A = -1, R = null, g.pop(), p = g.length > 0 ? g[g.length - 1] : null, f.pop(), u = f.length > 0 ? f[f.length - 1] : null
+                        } else Nt(f, t, e);
+                        null !== w && (K.updateMultisampleRenderTarget(w), K.updateRenderTargetMipmap(w)), !0 === t.isScene && t.onAfterRender(y, t, e), Y.buffers.depth.setTest(!0), Y.buffers.depth.setMask(!0), Y.buffers.color.setMask(!0), Y.setPolygonOffset(!1), xt.resetDefaultState(), S = -1, E = null, x.pop(), g = x.length > 0 ? x[x.length - 1] : null, v.pop(), f = v.length > 0 ? v[v.length - 1] : null
                     }, this.getActiveCubeFace = function() {
                         return M
                     }, this.getActiveMipmapLevel = function() {
                         return b
                     }, this.getRenderTarget = function() {
-                        return E
+                        return w
                     }, this.setRenderTargetTextures = function(t, e, n) {
-                        Q.get(t.texture).__webglTexture = e, Q.get(t.depthTexture).__webglTexture = n;
-                        const i = Q.get(t);
+                        J.get(t.texture).__webglTexture = e, J.get(t.depthTexture).__webglTexture = n;
+                        const i = J.get(t);
                         i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || t.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), t.useRenderToTexture = !1, t.useRenderbuffer = !0))
                     }, this.setRenderTargetFramebuffer = function(t, e) {
-                        const n = Q.get(t);
+                        const n = J.get(t);
                         n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
                     }, this.setRenderTarget = function(t, e = 0, n = 0) {
-                        E = t, M = e, b = n;
+                        w = t, M = e, b = n;
                         let i = !0;
                         if (t) {
-                            const e = Q.get(t);
-                            void 0 !== e.__useDefaultFramebuffer ? (J.bindFramebuffer(xt.FRAMEBUFFER, null), i = !1) : void 0 === e.__webglFramebuffer ? $.setupRenderTarget(t) : e.__hasExternalTextures && $.rebindTextures(t, Q.get(t.texture).__webglTexture, Q.get(t.depthTexture).__webglTexture)
+                            const e = J.get(t);
+                            void 0 !== e.__useDefaultFramebuffer ? (Y.bindFramebuffer(Mt.FRAMEBUFFER, null), i = !1) : void 0 === e.__webglFramebuffer ? K.setupRenderTarget(t) : e.__hasExternalTextures && K.rebindTextures(t, J.get(t.texture).__webglTexture, J.get(t.depthTexture).__webglTexture)
                         }
                         let r = null,
                             s = !1,
                             a = !1;
                         if (t) {
                             const n = t.texture;
                             (n.isDataTexture3D || n.isDataTexture2DArray) && (a = !0);
-                            const i = Q.get(t).__webglFramebuffer;
-                            t.isWebGLCubeRenderTarget ? (r = i[e], s = !0) : r = t.useRenderbuffer ? Q.get(t).__webglMultisampledFramebuffer : i, L.copy(t.viewport), C.copy(t.scissor), P = t.scissorTest
-                        } else L.copy(B).multiplyScalar(N).floor(), C.copy(F).multiplyScalar(N).floor(), P = z;
-                        if (J.bindFramebuffer(xt.FRAMEBUFFER, r) && Z.drawBuffers && i && J.drawBuffers(t, r), J.viewport(L), J.scissor(C), J.setScissorTest(P), s) {
-                            const i = Q.get(t.texture);
-                            xt.framebufferTexture2D(xt.FRAMEBUFFER, xt.COLOR_ATTACHMENT0, xt.TEXTURE_CUBE_MAP_POSITIVE_X + e, i.__webglTexture, n)
+                            const i = J.get(t).__webglFramebuffer;
+                            t.isWebGLCubeRenderTarget ? (r = i[e], s = !0) : r = t.useRenderbuffer ? J.get(t).__webglMultisampledFramebuffer : i, T.copy(t.viewport), A.copy(t.scissor), R = t.scissorTest
+                        } else T.copy(N).multiplyScalar(P).floor(), A.copy(O).multiplyScalar(P).floor(), R = U;
+                        if (Y.bindFramebuffer(Mt.FRAMEBUFFER, r) && q.drawBuffers && i && Y.drawBuffers(t, r), Y.viewport(T), Y.scissor(A), Y.setScissorTest(R), s) {
+                            const i = J.get(t.texture);
+                            Mt.framebufferTexture2D(Mt.FRAMEBUFFER, Mt.COLOR_ATTACHMENT0, Mt.TEXTURE_CUBE_MAP_POSITIVE_X + e, i.__webglTexture, n)
                         } else if (a) {
-                            const i = Q.get(t.texture),
+                            const i = J.get(t.texture),
                                 r = e || 0;
-                            xt.framebufferTextureLayer(xt.FRAMEBUFFER, xt.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
+                            Mt.framebufferTextureLayer(Mt.FRAMEBUFFER, Mt.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                         }
-                        A = -1
+                        S = -1
                     }, this.readRenderTargetPixels = function(t, e, n, i, r, s, a) {
                         if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
-                        let o = Q.get(t).__webglFramebuffer;
+                        let o = J.get(t).__webglFramebuffer;
                         if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
-                            J.bindFramebuffer(xt.FRAMEBUFFER, o);
+                            Y.bindFramebuffer(Mt.FRAMEBUFFER, o);
                             try {
                                 const a = t.texture,
                                     o = a.format,
                                     l = a.type;
-                                if (o !== T && gt.convert(o) !== xt.getParameter(xt.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
-                                const c = l === S && (Y.has("EXT_color_buffer_half_float") || Z.isWebGL2 && Y.has("EXT_color_buffer_float"));
-                                if (!(l === _ || gt.convert(l) === xt.getParameter(xt.IMPLEMENTATION_COLOR_READ_TYPE) || l === w && (Z.isWebGL2 || Y.has("OES_texture_float") || Y.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
-                                xt.checkFramebufferStatus(xt.FRAMEBUFFER) === xt.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && xt.readPixels(e, n, i, r, gt.convert(o), gt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
+                                if (o !== Et && vt.convert(o) !== Mt.getParameter(Mt.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
+                                const c = l === _t && (X.has("EXT_color_buffer_half_float") || q.isWebGL2 && X.has("EXT_color_buffer_float"));
+                                if (!(l === pt || vt.convert(l) === Mt.getParameter(Mt.IMPLEMENTATION_COLOR_READ_TYPE) || l === yt && (q.isWebGL2 || X.has("OES_texture_float") || X.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
+                                Mt.checkFramebufferStatus(Mt.FRAMEBUFFER) === Mt.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && Mt.readPixels(e, n, i, r, vt.convert(o), vt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                             } finally {
-                                const t = null !== E ? Q.get(E).__webglFramebuffer : null;
-                                J.bindFramebuffer(xt.FRAMEBUFFER, t)
+                                const t = null !== w ? J.get(w).__webglFramebuffer : null;
+                                Y.bindFramebuffer(Mt.FRAMEBUFFER, t)
                             }
                         }
                     }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                         if (!0 !== e.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
                         const i = Math.pow(2, -n),
                             r = Math.floor(e.image.width * i),
                             s = Math.floor(e.image.height * i);
-                        $.setTexture2D(e, 0), xt.copyTexSubImage2D(xt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s), J.unbindTexture()
+                        K.setTexture2D(e, 0), Mt.copyTexSubImage2D(Mt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s), Y.unbindTexture()
                     }, this.copyTextureToTexture = function(t, e, n, i = 0) {
                         const r = e.image.width,
                             s = e.image.height,
-                            a = gt.convert(n.format),
-                            o = gt.convert(n.type);
-                        $.setTexture2D(n, 0), xt.pixelStorei(xt.UNPACK_FLIP_Y_WEBGL, n.flipY), xt.pixelStorei(xt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), xt.pixelStorei(xt.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? xt.texSubImage2D(xt.TEXTURE_2D, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? xt.compressedTexSubImage2D(xt.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : xt.texSubImage2D(xt.TEXTURE_2D, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && xt.generateMipmap(xt.TEXTURE_2D), J.unbindTexture()
+                            a = vt.convert(n.format),
+                            o = vt.convert(n.type);
+                        K.setTexture2D(n, 0), Mt.pixelStorei(Mt.UNPACK_FLIP_Y_WEBGL, n.flipY), Mt.pixelStorei(Mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), Mt.pixelStorei(Mt.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? Mt.texSubImage2D(Mt.TEXTURE_2D, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? Mt.compressedTexSubImage2D(Mt.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : Mt.texSubImage2D(Mt.TEXTURE_2D, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && Mt.generateMipmap(Mt.TEXTURE_2D), Y.unbindTexture()
                     }, this.copyTextureToTexture3D = function(t, e, n, i, r = 0) {
-                        if (v.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
+                        if (y.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                         const s = t.max.x - t.min.x + 1,
                             a = t.max.y - t.min.y + 1,
                             o = t.max.z - t.min.z + 1,
-                            l = gt.convert(i.format),
-                            c = gt.convert(i.type);
+                            l = vt.convert(i.format),
+                            c = vt.convert(i.type);
                         let h;
-                        if (i.isDataTexture3D) $.setTexture3D(i, 0), h = xt.TEXTURE_3D;
+                        if (i.isDataTexture3D) K.setTexture3D(i, 0), h = Mt.TEXTURE_3D;
                         else {
                             if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
-                            $.setTexture2DArray(i, 0), h = xt.TEXTURE_2D_ARRAY
+                            K.setTexture2DArray(i, 0), h = Mt.TEXTURE_2D_ARRAY
                         }
-                        xt.pixelStorei(xt.UNPACK_FLIP_Y_WEBGL, i.flipY), xt.pixelStorei(xt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), xt.pixelStorei(xt.UNPACK_ALIGNMENT, i.unpackAlignment);
-                        const u = xt.getParameter(xt.UNPACK_ROW_LENGTH),
-                            d = xt.getParameter(xt.UNPACK_IMAGE_HEIGHT),
-                            p = xt.getParameter(xt.UNPACK_SKIP_PIXELS),
-                            m = xt.getParameter(xt.UNPACK_SKIP_ROWS),
-                            f = xt.getParameter(xt.UNPACK_SKIP_IMAGES),
+                        Mt.pixelStorei(Mt.UNPACK_FLIP_Y_WEBGL, i.flipY), Mt.pixelStorei(Mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), Mt.pixelStorei(Mt.UNPACK_ALIGNMENT, i.unpackAlignment);
+                        const u = Mt.getParameter(Mt.UNPACK_ROW_LENGTH),
+                            d = Mt.getParameter(Mt.UNPACK_IMAGE_HEIGHT),
+                            p = Mt.getParameter(Mt.UNPACK_SKIP_PIXELS),
+                            m = Mt.getParameter(Mt.UNPACK_SKIP_ROWS),
+                            f = Mt.getParameter(Mt.UNPACK_SKIP_IMAGES),
                             g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
-                        xt.pixelStorei(xt.UNPACK_ROW_LENGTH, g.width), xt.pixelStorei(xt.UNPACK_IMAGE_HEIGHT, g.height), xt.pixelStorei(xt.UNPACK_SKIP_PIXELS, t.min.x), xt.pixelStorei(xt.UNPACK_SKIP_ROWS, t.min.y), xt.pixelStorei(xt.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isDataTexture3D ? xt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), xt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data)) : xt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g), xt.pixelStorei(xt.UNPACK_ROW_LENGTH, u), xt.pixelStorei(xt.UNPACK_IMAGE_HEIGHT, d), xt.pixelStorei(xt.UNPACK_SKIP_PIXELS, p), xt.pixelStorei(xt.UNPACK_SKIP_ROWS, m), xt.pixelStorei(xt.UNPACK_SKIP_IMAGES, f), 0 === r && i.generateMipmaps && xt.generateMipmap(h), J.unbindTexture()
+                        Mt.pixelStorei(Mt.UNPACK_ROW_LENGTH, g.width), Mt.pixelStorei(Mt.UNPACK_IMAGE_HEIGHT, g.height), Mt.pixelStorei(Mt.UNPACK_SKIP_PIXELS, t.min.x), Mt.pixelStorei(Mt.UNPACK_SKIP_ROWS, t.min.y), Mt.pixelStorei(Mt.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isDataTexture3D ? Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Mt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data)) : Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g), Mt.pixelStorei(Mt.UNPACK_ROW_LENGTH, u), Mt.pixelStorei(Mt.UNPACK_IMAGE_HEIGHT, d), Mt.pixelStorei(Mt.UNPACK_SKIP_PIXELS, p), Mt.pixelStorei(Mt.UNPACK_SKIP_ROWS, m), Mt.pixelStorei(Mt.UNPACK_SKIP_IMAGES, f), 0 === r && i.generateMipmaps && Mt.generateMipmap(h), Y.unbindTexture()
                     }, this.initTexture = function(t) {
-                        $.setTexture2D(t, 0), J.unbindTexture()
+                        K.setTexture2D(t, 0), Y.unbindTexture()
                     }, this.resetState = function() {
-                        M = 0, b = 0, E = null, J.reset(), vt.reset()
+                        M = 0, b = 0, w = null, Y.reset(), xt.reset()
                     }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                         detail: this
                     }))
                 }
-                ra.prototype.isWebGLRenderer = !0;
-                class sa extends ra {}
-                sa.prototype.isWebGL1Renderer = !0;
-                class aa {
+                yo.prototype.isWebGLRenderer = !0;
+                class _o extends yo {}
+                _o.prototype.isWebGL1Renderer = !0;
+                class Mo {
                     constructor(t, e = 25e-5) {
-                        this.name = "", this.color = new zt(t), this.density = e
+                        this.name = "", this.color = new Ze(t), this.density = e
                     }
                     clone() {
-                        return new aa(this.color, this.density)
+                        return new Mo(this.color, this.density)
                     }
                     toJSON() {
                         return {
                             type: "FogExp2",
                             color: this.color.getHex(),
                             density: this.density
                         }
                     }
                 }
-                aa.prototype.isFogExp2 = !0;
-                class oa {
+                Mo.prototype.isFogExp2 = !0;
+                class bo {
                     constructor(t, e = 1, n = 1e3) {
-                        this.name = "", this.color = new zt(t), this.near = e, this.far = n
+                        this.name = "", this.color = new Ze(t), this.near = e, this.far = n
                     }
                     clone() {
-                        return new oa(this.color, this.near, this.far)
+                        return new bo(this.color, this.near, this.far)
                     }
                     toJSON() {
                         return {
                             type: "Fog",
                             color: this.color.getHex(),
                             near: this.near,
                             far: this.far
                         }
                     }
                 }
-                oa.prototype.isFog = !0;
-                class la extends Qe {
+                bo.prototype.isFog = !0;
+                class wo extends ci {
                     constructor() {
                         super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                             detail: this
                         }))
                     }
                     copy(t, e) {
                         return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                     }
                 }
-                la.prototype.isScene = !0;
-                class ca {
+                wo.prototype.isScene = !0;
+                class So {
                     constructor(t, e) {
-                        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = ht, this.updateRange = {
+                        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = _e, this.updateRange = {
                             offset: 0,
                             count: -1
-                        }, this.version = 0, this.uuid = yt()
+                        }, this.version = 0, this.uuid = Le()
                     }
                     onUploadCallback() {}
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                     setUsage(t) {
                         return this.usage = t, this
@@ -9303,56 +9671,56 @@
                         for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                         return this
                     }
                     set(t, e = 0) {
                         return this.array.set(t, e), this
                     }
                     clone(t) {
-                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = yt()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
+                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Le()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                         const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                             n = new this.constructor(e, this.stride);
                         return n.setUsage(this.usage), n
                     }
                     onUpload(t) {
                         return this.onUploadCallback = t, this
                     }
                     toJSON(t) {
-                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = yt()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
+                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Le()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                             uuid: this.uuid,
                             buffer: this.array.buffer._uuid,
                             type: this.array.constructor.name,
                             stride: this.stride
                         }
                     }
                 }
-                ca.prototype.isInterleavedBuffer = !0;
-                const ha = new Jt;
-                class ua {
+                So.prototype.isInterleavedBuffer = !0;
+                const Eo = new on;
+                class To {
                     constructor(t, e, n, i = !1) {
                         this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
                     }
                     get count() {
                         return this.data.count
                     }
                     get array() {
                         return this.data.array
                     }
                     set needsUpdate(t) {
                         this.data.needsUpdate = t
                     }
                     applyMatrix4(t) {
-                        for (let e = 0, n = this.data.count; e < n; e++) ha.x = this.getX(e), ha.y = this.getY(e), ha.z = this.getZ(e), ha.applyMatrix4(t), this.setXYZ(e, ha.x, ha.y, ha.z);
+                        for (let e = 0, n = this.data.count; e < n; e++) Eo.x = this.getX(e), Eo.y = this.getY(e), Eo.z = this.getZ(e), Eo.applyMatrix4(t), this.setXYZ(e, Eo.x, Eo.y, Eo.z);
                         return this
                     }
                     applyNormalMatrix(t) {
-                        for (let e = 0, n = this.count; e < n; e++) ha.x = this.getX(e), ha.y = this.getY(e), ha.z = this.getZ(e), ha.applyNormalMatrix(t), this.setXYZ(e, ha.x, ha.y, ha.z);
+                        for (let e = 0, n = this.count; e < n; e++) Eo.x = this.getX(e), Eo.y = this.getY(e), Eo.z = this.getZ(e), Eo.applyNormalMatrix(t), this.setXYZ(e, Eo.x, Eo.y, Eo.z);
                         return this
                     }
                     transformDirection(t) {
-                        for (let e = 0, n = this.count; e < n; e++) ha.x = this.getX(e), ha.y = this.getY(e), ha.z = this.getZ(e), ha.transformDirection(t), this.setXYZ(e, ha.x, ha.y, ha.z);
+                        for (let e = 0, n = this.count; e < n; e++) Eo.x = this.getX(e), Eo.y = this.getY(e), Eo.z = this.getZ(e), Eo.transformDirection(t), this.setXYZ(e, Eo.x, Eo.y, Eo.z);
                         return this
                     }
                     setX(t, e) {
                         return this.data.array[t * this.data.stride + this.offset] = e, this
                     }
                     setY(t, e) {
                         return this.data.array[t * this.data.stride + this.offset + 1] = e, this
@@ -9388,17 +9756,17 @@
                         if (void 0 === t) {
                             console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                             const t = [];
                             for (let e = 0; e < this.count; e++) {
                                 const n = e * this.data.stride + this.offset;
                                 for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                             }
-                            return new gn(new this.array.constructor(t), this.itemSize, this.normalized)
+                            return new Ti(new this.array.constructor(t), this.itemSize, this.normalized)
                         }
-                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ua(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
+                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new To(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                     }
                     toJSON(t) {
                         if (void 0 === t) {
                             console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                             const t = [];
                             for (let e = 0; e < this.count; e++) {
                                 const n = e * this.data.stride + this.offset;
@@ -9416,77 +9784,77 @@
                             itemSize: this.itemSize,
                             data: this.data.uuid,
                             offset: this.offset,
                             normalized: this.normalized
                         }
                     }
                 }
-                ua.prototype.isInterleavedBufferAttribute = !0;
-                class da extends dn {
+                To.prototype.isInterleavedBufferAttribute = !0;
+                class Ao extends bi {
                     constructor(t) {
-                        super(), this.type = "SpriteMaterial", this.color = new zt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
+                        super(), this.type = "SpriteMaterial", this.color = new Ze(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
                     }
                 }
-                let pa;
-                da.prototype.isSpriteMaterial = !0;
-                const ma = new Jt,
-                    fa = new Jt,
-                    ga = new Jt,
-                    va = new At,
-                    xa = new At,
-                    ya = new Ae,
-                    _a = new Jt,
-                    Ma = new Jt,
-                    ba = new Jt,
-                    wa = new At,
-                    Sa = new At,
-                    Ea = new At;
-                class Ta extends Qe {
+                let Ro;
+                Ao.prototype.isSpriteMaterial = !0;
+                const Lo = new on,
+                    Co = new on,
+                    Po = new on,
+                    Do = new Be,
+                    Io = new Be,
+                    No = new Fn,
+                    Oo = new on,
+                    Uo = new on,
+                    Bo = new on,
+                    Fo = new Be,
+                    zo = new Be,
+                    Ho = new Be;
+                class Go extends ci {
                     constructor(t) {
-                        if (super(), this.type = "Sprite", void 0 === pa) {
-                            pa = new Nn;
+                        if (super(), this.type = "Sprite", void 0 === Ro) {
+                            Ro = new Wi;
                             const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
-                                e = new ca(t, 5);
-                            pa.setIndex([0, 1, 2, 0, 2, 3]), pa.setAttribute("position", new ua(e, 3, 0, !1)), pa.setAttribute("uv", new ua(e, 2, 3, !1))
+                                e = new So(t, 5);
+                            Ro.setIndex([0, 1, 2, 0, 2, 3]), Ro.setAttribute("position", new To(e, 3, 0, !1)), Ro.setAttribute("uv", new To(e, 2, 3, !1))
                         }
-                        this.geometry = pa, this.material = void 0 !== t ? t : new da, this.center = new At(.5, .5)
+                        this.geometry = Ro, this.material = void 0 !== t ? t : new Ao, this.center = new Be(.5, .5)
                     }
                     raycast(t, e) {
-                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), fa.setFromMatrixScale(this.matrixWorld), ya.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ga.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && fa.multiplyScalar(-ga.z);
+                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Co.setFromMatrixScale(this.matrixWorld), No.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Po.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Co.multiplyScalar(-Po.z);
                         const n = this.material.rotation;
                         let i, r;
                         0 !== n && (r = Math.cos(n), i = Math.sin(n));
                         const s = this.center;
-                        Aa(_a.set(-.5, -.5, 0), ga, s, fa, i, r), Aa(Ma.set(.5, -.5, 0), ga, s, fa, i, r), Aa(ba.set(.5, .5, 0), ga, s, fa, i, r), wa.set(0, 0), Sa.set(1, 0), Ea.set(1, 1);
-                        let a = t.ray.intersectTriangle(_a, Ma, ba, !1, ma);
-                        if (null === a && (Aa(Ma.set(-.5, .5, 0), ga, s, fa, i, r), Sa.set(0, 1), a = t.ray.intersectTriangle(_a, ba, Ma, !1, ma), null === a)) return;
-                        const o = t.ray.origin.distanceTo(ma);
+                        Vo(Oo.set(-.5, -.5, 0), Po, s, Co, i, r), Vo(Uo.set(.5, -.5, 0), Po, s, Co, i, r), Vo(Bo.set(.5, .5, 0), Po, s, Co, i, r), Fo.set(0, 0), zo.set(1, 0), Ho.set(1, 1);
+                        let a = t.ray.intersectTriangle(Oo, Uo, Bo, !1, Lo);
+                        if (null === a && (Vo(Uo.set(-.5, .5, 0), Po, s, Co, i, r), zo.set(0, 1), a = t.ray.intersectTriangle(Oo, Bo, Uo, !1, Lo), null === a)) return;
+                        const o = t.ray.origin.distanceTo(Lo);
                         o < t.near || o > t.far || e.push({
                             distance: o,
-                            point: ma.clone(),
-                            uv: hn.getUV(ma, _a, Ma, ba, wa, Sa, Ea, new At),
+                            point: Lo.clone(),
+                            uv: _i.getUV(Lo, Oo, Uo, Bo, Fo, zo, Ho, new Be),
                             face: null,
                             object: this
                         })
                     }
                     copy(t) {
                         return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                     }
                 }
 
-                function Aa(t, e, n, i, r, s) {
-                    va.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (xa.x = s * va.x - r * va.y, xa.y = r * va.x + s * va.y) : xa.copy(va), t.copy(e), t.x += xa.x, t.y += xa.y, t.applyMatrix4(ya)
+                function Vo(t, e, n, i, r, s) {
+                    Do.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (Io.x = s * Do.x - r * Do.y, Io.y = r * Do.x + s * Do.y) : Io.copy(Do), t.copy(e), t.x += Io.x, t.y += Io.y, t.applyMatrix4(No)
                 }
-                Ta.prototype.isSprite = !0;
-                const Ra = new Jt,
-                    La = new Jt;
-                class Ca extends Qe {
+                Go.prototype.isSprite = !0;
+                const ko = new on,
+                    Wo = new on;
+                class jo extends ci {
                     constructor() {
                         super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                             levels: {
                                 enumerable: !0,
                                 value: []
                             },
                             isLOD: {
@@ -9523,24 +9891,24 @@
                             for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                             return e[n - 1].object
                         }
                         return null
                     }
                     raycast(t, e) {
                         if (this.levels.length > 0) {
-                            Ra.setFromMatrixPosition(this.matrixWorld);
-                            const n = t.ray.origin.distanceTo(Ra);
+                            ko.setFromMatrixPosition(this.matrixWorld);
+                            const n = t.ray.origin.distanceTo(ko);
                             this.getObjectForDistance(n).raycast(t, e)
                         }
                     }
                     update(t) {
                         const e = this.levels;
                         if (e.length > 1) {
-                            Ra.setFromMatrixPosition(t.matrixWorld), La.setFromMatrixPosition(this.matrixWorld);
-                            const n = Ra.distanceTo(La) / t.zoom;
+                            ko.setFromMatrixPosition(t.matrixWorld), Wo.setFromMatrixPosition(this.matrixWorld);
+                            const n = ko.distanceTo(Wo) / t.zoom;
                             let i, r;
                             for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                             for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1
                         }
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
@@ -9552,94 +9920,94 @@
                                 object: i.object.uuid,
                                 distance: i.distance
                             })
                         }
                         return e
                     }
                 }
-                const Pa = new Jt,
-                    Da = new jt,
-                    Ia = new jt,
-                    Na = new Jt,
-                    Oa = new Ae;
-                class Ua extends Qn {
+                const Xo = new on,
+                    qo = new en,
+                    Yo = new en,
+                    Zo = new on,
+                    Jo = new Fn;
+                class Ko extends lr {
                     constructor(t, e) {
-                        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ae, this.bindMatrixInverse = new Ae
+                        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Fn, this.bindMatrixInverse = new Fn
                     }
                     copy(t) {
                         return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                     }
                     bind(t, e) {
                         this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                     }
                     pose() {
                         this.skeleton.pose()
                     }
                     normalizeSkinWeights() {
-                        const t = new jt,
+                        const t = new en,
                             e = this.geometry.attributes.skinWeight;
                         for (let n = 0, i = e.count; n < i; n++) {
                             t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                             const i = 1 / t.manhattanLength();
                             i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                         }
                     }
                     updateMatrixWorld(t) {
                         super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                     }
                     boneTransform(t, e) {
                         const n = this.skeleton,
                             i = this.geometry;
-                        Da.fromBufferAttribute(i.attributes.skinIndex, t), Ia.fromBufferAttribute(i.attributes.skinWeight, t), Pa.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
+                        qo.fromBufferAttribute(i.attributes.skinIndex, t), Yo.fromBufferAttribute(i.attributes.skinWeight, t), Xo.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                         for (let t = 0; t < 4; t++) {
-                            const i = Ia.getComponent(t);
+                            const i = Yo.getComponent(t);
                             if (0 !== i) {
-                                const r = Da.getComponent(t);
-                                Oa.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Na.copy(Pa).applyMatrix4(Oa), i)
+                                const r = qo.getComponent(t);
+                                Jo.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Zo.copy(Xo).applyMatrix4(Jo), i)
                             }
                         }
                         return e.applyMatrix4(this.bindMatrixInverse)
                     }
                 }
-                Ua.prototype.isSkinnedMesh = !0;
-                class Ba extends Qe {
+                Ko.prototype.isSkinnedMesh = !0;
+                class Qo extends ci {
                     constructor() {
                         super(), this.type = "Bone"
                     }
                 }
-                Ba.prototype.isBone = !0;
-                class Fa extends kt {
-                    constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, h, u) {
+                Qo.prototype.isBone = !0;
+                class $o extends $e {
+                    constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = ot, c = ot, h, u) {
                         super(null, s, a, o, l, c, i, r, h, u), this.image = {
                             data: t,
                             width: e,
                             height: n
                         }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }
-                Fa.prototype.isDataTexture = !0;
-                const za = new Ae,
-                    Ha = new Ae;
-                class Ga {
+                $o.prototype.isDataTexture = !0;
+                const tl = new Fn,
+                    el = new Fn;
+                class nl {
                     constructor(t = [], e = []) {
-                        this.uuid = yt(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
+                        this.uuid = Le(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                     }
                     init() {
                         const t = this.bones,
                             e = this.boneInverses;
                         if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                         else if (t.length !== e.length) {
                             console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
-                            for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Ae)
+                            for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Fn)
                         }
                     }
                     calculateInverses() {
                         this.boneInverses.length = 0;
                         for (let t = 0, e = this.bones.length; t < e; t++) {
-                            const e = new Ae;
+                            const e = new Fn;
                             this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                         }
                     }
                     pose() {
                         for (let t = 0, e = this.bones.length; t < e; t++) {
                             const e = this.bones[t];
                             e && e.matrixWorld.copy(this.boneInverses[t]).invert()
@@ -9651,28 +10019,28 @@
                     }
                     update() {
                         const t = this.bones,
                             e = this.boneInverses,
                             n = this.boneMatrices,
                             i = this.boneTexture;
                         for (let i = 0, r = t.length; i < r; i++) {
-                            const r = t[i] ? t[i].matrixWorld : Ha;
-                            za.multiplyMatrices(r, e[i]), za.toArray(n, 16 * i)
+                            const r = t[i] ? t[i].matrixWorld : el;
+                            tl.multiplyMatrices(r, e[i]), tl.toArray(n, 16 * i)
                         }
                         null !== i && (i.needsUpdate = !0)
                     }
                     clone() {
-                        return new Ga(this.bones, this.boneInverses)
+                        return new nl(this.bones, this.boneInverses)
                     }
                     computeBoneTexture() {
                         let t = Math.sqrt(4 * this.bones.length);
-                        t = St(t), t = Math.max(t, 4);
+                        t = Ne(t), t = Math.max(t, 4);
                         const e = new Float32Array(t * t * 4);
                         e.set(this.boneMatrices);
-                        const n = new Fa(e, t, t, T, w);
+                        const n = new $o(e, t, t, Et, yt);
                         return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this
                     }
                     getBoneByName(t) {
                         for (let e = 0, n = this.bones.length; e < n; e++) {
                             const n = this.bones[e];
                             if (n.name === t) return n
                         }
@@ -9681,15 +10049,15 @@
                         null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                     }
                     fromJSON(t, e) {
                         this.uuid = t.uuid;
                         for (let n = 0, i = t.bones.length; n < i; n++) {
                             const i = t.bones[n];
                             let r = e[i];
-                            void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Ba), this.bones.push(r), this.boneInverses.push((new Ae).fromArray(t.boneInverses[n]))
+                            void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Qo), this.bones.push(r), this.boneInverses.push((new Fn).fromArray(t.boneInverses[n]))
                         }
                         return this.init(), this
                     }
                     toJSON() {
                         const t = {
                             metadata: {
                                 version: 4.5,
@@ -9707,139 +10075,139 @@
                             t.bones.push(r.uuid);
                             const s = n[i];
                             t.boneInverses.push(s.toArray())
                         }
                         return t
                     }
                 }
-                class Va extends gn {
+                class il extends Ti {
                     constructor(t, e, n, i = 1) {
                         "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = i
                     }
                     copy(t) {
                         return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                     }
                 }
-                Va.prototype.isInstancedBufferAttribute = !0;
-                const ka = new Ae,
-                    Wa = new Ae,
-                    ja = [],
-                    Xa = new Qn;
-                class qa extends Qn {
+                il.prototype.isInstancedBufferAttribute = !0;
+                const rl = new Fn,
+                    sl = new Fn,
+                    al = [],
+                    ol = new lr;
+                class ll extends lr {
                     constructor(t, e, n) {
-                        super(t, e), this.instanceMatrix = new Va(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
+                        super(t, e), this.instanceMatrix = new il(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
                     }
                     copy(t) {
                         return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
                     }
                     getColorAt(t, e) {
                         e.fromArray(this.instanceColor.array, 3 * t)
                     }
                     getMatrixAt(t, e) {
                         e.fromArray(this.instanceMatrix.array, 16 * t)
                     }
                     raycast(t, e) {
                         const n = this.matrixWorld,
                             i = this.count;
-                        if (Xa.geometry = this.geometry, Xa.material = this.material, void 0 !== Xa.material)
+                        if (ol.geometry = this.geometry, ol.material = this.material, void 0 !== ol.material)
                             for (let r = 0; r < i; r++) {
-                                this.getMatrixAt(r, ka), Wa.multiplyMatrices(n, ka), Xa.matrixWorld = Wa, Xa.raycast(t, ja);
-                                for (let t = 0, n = ja.length; t < n; t++) {
-                                    const n = ja[t];
+                                this.getMatrixAt(r, rl), sl.multiplyMatrices(n, rl), ol.matrixWorld = sl, ol.raycast(t, al);
+                                for (let t = 0, n = al.length; t < n; t++) {
+                                    const n = al[t];
                                     n.instanceId = r, n.object = this, e.push(n)
                                 }
-                                ja.length = 0
+                                al.length = 0
                             }
                     }
                     setColorAt(t, e) {
-                        null === this.instanceColor && (this.instanceColor = new Va(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
+                        null === this.instanceColor && (this.instanceColor = new il(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                     }
                     setMatrixAt(t, e) {
                         e.toArray(this.instanceMatrix.array, 16 * t)
                     }
                     updateMorphTargets() {}
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }
-                qa.prototype.isInstancedMesh = !0;
-                class Ya extends dn {
+                ll.prototype.isInstancedMesh = !0;
+                class cl extends bi {
                     constructor(t) {
-                        super(), this.type = "LineBasicMaterial", this.color = new zt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
+                        super(), this.type = "LineBasicMaterial", this.color = new Ze(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
                     }
                 }
-                Ya.prototype.isLineBasicMaterial = !0;
-                const Za = new Jt,
-                    Ja = new Jt,
-                    Ka = new Ae,
-                    Qa = new Te,
-                    $a = new xe;
-                class to extends Qe {
-                    constructor(t = new Nn, e = new Ya) {
+                cl.prototype.isLineBasicMaterial = !0;
+                const hl = new on,
+                    ul = new on,
+                    dl = new Fn,
+                    pl = new Bn,
+                    ml = new Ln;
+                class fl extends ci {
+                    constructor(t = new Wi, e = new cl) {
                         super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                     }
                     computeLineDistances() {
                         const t = this.geometry;
                         if (t.isBufferGeometry)
                             if (null === t.index) {
                                 const e = t.attributes.position,
                                     n = [0];
-                                for (let t = 1, i = e.count; t < i; t++) Za.fromBufferAttribute(e, t - 1), Ja.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Za.distanceTo(Ja);
-                                t.setAttribute("lineDistance", new En(n, 1))
+                                for (let t = 1, i = e.count; t < i; t++) hl.fromBufferAttribute(e, t - 1), ul.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += hl.distanceTo(ul);
+                                t.setAttribute("lineDistance", new Oi(n, 1))
                             } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                         else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                         return this
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.matrixWorld,
                             r = t.params.Line.threshold,
                             s = n.drawRange;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), $a.copy(n.boundingSphere), $a.applyMatrix4(i), $a.radius += r, !1 === t.ray.intersectsSphere($a)) return;
-                        Ka.copy(i).invert(), Qa.copy(t.ray).applyMatrix4(Ka);
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), ml.copy(n.boundingSphere), ml.applyMatrix4(i), ml.radius += r, !1 === t.ray.intersectsSphere(ml)) return;
+                        dl.copy(i).invert(), pl.copy(t.ray).applyMatrix4(dl);
                         const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                             o = a * a,
-                            l = new Jt,
-                            c = new Jt,
-                            h = new Jt,
-                            u = new Jt,
+                            l = new on,
+                            c = new on,
+                            h = new on,
+                            u = new on,
                             d = this.isLineSegments ? 2 : 1;
                         if (n.isBufferGeometry) {
                             const i = n.index,
                                 r = n.attributes.position;
                             if (null !== i)
                                 for (let n = Math.max(0, s.start), a = Math.min(i.count, s.start + s.count) - 1; n < a; n += d) {
                                     const s = i.getX(n),
                                         a = i.getX(n + 1);
-                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a), Qa.distanceSqToSegment(l, c, u, h) > o) continue;
+                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a), pl.distanceSqToSegment(l, c, u, h) > o) continue;
                                     u.applyMatrix4(this.matrixWorld);
                                     const d = t.ray.origin.distanceTo(u);
                                     d < t.near || d > t.far || e.push({
                                         distance: d,
                                         point: h.clone().applyMatrix4(this.matrixWorld),
                                         index: n,
                                         face: null,
                                         faceIndex: null,
                                         object: this
                                     })
                                 } else
                                     for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
-                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), Qa.distanceSqToSegment(l, c, u, h) > o) continue;
+                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), pl.distanceSqToSegment(l, c, u, h) > o) continue;
                                         u.applyMatrix4(this.matrixWorld);
                                         const i = t.ray.origin.distanceTo(u);
                                         i < t.near || i > t.far || e.push({
                                             distance: i,
                                             point: h.clone().applyMatrix4(this.matrixWorld),
                                             index: n,
                                             face: null,
@@ -9866,79 +10234,79 @@
                             }
                         } else {
                             const e = t.morphTargets;
                             void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                         }
                     }
                 }
-                to.prototype.isLine = !0;
-                const eo = new Jt,
-                    no = new Jt;
-                class io extends to {
+                fl.prototype.isLine = !0;
+                const gl = new on,
+                    vl = new on;
+                class xl extends fl {
                     constructor(t, e) {
                         super(t, e), this.type = "LineSegments"
                     }
                     computeLineDistances() {
                         const t = this.geometry;
                         if (t.isBufferGeometry)
                             if (null === t.index) {
                                 const e = t.attributes.position,
                                     n = [];
-                                for (let t = 0, i = e.count; t < i; t += 2) eo.fromBufferAttribute(e, t), no.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + eo.distanceTo(no);
-                                t.setAttribute("lineDistance", new En(n, 1))
+                                for (let t = 0, i = e.count; t < i; t += 2) gl.fromBufferAttribute(e, t), vl.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + gl.distanceTo(vl);
+                                t.setAttribute("lineDistance", new Oi(n, 1))
                             } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                         else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                         return this
                     }
                 }
-                io.prototype.isLineSegments = !0;
-                class ro extends to {
+                xl.prototype.isLineSegments = !0;
+                class yl extends fl {
                     constructor(t, e) {
                         super(t, e), this.type = "LineLoop"
                     }
                 }
-                ro.prototype.isLineLoop = !0;
-                class so extends dn {
+                yl.prototype.isLineLoop = !0;
+                class _l extends bi {
                     constructor(t) {
-                        super(), this.type = "PointsMaterial", this.color = new zt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
+                        super(), this.type = "PointsMaterial", this.color = new Ze(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
                     }
                 }
-                so.prototype.isPointsMaterial = !0;
-                const ao = new Ae,
-                    oo = new Te,
-                    lo = new xe,
-                    co = new Jt;
-                class ho extends Qe {
-                    constructor(t = new Nn, e = new so) {
+                _l.prototype.isPointsMaterial = !0;
+                const Ml = new Fn,
+                    bl = new Bn,
+                    wl = new Ln,
+                    Sl = new on;
+                class El extends ci {
+                    constructor(t = new Wi, e = new _l) {
                         super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.matrixWorld,
                             r = t.params.Points.threshold,
                             s = n.drawRange;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), lo.copy(n.boundingSphere), lo.applyMatrix4(i), lo.radius += r, !1 === t.ray.intersectsSphere(lo)) return;
-                        ao.copy(i).invert(), oo.copy(t.ray).applyMatrix4(ao);
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), wl.copy(n.boundingSphere), wl.applyMatrix4(i), wl.radius += r, !1 === t.ray.intersectsSphere(wl)) return;
+                        Ml.copy(i).invert(), bl.copy(t.ray).applyMatrix4(Ml);
                         const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                             o = a * a;
                         if (n.isBufferGeometry) {
                             const r = n.index,
                                 a = n.attributes.position;
                             if (null !== r)
                                 for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                                     const s = r.getX(n);
-                                    co.fromBufferAttribute(a, s), uo(co, s, o, i, t, e, this)
+                                    Sl.fromBufferAttribute(a, s), Tl(Sl, s, o, i, t, e, this)
                                 } else
-                                    for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++) co.fromBufferAttribute(a, n), uo(co, n, o, i, t, e, this)
+                                    for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++) Sl.fromBufferAttribute(a, n), Tl(Sl, n, o, i, t, e, this)
                         } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                     }
                     updateMorphTargets() {
                         const t = this.geometry;
                         if (t.isBufferGeometry) {
                             const e = t.morphAttributes,
                                 n = Object.keys(e);
@@ -9955,100 +10323,100 @@
                         } else {
                             const e = t.morphTargets;
                             void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                         }
                     }
                 }
 
-                function uo(t, e, n, i, r, s, a) {
-                    const o = oo.distanceSqToPoint(t);
+                function Tl(t, e, n, i, r, s, a) {
+                    const o = bl.distanceSqToPoint(t);
                     if (o < n) {
-                        const n = new Jt;
-                        oo.closestPointToPoint(t, n), n.applyMatrix4(i);
+                        const n = new on;
+                        bl.closestPointToPoint(t, n), n.applyMatrix4(i);
                         const l = r.ray.origin.distanceTo(n);
                         if (l < r.near || l > r.far) return;
                         s.push({
                             distance: l,
                             distanceToRay: Math.sqrt(o),
                             point: n,
                             index: e,
                             face: null,
                             object: a
                         })
                     }
                 }
-                ho.prototype.isPoints = !0;
-                class po extends kt {
+                El.prototype.isPoints = !0;
+                class Al extends $e {
                     constructor(t, e, n, i, r, s, a, o, l) {
-                        super(t, e, n, i, r, s, a, o, l), this.minFilter = void 0 !== s ? s : v, this.magFilter = void 0 !== r ? r : v, this.generateMipmaps = !1;
+                        super(t, e, n, i, r, s, a, o, l), this.minFilter = void 0 !== s ? s : ht, this.magFilter = void 0 !== r ? r : ht, this.generateMipmaps = !1;
                         const c = this;
                         "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                             c.needsUpdate = !0, t.requestVideoFrameCallback(e)
                         }))
                     }
                     clone() {
                         return new this.constructor(this.image).copy(this)
                     }
                     update() {
                         const t = this.image;
                         !1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                     }
                 }
-                po.prototype.isVideoTexture = !0;
-                class mo extends kt {
+                Al.prototype.isVideoTexture = !0;
+                class Rl extends $e {
                     constructor(t, e, n) {
                         super({
                             width: t,
                             height: e
-                        }), this.format = n, this.magFilter = m, this.minFilter = m, this.generateMipmaps = !1, this.needsUpdate = !0
+                        }), this.format = n, this.magFilter = ot, this.minFilter = ot, this.generateMipmaps = !1, this.needsUpdate = !0
                     }
                 }
-                mo.prototype.isFramebufferTexture = !0;
-                class fo extends kt {
+                Rl.prototype.isFramebufferTexture = !0;
+                class Ll extends $e {
                     constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
                         super(null, s, a, o, l, c, i, r, h, u), this.image = {
                             width: e,
                             height: n
                         }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                     }
                 }
-                fo.prototype.isCompressedTexture = !0;
-                class go extends kt {
+                Ll.prototype.isCompressedTexture = !0;
+                class Cl extends $e {
                     constructor(t, e, n, i, r, s, a, o, l) {
                         super(t, e, n, i, r, s, a, o, l), this.needsUpdate = !0
                     }
                 }
-                go.prototype.isCanvasTexture = !0;
-                class vo extends Nn {
+                Cl.prototype.isCanvasTexture = !0;
+                class Pl extends Wi {
                     constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {
                         super(), this.type = "CircleGeometry", this.parameters = {
                             radius: t,
                             segments: e,
                             thetaStart: n,
                             thetaLength: i
                         }, e = Math.max(3, e);
                         const r = [],
                             s = [],
                             a = [],
                             o = [],
-                            l = new Jt,
-                            c = new At;
+                            l = new on,
+                            c = new Be;
                         s.push(0, 0, 0), a.push(0, 0, 1), o.push(.5, .5);
                         for (let r = 0, h = 3; r <= e; r++, h += 3) {
                             const u = n + r / e * i;
                             l.x = t * Math.cos(u), l.y = t * Math.sin(u), s.push(l.x, l.y, l.z), a.push(0, 0, 1), c.x = (s[h] / t + 1) / 2, c.y = (s[h + 1] / t + 1) / 2, o.push(c.x, c.y)
                         }
                         for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
-                        this.setIndex(r), this.setAttribute("position", new En(s, 3)), this.setAttribute("normal", new En(a, 3)), this.setAttribute("uv", new En(o, 2))
+                        this.setIndex(r), this.setAttribute("position", new Oi(s, 3)), this.setAttribute("normal", new Oi(a, 3)), this.setAttribute("uv", new Oi(o, 2))
                     }
                     static fromJSON(t) {
-                        return new vo(t.radius, t.segments, t.thetaStart, t.thetaLength)
+                        return new Pl(t.radius, t.segments, t.thetaStart, t.thetaLength)
                     }
                 }
-                class xo extends Nn {
+                class Dl extends Wi {
                     constructor(t = 1, e = 1, n = 1, i = 8, r = 1, s = !1, a = 0, o = 2 * Math.PI) {
                         super(), this.type = "CylinderGeometry", this.parameters = {
                             radiusTop: t,
                             radiusBottom: e,
                             height: n,
                             radialSegments: i,
                             heightSegments: r,
@@ -10065,16 +10433,16 @@
                         let p = 0;
                         const m = [],
                             f = n / 2;
                         let g = 0;
 
                         function v(n) {
                             const r = p,
-                                s = new At,
-                                m = new Jt;
+                                s = new Be,
+                                m = new on;
                             let v = 0;
                             const x = !0 === n ? t : e,
                                 y = !0 === n ? 1 : -1;
                             for (let t = 1; t <= i; t++) h.push(0, f * y, 0), u.push(0, y, 0), d.push(.5, .5), p++;
                             const _ = p;
                             for (let t = 0; t <= i; t++) {
                                 const e = t / i * o + a,
@@ -10085,16 +10453,16 @@
                             for (let t = 0; t < i; t++) {
                                 const e = r + t,
                                     i = _ + t;
                                 !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), v += 3
                             }
                             l.addGroup(g, v, !0 === n ? 1 : 2), g += v
                         }! function() {
-                            const s = new Jt,
-                                v = new Jt;
+                            const s = new on,
+                                v = new on;
                             let x = 0;
                             const y = (e - t) / n;
                             for (let l = 0; l <= r; l++) {
                                 const c = [],
                                     g = l / r,
                                     x = g * (e - t) + t;
                                 for (let t = 0; t <= i; t++) {
@@ -10111,37 +10479,37 @@
                                     const n = m[e][t],
                                         i = m[e + 1][t],
                                         r = m[e + 1][t + 1],
                                         s = m[e][t + 1];
                                     c.push(n, i, s), c.push(i, r, s), x += 6
                                 }
                             l.addGroup(g, x, 0), g += x
-                        }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new En(h, 3)), this.setAttribute("normal", new En(u, 3)), this.setAttribute("uv", new En(d, 2))
+                        }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new Oi(h, 3)), this.setAttribute("normal", new Oi(u, 3)), this.setAttribute("uv", new Oi(d, 2))
                     }
                     static fromJSON(t) {
-                        return new xo(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
+                        return new Dl(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
                     }
                 }
-                class yo extends xo {
+                class Il extends Dl {
                     constructor(t = 1, e = 1, n = 8, i = 1, r = !1, s = 0, a = 2 * Math.PI) {
                         super(0, t, e, n, i, r, s, a), this.type = "ConeGeometry", this.parameters = {
                             radius: t,
                             height: e,
                             radialSegments: n,
                             heightSegments: i,
                             openEnded: r,
                             thetaStart: s,
                             thetaLength: a
                         }
                     }
                     static fromJSON(t) {
-                        return new yo(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
+                        return new Il(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
                     }
                 }
-                class _o extends Nn {
+                class Nl extends Wi {
                     constructor(t = [], e = [], n = 1, i = 0) {
                         super(), this.type = "PolyhedronGeometry", this.parameters = {
                             vertices: t,
                             indices: e,
                             radius: n,
                             detail: i
                         };
@@ -10177,40 +10545,40 @@
                         function c(t, e, n, i) {
                             i < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + .5)
                         }
 
                         function h(t) {
                             return Math.atan2(t.z, -t.x)
                         }! function(t) {
-                            const n = new Jt,
-                                i = new Jt,
-                                r = new Jt;
+                            const n = new on,
+                                i = new on,
+                                r = new on;
                             for (let s = 0; s < e.length; s += 3) l(e[s + 0], n), l(e[s + 1], i), l(e[s + 2], r), a(n, i, r, t)
                         }(i),
                         function(t) {
-                            const e = new Jt;
+                            const e = new on;
                             for (let n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z
                         }(n),
                         function() {
-                            const t = new Jt;
+                            const t = new on;
                             for (let n = 0; n < r.length; n += 3) {
                                 t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2];
                                 const i = h(t) / 2 / Math.PI + .5,
                                     a = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
                                 s.push(i, 1 - a)
                             }
                             var e;
                             (function() {
-                                const t = new Jt,
-                                    e = new Jt,
-                                    n = new Jt,
-                                    i = new Jt,
-                                    a = new At,
-                                    o = new At,
-                                    l = new At;
+                                const t = new on,
+                                    e = new on,
+                                    n = new on,
+                                    i = new on,
+                                    a = new Be,
+                                    o = new Be,
+                                    l = new Be;
                                 for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                                     t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), a.set(s[d + 0], s[d + 1]), o.set(s[d + 2], s[d + 3]), l.set(s[d + 4], s[d + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                                     const p = h(i);
                                     c(a, d + 0, t, p), c(o, d + 2, e, p), c(l, d + 4, n, p)
                                 }
                             })(),
                             function() {
@@ -10219,89 +10587,89 @@
                                         n = s[t + 2],
                                         i = s[t + 4],
                                         r = Math.max(e, n, i),
                                         a = Math.min(e, n, i);
                                     r > .9 && a < .1 && (e < .2 && (s[t + 0] += 1), n < .2 && (s[t + 2] += 1), i < .2 && (s[t + 4] += 1))
                                 }
                             }()
-                        }(), this.setAttribute("position", new En(r, 3)), this.setAttribute("normal", new En(r.slice(), 3)), this.setAttribute("uv", new En(s, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
+                        }(), this.setAttribute("position", new Oi(r, 3)), this.setAttribute("normal", new Oi(r.slice(), 3)), this.setAttribute("uv", new Oi(s, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
                     }
                     static fromJSON(t) {
-                        return new _o(t.vertices, t.indices, t.radius, t.details)
+                        return new Nl(t.vertices, t.indices, t.radius, t.details)
                     }
                 }
-                class Mo extends _o {
+                class Ol extends Nl {
                     constructor(t = 1, e = 0) {
                         const n = (1 + Math.sqrt(5)) / 2,
                             i = 1 / n;
                         super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = {
                             radius: t,
                             detail: e
                         }
                     }
                     static fromJSON(t) {
-                        return new Mo(t.radius, t.detail)
+                        return new Ol(t.radius, t.detail)
                     }
                 }
-                const bo = new Jt,
-                    wo = new Jt,
-                    So = new Jt,
-                    Eo = new hn;
-                class To extends Nn {
+                const Ul = new on,
+                    Bl = new on,
+                    Fl = new on,
+                    zl = new _i;
+                class Hl extends Wi {
                     constructor(t = null, e = 1) {
                         if (super(), this.type = "EdgesGeometry", this.parameters = {
                                 geometry: t,
                                 thresholdAngle: e
                             }, null !== t) {
                             const n = 4,
                                 i = Math.pow(10, n),
-                                r = Math.cos(vt * e),
+                                r = Math.cos(Ae * e),
                                 s = t.getIndex(),
                                 a = t.getAttribute("position"),
                                 o = s ? s.count : a.count,
                                 l = [0, 0, 0],
                                 c = ["a", "b", "c"],
                                 h = new Array(3),
                                 u = {},
                                 d = [];
                             for (let t = 0; t < o; t += 3) {
                                 s ? (l[0] = s.getX(t), l[1] = s.getX(t + 1), l[2] = s.getX(t + 2)) : (l[0] = t, l[1] = t + 1, l[2] = t + 2);
                                 const {
                                     a: e,
                                     b: n,
                                     c: o
-                                } = Eo;
-                                if (e.fromBufferAttribute(a, l[0]), n.fromBufferAttribute(a, l[1]), o.fromBufferAttribute(a, l[2]), Eo.getNormal(So), h[0] = `${Math.round(e.x*i)},${Math.round(e.y*i)},${Math.round(e.z*i)}`, h[1] = `${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`, h[2] = `${Math.round(o.x*i)},${Math.round(o.y*i)},${Math.round(o.z*i)}`, h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
+                                } = zl;
+                                if (e.fromBufferAttribute(a, l[0]), n.fromBufferAttribute(a, l[1]), o.fromBufferAttribute(a, l[2]), zl.getNormal(Fl), h[0] = `${Math.round(e.x*i)},${Math.round(e.y*i)},${Math.round(e.z*i)}`, h[1] = `${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`, h[2] = `${Math.round(o.x*i)},${Math.round(o.y*i)},${Math.round(o.z*i)}`, h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
                                     for (let t = 0; t < 3; t++) {
                                         const e = (t + 1) % 3,
                                             n = h[t],
                                             i = h[e],
-                                            s = Eo[c[t]],
-                                            a = Eo[c[e]],
+                                            s = zl[c[t]],
+                                            a = zl[c[e]],
                                             o = `${n}_${i}`,
                                             p = `${i}_${n}`;
-                                        p in u && u[p] ? (So.dot(u[p].normal) <= r && (d.push(s.x, s.y, s.z), d.push(a.x, a.y, a.z)), u[p] = null) : o in u || (u[o] = {
+                                        p in u && u[p] ? (Fl.dot(u[p].normal) <= r && (d.push(s.x, s.y, s.z), d.push(a.x, a.y, a.z)), u[p] = null) : o in u || (u[o] = {
                                             index0: l[t],
                                             index1: l[e],
-                                            normal: So.clone()
+                                            normal: Fl.clone()
                                         })
                                     }
                             }
                             for (const t in u)
                                 if (u[t]) {
                                     const {
                                         index0: e,
                                         index1: n
                                     } = u[t];
-                                    bo.fromBufferAttribute(a, e), wo.fromBufferAttribute(a, n), d.push(bo.x, bo.y, bo.z), d.push(wo.x, wo.y, wo.z)
-                                } this.setAttribute("position", new En(d, 3))
+                                    Ul.fromBufferAttribute(a, e), Bl.fromBufferAttribute(a, n), d.push(Ul.x, Ul.y, Ul.z), d.push(Bl.x, Bl.y, Bl.z)
+                                } this.setAttribute("position", new Oi(d, 3))
                         }
                     }
                 }
-                class Ao {
+                class Gl {
                     constructor() {
                         this.type = "Curve", this.arcLengthDivisions = 200
                     }
                     getPoint() {
                         return console.warn("THREE.Curve: .getPoint() not implemented."), null
                     }
                     getPointAt(t, e) {
@@ -10358,48 +10726,48 @@
                     getTangent(t, e) {
                         const n = 1e-4;
                         let i = t - n,
                             r = t + n;
                         i < 0 && (i = 0), r > 1 && (r = 1);
                         const s = this.getPoint(i),
                             a = this.getPoint(r),
-                            o = e || (s.isVector2 ? new At : new Jt);
+                            o = e || (s.isVector2 ? new Be : new on);
                         return o.copy(a).sub(s).normalize(), o
                     }
                     getTangentAt(t, e) {
                         const n = this.getUtoTmapping(t);
                         return this.getTangent(n, e)
                     }
                     computeFrenetFrames(t, e) {
-                        const n = new Jt,
+                        const n = new on,
                             i = [],
                             r = [],
                             s = [],
-                            a = new Jt,
-                            o = new Ae;
+                            a = new on,
+                            o = new Fn;
                         for (let e = 0; e <= t; e++) {
                             const n = e / t;
-                            i[e] = this.getTangentAt(n, new Jt)
+                            i[e] = this.getTangentAt(n, new on)
                         }
-                        r[0] = new Jt, s[0] = new Jt;
+                        r[0] = new on, s[0] = new on;
                         let l = Number.MAX_VALUE;
                         const c = Math.abs(i[0].x),
                             h = Math.abs(i[0].y),
                             u = Math.abs(i[0].z);
                         c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), s[0].crossVectors(i[0], r[0]);
                         for (let e = 1; e <= t; e++) {
                             if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), a.crossVectors(i[e - 1], i[e]), a.length() > Number.EPSILON) {
                                 a.normalize();
-                                const t = Math.acos(_t(i[e - 1].dot(i[e]), -1, 1));
+                                const t = Math.acos(Ce(i[e - 1].dot(i[e]), -1, 1));
                                 r[e].applyMatrix4(o.makeRotationAxis(a, t))
                             }
                             s[e].crossVectors(i[e], r[e])
                         }
                         if (!0 === e) {
-                            let e = Math.acos(_t(r[0].dot(r[t]), -1, 1));
+                            let e = Math.acos(Ce(r[0].dot(r[t]), -1, 1));
                             e /= t, i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                             for (let n = 1; n <= t; n++) r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
                         }
                         return {
                             tangents: i,
                             normals: r,
                             binormals: s
@@ -10421,20 +10789,20 @@
                         };
                         return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                     }
                     fromJSON(t) {
                         return this.arcLengthDivisions = t.arcLengthDivisions, this
                     }
                 }
-                class Ro extends Ao {
+                class Vl extends Gl {
                     constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
                         super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
                     }
                     getPoint(t, e) {
-                        const n = e || new At,
+                        const n = e || new Be,
                             i = 2 * Math.PI;
                         let r = this.aEndAngle - this.aStartAngle;
                         const s = Math.abs(r) < Number.EPSILON;
                         for (; r < 0;) r += i;
                         for (; r > i;) r -= i;
                         r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                         const a = this.aStartAngle + t * r;
@@ -10456,22 +10824,22 @@
                         const t = super.toJSON();
                         return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                     }
                 }
-                Ro.prototype.isEllipseCurve = !0;
-                class Lo extends Ro {
+                Vl.prototype.isEllipseCurve = !0;
+                class kl extends Vl {
                     constructor(t, e, n, i, r, s) {
                         super(t, e, n, n, i, r, s), this.type = "ArcCurve"
                     }
                 }
 
-                function Co() {
+                function Wl() {
                     let t = 0,
                         e = 0,
                         n = 0,
                         i = 0;
 
                     function r(r, s, a, o) {
                         t = r, e = a, n = -3 * r + 3 * s - 2 * a - o, i = 2 * r - 2 * s + a + o
@@ -10487,41 +10855,41 @@
                         },
                         calc: function(r) {
                             const s = r * r;
                             return t + e * r + n * s + i * (s * r)
                         }
                     }
                 }
-                Lo.prototype.isArcCurve = !0;
-                const Po = new Jt,
-                    Do = new Co,
-                    Io = new Co,
-                    No = new Co;
-                class Oo extends Ao {
+                kl.prototype.isArcCurve = !0;
+                const jl = new on,
+                    Xl = new Wl,
+                    ql = new Wl,
+                    Yl = new Wl;
+                class Zl extends Gl {
                     constructor(t = [], e = !1, n = "centripetal", i = .5) {
                         super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i
                     }
-                    getPoint(t, e = new Jt) {
+                    getPoint(t, e = new on) {
                         const n = e,
                             i = this.points,
                             r = i.length,
                             s = (r - (this.closed ? 0 : 1)) * t;
                         let a, o, l = Math.floor(s),
                             c = s - l;
-                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (Po.subVectors(i[0], i[1]).add(i[0]), a = Po);
+                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (jl.subVectors(i[0], i[1]).add(i[0]), a = jl);
                         const h = i[l % r],
                             u = i[(l + 1) % r];
-                        if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (Po.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = Po), "centripetal" === this.curveType || "chordal" === this.curveType) {
+                        if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (jl.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = jl), "centripetal" === this.curveType || "chordal" === this.curveType) {
                             const t = "chordal" === this.curveType ? .5 : .25;
                             let e = Math.pow(a.distanceToSquared(h), t),
                                 n = Math.pow(h.distanceToSquared(u), t),
                                 i = Math.pow(u.distanceToSquared(o), t);
-                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Do.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i), Io.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i), No.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i)
-                        } else "catmullrom" === this.curveType && (Do.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), Io.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), No.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
-                        return n.set(Do.calc(c), Io.calc(c), No.calc(c)), n
+                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Xl.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i), ql.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i), Yl.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i)
+                        } else "catmullrom" === this.curveType && (Xl.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), ql.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), Yl.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
+                        return n.set(Xl.calc(c), ql.calc(c), Yl.calc(c)), n
                     }
                     copy(t) {
                         super.copy(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
                             this.points.push(n.clone())
                         }
@@ -10536,132 +10904,132 @@
                         }
                         return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
-                            this.points.push((new Jt).fromArray(n))
+                            this.points.push((new on).fromArray(n))
                         }
                         return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                     }
                 }
 
-                function Uo(t, e, n, i, r) {
+                function Jl(t, e, n, i, r) {
                     const s = .5 * (i - e),
                         a = .5 * (r - n),
                         o = t * t;
                     return (2 * n - 2 * i + s + a) * (t * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * t + n
                 }
 
-                function Bo(t, e, n, i) {
+                function Kl(t, e, n, i) {
                     return function(t, e) {
                         const n = 1 - t;
                         return n * n * e
                     }(t, e) + function(t, e) {
                         return 2 * (1 - t) * t * e
                     }(t, n) + function(t, e) {
                         return t * t * e
                     }(t, i)
                 }
 
-                function Fo(t, e, n, i, r) {
+                function Ql(t, e, n, i, r) {
                     return function(t, e) {
                         const n = 1 - t;
                         return n * n * n * e
                     }(t, e) + function(t, e) {
                         const n = 1 - t;
                         return 3 * n * n * t * e
                     }(t, n) + function(t, e) {
                         return 3 * (1 - t) * t * t * e
                     }(t, i) + function(t, e) {
                         return t * t * t * e
                     }(t, r)
                 }
-                Oo.prototype.isCatmullRomCurve3 = !0;
-                class zo extends Ao {
-                    constructor(t = new At, e = new At, n = new At, i = new At) {
+                Zl.prototype.isCatmullRomCurve3 = !0;
+                class $l extends Gl {
+                    constructor(t = new Be, e = new Be, n = new Be, i = new Be) {
                         super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                     }
-                    getPoint(t, e = new At) {
+                    getPoint(t, e = new Be) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2,
                             a = this.v3;
-                        return n.set(Fo(t, i.x, r.x, s.x, a.x), Fo(t, i.y, r.y, s.y, a.y)), n
+                        return n.set(Ql(t, i.x, r.x, s.x, a.x), Ql(t, i.y, r.y, s.y, a.y)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                     }
                 }
-                zo.prototype.isCubicBezierCurve = !0;
-                class Ho extends Ao {
-                    constructor(t = new Jt, e = new Jt, n = new Jt, i = new Jt) {
+                $l.prototype.isCubicBezierCurve = !0;
+                class tc extends Gl {
+                    constructor(t = new on, e = new on, n = new on, i = new on) {
                         super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                     }
-                    getPoint(t, e = new Jt) {
+                    getPoint(t, e = new on) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2,
                             a = this.v3;
-                        return n.set(Fo(t, i.x, r.x, s.x, a.x), Fo(t, i.y, r.y, s.y, a.y), Fo(t, i.z, r.z, s.z, a.z)), n
+                        return n.set(Ql(t, i.x, r.x, s.x, a.x), Ql(t, i.y, r.y, s.y, a.y), Ql(t, i.z, r.z, s.z, a.z)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                     }
                 }
-                Ho.prototype.isCubicBezierCurve3 = !0;
-                class Go extends Ao {
-                    constructor(t = new At, e = new At) {
+                tc.prototype.isCubicBezierCurve3 = !0;
+                class ec extends Gl {
+                    constructor(t = new Be, e = new Be) {
                         super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
                     }
-                    getPoint(t, e = new At) {
+                    getPoint(t, e = new Be) {
                         const n = e;
                         return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                     }
                     getPointAt(t, e) {
                         return this.getPoint(t, e)
                     }
                     getTangent(t, e) {
-                        const n = e || new At;
+                        const n = e || new Be;
                         return n.copy(this.v2).sub(this.v1).normalize(), n
                     }
                     copy(t) {
                         return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                Go.prototype.isLineCurve = !0;
-                class Vo extends Ao {
-                    constructor(t = new Jt, e = new Jt) {
+                ec.prototype.isLineCurve = !0;
+                class nc extends Gl {
+                    constructor(t = new on, e = new on) {
                         super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                     }
-                    getPoint(t, e = new Jt) {
+                    getPoint(t, e = new on) {
                         const n = e;
                         return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                     }
                     getPointAt(t, e) {
                         return this.getPoint(t, e)
                     }
                     copy(t) {
@@ -10671,75 +11039,75 @@
                         const t = super.toJSON();
                         return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                class ko extends Ao {
-                    constructor(t = new At, e = new At, n = new At) {
+                class ic extends Gl {
+                    constructor(t = new Be, e = new Be, n = new Be) {
                         super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
                     }
-                    getPoint(t, e = new At) {
+                    getPoint(t, e = new Be) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2;
-                        return n.set(Bo(t, i.x, r.x, s.x), Bo(t, i.y, r.y, s.y)), n
+                        return n.set(Kl(t, i.x, r.x, s.x), Kl(t, i.y, r.y, s.y)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                ko.prototype.isQuadraticBezierCurve = !0;
-                class Wo extends Ao {
-                    constructor(t = new Jt, e = new Jt, n = new Jt) {
+                ic.prototype.isQuadraticBezierCurve = !0;
+                class rc extends Gl {
+                    constructor(t = new on, e = new on, n = new on) {
                         super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
                     }
-                    getPoint(t, e = new Jt) {
+                    getPoint(t, e = new on) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2;
-                        return n.set(Bo(t, i.x, r.x, s.x), Bo(t, i.y, r.y, s.y), Bo(t, i.z, r.z, s.z)), n
+                        return n.set(Kl(t, i.x, r.x, s.x), Kl(t, i.y, r.y, s.y), Kl(t, i.z, r.z, s.z)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                Wo.prototype.isQuadraticBezierCurve3 = !0;
-                class jo extends Ao {
+                rc.prototype.isQuadraticBezierCurve3 = !0;
+                class sc extends Gl {
                     constructor(t = []) {
                         super(), this.type = "SplineCurve", this.points = t
                     }
-                    getPoint(t, e = new At) {
+                    getPoint(t, e = new Be) {
                         const n = e,
                             i = this.points,
                             r = (i.length - 1) * t,
                             s = Math.floor(r),
                             a = r - s,
                             o = i[0 === s ? s : s - 1],
                             l = i[s],
                             c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                             h = i[s > i.length - 3 ? i.length - 1 : s + 2];
-                        return n.set(Uo(a, o.x, l.x, c.x, h.x), Uo(a, o.y, l.y, c.y, h.y)), n
+                        return n.set(Jl(a, o.x, l.x, c.x, h.x), Jl(a, o.y, l.y, c.y, h.y)), n
                     }
                     copy(t) {
                         super.copy(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
                             this.points.push(n.clone())
                         }
@@ -10754,44 +11122,44 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
-                            this.points.push((new At).fromArray(n))
+                            this.points.push((new Be).fromArray(n))
                         }
                         return this
                     }
                 }
-                jo.prototype.isSplineCurve = !0;
-                var Xo = Object.freeze({
+                sc.prototype.isSplineCurve = !0;
+                var ac = Object.freeze({
                     __proto__: null,
-                    ArcCurve: Lo,
-                    CatmullRomCurve3: Oo,
-                    CubicBezierCurve: zo,
-                    CubicBezierCurve3: Ho,
-                    EllipseCurve: Ro,
-                    LineCurve: Go,
-                    LineCurve3: Vo,
-                    QuadraticBezierCurve: ko,
-                    QuadraticBezierCurve3: Wo,
-                    SplineCurve: jo
+                    ArcCurve: kl,
+                    CatmullRomCurve3: Zl,
+                    CubicBezierCurve: $l,
+                    CubicBezierCurve3: tc,
+                    EllipseCurve: Vl,
+                    LineCurve: ec,
+                    LineCurve3: nc,
+                    QuadraticBezierCurve: ic,
+                    QuadraticBezierCurve3: rc,
+                    SplineCurve: sc
                 });
-                class qo extends Ao {
+                class oc extends Gl {
                     constructor() {
                         super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                     }
                     add(t) {
                         this.curves.push(t)
                     }
                     closePath() {
                         const t = this.curves[0].getPoint(0),
                             e = this.curves[this.curves.length - 1].getPoint(1);
-                        t.equals(e) || this.curves.push(new Go(e, t))
+                        t.equals(e) || this.curves.push(new ec(e, t))
                     }
                     getPoint(t, e) {
                         const n = t * this.getLength(),
                             i = this.getCurveLengths();
                         let r = 0;
                         for (; r < i.length;) {
                             if (i[r] >= n) {
@@ -10855,46 +11223,46 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                         for (let e = 0, n = t.curves.length; e < n; e++) {
                             const n = t.curves[e];
-                            this.curves.push((new Xo[n.type]).fromJSON(n))
+                            this.curves.push((new ac[n.type]).fromJSON(n))
                         }
                         return this
                     }
                 }
-                class Yo extends qo {
+                class lc extends oc {
                     constructor(t) {
-                        super(), this.type = "Path", this.currentPoint = new At, t && this.setFromPoints(t)
+                        super(), this.type = "Path", this.currentPoint = new Be, t && this.setFromPoints(t)
                     }
                     setFromPoints(t) {
                         this.moveTo(t[0].x, t[0].y);
                         for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                         return this
                     }
                     moveTo(t, e) {
                         return this.currentPoint.set(t, e), this
                     }
                     lineTo(t, e) {
-                        const n = new Go(this.currentPoint.clone(), new At(t, e));
+                        const n = new ec(this.currentPoint.clone(), new Be(t, e));
                         return this.curves.push(n), this.currentPoint.set(t, e), this
                     }
                     quadraticCurveTo(t, e, n, i) {
-                        const r = new ko(this.currentPoint.clone(), new At(t, e), new At(n, i));
+                        const r = new ic(this.currentPoint.clone(), new Be(t, e), new Be(n, i));
                         return this.curves.push(r), this.currentPoint.set(n, i), this
                     }
                     bezierCurveTo(t, e, n, i, r, s) {
-                        const a = new zo(this.currentPoint.clone(), new At(t, e), new At(n, i), new At(r, s));
+                        const a = new $l(this.currentPoint.clone(), new Be(t, e), new Be(n, i), new Be(r, s));
                         return this.curves.push(a), this.currentPoint.set(r, s), this
                     }
                     splineThru(t) {
                         const e = [this.currentPoint.clone()].concat(t),
-                            n = new jo(e);
+                            n = new sc(e);
                         return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                     }
                     arc(t, e, n, i, r, s) {
                         const a = this.currentPoint.x,
                             o = this.currentPoint.y;
                         return this.absarc(t + a, e + o, n, i, r, s), this
                     }
@@ -10903,15 +11271,15 @@
                     }
                     ellipse(t, e, n, i, r, s, a, o) {
                         const l = this.currentPoint.x,
                             c = this.currentPoint.y;
                         return this.absellipse(t + l, e + c, n, i, r, s, a, o), this
                     }
                     absellipse(t, e, n, i, r, s, a, o) {
-                        const l = new Ro(t, e, n, i, r, s, a, o);
+                        const l = new Vl(t, e, n, i, r, s, a, o);
                         if (this.curves.length > 0) {
                             const t = l.getPoint(0);
                             t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                         }
                         this.curves.push(l);
                         const c = l.getPoint(1);
                         return this.currentPoint.copy(c), this
@@ -10923,17 +11291,17 @@
                         const t = super.toJSON();
                         return t.currentPoint = this.currentPoint.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                     }
                 }
-                class Zo extends Yo {
+                class cc extends lc {
                     constructor(t) {
-                        super(t), this.uuid = yt(), this.type = "Shape", this.holes = []
+                        super(t), this.uuid = Le(), this.type = "Shape", this.holes = []
                     }
                     getPointsHoles(t) {
                         const e = [];
                         for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                         return e
                     }
                     extractPoints(t) {
@@ -10959,53 +11327,53 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                         for (let e = 0, n = t.holes.length; e < n; e++) {
                             const n = t.holes[e];
-                            this.holes.push((new Yo).fromJSON(n))
+                            this.holes.push((new lc).fromJSON(n))
                         }
                         return this
                     }
                 }
 
-                function Jo(t, e, n, i, r) {
+                function hc(t, e, n, i, r) {
                     let s, a;
                     if (r === function(t, e, n, i) {
                             let r = 0;
                             for (let s = e, a = n - i; s < n; s += i) r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;
                             return r
                         }(t, e, n, i) > 0)
-                        for (s = e; s < n; s += i) a = vl(s, t[s], t[s + 1], a);
+                        for (s = e; s < n; s += i) a = Pc(s, t[s], t[s + 1], a);
                     else
-                        for (s = n - i; s >= e; s -= i) a = vl(s, t[s], t[s + 1], a);
-                    return a && ul(a, a.next) && (xl(a), a = a.next), a
+                        for (s = n - i; s >= e; s -= i) a = Pc(s, t[s], t[s + 1], a);
+                    return a && Ec(a, a.next) && (Dc(a), a = a.next), a
                 }
 
-                function Ko(t, e) {
+                function uc(t, e) {
                     if (!t) return t;
                     e || (e = t);
                     let n, i = t;
                     do {
-                        if (n = !1, i.steiner || !ul(i, i.next) && 0 !== hl(i.prev, i, i.next)) i = i.next;
+                        if (n = !1, i.steiner || !Ec(i, i.next) && 0 !== Sc(i.prev, i, i.next)) i = i.next;
                         else {
-                            if (xl(i), i = e = i.prev, i === i.next) break;
+                            if (Dc(i), i = e = i.prev, i === i.next) break;
                             n = !0
                         }
                     } while (n || i !== e);
                     return e
                 }
 
-                function Qo(t, e, n, i, r, s, a) {
+                function dc(t, e, n, i, r, s, a) {
                     if (!t) return;
                     !a && s && function(t, e, n, i) {
                         let r = t;
                         do {
-                            null === r.z && (r.z = al(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
+                            null === r.z && (r.z = _c(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                         } while (r !== t);
                         r.prevZ.nextZ = null, r.prevZ = null,
                             function(t) {
                                 let e, n, i, r, s, a, o, l, c = 1;
                                 do {
                                     for (n = t, t = null, s = null, a = 0; n;) {
                                         for (a++, i = n, o = 0, e = 0; e < c && (o++, i = i.nextZ, i); e++);
@@ -11014,93 +11382,93 @@
                                     }
                                     s.nextZ = null, c *= 2
                                 } while (a > 1)
                             }(r)
                     }(t, i, r, s);
                     let o, l, c = t;
                     for (; t.prev !== t.next;)
-                        if (o = t.prev, l = t.next, s ? tl(t, i, r, s) : $o(t)) e.push(o.i / n), e.push(t.i / n), e.push(l.i / n), xl(t), t = l.next, c = l.next;
+                        if (o = t.prev, l = t.next, s ? mc(t, i, r, s) : pc(t)) e.push(o.i / n), e.push(t.i / n), e.push(l.i / n), Dc(t), t = l.next, c = l.next;
                         else if ((t = l) === c) {
-                        a ? 1 === a ? Qo(t = el(Ko(t), e, n), e, n, i, r, s, 2) : 2 === a && nl(t, e, n, i, r, s) : Qo(Ko(t), e, n, i, r, s, 1);
+                        a ? 1 === a ? dc(t = fc(uc(t), e, n), e, n, i, r, s, 2) : 2 === a && gc(t, e, n, i, r, s) : dc(uc(t), e, n, i, r, s, 1);
                         break
                     }
                 }
 
-                function $o(t) {
+                function pc(t) {
                     const e = t.prev,
                         n = t,
                         i = t.next;
-                    if (hl(e, n, i) >= 0) return !1;
+                    if (Sc(e, n, i) >= 0) return !1;
                     let r = t.next.next;
                     for (; r !== t.prev;) {
-                        if (ll(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && hl(r.prev, r, r.next) >= 0) return !1;
+                        if (bc(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Sc(r.prev, r, r.next) >= 0) return !1;
                         r = r.next
                     }
                     return !0
                 }
 
-                function tl(t, e, n, i) {
+                function mc(t, e, n, i) {
                     const r = t.prev,
                         s = t,
                         a = t.next;
-                    if (hl(r, s, a) >= 0) return !1;
+                    if (Sc(r, s, a) >= 0) return !1;
                     const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x,
                         l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y,
                         c = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x,
                         h = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y,
-                        u = al(o, l, e, n, i),
-                        d = al(c, h, e, n, i);
+                        u = _c(o, l, e, n, i),
+                        d = _c(c, h, e, n, i);
                     let p = t.prevZ,
                         m = t.nextZ;
                     for (; p && p.z >= u && m && m.z <= d;) {
-                        if (p !== t.prev && p !== t.next && ll(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && hl(p.prev, p, p.next) >= 0) return !1;
-                        if (p = p.prevZ, m !== t.prev && m !== t.next && ll(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && hl(m.prev, m, m.next) >= 0) return !1;
+                        if (p !== t.prev && p !== t.next && bc(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Sc(p.prev, p, p.next) >= 0) return !1;
+                        if (p = p.prevZ, m !== t.prev && m !== t.next && bc(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Sc(m.prev, m, m.next) >= 0) return !1;
                         m = m.nextZ
                     }
                     for (; p && p.z >= u;) {
-                        if (p !== t.prev && p !== t.next && ll(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && hl(p.prev, p, p.next) >= 0) return !1;
+                        if (p !== t.prev && p !== t.next && bc(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Sc(p.prev, p, p.next) >= 0) return !1;
                         p = p.prevZ
                     }
                     for (; m && m.z <= d;) {
-                        if (m !== t.prev && m !== t.next && ll(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && hl(m.prev, m, m.next) >= 0) return !1;
+                        if (m !== t.prev && m !== t.next && bc(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Sc(m.prev, m, m.next) >= 0) return !1;
                         m = m.nextZ
                     }
                     return !0
                 }
 
-                function el(t, e, n) {
+                function fc(t, e, n) {
                     let i = t;
                     do {
                         const r = i.prev,
                             s = i.next.next;
-                        !ul(r, s) && dl(r, i, i.next, s) && fl(r, s) && fl(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), xl(i), xl(i.next), i = t = s), i = i.next
+                        !Ec(r, s) && Tc(r, i, i.next, s) && Lc(r, s) && Lc(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), Dc(i), Dc(i.next), i = t = s), i = i.next
                     } while (i !== t);
-                    return Ko(i)
+                    return uc(i)
                 }
 
-                function nl(t, e, n, i, r, s) {
+                function gc(t, e, n, i, r, s) {
                     let a = t;
                     do {
                         let t = a.next.next;
                         for (; t !== a.prev;) {
-                            if (a.i !== t.i && cl(a, t)) {
-                                let o = gl(a, t);
-                                return a = Ko(a, a.next), o = Ko(o, o.next), Qo(a, e, n, i, r, s), void Qo(o, e, n, i, r, s)
+                            if (a.i !== t.i && wc(a, t)) {
+                                let o = Cc(a, t);
+                                return a = uc(a, a.next), o = uc(o, o.next), dc(a, e, n, i, r, s), void dc(o, e, n, i, r, s)
                             }
                             t = t.next
                         }
                         a = a.next
                     } while (a !== t)
                 }
 
-                function il(t, e) {
+                function vc(t, e) {
                     return t.x - e.x
                 }
 
-                function rl(t, e) {
+                function xc(t, e) {
                     if (e = function(t, e) {
                             let n = e;
                             const i = t.x,
                                 r = t.y;
                             let s, a = -1 / 0;
                             do {
                                 if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
@@ -11119,165 +11487,165 @@
                             if (i === a) return s;
                             const o = s,
                                 l = s.x,
                                 c = s.y;
                             let h, u = 1 / 0;
                             n = s;
                             do {
-                                i >= n.x && n.x >= l && i !== n.x && ll(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), fl(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && sl(s, n))) && (s = n, u = h)), n = n.next
+                                i >= n.x && n.x >= l && i !== n.x && bc(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), Lc(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && yc(s, n))) && (s = n, u = h)), n = n.next
                             } while (n !== o);
                             return s
                         }(t, e), e) {
-                        const n = gl(e, t);
-                        Ko(e, e.next), Ko(n, n.next)
+                        const n = Cc(e, t);
+                        uc(e, e.next), uc(n, n.next)
                     }
                 }
 
-                function sl(t, e) {
-                    return hl(t.prev, t, e.prev) < 0 && hl(e.next, t, t.next) < 0
+                function yc(t, e) {
+                    return Sc(t.prev, t, e.prev) < 0 && Sc(e.next, t, t.next) < 0
                 }
 
-                function al(t, e, n, i, r) {
+                function _c(t, e, n, i, r) {
                     return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                 }
 
-                function ol(t) {
+                function Mc(t) {
                     let e = t,
                         n = t;
                     do {
                         (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                     } while (e !== t);
                     return n
                 }
 
-                function ll(t, e, n, i, r, s, a, o) {
+                function bc(t, e, n, i, r, s, a, o) {
                     return (r - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (i - o) - (n - a) * (e - o) >= 0 && (n - a) * (s - o) - (r - a) * (i - o) >= 0
                 }
 
-                function cl(t, e) {
+                function wc(t, e) {
                     return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                         let n = t;
                         do {
-                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && dl(n, n.next, t, e)) return !0;
+                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Tc(n, n.next, t, e)) return !0;
                             n = n.next
                         } while (n !== t);
                         return !1
-                    }(t, e) && (fl(t, e) && fl(e, t) && function(t, e) {
+                    }(t, e) && (Lc(t, e) && Lc(e, t) && function(t, e) {
                         let n = t,
                             i = !1;
                         const r = (t.x + e.x) / 2,
                             s = (t.y + e.y) / 2;
                         do {
                             n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                         } while (n !== t);
                         return i
-                    }(t, e) && (hl(t.prev, t, e.prev) || hl(t, e.prev, e)) || ul(t, e) && hl(t.prev, t, t.next) > 0 && hl(e.prev, e, e.next) > 0)
+                    }(t, e) && (Sc(t.prev, t, e.prev) || Sc(t, e.prev, e)) || Ec(t, e) && Sc(t.prev, t, t.next) > 0 && Sc(e.prev, e, e.next) > 0)
                 }
 
-                function hl(t, e, n) {
+                function Sc(t, e, n) {
                     return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
                 }
 
-                function ul(t, e) {
+                function Ec(t, e) {
                     return t.x === e.x && t.y === e.y
                 }
 
-                function dl(t, e, n, i) {
-                    const r = ml(hl(t, e, n)),
-                        s = ml(hl(t, e, i)),
-                        a = ml(hl(n, i, t)),
-                        o = ml(hl(n, i, e));
-                    return r !== s && a !== o || !(0 !== r || !pl(t, n, e)) || !(0 !== s || !pl(t, i, e)) || !(0 !== a || !pl(n, t, i)) || !(0 !== o || !pl(n, e, i))
+                function Tc(t, e, n, i) {
+                    const r = Rc(Sc(t, e, n)),
+                        s = Rc(Sc(t, e, i)),
+                        a = Rc(Sc(n, i, t)),
+                        o = Rc(Sc(n, i, e));
+                    return r !== s && a !== o || !(0 !== r || !Ac(t, n, e)) || !(0 !== s || !Ac(t, i, e)) || !(0 !== a || !Ac(n, t, i)) || !(0 !== o || !Ac(n, e, i))
                 }
 
-                function pl(t, e, n) {
+                function Ac(t, e, n) {
                     return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
                 }
 
-                function ml(t) {
+                function Rc(t) {
                     return t > 0 ? 1 : t < 0 ? -1 : 0
                 }
 
-                function fl(t, e) {
-                    return hl(t.prev, t, t.next) < 0 ? hl(t, e, t.next) >= 0 && hl(t, t.prev, e) >= 0 : hl(t, e, t.prev) < 0 || hl(t, t.next, e) < 0
+                function Lc(t, e) {
+                    return Sc(t.prev, t, t.next) < 0 ? Sc(t, e, t.next) >= 0 && Sc(t, t.prev, e) >= 0 : Sc(t, e, t.prev) < 0 || Sc(t, t.next, e) < 0
                 }
 
-                function gl(t, e) {
-                    const n = new yl(t.i, t.x, t.y),
-                        i = new yl(e.i, e.x, e.y),
+                function Cc(t, e) {
+                    const n = new Ic(t.i, t.x, t.y),
+                        i = new Ic(e.i, e.x, e.y),
                         r = t.next,
                         s = e.prev;
                     return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
                 }
 
-                function vl(t, e, n, i) {
-                    const r = new yl(t, e, n);
+                function Pc(t, e, n, i) {
+                    const r = new Ic(t, e, n);
                     return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
                 }
 
-                function xl(t) {
+                function Dc(t) {
                     t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                 }
 
-                function yl(t, e, n) {
+                function Ic(t, e, n) {
                     this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
                 }
-                class _l {
+                class Nc {
                     static area(t) {
                         const e = t.length;
                         let n = 0;
                         for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                         return .5 * n
                     }
                     static isClockWise(t) {
-                        return _l.area(t) < 0
+                        return Nc.area(t) < 0
                     }
                     static triangulateShape(t, e) {
                         const n = [],
                             i = [],
                             r = [];
-                        Ml(t), bl(n, t);
+                        Oc(t), Uc(n, t);
                         let s = t.length;
-                        e.forEach(Ml);
-                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, bl(n, e[t]);
+                        e.forEach(Oc);
+                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, Uc(n, e[t]);
                         const a = function(t, e, n = 2) {
                             const i = e && e.length,
                                 r = i ? e[0] * n : t.length;
-                            let s = Jo(t, 0, r, n, !0);
+                            let s = hc(t, 0, r, n, !0);
                             const a = [];
                             if (!s || s.next === s.prev) return a;
                             let o, l, c, h, u, d, p;
                             if (i && (s = function(t, e, n, i) {
                                     const r = [];
                                     let s, a, o, l, c;
-                                    for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : t.length, c = Jo(t, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(ol(c));
-                                    for (r.sort(il), s = 0; s < r.length; s++) rl(r[s], n), n = Ko(n, n.next);
+                                    for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : t.length, c = hc(t, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(Mc(c));
+                                    for (r.sort(vc), s = 0; s < r.length; s++) xc(r[s], n), n = uc(n, n.next);
                                     return n
                                 }(t, e, s, n)), t.length > 80 * n) {
                                 o = c = t[0], l = h = t[1];
                                 for (let e = n; e < r; e += n) u = t[e], d = t[e + 1], u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
                                 p = Math.max(c - o, h - l), p = 0 !== p ? 1 / p : 0
                             }
-                            return Qo(s, a, n, o, l, p), a
+                            return dc(s, a, n, o, l, p), a
                         }(n, i);
                         for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
                         return r
                     }
                 }
 
-                function Ml(t) {
+                function Oc(t) {
                     const e = t.length;
                     e > 2 && t[e - 1].equals(t[0]) && t.pop()
                 }
 
-                function bl(t, e) {
+                function Uc(t, e) {
                     for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
                 }
-                class wl extends Nn {
-                    constructor(t = new Zo([new At(.5, .5), new At(-.5, .5), new At(-.5, -.5), new At(.5, -.5)]), e = {}) {
+                class Bc extends Wi {
+                    constructor(t = new cc([new Be(.5, .5), new Be(-.5, .5), new Be(-.5, -.5), new Be(.5, -.5)]), e = {}) {
                         super(), this.type = "ExtrudeGeometry", this.parameters = {
                             shapes: t,
                             options: e
                         }, t = Array.isArray(t) ? t : [t];
                         const n = this,
                             i = [],
                             r = [];
@@ -11290,29 +11658,29 @@
                             let l = void 0 !== e.depth ? e.depth : 1,
                                 c = void 0 === e.bevelEnabled || e.bevelEnabled,
                                 h = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                                 u = void 0 !== e.bevelSize ? e.bevelSize : h - .1,
                                 d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                 p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                             const m = e.extrudePath,
-                                f = void 0 !== e.UVGenerator ? e.UVGenerator : Sl;
+                                f = void 0 !== e.UVGenerator ? e.UVGenerator : Fc;
                             void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                             let g, v, x, y, _, M = !1;
-                            m && (g = m.getSpacedPoints(o), M = !0, c = !1, v = m.computeFrenetFrames(o, !1), x = new Jt, y = new Jt, _ = new Jt), c || (p = 0, h = 0, u = 0, d = 0);
+                            m && (g = m.getSpacedPoints(o), M = !0, c = !1, v = m.computeFrenetFrames(o, !1), x = new on, y = new on, _ = new on), c || (p = 0, h = 0, u = 0, d = 0);
                             const b = t.extractPoints(a);
                             let w = b.shape;
                             const S = b.holes;
-                            if (!_l.isClockWise(w)) {
+                            if (!Nc.isClockWise(w)) {
                                 w = w.reverse();
                                 for (let t = 0, e = S.length; t < e; t++) {
                                     const e = S[t];
-                                    _l.isClockWise(e) && (S[t] = e.reverse())
+                                    Nc.isClockWise(e) && (S[t] = e.reverse())
                                 }
                             }
-                            const E = _l.triangulateShape(w, S),
+                            const E = Nc.triangulateShape(w, S),
                                 T = w;
                             for (let t = 0, e = S.length; t < e; t++) {
                                 const e = S[t];
                                 w = w.concat(e)
                             }
 
                             function A(t, e, n) {
@@ -11333,21 +11701,21 @@
                                     const u = Math.sqrt(h),
                                         d = Math.sqrt(l * l + c * c),
                                         p = e.x - o / u,
                                         m = e.y + a / u,
                                         f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (a * c - o * l);
                                     i = p + a * f - t.x, r = m + o * f - t.y;
                                     const g = i * i + r * r;
-                                    if (g <= 2) return new At(i, r);
+                                    if (g <= 2) return new Be(i, r);
                                     s = Math.sqrt(g / 2)
                                 } else {
                                     let t = !1;
                                     a > Number.EPSILON ? l > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(c) && (t = !0), t ? (i = -o, r = a, s = Math.sqrt(h)) : (i = a, r = o, s = Math.sqrt(h / 2))
                                 }
-                                return new At(i / s, r / s)
+                                return new Be(i / s, r / s)
                             }
                             const P = [];
                             for (let t = 0, e = T.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), P[t] = C(T[t], T[n], T[i]);
                             const D = [];
                             let I, N = P.concat();
                             for (let t = 0, e = S.length; t < e; t++) {
                                 const e = S[t];
@@ -11471,15 +11839,15 @@
                                 for (let t = 0, n = S.length; t < n; t++) {
                                     const n = S[t];
                                     U(n, e), e += n.length
                                 }
                                 n.addGroup(t, i.length / 3 - t, 1)
                             }()
                         }
-                        this.setAttribute("position", new En(i, 3)), this.setAttribute("uv", new En(r, 2)), this.computeVertexNormals()
+                        this.setAttribute("position", new Oi(i, 3)), this.setAttribute("uv", new Oi(r, 2)), this.computeVertexNormals()
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return function(t, e, n) {
                             if (n.shapes = [], Array.isArray(t))
                                 for (let e = 0, i = t.length; e < i; e++) {
                                     const i = t[e];
@@ -11491,74 +11859,74 @@
                     static fromJSON(t, e) {
                         const n = [];
                         for (let i = 0, r = t.shapes.length; i < r; i++) {
                             const r = e[t.shapes[i]];
                             n.push(r)
                         }
                         const i = t.options.extrudePath;
-                        return void 0 !== i && (t.options.extrudePath = (new Xo[i.type]).fromJSON(i)), new wl(n, t.options)
+                        return void 0 !== i && (t.options.extrudePath = (new ac[i.type]).fromJSON(i)), new Bc(n, t.options)
                     }
                 }
-                const Sl = {
+                const Fc = {
                     generateTopUV: function(t, e, n, i, r) {
                         const s = e[3 * n],
                             a = e[3 * n + 1],
                             o = e[3 * i],
                             l = e[3 * i + 1],
                             c = e[3 * r],
                             h = e[3 * r + 1];
-                        return [new At(s, a), new At(o, l), new At(c, h)]
+                        return [new Be(s, a), new Be(o, l), new Be(c, h)]
                     },
                     generateSideWallUV: function(t, e, n, i, r, s) {
                         const a = e[3 * n],
                             o = e[3 * n + 1],
                             l = e[3 * n + 2],
                             c = e[3 * i],
                             h = e[3 * i + 1],
                             u = e[3 * i + 2],
                             d = e[3 * r],
                             p = e[3 * r + 1],
                             m = e[3 * r + 2],
                             f = e[3 * s],
                             g = e[3 * s + 1],
                             v = e[3 * s + 2];
-                        return Math.abs(o - h) < Math.abs(a - c) ? [new At(a, 1 - l), new At(c, 1 - u), new At(d, 1 - m), new At(f, 1 - v)] : [new At(o, 1 - l), new At(h, 1 - u), new At(p, 1 - m), new At(g, 1 - v)]
+                        return Math.abs(o - h) < Math.abs(a - c) ? [new Be(a, 1 - l), new Be(c, 1 - u), new Be(d, 1 - m), new Be(f, 1 - v)] : [new Be(o, 1 - l), new Be(h, 1 - u), new Be(p, 1 - m), new Be(g, 1 - v)]
                     }
                 };
-                class El extends _o {
+                class zc extends Nl {
                     constructor(t = 1, e = 0) {
                         const n = (1 + Math.sqrt(5)) / 2;
                         super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = {
                             radius: t,
                             detail: e
                         }
                     }
                     static fromJSON(t) {
-                        return new El(t.radius, t.detail)
+                        return new zc(t.radius, t.detail)
                     }
                 }
-                class Tl extends Nn {
-                    constructor(t = [new At(0, .5), new At(.5, 0), new At(0, -.5)], e = 12, n = 0, i = 2 * Math.PI) {
+                class Hc extends Wi {
+                    constructor(t = [new Be(0, .5), new Be(.5, 0), new Be(0, -.5)], e = 12, n = 0, i = 2 * Math.PI) {
                         super(), this.type = "LatheGeometry", this.parameters = {
                             points: t,
                             segments: e,
                             phiStart: n,
                             phiLength: i
-                        }, e = Math.floor(e), i = _t(i, 0, 2 * Math.PI);
+                        }, e = Math.floor(e), i = Ce(i, 0, 2 * Math.PI);
                         const r = [],
                             s = [],
                             a = [],
                             o = [],
                             l = [],
                             c = 1 / e,
-                            h = new Jt,
-                            u = new At,
-                            d = new Jt,
-                            p = new Jt,
-                            m = new Jt;
+                            h = new on,
+                            u = new Be,
+                            d = new on,
+                            p = new on,
+                            m = new on;
                         let f = 0,
                             g = 0;
                         for (let e = 0; e <= t.length - 1; e++) switch (e) {
                             case 0:
                                 f = t[e + 1].x - t[e].x, g = t[e + 1].y - t[e].y, d.x = 1 * g, d.y = -f, d.z = 0 * g, m.copy(d), d.normalize(), o.push(d.x, d.y, d.z);
                                 break;
                             case t.length - 1:
@@ -11584,32 +11952,32 @@
                                 const i = e + n * t.length,
                                     s = i,
                                     a = i + t.length,
                                     o = i + t.length + 1,
                                     l = i + 1;
                                 r.push(s, a, l), r.push(o, l, a)
                             }
-                        this.setIndex(r), this.setAttribute("position", new En(s, 3)), this.setAttribute("uv", new En(a, 2)), this.setAttribute("normal", new En(l, 3))
+                        this.setIndex(r), this.setAttribute("position", new Oi(s, 3)), this.setAttribute("uv", new Oi(a, 2)), this.setAttribute("normal", new Oi(l, 3))
                     }
                     static fromJSON(t) {
-                        return new Tl(t.points, t.segments, t.phiStart, t.phiLength)
+                        return new Hc(t.points, t.segments, t.phiStart, t.phiLength)
                     }
                 }
-                class Al extends _o {
+                class Gc extends Nl {
                     constructor(t = 1, e = 0) {
                         super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = {
                             radius: t,
                             detail: e
                         }
                     }
                     static fromJSON(t) {
-                        return new Al(t.radius, t.detail)
+                        return new Gc(t.radius, t.detail)
                     }
                 }
-                class Rl extends Nn {
+                class Vc extends Wi {
                     constructor(t = .5, e = 1, n = 8, i = 1, r = 0, s = 2 * Math.PI) {
                         super(), this.type = "RingGeometry", this.parameters = {
                             innerRadius: t,
                             outerRadius: e,
                             thetaSegments: n,
                             phiSegments: i,
                             thetaStart: r,
@@ -11617,16 +11985,16 @@
                         }, n = Math.max(3, n);
                         const a = [],
                             o = [],
                             l = [],
                             c = [];
                         let h = t;
                         const u = (e - t) / (i = Math.max(1, i)),
-                            d = new Jt,
-                            p = new At;
+                            d = new on,
+                            p = new Be;
                         for (let t = 0; t <= i; t++) {
                             for (let t = 0; t <= n; t++) {
                                 const i = r + t / n * s;
                                 d.x = h * Math.cos(i), d.y = h * Math.sin(i), o.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / e + 1) / 2, p.y = (d.y / e + 1) / 2, c.push(p.x, p.y)
                             }
                             h += u
                         }
@@ -11637,22 +12005,22 @@
                                     r = i,
                                     s = i + n + 1,
                                     o = i + n + 2,
                                     l = i + 1;
                                 a.push(r, s, l), a.push(s, o, l)
                             }
                         }
-                        this.setIndex(a), this.setAttribute("position", new En(o, 3)), this.setAttribute("normal", new En(l, 3)), this.setAttribute("uv", new En(c, 2))
+                        this.setIndex(a), this.setAttribute("position", new Oi(o, 3)), this.setAttribute("normal", new Oi(l, 3)), this.setAttribute("uv", new Oi(c, 2))
                     }
                     static fromJSON(t) {
-                        return new Rl(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
+                        return new Vc(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
                     }
                 }
-                class Ll extends Nn {
-                    constructor(t = new Zo([new At(0, .5), new At(-.5, -.5), new At(.5, -.5)]), e = 12) {
+                class kc extends Wi {
+                    constructor(t = new cc([new Be(0, .5), new Be(-.5, -.5), new Be(.5, -.5)]), e = 12) {
                         super(), this.type = "ShapeGeometry", this.parameters = {
                             shapes: t,
                             curveSegments: e
                         };
                         const n = [],
                             i = [],
                             r = [],
@@ -11664,20 +12032,20 @@
                             for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(a, o, e), a += o, o = 0;
 
                         function l(t) {
                             const a = i.length / 3,
                                 l = t.extractPoints(e);
                             let c = l.shape;
                             const h = l.holes;
-                            !1 === _l.isClockWise(c) && (c = c.reverse());
+                            !1 === Nc.isClockWise(c) && (c = c.reverse());
                             for (let t = 0, e = h.length; t < e; t++) {
                                 const e = h[t];
-                                !0 === _l.isClockWise(e) && (h[t] = e.reverse())
+                                !0 === Nc.isClockWise(e) && (h[t] = e.reverse())
                             }
-                            const u = _l.triangulateShape(c, h);
+                            const u = Nc.triangulateShape(c, h);
                             for (let t = 0, e = h.length; t < e; t++) {
                                 const e = h[t];
                                 c = c.concat(e)
                             }
                             for (let t = 0, e = c.length; t < e; t++) {
                                 const e = c[t];
                                 i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
@@ -11686,15 +12054,15 @@
                                 const e = u[t],
                                     i = e[0] + a,
                                     r = e[1] + a,
                                     s = e[2] + a;
                                 n.push(i, r, s), o += 3
                             }
                         }
-                        this.setIndex(n), this.setAttribute("position", new En(i, 3)), this.setAttribute("normal", new En(r, 3)), this.setAttribute("uv", new En(s, 2))
+                        this.setIndex(n), this.setAttribute("position", new Oi(i, 3)), this.setAttribute("normal", new Oi(r, 3)), this.setAttribute("uv", new Oi(s, 2))
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return function(t, e) {
                             if (e.shapes = [], Array.isArray(t))
                                 for (let n = 0, i = t.length; n < i; n++) {
                                     const i = t[n];
@@ -11705,33 +12073,33 @@
                     }
                     static fromJSON(t, e) {
                         const n = [];
                         for (let i = 0, r = t.shapes.length; i < r; i++) {
                             const r = e[t.shapes[i]];
                             n.push(r)
                         }
-                        return new Ll(n, t.curveSegments)
+                        return new kc(n, t.curveSegments)
                     }
                 }
-                class Cl extends Nn {
+                class Wc extends Wi {
                     constructor(t = 1, e = 32, n = 16, i = 0, r = 2 * Math.PI, s = 0, a = Math.PI) {
                         super(), this.type = "SphereGeometry", this.parameters = {
                             radius: t,
                             widthSegments: e,
                             heightSegments: n,
                             phiStart: i,
                             phiLength: r,
                             thetaStart: s,
                             thetaLength: a
                         }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
                         const o = Math.min(s + a, Math.PI);
                         let l = 0;
                         const c = [],
-                            h = new Jt,
-                            u = new Jt,
+                            h = new on,
+                            u = new on,
                             d = [],
                             p = [],
                             m = [],
                             f = [];
                         for (let d = 0; d <= n; d++) {
                             const g = [],
                                 v = d / n;
@@ -11747,88 +12115,88 @@
                             for (let i = 0; i < e; i++) {
                                 const e = c[t][i + 1],
                                     r = c[t][i],
                                     a = c[t + 1][i],
                                     l = c[t + 1][i + 1];
                                 (0 !== t || s > 0) && d.push(e, r, l), (t !== n - 1 || o < Math.PI) && d.push(r, a, l)
                             }
-                        this.setIndex(d), this.setAttribute("position", new En(p, 3)), this.setAttribute("normal", new En(m, 3)), this.setAttribute("uv", new En(f, 2))
+                        this.setIndex(d), this.setAttribute("position", new Oi(p, 3)), this.setAttribute("normal", new Oi(m, 3)), this.setAttribute("uv", new Oi(f, 2))
                     }
                     static fromJSON(t) {
-                        return new Cl(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
+                        return new Wc(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
                     }
                 }
-                class Pl extends _o {
+                class jc extends Nl {
                     constructor(t = 1, e = 0) {
                         super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = {
                             radius: t,
                             detail: e
                         }
                     }
                     static fromJSON(t) {
-                        return new Pl(t.radius, t.detail)
+                        return new jc(t.radius, t.detail)
                     }
                 }
-                class Dl extends Nn {
+                class Xc extends Wi {
                     constructor(t = 1, e = .4, n = 8, i = 6, r = 2 * Math.PI) {
                         super(), this.type = "TorusGeometry", this.parameters = {
                             radius: t,
                             tube: e,
                             radialSegments: n,
                             tubularSegments: i,
                             arc: r
                         }, n = Math.floor(n), i = Math.floor(i);
                         const s = [],
                             a = [],
                             o = [],
                             l = [],
-                            c = new Jt,
-                            h = new Jt,
-                            u = new Jt;
+                            c = new on,
+                            h = new on,
+                            u = new on;
                         for (let s = 0; s <= n; s++)
                             for (let d = 0; d <= i; d++) {
                                 const p = d / i * r,
                                     m = s / n * Math.PI * 2;
                                 h.x = (t + e * Math.cos(m)) * Math.cos(p), h.y = (t + e * Math.cos(m)) * Math.sin(p), h.z = e * Math.sin(m), a.push(h.x, h.y, h.z), c.x = t * Math.cos(p), c.y = t * Math.sin(p), u.subVectors(h, c).normalize(), o.push(u.x, u.y, u.z), l.push(d / i), l.push(s / n)
                             }
                         for (let t = 1; t <= n; t++)
                             for (let e = 1; e <= i; e++) {
                                 const n = (i + 1) * t + e - 1,
                                     r = (i + 1) * (t - 1) + e - 1,
                                     a = (i + 1) * (t - 1) + e,
                                     o = (i + 1) * t + e;
                                 s.push(n, r, o), s.push(r, a, o)
                             }
-                        this.setIndex(s), this.setAttribute("position", new En(a, 3)), this.setAttribute("normal", new En(o, 3)), this.setAttribute("uv", new En(l, 2))
+                        this.setIndex(s), this.setAttribute("position", new Oi(a, 3)), this.setAttribute("normal", new Oi(o, 3)), this.setAttribute("uv", new Oi(l, 2))
                     }
                     static fromJSON(t) {
-                        return new Dl(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
+                        return new Xc(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
                     }
                 }
-                class Il extends Nn {
+                class qc extends Wi {
                     constructor(t = 1, e = .4, n = 64, i = 8, r = 2, s = 3) {
                         super(), this.type = "TorusKnotGeometry", this.parameters = {
                             radius: t,
                             tube: e,
                             tubularSegments: n,
                             radialSegments: i,
                             p: r,
                             q: s
                         }, n = Math.floor(n), i = Math.floor(i);
                         const a = [],
                             o = [],
                             l = [],
                             c = [],
-                            h = new Jt,
-                            u = new Jt,
-                            d = new Jt,
-                            p = new Jt,
-                            m = new Jt,
-                            f = new Jt,
-                            g = new Jt;
+                            h = new on,
+                            u = new on,
+                            d = new on,
+                            p = new on,
+                            m = new on,
+                            f = new on,
+                            g = new on;
                         for (let a = 0; a <= n; ++a) {
                             const x = a / n * r * Math.PI * 2;
                             v(x, r, s, t, d), v(x + .01, r, s, t, p), f.subVectors(p, d), g.addVectors(p, d), m.crossVectors(f, g), g.crossVectors(m, f), m.normalize(), g.normalize();
                             for (let t = 0; t <= i; ++t) {
                                 const r = t / i * Math.PI * 2,
                                     s = -e * Math.cos(r),
                                     p = e * Math.sin(r);
@@ -11847,35 +12215,35 @@
                         function v(t, e, n, i, r) {
                             const s = Math.cos(t),
                                 a = Math.sin(t),
                                 o = n / e * t,
                                 l = Math.cos(o);
                             r.x = i * (2 + l) * .5 * s, r.y = i * (2 + l) * a * .5, r.z = i * Math.sin(o) * .5
                         }
-                        this.setIndex(a), this.setAttribute("position", new En(o, 3)), this.setAttribute("normal", new En(l, 3)), this.setAttribute("uv", new En(c, 2))
+                        this.setIndex(a), this.setAttribute("position", new Oi(o, 3)), this.setAttribute("normal", new Oi(l, 3)), this.setAttribute("uv", new Oi(c, 2))
                     }
                     static fromJSON(t) {
-                        return new Il(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q)
+                        return new qc(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q)
                     }
                 }
-                class Nl extends Nn {
-                    constructor(t = new Wo(new Jt(-1, -1, 0), new Jt(-1, 1, 0), new Jt(1, 1, 0)), e = 64, n = 1, i = 8, r = !1) {
+                class Yc extends Wi {
+                    constructor(t = new rc(new on(-1, -1, 0), new on(-1, 1, 0), new on(1, 1, 0)), e = 64, n = 1, i = 8, r = !1) {
                         super(), this.type = "TubeGeometry", this.parameters = {
                             path: t,
                             tubularSegments: e,
                             radius: n,
                             radialSegments: i,
                             closed: r
                         };
                         const s = t.computeFrenetFrames(e, r);
                         this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
-                        const a = new Jt,
-                            o = new Jt,
-                            l = new At;
-                        let c = new Jt;
+                        const a = new on,
+                            o = new on,
+                            l = new Be;
+                        let c = new on;
                         const h = [],
                             u = [],
                             d = [],
                             p = [];
 
                         function m(r) {
                             c = t.getPointAt(r / e, c);
@@ -11900,33 +12268,33 @@
                                             const n = (i + 1) * (t - 1) + (e - 1),
                                                 r = (i + 1) * t + (e - 1),
                                                 s = (i + 1) * t + e,
                                                 a = (i + 1) * (t - 1) + e;
                                             p.push(n, r, a), p.push(r, s, a)
                                         }
                                 }()
-                        }(), this.setIndex(p), this.setAttribute("position", new En(h, 3)), this.setAttribute("normal", new En(u, 3)), this.setAttribute("uv", new En(d, 2))
+                        }(), this.setIndex(p), this.setAttribute("position", new Oi(h, 3)), this.setAttribute("normal", new Oi(u, 3)), this.setAttribute("uv", new Oi(d, 2))
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.path = this.parameters.path.toJSON(), t
                     }
                     static fromJSON(t) {
-                        return new Nl((new Xo[t.path.type]).fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed)
+                        return new Yc((new ac[t.path.type]).fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed)
                     }
                 }
-                class Ol extends Nn {
+                class Zc extends Wi {
                     constructor(t = null) {
                         if (super(), this.type = "WireframeGeometry", this.parameters = {
                                 geometry: t
                             }, null !== t) {
                             const e = [],
                                 n = new Set,
-                                i = new Jt,
-                                r = new Jt;
+                                i = new on,
+                                r = new on;
                             if (null !== t.index) {
                                 const s = t.attributes.position,
                                     a = t.index;
                                 let o = t.groups;
                                 0 === o.length && (o = [{
                                     start: 0,
                                     count: a.count,
@@ -11935,112 +12303,112 @@
                                 for (let t = 0, l = o.length; t < l; ++t) {
                                     const l = o[t],
                                         c = l.start;
                                     for (let t = c, o = c + l.count; t < o; t += 3)
                                         for (let o = 0; o < 3; o++) {
                                             const l = a.getX(t + o),
                                                 c = a.getX(t + (o + 1) % 3);
-                                            i.fromBufferAttribute(s, l), r.fromBufferAttribute(s, c), !0 === Ul(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
+                                            i.fromBufferAttribute(s, l), r.fromBufferAttribute(s, c), !0 === Jc(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
                                         }
                                 }
                             } else {
                                 const s = t.attributes.position;
                                 for (let t = 0, a = s.count / 3; t < a; t++)
                                     for (let a = 0; a < 3; a++) {
                                         const o = 3 * t + a,
                                             l = 3 * t + (a + 1) % 3;
-                                        i.fromBufferAttribute(s, o), r.fromBufferAttribute(s, l), !0 === Ul(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
+                                        i.fromBufferAttribute(s, o), r.fromBufferAttribute(s, l), !0 === Jc(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
                                     }
                             }
-                            this.setAttribute("position", new En(e, 3))
+                            this.setAttribute("position", new Oi(e, 3))
                         }
                     }
                 }
 
-                function Ul(t, e, n) {
+                function Jc(t, e, n) {
                     const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
                         r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
                     return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i, r), !0)
                 }
-                var Bl = Object.freeze({
+                var Kc = Object.freeze({
                     __proto__: null,
-                    BoxGeometry: ti,
-                    BoxBufferGeometry: ti,
-                    CircleGeometry: vo,
-                    CircleBufferGeometry: vo,
-                    ConeGeometry: yo,
-                    ConeBufferGeometry: yo,
-                    CylinderGeometry: xo,
-                    CylinderBufferGeometry: xo,
-                    DodecahedronGeometry: Mo,
-                    DodecahedronBufferGeometry: Mo,
-                    EdgesGeometry: To,
-                    ExtrudeGeometry: wl,
-                    ExtrudeBufferGeometry: wl,
-                    IcosahedronGeometry: El,
-                    IcosahedronBufferGeometry: El,
-                    LatheGeometry: Tl,
-                    LatheBufferGeometry: Tl,
-                    OctahedronGeometry: Al,
-                    OctahedronBufferGeometry: Al,
-                    PlaneGeometry: _i,
-                    PlaneBufferGeometry: _i,
-                    PolyhedronGeometry: _o,
-                    PolyhedronBufferGeometry: _o,
-                    RingGeometry: Rl,
-                    RingBufferGeometry: Rl,
-                    ShapeGeometry: Ll,
-                    ShapeBufferGeometry: Ll,
-                    SphereGeometry: Cl,
-                    SphereBufferGeometry: Cl,
-                    TetrahedronGeometry: Pl,
-                    TetrahedronBufferGeometry: Pl,
-                    TorusGeometry: Dl,
-                    TorusBufferGeometry: Dl,
-                    TorusKnotGeometry: Il,
-                    TorusKnotBufferGeometry: Il,
-                    TubeGeometry: Nl,
-                    TubeBufferGeometry: Nl,
-                    WireframeGeometry: Ol
+                    BoxGeometry: hr,
+                    BoxBufferGeometry: hr,
+                    CircleGeometry: Pl,
+                    CircleBufferGeometry: Pl,
+                    ConeGeometry: Il,
+                    ConeBufferGeometry: Il,
+                    CylinderGeometry: Dl,
+                    CylinderBufferGeometry: Dl,
+                    DodecahedronGeometry: Ol,
+                    DodecahedronBufferGeometry: Ol,
+                    EdgesGeometry: Hl,
+                    ExtrudeGeometry: Bc,
+                    ExtrudeBufferGeometry: Bc,
+                    IcosahedronGeometry: zc,
+                    IcosahedronBufferGeometry: zc,
+                    LatheGeometry: Hc,
+                    LatheBufferGeometry: Hc,
+                    OctahedronGeometry: Gc,
+                    OctahedronBufferGeometry: Gc,
+                    PlaneGeometry: Cr,
+                    PlaneBufferGeometry: Cr,
+                    PolyhedronGeometry: Nl,
+                    PolyhedronBufferGeometry: Nl,
+                    RingGeometry: Vc,
+                    RingBufferGeometry: Vc,
+                    ShapeGeometry: kc,
+                    ShapeBufferGeometry: kc,
+                    SphereGeometry: Wc,
+                    SphereBufferGeometry: Wc,
+                    TetrahedronGeometry: jc,
+                    TetrahedronBufferGeometry: jc,
+                    TorusGeometry: Xc,
+                    TorusBufferGeometry: Xc,
+                    TorusKnotGeometry: qc,
+                    TorusKnotBufferGeometry: qc,
+                    TubeGeometry: Yc,
+                    TubeBufferGeometry: Yc,
+                    WireframeGeometry: Zc
                 });
-                class Fl extends dn {
+                class Qc extends bi {
                     constructor(t) {
-                        super(), this.type = "ShadowMaterial", this.color = new zt(0), this.transparent = !0, this.setValues(t)
+                        super(), this.type = "ShadowMaterial", this.color = new Ze(0), this.transparent = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this
                     }
                 }
-                Fl.prototype.isShadowMaterial = !0;
-                class zl extends dn {
+                Qc.prototype.isShadowMaterial = !0;
+                class $c extends bi {
                     constructor(t) {
                         super(), this.defines = {
                             STANDARD: ""
-                        }, this.type = "MeshStandardMaterial", this.color = new zt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new At(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
+                        }, this.type = "MeshStandardMaterial", this.color = new Ze(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ve, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.defines = {
                             STANDARD: ""
                         }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                     }
                 }
-                zl.prototype.isMeshStandardMaterial = !0;
-                class Hl extends zl {
+                $c.prototype.isMeshStandardMaterial = !0;
+                class th extends $c {
                     constructor(t) {
                         super(), this.defines = {
                             STANDARD: "",
                             PHYSICAL: ""
-                        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new At(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
+                        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Be(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                             get: function() {
-                                return _t(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
+                                return Ce(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                             },
                             set: function(t) {
                                 this.ior = (1 + .4 * t) / (1 - .4 * t)
                             }
-                        }), this.sheenColor = new zt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new zt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new zt(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
+                        }), this.sheenColor = new Ze(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Ze(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ze(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
                     }
                     get sheen() {
                         return this._sheen
                     }
                     set sheen(t) {
                         this._sheen > 0 != t > 0 && this.version++, this._sheen = t
                     }
@@ -12059,99 +12427,99 @@
                     copy(t) {
                         return super.copy(t), this.defines = {
                             STANDARD: "",
                             PHYSICAL: ""
                         }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
                     }
                 }
-                Hl.prototype.isMeshPhysicalMaterial = !0;
-                class Gl extends dn {
+                th.prototype.isMeshPhysicalMaterial = !0;
+                class eh extends bi {
                     constructor(t) {
-                        super(), this.type = "MeshPhongMaterial", this.color = new zt(16777215), this.specular = new zt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new At(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
+                        super(), this.type = "MeshPhongMaterial", this.color = new Ze(16777215), this.specular = new Ze(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ve, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                     }
                 }
-                Gl.prototype.isMeshPhongMaterial = !0;
-                class Vl extends dn {
+                eh.prototype.isMeshPhongMaterial = !0;
+                class nh extends bi {
                     constructor(t) {
                         super(), this.defines = {
                             TOON: ""
-                        }, this.type = "MeshToonMaterial", this.color = new zt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new At(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        }, this.type = "MeshToonMaterial", this.color = new Ze(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ve, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }
-                Vl.prototype.isMeshToonMaterial = !0;
-                class kl extends dn {
+                nh.prototype.isMeshToonMaterial = !0;
+                class ih extends bi {
                     constructor(t) {
-                        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new At(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
+                        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ve, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
                     }
                 }
-                kl.prototype.isMeshNormalMaterial = !0;
-                class Wl extends dn {
+                ih.prototype.isMeshNormalMaterial = !0;
+                class rh extends bi {
                     constructor(t) {
-                        super(), this.type = "MeshLambertMaterial", this.color = new zt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        super(), this.type = "MeshLambertMaterial", this.color = new Ze(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }
-                Wl.prototype.isMeshLambertMaterial = !0;
-                class jl extends dn {
+                rh.prototype.isMeshLambertMaterial = !0;
+                class sh extends bi {
                     constructor(t) {
                         super(), this.defines = {
                             MATCAP: ""
-                        }, this.type = "MeshMatcapMaterial", this.color = new zt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new At(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
+                        }, this.type = "MeshMatcapMaterial", this.color = new Ze(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ve, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.defines = {
                             MATCAP: ""
                         }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this
                     }
                 }
-                jl.prototype.isMeshMatcapMaterial = !0;
-                class Xl extends Ya {
+                sh.prototype.isMeshMatcapMaterial = !0;
+                class ah extends cl {
                     constructor(t) {
                         super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
                     }
                 }
-                Xl.prototype.isLineDashedMaterial = !0;
-                var ql = Object.freeze({
+                ah.prototype.isLineDashedMaterial = !0;
+                var oh = Object.freeze({
                     __proto__: null,
-                    ShadowMaterial: Fl,
-                    SpriteMaterial: da,
-                    RawShaderMaterial: Pi,
-                    ShaderMaterial: ri,
-                    PointsMaterial: so,
-                    MeshPhysicalMaterial: Hl,
-                    MeshStandardMaterial: zl,
-                    MeshPhongMaterial: Gl,
-                    MeshToonMaterial: Vl,
-                    MeshNormalMaterial: kl,
-                    MeshLambertMaterial: Wl,
-                    MeshDepthMaterial: js,
-                    MeshDistanceMaterial: Xs,
-                    MeshBasicMaterial: pn,
-                    MeshMatcapMaterial: jl,
-                    LineDashedMaterial: Xl,
-                    LineBasicMaterial: Ya,
-                    Material: dn
+                    ShadowMaterial: Qc,
+                    SpriteMaterial: Ao,
+                    RawShaderMaterial: Gr,
+                    ShaderMaterial: mr,
+                    PointsMaterial: _l,
+                    MeshPhysicalMaterial: th,
+                    MeshStandardMaterial: $c,
+                    MeshPhongMaterial: eh,
+                    MeshToonMaterial: nh,
+                    MeshNormalMaterial: ih,
+                    MeshLambertMaterial: rh,
+                    MeshDepthMaterial: io,
+                    MeshDistanceMaterial: ro,
+                    MeshBasicMaterial: wi,
+                    MeshMatcapMaterial: sh,
+                    LineDashedMaterial: ah,
+                    LineBasicMaterial: cl,
+                    Material: bi
                 });
-                const Yl = {
+                const lh = {
                     arraySlice: function(t, e, n) {
-                        return Yl.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
+                        return lh.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                     },
                     convertArray: function(t, e, n) {
                         return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                     },
                     isTypedArray: function(t) {
                         return ArrayBuffer.isView(t) && !(t instanceof DataView)
                     },
@@ -12204,15 +12572,15 @@
                             for (let t = 0; t < e.times.length; ++t) {
                                 const s = e.times[t] * r;
                                 if (!(s < n || s >= i)) {
                                     l.push(e.times[t]);
                                     for (let n = 0; n < o; ++n) c.push(e.values[t * o + n])
                                 }
                             }
-                            0 !== l.length && (e.times = Yl.convertArray(l, e.times.constructor), e.values = Yl.convertArray(c, e.values.constructor), a.push(e))
+                            0 !== l.length && (e.times = lh.convertArray(l, e.times.constructor), e.values = lh.convertArray(c, e.values.constructor), a.push(e))
                         }
                         s.tracks = a;
                         let o = 1 / 0;
                         for (let t = 0; t < s.tracks.length; ++t) o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
                         for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);
                         return s.resetDuration(), s
                     },
@@ -12235,40 +12603,40 @@
                             const h = a.getValueSize();
                             a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                             const u = i.times.length - 1;
                             let d;
                             if (s <= i.times[0]) {
                                 const t = o,
                                     e = l - o;
-                                d = Yl.arraySlice(i.values, t, e)
+                                d = lh.arraySlice(i.values, t, e)
                             } else if (s >= i.times[u]) {
                                 const t = u * l + o,
                                     e = t + l - o;
-                                d = Yl.arraySlice(i.values, t, e)
+                                d = lh.arraySlice(i.values, t, e)
                             } else {
                                 const t = i.createInterpolant(),
                                     e = o,
                                     n = l - o;
-                                t.evaluate(s), d = Yl.arraySlice(t.resultBuffer, e, n)
+                                t.evaluate(s), d = lh.arraySlice(t.resultBuffer, e, n)
                             }
-                            "quaternion" === r && (new Zt).fromArray(d).normalize().conjugate().toArray(d);
+                            "quaternion" === r && (new an).fromArray(d).normalize().conjugate().toArray(d);
                             const p = a.times.length;
                             for (let t = 0; t < p; ++t) {
                                 const e = t * h + c;
-                                if ("quaternion" === r) Zt.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
+                                if ("quaternion" === r) an.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                                 else {
                                     const t = h - 2 * c;
                                     for (let n = 0; n < t; ++n) a.values[e + n] -= d[n]
                                 }
                             }
                         }
-                        return t.blendMode = at, t
+                        return t.blendMode = pe, t
                     }
                 };
-                class Zl {
+                class ch {
                     constructor(t, e, n, i) {
                         this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                     }
                     evaluate(t) {
                         const e = this.parameterPositions;
                         let n = this._cachedIndex,
                             i = e[n],
@@ -12325,43 +12693,43 @@
                         return e
                     }
                     interpolate_() {
                         throw new Error("call to abstract method")
                     }
                     intervalChanged_() {}
                 }
-                Zl.prototype.beforeStart_ = Zl.prototype.copySampleValue_, Zl.prototype.afterEnd_ = Zl.prototype.copySampleValue_;
-                class Jl extends Zl {
+                ch.prototype.beforeStart_ = ch.prototype.copySampleValue_, ch.prototype.afterEnd_ = ch.prototype.copySampleValue_;
+                class hh extends ch {
                     constructor(t, e, n, i) {
                         super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
-                            endingStart: it,
-                            endingEnd: it
+                            endingStart: he,
+                            endingEnd: he
                         }
                     }
                     intervalChanged_(t, e, n) {
                         const i = this.parameterPositions;
                         let r = t - 2,
                             s = t + 1,
                             a = i[r],
                             o = i[s];
                         if (void 0 === a) switch (this.getSettings_().endingStart) {
-                            case rt:
+                            case ue:
                                 r = t, a = 2 * e - n;
                                 break;
-                            case st:
+                            case de:
                                 r = i.length - 2, a = e + i[r] - i[r + 1];
                                 break;
                             default:
                                 r = t, a = n
                         }
                         if (void 0 === o) switch (this.getSettings_().endingEnd) {
-                            case rt:
+                            case ue:
                                 s = t, o = 2 * n - e;
                                 break;
-                            case st:
+                            case de:
                                 s = 1, o = n + i[1] - i[0];
                                 break;
                             default:
                                 s = t - 1, o = e
                         }
                         const l = .5 * (n - e),
                             c = this.valueSize;
@@ -12384,15 +12752,15 @@
                             v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                             x = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                             y = d * f - d * m;
                         for (let t = 0; t !== a; ++t) r[t] = g * s[c + t] + v * s[l + t] + x * s[o + t] + y * s[h + t];
                         return r
                     }
                 }
-                class Kl extends Zl {
+                class uh extends ch {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t, e, n, i) {
                         const r = this.resultBuffer,
                             s = this.sampleValues,
                             a = this.valueSize,
@@ -12400,62 +12768,62 @@
                             l = o - a,
                             c = (n - e) / (i - e),
                             h = 1 - c;
                         for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;
                         return r
                     }
                 }
-                class Ql extends Zl {
+                class dh extends ch {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t) {
                         return this.copySampleValue_(t - 1)
                     }
                 }
-                class $l {
+                class ph {
                     constructor(t, e, n, i) {
                         if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                         if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
-                        this.name = t, this.times = Yl.convertArray(e, this.TimeBufferType), this.values = Yl.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
+                        this.name = t, this.times = lh.convertArray(e, this.TimeBufferType), this.values = lh.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                     }
                     static toJSON(t) {
                         const e = t.constructor;
                         let n;
                         if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                         else {
                             n = {
                                 name: t.name,
-                                times: Yl.convertArray(t.times, Array),
-                                values: Yl.convertArray(t.values, Array)
+                                times: lh.convertArray(t.times, Array),
+                                values: lh.convertArray(t.values, Array)
                             };
                             const e = t.getInterpolation();
                             e !== t.DefaultInterpolation && (n.interpolation = e)
                         }
                         return n.type = t.ValueTypeName, n
                     }
                     InterpolantFactoryMethodDiscrete(t) {
-                        return new Ql(this.times, this.values, this.getValueSize(), t)
+                        return new dh(this.times, this.values, this.getValueSize(), t)
                     }
                     InterpolantFactoryMethodLinear(t) {
-                        return new Kl(this.times, this.values, this.getValueSize(), t)
+                        return new uh(this.times, this.values, this.getValueSize(), t)
                     }
                     InterpolantFactoryMethodSmooth(t) {
-                        return new Jl(this.times, this.values, this.getValueSize(), t)
+                        return new hh(this.times, this.values, this.getValueSize(), t)
                     }
                     setInterpolation(t) {
                         let e;
                         switch (t) {
-                            case tt:
+                            case oe:
                                 e = this.InterpolantFactoryMethodDiscrete;
                                 break;
-                            case et:
+                            case le:
                                 e = this.InterpolantFactoryMethodLinear;
                                 break;
-                            case nt:
+                            case ce:
                                 e = this.InterpolantFactoryMethodSmooth
                         }
                         if (void 0 === e) {
                             const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                             if (void 0 === this.createInterpolant) {
                                 if (t === this.DefaultInterpolation) throw new Error(e);
                                 this.setInterpolation(this.DefaultInterpolation)
@@ -12463,19 +12831,19 @@
                             return console.warn("THREE.KeyframeTrack:", e), this
                         }
                         return this.createInterpolant = e, this
                     }
                     getInterpolation() {
                         switch (this.createInterpolant) {
                             case this.InterpolantFactoryMethodDiscrete:
-                                return tt;
+                                return oe;
                             case this.InterpolantFactoryMethodLinear:
-                                return et;
+                                return le;
                             case this.InterpolantFactoryMethodSmooth:
-                                return nt
+                                return ce
                         }
                     }
                     getValueSize() {
                         return this.values.length / this.times.length
                     }
                     shift(t) {
                         if (0 !== t) {
@@ -12497,15 +12865,15 @@
                         let r = 0,
                             s = i - 1;
                         for (; r !== i && n[r] < t;) ++r;
                         for (; - 1 !== s && n[s] > e;) --s;
                         if (++s, 0 !== r || s !== i) {
                             r >= s && (s = Math.max(s, 1), r = s - 1);
                             const t = this.getValueSize();
-                            this.times = Yl.arraySlice(n, r, s), this.values = Yl.arraySlice(this.values, r * t, s * t)
+                            this.times = lh.arraySlice(n, r, s), this.values = lh.arraySlice(this.values, r * t, s * t)
                         }
                         return this
                     }
                     validate() {
                         let t = !0;
                         const e = this.getValueSize();
                         e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
@@ -12522,29 +12890,29 @@
                             }
                             if (null !== s && s > i) {
                                 console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1;
                                 break
                             }
                             s = i
                         }
-                        if (void 0 !== i && Yl.isTypedArray(i))
+                        if (void 0 !== i && lh.isTypedArray(i))
                             for (let e = 0, n = i.length; e !== n; ++e) {
                                 const n = i[e];
                                 if (isNaN(n)) {
                                     console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                                     break
                                 }
                             }
                         return t
                     }
                     optimize() {
-                        const t = Yl.arraySlice(this.times),
-                            e = Yl.arraySlice(this.values),
+                        const t = lh.arraySlice(this.times),
+                            e = lh.arraySlice(this.values),
                             n = this.getValueSize(),
-                            i = this.getInterpolation() === nt,
+                            i = this.getInterpolation() === ce,
                             r = t.length - 1;
                         let s = 1;
                         for (let a = 1; a < r; ++a) {
                             let r = !1;
                             const o = t[a];
                             if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                                 if (i) r = !0;
@@ -12569,88 +12937,88 @@
                             }
                         }
                         if (r > 0) {
                             t[s] = t[r];
                             for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
                             ++s
                         }
-                        return s !== t.length ? (this.times = Yl.arraySlice(t, 0, s), this.values = Yl.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
+                        return s !== t.length ? (this.times = lh.arraySlice(t, 0, s), this.values = lh.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
                     }
                     clone() {
-                        const t = Yl.arraySlice(this.times, 0),
-                            e = Yl.arraySlice(this.values, 0),
+                        const t = lh.arraySlice(this.times, 0),
+                            e = lh.arraySlice(this.values, 0),
                             n = new(0, this.constructor)(this.name, t, e);
                         return n.createInterpolant = this.createInterpolant, n
                     }
                 }
-                $l.prototype.TimeBufferType = Float32Array, $l.prototype.ValueBufferType = Float32Array, $l.prototype.DefaultInterpolation = et;
-                class tc extends $l {}
-                tc.prototype.ValueTypeName = "bool", tc.prototype.ValueBufferType = Array, tc.prototype.DefaultInterpolation = tt, tc.prototype.InterpolantFactoryMethodLinear = void 0, tc.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class ec extends $l {}
-                ec.prototype.ValueTypeName = "color";
-                class nc extends $l {}
-                nc.prototype.ValueTypeName = "number";
-                class ic extends Zl {
+                ph.prototype.TimeBufferType = Float32Array, ph.prototype.ValueBufferType = Float32Array, ph.prototype.DefaultInterpolation = le;
+                class mh extends ph {}
+                mh.prototype.ValueTypeName = "bool", mh.prototype.ValueBufferType = Array, mh.prototype.DefaultInterpolation = oe, mh.prototype.InterpolantFactoryMethodLinear = void 0, mh.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class fh extends ph {}
+                fh.prototype.ValueTypeName = "color";
+                class gh extends ph {}
+                gh.prototype.ValueTypeName = "number";
+                class vh extends ch {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t, e, n, i) {
                         const r = this.resultBuffer,
                             s = this.sampleValues,
                             a = this.valueSize,
                             o = (n - e) / (i - e);
                         let l = t * a;
-                        for (let t = l + a; l !== t; l += 4) Zt.slerpFlat(r, 0, s, l - a, s, l, o);
+                        for (let t = l + a; l !== t; l += 4) an.slerpFlat(r, 0, s, l - a, s, l, o);
                         return r
                     }
                 }
-                class rc extends $l {
+                class xh extends ph {
                     InterpolantFactoryMethodLinear(t) {
-                        return new ic(this.times, this.values, this.getValueSize(), t)
+                        return new vh(this.times, this.values, this.getValueSize(), t)
                     }
                 }
-                rc.prototype.ValueTypeName = "quaternion", rc.prototype.DefaultInterpolation = et, rc.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class sc extends $l {}
-                sc.prototype.ValueTypeName = "string", sc.prototype.ValueBufferType = Array, sc.prototype.DefaultInterpolation = tt, sc.prototype.InterpolantFactoryMethodLinear = void 0, sc.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class ac extends $l {}
-                ac.prototype.ValueTypeName = "vector";
-                class oc {
+                xh.prototype.ValueTypeName = "quaternion", xh.prototype.DefaultInterpolation = le, xh.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class yh extends ph {}
+                yh.prototype.ValueTypeName = "string", yh.prototype.ValueBufferType = Array, yh.prototype.DefaultInterpolation = oe, yh.prototype.InterpolantFactoryMethodLinear = void 0, yh.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class _h extends ph {}
+                _h.prototype.ValueTypeName = "vector";
+                class Mh {
                     constructor(t, e = -1, n, i = 2500) {
-                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = yt(), this.duration < 0 && this.resetDuration()
+                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Le(), this.duration < 0 && this.resetDuration()
                     }
                     static parse(t) {
                         const e = [],
                             n = t.tracks,
                             i = 1 / (t.fps || 1);
-                        for (let t = 0, r = n.length; t !== r; ++t) e.push(lc(n[t]).scale(i));
+                        for (let t = 0, r = n.length; t !== r; ++t) e.push(bh(n[t]).scale(i));
                         const r = new this(t.name, t.duration, e, t.blendMode);
                         return r.uuid = t.uuid, r
                     }
                     static toJSON(t) {
                         const e = [],
                             n = t.tracks,
                             i = {
                                 name: t.name,
                                 duration: t.duration,
                                 tracks: e,
                                 uuid: t.uuid,
                                 blendMode: t.blendMode
                             };
-                        for (let t = 0, i = n.length; t !== i; ++t) e.push($l.toJSON(n[t]));
+                        for (let t = 0, i = n.length; t !== i; ++t) e.push(ph.toJSON(n[t]));
                         return i
                     }
                     static CreateFromMorphTargetSequence(t, e, n, i) {
                         const r = e.length,
                             s = [];
                         for (let t = 0; t < r; t++) {
                             let a = [],
                                 o = [];
                             a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
-                            const l = Yl.getKeyframeOrder(a);
-                            a = Yl.sortedArray(a, 1, l), o = Yl.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new nc(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / n))
+                            const l = lh.getKeyframeOrder(a);
+                            a = lh.sortedArray(a, 1, l), o = lh.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new gh(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / n))
                         }
                         return new this(t, -1, s)
                     }
                     static findByName(t, e) {
                         let n = t;
                         if (!Array.isArray(t)) {
                             const e = t;
@@ -12678,15 +13046,15 @@
                     }
                     static parseAnimation(t, e) {
                         if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                         const n = function(t, e, n, i, r) {
                                 if (0 !== n.length) {
                                     const s = [],
                                         a = [];
-                                    Yl.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a))
+                                    lh.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a))
                                 }
                             },
                             i = [],
                             r = t.name || "default",
                             s = t.fps || 30,
                             a = t.blendMode;
                         let o = t.length || -1;
@@ -12703,20 +13071,20 @@
                                     for (const n in t) {
                                         const t = [],
                                             s = [];
                                         for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                             const i = r[e];
                                             t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                         }
-                                        i.push(new nc(".morphTargetInfluence[" + n + "]", t, s))
+                                        i.push(new gh(".morphTargetInfluence[" + n + "]", t, s))
                                     }
                                     o = t.length * (s || 1)
                                 } else {
                                     const s = ".bones[" + e[t].name + "]";
-                                    n(ac, s + ".position", r, "pos", i), n(rc, s + ".quaternion", r, "rot", i), n(ac, s + ".scale", r, "scl", i)
+                                    n(_h, s + ".position", r, "pos", i), n(xh, s + ".quaternion", r, "rot", i), n(_h, s + ".scale", r, "scl", i)
                                 }
                         }
                         return 0 === i.length ? null : new this(r, o, i, a)
                     }
                     resetDuration() {
                         let t = 0;
                         for (let e = 0, n = this.tracks.length; e !== n; ++e) {
@@ -12744,49 +13112,49 @@
                         return new this.constructor(this.name, this.duration, t, this.blendMode)
                     }
                     toJSON() {
                         return this.constructor.toJSON(this)
                     }
                 }
 
-                function lc(t) {
+                function bh(t) {
                     if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                     const e = function(t) {
                         switch (t.toLowerCase()) {
                             case "scalar":
                             case "double":
                             case "float":
                             case "number":
                             case "integer":
-                                return nc;
+                                return gh;
                             case "vector":
                             case "vector2":
                             case "vector3":
                             case "vector4":
-                                return ac;
+                                return _h;
                             case "color":
-                                return ec;
+                                return fh;
                             case "quaternion":
-                                return rc;
+                                return xh;
                             case "bool":
                             case "boolean":
-                                return tc;
+                                return mh;
                             case "string":
-                                return sc
+                                return yh
                         }
                         throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                     }(t.type);
                     if (void 0 === t.times) {
                         const e = [],
                             n = [];
-                        Yl.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
+                        lh.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                     }
                     return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                 }
-                const cc = {
+                const wh = {
                     enabled: !1,
                     files: {},
                     add: function(t, e) {
                         !1 !== this.enabled && (this.files[t] = e)
                     },
                     get: function(t) {
                         if (!1 !== this.enabled) return this.files[t]
@@ -12794,15 +13162,15 @@
                     remove: function(t) {
                         delete this.files[t]
                     },
                     clear: function() {
                         this.files = {}
                     }
                 };
-                class hc {
+                class Sh {
                     constructor(t, e, n) {
                         const i = this;
                         let r, s = !1,
                             a = 0,
                             o = 0;
                         const l = [];
                         this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
@@ -12826,18 +13194,18 @@
                                     i = l[e + 1];
                                 if (n.global && (n.lastIndex = 0), n.test(t)) return i
                             }
                             return null
                         }
                     }
                 }
-                const uc = new hc;
-                class dc {
+                const Eh = new Sh;
+                class Th {
                     constructor(t) {
-                        this.manager = void 0 !== t ? t : uc, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
+                        this.manager = void 0 !== t ? t : Eh, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                     }
                     load() {}
                     loadAsync(t, e) {
                         const n = this;
                         return new Promise((function(i, r) {
                             n.load(t, i, e, r)
                         }))
@@ -12855,45 +13223,45 @@
                     setResourcePath(t) {
                         return this.resourcePath = t, this
                     }
                     setRequestHeader(t) {
                         return this.requestHeader = t, this
                     }
                 }
-                const pc = {};
-                class mc extends dc {
+                const Ah = {};
+                class Rh extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
-                        const r = cc.get(t);
+                        const r = wh.get(t);
                         if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => {
                             e && e(r), this.manager.itemEnd(t)
                         }), 0), r;
-                        if (void 0 !== pc[t]) return void pc[t].push({
+                        if (void 0 !== Ah[t]) return void Ah[t].push({
                             onLoad: e,
                             onProgress: n,
                             onError: i
                         });
-                        pc[t] = [], pc[t].push({
+                        Ah[t] = [], Ah[t].push({
                             onLoad: e,
                             onProgress: n,
                             onError: i
                         });
                         const s = new Request(t, {
                                 headers: new Headers(this.requestHeader),
                                 credentials: this.withCredentials ? "include" : "same-origin"
                             }),
                             a = this.mimeType,
                             o = this.responseType;
                         fetch(s).then((e => {
                             if (200 === e.status || 0 === e.status) {
                                 if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body.getReader) return e;
-                                const n = pc[t],
+                                const n = Ah[t],
                                     i = e.body.getReader(),
                                     r = e.headers.get("Content-Length"),
                                     s = r ? parseInt(r) : 0,
                                     a = 0 !== s;
                                 let o = 0;
                                 const l = new ReadableStream({
                                     start(t) {
@@ -12938,25 +13306,25 @@
                                         const e = /charset="?([^;"\s]*)"?/i.exec(a),
                                             n = e && e[1] ? e[1].toLowerCase() : void 0,
                                             i = new TextDecoder(n);
                                         return t.arrayBuffer().then((t => i.decode(t)))
                                     }
                             }
                         })).then((e => {
-                            cc.add(t, e);
-                            const n = pc[t];
-                            delete pc[t];
+                            wh.add(t, e);
+                            const n = Ah[t];
+                            delete Ah[t];
                             for (let t = 0, i = n.length; t < i; t++) {
                                 const i = n[t];
                                 i.onLoad && i.onLoad(e)
                             }
                         })).catch((e => {
-                            const n = pc[t];
+                            const n = Ah[t];
                             if (void 0 === n) throw this.manager.itemError(t), e;
-                            delete pc[t];
+                            delete Ah[t];
                             for (let t = 0, i = n.length; t < i; t++) {
                                 const i = n[t];
                                 i.onError && i.onError(e)
                             }
                             this.manager.itemError(t)
                         })).finally((() => {
                             this.manager.itemEnd(t)
@@ -12965,126 +13333,126 @@
                     setResponseType(t) {
                         return this.responseType = t, this
                     }
                     setMimeType(t) {
                         return this.mimeType = t, this
                     }
                 }
-                class fc extends dc {
+                class Lh extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                         const r = this,
-                            s = cc.get(t);
+                            s = wh.get(t);
                         if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                             e && e(s), r.manager.itemEnd(t)
                         }), 0), s;
-                        const a = Dt("img");
+                        const a = Ve("img");
 
                         function o() {
-                            c(), cc.add(t, this), e && e(this), r.manager.itemEnd(t)
+                            c(), wh.add(t, this), e && e(this), r.manager.itemEnd(t)
                         }
 
                         function l(e) {
                             c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                         }
 
                         function c() {
                             a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
                         }
                         return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                     }
                 }
-                class gc extends dc {
+                class Ch extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
-                        const r = new ci,
-                            s = new fc(this.manager);
+                        const r = new yr,
+                            s = new Lh(this.manager);
                         s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                         let a = 0;
 
                         function o(n) {
                             s.load(t[n], (function(t) {
                                 r.images[n] = t, a++, 6 === a && (r.needsUpdate = !0, e && e(r))
                             }), void 0, i)
                         }
                         for (let e = 0; e < t.length; ++e) o(e);
                         return r
                     }
                 }
-                class vc extends dc {
+                class Ph extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new Fa,
-                            a = new mc(this.manager);
+                            s = new $o,
+                            a = new Rh(this.manager);
                         return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(t, (function(t) {
                             const n = r.parse(t);
-                            n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : d, s.wrapT = void 0 !== n.wrapT ? n.wrapT : d, s.magFilter = void 0 !== n.magFilter ? n.magFilter : v, s.minFilter = void 0 !== n.minFilter ? n.minFilter : v, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = y), 1 === n.mipmapCount && (s.minFilter = v), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, e && e(s, n))
+                            n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : st, s.wrapT = void 0 !== n.wrapT ? n.wrapT : st, s.magFilter = void 0 !== n.magFilter ? n.magFilter : ht, s.minFilter = void 0 !== n.minFilter ? n.minFilter : ht, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = dt), 1 === n.mipmapCount && (s.minFilter = ht), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, e && e(s, n))
                         }), n, i), s
                     }
                 }
-                class xc extends dc {
+                class Dh extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
-                        const r = new kt,
-                            s = new fc(this.manager);
+                        const r = new $e,
+                            s = new Lh(this.manager);
                         return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(t) {
                             r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                         }), n, i), r
                     }
                 }
-                class yc extends Qe {
+                class Ih extends ci {
                     constructor(t, e = 1) {
-                        super(), this.type = "Light", this.color = new zt(t), this.intensity = e
+                        super(), this.type = "Light", this.color = new Ze(t), this.intensity = e
                     }
                     dispose() {}
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                     }
                 }
-                yc.prototype.isLight = !0;
-                class _c extends yc {
+                Ih.prototype.isLight = !0;
+                class Nh extends Ih {
                     constructor(t, e, n) {
-                        super(t, n), this.type = "HemisphereLight", this.position.copy(Qe.DefaultUp), this.updateMatrix(), this.groundColor = new zt(e)
+                        super(t, n), this.type = "HemisphereLight", this.position.copy(ci.DefaultUp), this.updateMatrix(), this.groundColor = new Ze(e)
                     }
                     copy(t) {
-                        return yc.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
+                        return Ih.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                     }
                 }
-                _c.prototype.isHemisphereLight = !0;
-                const Mc = new Ae,
-                    bc = new Jt,
-                    wc = new Jt;
-                class Sc {
+                Nh.prototype.isHemisphereLight = !0;
+                const Oh = new Fn,
+                    Uh = new on,
+                    Bh = new on;
+                class Fh {
                     constructor(t) {
-                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new At(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ae, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new vi, this._frameExtents = new At(1, 1), this._viewportCount = 1, this._viewports = [new jt(0, 0, 1, 1)]
+                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Be(512, 512), this.map = null, this.mapPass = null, this.matrix = new Fn, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ar, this._frameExtents = new Be(1, 1), this._viewportCount = 1, this._viewports = [new en(0, 0, 1, 1)]
                     }
                     getViewportCount() {
                         return this._viewportCount
                     }
                     getFrustum() {
                         return this._frustum
                     }
                     updateMatrices(t) {
                         const e = this.camera,
                             n = this.matrix;
-                        bc.setFromMatrixPosition(t.matrixWorld), e.position.copy(bc), wc.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(wc), e.updateMatrixWorld(), Mc.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Mc), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
+                        Uh.setFromMatrixPosition(t.matrixWorld), e.position.copy(Uh), Bh.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Bh), e.updateMatrixWorld(), Oh.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Oh), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                     }
                     getViewport(t) {
                         return this._viewports[t]
                     }
                     getFrameExtents() {
                         return this._frameExtents
                     }
@@ -13098,106 +13466,106 @@
                         return (new this.constructor).copy(this)
                     }
                     toJSON() {
                         const t = {};
                         return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                     }
                 }
-                class Ec extends Sc {
+                class zh extends Fh {
                     constructor() {
-                        super(new ai(50, 1, .5, 500)), this.focus = 1
+                        super(new gr(50, 1, .5, 500)), this.focus = 1
                     }
                     updateMatrices(t) {
                         const e = this.camera,
-                            n = 2 * xt * t.angle * this.focus,
+                            n = 2 * Re * t.angle * this.focus,
                             i = this.mapSize.width / this.mapSize.height,
                             r = t.distance || e.far;
                         n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                     }
                     copy(t) {
                         return super.copy(t), this.focus = t.focus, this
                     }
                 }
-                Ec.prototype.isSpotLightShadow = !0;
-                class Tc extends yc {
+                zh.prototype.isSpotLightShadow = !0;
+                class Hh extends Ih {
                     constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
-                        super(t, e), this.type = "SpotLight", this.position.copy(Qe.DefaultUp), this.updateMatrix(), this.target = new Qe, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new Ec
+                        super(t, e), this.type = "SpotLight", this.position.copy(ci.DefaultUp), this.updateMatrix(), this.target = new ci, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new zh
                     }
                     get power() {
                         return this.intensity * Math.PI
                     }
                     set power(t) {
                         this.intensity = t / Math.PI
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                     }
                 }
-                Tc.prototype.isSpotLight = !0;
-                const Ac = new Ae,
-                    Rc = new Jt,
-                    Lc = new Jt;
-                class Cc extends Sc {
+                Hh.prototype.isSpotLight = !0;
+                const Gh = new Fn,
+                    Vh = new on,
+                    kh = new on;
+                class Wh extends Fh {
                     constructor() {
-                        super(new ai(90, 1, .5, 500)), this._frameExtents = new At(4, 2), this._viewportCount = 6, this._viewports = [new jt(2, 1, 1, 1), new jt(0, 1, 1, 1), new jt(3, 1, 1, 1), new jt(1, 1, 1, 1), new jt(3, 0, 1, 1), new jt(1, 0, 1, 1)], this._cubeDirections = [new Jt(1, 0, 0), new Jt(-1, 0, 0), new Jt(0, 0, 1), new Jt(0, 0, -1), new Jt(0, 1, 0), new Jt(0, -1, 0)], this._cubeUps = [new Jt(0, 1, 0), new Jt(0, 1, 0), new Jt(0, 1, 0), new Jt(0, 1, 0), new Jt(0, 0, 1), new Jt(0, 0, -1)]
+                        super(new gr(90, 1, .5, 500)), this._frameExtents = new Be(4, 2), this._viewportCount = 6, this._viewports = [new en(2, 1, 1, 1), new en(0, 1, 1, 1), new en(3, 1, 1, 1), new en(1, 1, 1, 1), new en(3, 0, 1, 1), new en(1, 0, 1, 1)], this._cubeDirections = [new on(1, 0, 0), new on(-1, 0, 0), new on(0, 0, 1), new on(0, 0, -1), new on(0, 1, 0), new on(0, -1, 0)], this._cubeUps = [new on(0, 1, 0), new on(0, 1, 0), new on(0, 1, 0), new on(0, 1, 0), new on(0, 0, 1), new on(0, 0, -1)]
                     }
                     updateMatrices(t, e = 0) {
                         const n = this.camera,
                             i = this.matrix,
                             r = t.distance || n.far;
-                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Rc.setFromMatrixPosition(t.matrixWorld), n.position.copy(Rc), Lc.copy(n.position), Lc.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Lc), n.updateMatrixWorld(), i.makeTranslation(-Rc.x, -Rc.y, -Rc.z), Ac.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ac)
+                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Vh.setFromMatrixPosition(t.matrixWorld), n.position.copy(Vh), kh.copy(n.position), kh.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(kh), n.updateMatrixWorld(), i.makeTranslation(-Vh.x, -Vh.y, -Vh.z), Gh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Gh)
                     }
                 }
-                Cc.prototype.isPointLightShadow = !0;
-                class Pc extends yc {
+                Wh.prototype.isPointLightShadow = !0;
+                class jh extends Ih {
                     constructor(t, e, n = 0, i = 1) {
-                        super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Cc
+                        super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Wh
                     }
                     get power() {
                         return 4 * this.intensity * Math.PI
                     }
                     set power(t) {
                         this.intensity = t / (4 * Math.PI)
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                     }
                 }
-                Pc.prototype.isPointLight = !0;
-                class Dc extends Sc {
+                jh.prototype.isPointLight = !0;
+                class Xh extends Fh {
                     constructor() {
-                        super(new Ci(-5, 5, 5, -5, .5, 500))
+                        super(new Hr(-5, 5, 5, -5, .5, 500))
                     }
                 }
-                Dc.prototype.isDirectionalLightShadow = !0;
-                class Ic extends yc {
+                Xh.prototype.isDirectionalLightShadow = !0;
+                class qh extends Ih {
                     constructor(t, e) {
-                        super(t, e), this.type = "DirectionalLight", this.position.copy(Qe.DefaultUp), this.updateMatrix(), this.target = new Qe, this.shadow = new Dc
+                        super(t, e), this.type = "DirectionalLight", this.position.copy(ci.DefaultUp), this.updateMatrix(), this.target = new ci, this.shadow = new Xh
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                     }
                 }
-                Ic.prototype.isDirectionalLight = !0;
-                class Nc extends yc {
+                qh.prototype.isDirectionalLight = !0;
+                class Yh extends Ih {
                     constructor(t, e) {
                         super(t, e), this.type = "AmbientLight"
                     }
                 }
-                Nc.prototype.isAmbientLight = !0;
-                class Oc extends yc {
+                Yh.prototype.isAmbientLight = !0;
+                class Zh extends Ih {
                     constructor(t, e, n = 10, i = 10) {
                         super(t, e), this.type = "RectAreaLight", this.width = n, this.height = i
                     }
                     get power() {
                         return this.intensity * this.width * this.height * Math.PI
                     }
                     set power(t) {
@@ -13207,19 +13575,19 @@
                         return super.copy(t), this.width = t.width, this.height = t.height, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.width = this.width, e.object.height = this.height, e
                     }
                 }
-                Oc.prototype.isRectAreaLight = !0;
-                class Uc {
+                Zh.prototype.isRectAreaLight = !0;
+                class Jh {
                     constructor() {
                         this.coefficients = [];
-                        for (let t = 0; t < 9; t++) this.coefficients.push(new Jt)
+                        for (let t = 0; t < 9; t++) this.coefficients.push(new on)
                     }
                     set(t) {
                         for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                         return this
                     }
                     zero() {
                         for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
@@ -13279,95 +13647,95 @@
                     static getBasisAt(t, e) {
                         const n = t.x,
                             i = t.y,
                             r = t.z;
                         e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                     }
                 }
-                Uc.prototype.isSphericalHarmonics3 = !0;
-                class Bc extends yc {
-                    constructor(t = new Uc, e = 1) {
+                Jh.prototype.isSphericalHarmonics3 = !0;
+                class Kh extends Ih {
+                    constructor(t = new Jh, e = 1) {
                         super(void 0, e), this.sh = t
                     }
                     copy(t) {
                         return super.copy(t), this.sh.copy(t.sh), this
                     }
                     fromJSON(t) {
                         return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.sh = this.sh.toArray(), e
                     }
                 }
-                Bc.prototype.isLightProbe = !0;
-                class Fc extends dc {
+                Kh.prototype.isLightProbe = !0;
+                class Qh extends Th {
                     constructor(t) {
                         super(t), this.textures = {}
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new mc(r.manager);
+                            s = new Rh(r.manager);
                         s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) {
                             try {
                                 e(r.parse(JSON.parse(n)))
                             } catch (e) {
                                 i ? i(e) : console.error(e), r.manager.itemError(t)
                             }
                         }), n, i)
                     }
                     parse(t) {
                         const e = this.textures;
 
                         function n(t) {
                             return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                         }
-                        const i = new ql[t.type];
-                        if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = t.sheen), void 0 !== t.sheenColor && (i.sheenColor = (new zt).setHex(t.sheenColor)), void 0 !== t.sheenRoughness && (i.sheenRoughness = t.sheenRoughness), void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular), void 0 !== t.specularIntensity && (i.specularIntensity = t.specularIntensity), void 0 !== t.specularColor && void 0 !== i.specularColor && i.specularColor.setHex(t.specularColor), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.thickness && (i.thickness = t.thickness), void 0 !== t.attenuationDistance && (i.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationColor && void 0 !== i.attenuationColor && i.attenuationColor.setHex(t.attenuationColor), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.alphaWrite && (i.alphaWrite = t.alphaWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
+                        const i = new oh[t.type];
+                        if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = t.sheen), void 0 !== t.sheenColor && (i.sheenColor = (new Ze).setHex(t.sheenColor)), void 0 !== t.sheenRoughness && (i.sheenRoughness = t.sheenRoughness), void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular), void 0 !== t.specularIntensity && (i.specularIntensity = t.specularIntensity), void 0 !== t.specularColor && void 0 !== i.specularColor && i.specularColor.setHex(t.specularColor), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.thickness && (i.thickness = t.thickness), void 0 !== t.attenuationDistance && (i.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationColor && void 0 !== i.attenuationColor && i.attenuationColor.setHex(t.attenuationColor), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.alphaWrite && (i.alphaWrite = t.alphaWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                             for (const e in t.uniforms) {
                                 const r = t.uniforms[e];
                                 switch (i.uniforms[e] = {}, r.type) {
                                     case "t":
                                         i.uniforms[e].value = n(r.value);
                                         break;
                                     case "c":
-                                        i.uniforms[e].value = (new zt).setHex(r.value);
+                                        i.uniforms[e].value = (new Ze).setHex(r.value);
                                         break;
                                     case "v2":
-                                        i.uniforms[e].value = (new At).fromArray(r.value);
+                                        i.uniforms[e].value = (new Be).fromArray(r.value);
                                         break;
                                     case "v3":
-                                        i.uniforms[e].value = (new Jt).fromArray(r.value);
+                                        i.uniforms[e].value = (new on).fromArray(r.value);
                                         break;
                                     case "v4":
-                                        i.uniforms[e].value = (new jt).fromArray(r.value);
+                                        i.uniforms[e].value = (new en).fromArray(r.value);
                                         break;
                                     case "m3":
-                                        i.uniforms[e].value = (new Rt).fromArray(r.value);
+                                        i.uniforms[e].value = (new Fe).fromArray(r.value);
                                         break;
                                     case "m4":
-                                        i.uniforms[e].value = (new Ae).fromArray(r.value);
+                                        i.uniforms[e].value = (new Fn).fromArray(r.value);
                                         break;
                                     default:
                                         i.uniforms[e].value = r.value
                                 }
                             }
                         if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                             for (const e in t.extensions) i.extensions[e] = t.extensions[e];
                         if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                             let e = t.normalScale;
-                            !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new At).fromArray(e)
+                            !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new Be).fromArray(e)
                         }
-                        return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.specularIntensityMap && (i.specularIntensityMap = n(t.specularIntensityMap)), void 0 !== t.specularColorMap && (i.specularColorMap = n(t.specularColorMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new At).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)), void 0 !== t.sheenColorMap && (i.sheenColorMap = n(t.sheenColorMap)), void 0 !== t.sheenRoughnessMap && (i.sheenRoughnessMap = n(t.sheenRoughnessMap)), i
+                        return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.specularIntensityMap && (i.specularIntensityMap = n(t.specularIntensityMap)), void 0 !== t.specularColorMap && (i.specularColorMap = n(t.specularColorMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new Be).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)), void 0 !== t.sheenColorMap && (i.sheenColorMap = n(t.sheenColorMap)), void 0 !== t.sheenRoughnessMap && (i.sheenRoughnessMap = n(t.sheenRoughnessMap)), i
                     }
                     setTextures(t) {
                         return this.textures = t, this
                     }
                 }
-                class zc {
+                class $h {
                     static decodeText(t) {
                         if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                         let e = "";
                         for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                         try {
                             return decodeURIComponent(escape(e))
                         } catch (t) {
@@ -13378,37 +13746,37 @@
                         const e = t.lastIndexOf("/");
                         return -1 === e ? "./" : t.substr(0, e + 1)
                     }
                     static resolveURL(t, e) {
                         return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                     }
                 }
-                class Hc extends Nn {
+                class tu extends Wi {
                     constructor() {
                         super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                     }
                     copy(t) {
                         return super.copy(t), this.instanceCount = t.instanceCount, this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     toJSON() {
                         const t = super.toJSON(this);
                         return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                     }
                 }
-                Hc.prototype.isInstancedBufferGeometry = !0;
-                class Gc extends dc {
+                tu.prototype.isInstancedBufferGeometry = !0;
+                class eu extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new mc(r.manager);
+                            s = new Rh(r.manager);
                         s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) {
                             try {
                                 e(r.parse(JSON.parse(n)))
                             } catch (e) {
                                 i ? i(e) : console.error(e), r.manager.itemError(t)
                             }
                         }), n, i)
@@ -13422,208 +13790,208 @@
                             const r = t.interleavedBuffers[i],
                                 s = function(t, e) {
                                     if (void 0 !== n[e]) return n[e];
                                     const i = t.arrayBuffers[e],
                                         r = new Uint32Array(i).buffer;
                                     return n[e] = r, r
                                 }(t, r.buffer),
-                                a = Pt(r.type, s),
-                                o = new ca(a, r.stride);
+                                a = Ge(r.type, s),
+                                o = new So(a, r.stride);
                             return o.uuid = r.uuid, e[i] = o, o
                         }
-                        const r = t.isInstancedBufferGeometry ? new Hc : new Nn,
+                        const r = t.isInstancedBufferGeometry ? new tu : new Wi,
                             s = t.data.index;
                         if (void 0 !== s) {
-                            const t = Pt(s.type, s.array);
-                            r.setIndex(new gn(t, 1))
+                            const t = Ge(s.type, s.array);
+                            r.setIndex(new Ti(t, 1))
                         }
                         const a = t.data.attributes;
                         for (const e in a) {
                             const n = a[e];
                             let s;
                             if (n.isInterleavedBufferAttribute) {
                                 const e = i(t.data, n.data);
-                                s = new ua(e, n.itemSize, n.offset, n.normalized)
+                                s = new To(e, n.itemSize, n.offset, n.normalized)
                             } else {
-                                const t = Pt(n.type, n.array);
-                                s = new(n.isInstancedBufferAttribute ? Va : gn)(t, n.itemSize, n.normalized)
+                                const t = Ge(n.type, n.array);
+                                s = new(n.isInstancedBufferAttribute ? il : Ti)(t, n.itemSize, n.normalized)
                             }
                             void 0 !== n.name && (s.name = n.name), void 0 !== n.usage && s.setUsage(n.usage), void 0 !== n.updateRange && (s.updateRange.offset = n.updateRange.offset, s.updateRange.count = n.updateRange.count), r.setAttribute(e, s)
                         }
                         const o = t.data.morphAttributes;
                         if (o)
                             for (const e in o) {
                                 const n = o[e],
                                     s = [];
                                 for (let e = 0, r = n.length; e < r; e++) {
                                     const r = n[e];
                                     let a;
                                     if (r.isInterleavedBufferAttribute) {
                                         const e = i(t.data, r.data);
-                                        a = new ua(e, r.itemSize, r.offset, r.normalized)
+                                        a = new To(e, r.itemSize, r.offset, r.normalized)
                                     } else {
-                                        const t = Pt(r.type, r.array);
-                                        a = new gn(t, r.itemSize, r.normalized)
+                                        const t = Ge(r.type, r.array);
+                                        a = new Ti(t, r.itemSize, r.normalized)
                                     }
                                     void 0 !== r.name && (a.name = r.name), s.push(a)
                                 }
                                 r.morphAttributes[e] = s
                             }
                         t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
                         const l = t.data.groups || t.data.drawcalls || t.data.offsets;
                         if (void 0 !== l)
                             for (let t = 0, e = l.length; t !== e; ++t) {
                                 const e = l[t];
                                 r.addGroup(e.start, e.count, e.materialIndex)
                             }
                         const c = t.data.boundingSphere;
                         if (void 0 !== c) {
-                            const t = new Jt;
-                            void 0 !== c.center && t.fromArray(c.center), r.boundingSphere = new xe(t, c.radius)
+                            const t = new on;
+                            void 0 !== c.center && t.fromArray(c.center), r.boundingSphere = new Ln(t, c.radius)
                         }
                         return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
                     }
                 }
-                const Vc = {
-                        UVMapping: r,
-                        CubeReflectionMapping: s,
-                        CubeRefractionMapping: a,
-                        EquirectangularReflectionMapping: o,
-                        EquirectangularRefractionMapping: l,
-                        CubeUVReflectionMapping: c,
-                        CubeUVRefractionMapping: h
-                    },
-                    kc = {
-                        RepeatWrapping: u,
-                        ClampToEdgeWrapping: d,
-                        MirroredRepeatWrapping: p
-                    },
-                    Wc = {
-                        NearestFilter: m,
-                        NearestMipmapNearestFilter: f,
-                        NearestMipmapLinearFilter: g,
-                        LinearFilter: v,
-                        LinearMipmapNearestFilter: x,
-                        LinearMipmapLinearFilter: y
+                const nu = {
+                        UVMapping: K,
+                        CubeReflectionMapping: Q,
+                        CubeRefractionMapping: $,
+                        EquirectangularReflectionMapping: tt,
+                        EquirectangularRefractionMapping: et,
+                        CubeUVReflectionMapping: nt,
+                        CubeUVRefractionMapping: it
+                    },
+                    iu = {
+                        RepeatWrapping: rt,
+                        ClampToEdgeWrapping: st,
+                        MirroredRepeatWrapping: at
+                    },
+                    ru = {
+                        NearestFilter: ot,
+                        NearestMipmapNearestFilter: lt,
+                        NearestMipmapLinearFilter: ct,
+                        LinearFilter: ht,
+                        LinearMipmapNearestFilter: ut,
+                        LinearMipmapLinearFilter: dt
                     };
-                class jc extends dc {
+                class su extends Th {
                     constructor(t) {
                         super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                             premultiplyAlpha: "none"
                         }
                     }
                     setOptions(t) {
                         return this.options = t, this
                     }
                     load(t, e, n, i) {
                         void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                         const r = this,
-                            s = cc.get(t);
+                            s = wh.get(t);
                         if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                             e && e(s), r.manager.itemEnd(t)
                         }), 0), s;
                         const a = {};
                         a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(t, a).then((function(t) {
                             return t.blob()
                         })).then((function(t) {
                             return createImageBitmap(t, Object.assign(r.options, {
                                 colorSpaceConversion: "none"
                             }))
                         })).then((function(n) {
-                            cc.add(t, n), e && e(n), r.manager.itemEnd(t)
+                            wh.add(t, n), e && e(n), r.manager.itemEnd(t)
                         })).catch((function(e) {
                             i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                         })), r.manager.itemStart(t)
                     }
                 }
-                let Xc;
-                jc.prototype.isImageBitmapLoader = !0;
-                const qc = {
+                let au;
+                su.prototype.isImageBitmapLoader = !0;
+                const ou = {
                     getContext: function() {
-                        return void 0 === Xc && (Xc = new(window.AudioContext || window.webkitAudioContext)), Xc
+                        return void 0 === au && (au = new(window.AudioContext || window.webkitAudioContext)), au
                     },
                     setContext: function(t) {
-                        Xc = t
+                        au = t
                     }
                 };
-                class Yc extends dc {
+                class lu extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new mc(this.manager);
+                            s = new Rh(this.manager);
                         s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                             try {
                                 const t = n.slice(0);
-                                qc.getContext().decodeAudioData(t, (function(t) {
+                                ou.getContext().decodeAudioData(t, (function(t) {
                                     e(t)
                                 }))
                             } catch (e) {
                                 i ? i(e) : console.error(e), r.manager.itemError(t)
                             }
                         }), n, i)
                     }
                 }
-                class Zc extends Bc {
+                class cu extends Kh {
                     constructor(t, e, n = 1) {
                         super(void 0, n);
-                        const i = (new zt).set(t),
-                            r = (new zt).set(e),
-                            s = new Jt(i.r, i.g, i.b),
-                            a = new Jt(r.r, r.g, r.b),
+                        const i = (new Ze).set(t),
+                            r = (new Ze).set(e),
+                            s = new on(i.r, i.g, i.b),
+                            a = new on(r.r, r.g, r.b),
                             o = Math.sqrt(Math.PI),
                             l = o * Math.sqrt(.75);
                         this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
                     }
                 }
-                Zc.prototype.isHemisphereLightProbe = !0;
-                class Jc extends Bc {
+                cu.prototype.isHemisphereLightProbe = !0;
+                class hu extends Kh {
                     constructor(t, e = 1) {
                         super(void 0, e);
-                        const n = (new zt).set(t);
+                        const n = (new Ze).set(t);
                         this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                     }
                 }
-                Jc.prototype.isAmbientLightProbe = !0;
-                const Kc = new Ae,
-                    Qc = new Ae,
-                    $c = new Ae;
-                class th {
+                hu.prototype.isAmbientLightProbe = !0;
+                const uu = new Fn,
+                    du = new Fn,
+                    pu = new Fn;
+                class mu {
                     constructor(t = !0) {
                         this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                     }
                     start() {
-                        this.startTime = eh(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
+                        this.startTime = fu(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                     }
                     stop() {
                         this.getElapsedTime(), this.running = !1, this.autoStart = !1
                     }
                     getElapsedTime() {
                         return this.getDelta(), this.elapsedTime
                     }
                     getDelta() {
                         let t = 0;
                         if (this.autoStart && !this.running) return this.start(), 0;
                         if (this.running) {
-                            const e = eh();
+                            const e = fu();
                             t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                         }
                         return t
                     }
                 }
 
-                function eh() {
+                function fu() {
                     return ("undefined" == typeof performance ? Date : performance).now()
                 }
-                const nh = new Jt,
-                    ih = new Zt,
-                    rh = new Jt,
-                    sh = new Jt;
-                class ah extends Qe {
+                const gu = new on,
+                    vu = new an,
+                    xu = new on,
+                    yu = new on;
+                class _u extends ci {
                     constructor(t) {
                         super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                     }
                     getOutput() {
                         return this.gain
                     }
                     setNodeSource(t) {
@@ -13713,33 +14081,33 @@
                     getVolume() {
                         return this.gain.gain.value
                     }
                     setVolume(t) {
                         return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                     }
                 }
-                const oh = new Jt,
-                    lh = new Zt,
-                    ch = new Jt,
-                    hh = new Jt;
-                class uh {
+                const Mu = new on,
+                    bu = new an,
+                    wu = new on,
+                    Su = new on;
+                class Eu {
                     constructor(t, e = 2048) {
                         this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
                     }
                     getFrequencyData() {
                         return this.analyser.getByteFrequencyData(this.data), this.data
                     }
                     getAverageFrequency() {
                         let t = 0;
                         const e = this.getFrequencyData();
                         for (let n = 0; n < e.length; n++) t += e[n];
                         return t / e.length
                     }
                 }
-                class dh {
+                class Tu {
                     constructor(t, e, n) {
                         let i, r, s;
                         switch (this.binding = t, this.valueSize = n, e) {
                             case "quaternion":
                                 i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                                 break;
                             case "string":
@@ -13817,19 +14185,19 @@
                         for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                     }
                     _select(t, e, n, i, r) {
                         if (i >= .5)
                             for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
                     }
                     _slerp(t, e, n, i) {
-                        Zt.slerpFlat(t, e, t, e, t, n, i)
+                        an.slerpFlat(t, e, t, e, t, n, i)
                     }
                     _slerpAdditive(t, e, n, i, r) {
                         const s = this._workIndex * r;
-                        Zt.multiplyQuaternionsFlat(t, s, t, e, t, n), Zt.slerpFlat(t, e, t, e, t, s, i)
+                        an.multiplyQuaternionsFlat(t, s, t, e, t, n), an.slerpFlat(t, e, t, e, t, s, i)
                     }
                     _lerp(t, e, n, i, r) {
                         const s = 1 - i;
                         for (let a = 0; a !== r; ++a) {
                             const r = e + a;
                             t[r] = t[r] * s + t[n + a] * i
                         }
@@ -13837,46 +14205,47 @@
                     _lerpAdditive(t, e, n, i, r) {
                         for (let s = 0; s !== r; ++s) {
                             const r = e + s;
                             t[r] = t[r] + t[n + s] * i
                         }
                     }
                 }
-                const ph = new RegExp("[\\[\\]\\.:\\/]", "g"),
-                    mh = "[^\\[\\]\\.:\\/]",
-                    fh = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
-                    gh = /((?:WC+[\/:])*)/.source.replace("WC", mh),
-                    vh = /(WCOD+)?/.source.replace("WCOD", fh),
-                    xh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", mh),
-                    yh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", mh),
-                    _h = new RegExp("^" + gh + vh + xh + yh + "$"),
-                    Mh = ["material", "materials", "bones"];
-                class bh {
+                const Au = "\\[\\]\\.:\\/",
+                    Ru = new RegExp("[" + Au + "]", "g"),
+                    Lu = "[^" + Au + "]",
+                    Cu = "[^" + Au.replace("\\.", "") + "]",
+                    Pu = /((?:WC+[\/:])*)/.source.replace("WC", Lu),
+                    Du = /(WCOD+)?/.source.replace("WCOD", Cu),
+                    Iu = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Lu),
+                    Nu = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Lu),
+                    Ou = new RegExp("^" + Pu + Du + Iu + Nu + "$"),
+                    Uu = ["material", "materials", "bones"];
+                class Bu {
                     constructor(t, e, n) {
-                        this.path = e, this.parsedPath = n || bh.parseTrackName(e), this.node = bh.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
+                        this.path = e, this.parsedPath = n || Bu.parseTrackName(e), this.node = Bu.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                     }
                     static create(t, e, n) {
-                        return t && t.isAnimationObjectGroup ? new bh.Composite(t, e, n) : new bh(t, e, n)
+                        return t && t.isAnimationObjectGroup ? new Bu.Composite(t, e, n) : new Bu(t, e, n)
                     }
                     static sanitizeNodeName(t) {
-                        return t.replace(/\s/g, "_").replace(ph, "")
+                        return t.replace(/\s/g, "_").replace(Ru, "")
                     }
                     static parseTrackName(t) {
-                        const e = _h.exec(t);
+                        const e = Ou.exec(t);
                         if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                         const n = {
                                 nodeName: e[2],
                                 objectName: e[3],
                                 objectIndex: e[4],
                                 propertyName: e[5],
                                 propertyIndex: e[6]
                             },
                             i = n.nodeName && n.nodeName.lastIndexOf(".");
                         if (void 0 !== i && -1 !== i) {
-                            const t = n.nodeName.substring(i + 1); - 1 !== Mh.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
+                            const t = n.nodeName.substring(i + 1); - 1 !== Uu.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                         }
                         if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                         return n
                     }
                     static findNode(t, e) {
                         if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                         if (t.skeleton) {
@@ -13962,15 +14331,15 @@
                     }
                     bind() {
                         let t = this.node;
                         const e = this.parsedPath,
                             n = e.objectName,
                             i = e.propertyName;
                         let r = e.propertyIndex;
-                        if (t || (t = bh.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
+                        if (t || (t = Bu.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                         if (n) {
                             let i = e.objectIndex;
                             switch (n) {
                                 case "materials":
                                     if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                     if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                     t = t.material.materials;
@@ -14011,17 +14380,17 @@
                         } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                         this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
                     }
                     unbind() {
                         this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                     }
                 }
-                bh.Composite = class {
+                Bu.Composite = class {
                     constructor(t, e, n) {
-                        const i = n || bh.parseTrackName(e);
+                        const i = n || Bu.parseTrackName(e);
                         this._targetGroup = t, this._bindings = t.subscribe_(e, i)
                     }
                     getValue(t, e) {
                         this.bind();
                         const n = this._targetGroup.nCachedObjects_,
                             i = this._bindings[n];
                         void 0 !== i && i.getValue(t, e)
@@ -14034,32 +14403,32 @@
                         const t = this._bindings;
                         for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                     }
                     unbind() {
                         const t = this._bindings;
                         for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                     }
-                }, bh.prototype.BindingType = {
+                }, Bu.prototype.BindingType = {
                     Direct: 0,
                     EntireArray: 1,
                     ArrayElement: 2,
                     HasFromToArray: 3
-                }, bh.prototype.Versioning = {
+                }, Bu.prototype.Versioning = {
                     None: 0,
                     NeedsUpdate: 1,
                     MatrixWorldNeedsUpdate: 2
-                }, bh.prototype.GetterByBindingType = [bh.prototype._getValue_direct, bh.prototype._getValue_array, bh.prototype._getValue_arrayElement, bh.prototype._getValue_toArray], bh.prototype.SetterByBindingTypeAndVersioning = [
-                    [bh.prototype._setValue_direct, bh.prototype._setValue_direct_setNeedsUpdate, bh.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
-                    [bh.prototype._setValue_array, bh.prototype._setValue_array_setNeedsUpdate, bh.prototype._setValue_array_setMatrixWorldNeedsUpdate],
-                    [bh.prototype._setValue_arrayElement, bh.prototype._setValue_arrayElement_setNeedsUpdate, bh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
-                    [bh.prototype._setValue_fromArray, bh.prototype._setValue_fromArray_setNeedsUpdate, bh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
+                }, Bu.prototype.GetterByBindingType = [Bu.prototype._getValue_direct, Bu.prototype._getValue_array, Bu.prototype._getValue_arrayElement, Bu.prototype._getValue_toArray], Bu.prototype.SetterByBindingTypeAndVersioning = [
+                    [Bu.prototype._setValue_direct, Bu.prototype._setValue_direct_setNeedsUpdate, Bu.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
+                    [Bu.prototype._setValue_array, Bu.prototype._setValue_array_setNeedsUpdate, Bu.prototype._setValue_array_setMatrixWorldNeedsUpdate],
+                    [Bu.prototype._setValue_arrayElement, Bu.prototype._setValue_arrayElement_setNeedsUpdate, Bu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
+                    [Bu.prototype._setValue_fromArray, Bu.prototype._setValue_fromArray_setNeedsUpdate, Bu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                 ];
-                class wh {
+                class Fu {
                     constructor() {
-                        this.uuid = yt(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
+                        this.uuid = Le(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                         const t = {};
                         this._indicesByUUID = t;
                         for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                         this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                         const e = this;
                         this.stats = {
                             objects: {
@@ -14086,25 +14455,25 @@
                             l = this.nCachedObjects_;
                         for (let c = 0, h = arguments.length; c !== h; ++c) {
                             const h = arguments[c],
                                 u = h.uuid;
                             let d = e[u];
                             if (void 0 === d) {
                                 d = o++, e[u] = d, t.push(h);
-                                for (let t = 0, e = s; t !== e; ++t) r[t].push(new bh(h, n[t], i[t]))
+                                for (let t = 0, e = s; t !== e; ++t) r[t].push(new Bu(h, n[t], i[t]))
                             } else if (d < l) {
                                 a = t[d];
                                 const o = --l,
                                     c = t[o];
                                 e[c.uuid] = d, t[d] = c, e[u] = o, t[o] = h;
                                 for (let t = 0, e = s; t !== e; ++t) {
                                     const e = r[t],
                                         s = e[o];
                                     let a = e[d];
-                                    e[d] = s, void 0 === a && (a = new bh(h, n[t], i[t])), e[o] = a
+                                    e[d] = s, void 0 === a && (a = new Bu(h, n[t], i[t])), e[o] = a
                                 }
                             } else t[d] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                         }
                         this.nCachedObjects_ = l
                     }
                     remove() {
                         const t = this._objects,
@@ -14175,15 +14544,15 @@
                             o = this._objects,
                             l = o.length,
                             c = this.nCachedObjects_,
                             h = new Array(l);
                         i = r.length, n[t] = i, s.push(t), a.push(e), r.push(h);
                         for (let n = c, i = o.length; n !== i; ++n) {
                             const i = o[n];
-                            h[n] = new bh(i, t, e)
+                            h[n] = new Bu(i, t, e)
                         }
                         return h
                     }
                     unsubscribe_(t) {
                         const e = this._bindingsIndicesByPath,
                             n = e[t];
                         if (void 0 !== n) {
@@ -14192,24 +14561,24 @@
                                 s = this._bindings,
                                 a = s.length - 1,
                                 o = s[a];
                             e[t[a]] = n, s[n] = o, s.pop(), r[n] = r[a], r.pop(), i[n] = i[a], i.pop()
                         }
                     }
                 }
-                wh.prototype.isAnimationObjectGroup = !0;
-                class Sh {
+                Fu.prototype.isAnimationObjectGroup = !0;
+                class zu {
                     constructor(t, e, n = null, i = e.blendMode) {
                         this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                         const r = e.tracks,
                             s = r.length,
                             a = new Array(s),
                             o = {
-                                endingStart: it,
-                                endingEnd: it
+                                endingStart: he,
+                                endingEnd: he
                             };
                         for (let t = 0; t !== s; ++t) {
                             const e = r[t].createInterpolant(null);
                             a[t] = e, e.settings = o
                         }
                         this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                     }
@@ -14311,15 +14680,15 @@
                         }
                         e *= this._updateTimeScale(t);
                         const s = this._updateTime(e),
                             a = this._updateWeight(t);
                         if (a > 0) {
                             const t = this._interpolants,
                                 e = this._propertyBindings;
-                            if (this.blendMode === at)
+                            if (this.blendMode === pe)
                                 for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulateAdditive(a);
                             else
                                 for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, a)
                         }
                     }
                     _updateWeight(t) {
                         let e = 0;
@@ -14392,27 +14761,27 @@
                             } else this.time = i;
                             if (s && 1 == (1 & r)) return e - i
                         }
                         return i
                     }
                     _setEndings(t, e, n) {
                         const i = this._interpolantSettings;
-                        n ? (i.endingStart = rt, i.endingEnd = rt) : (i.endingStart = t ? this.zeroSlopeAtStart ? rt : it : st, i.endingEnd = e ? this.zeroSlopeAtEnd ? rt : it : st)
+                        n ? (i.endingStart = ue, i.endingEnd = ue) : (i.endingStart = t ? this.zeroSlopeAtStart ? ue : he : de, i.endingEnd = e ? this.zeroSlopeAtEnd ? ue : he : de)
                     }
                     _scheduleFading(t, e, n) {
                         const i = this._mixer,
                             r = i.time;
                         let s = this._weightInterpolant;
                         null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                         const a = s.parameterPositions,
                             o = s.sampleValues;
                         return a[0] = r, o[0] = e, a[1] = r + t, o[1] = n, this
                     }
                 }
-                class Eh extends mt {
+                class Hu extends Se {
                     constructor(t) {
                         super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                     }
                     _bindAction(t, e) {
                         const n = t._localRoot || this._root,
                             i = t._clip.tracks,
                             r = i.length,
@@ -14429,15 +14798,15 @@
                             if (void 0 !== h) ++h.referenceCount, s[t] = h;
                             else {
                                 if (h = s[t], void 0 !== h) {
                                     null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l));
                                     continue
                                 }
                                 const i = e && e._propertyBindings[t].binding.parsedPath;
-                                h = new dh(bh.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), s[t] = h
+                                h = new Tu(Bu.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), s[t] = h
                             }
                             a[t].resultBuffer = h.buffer
                         }
                     }
                     _activateAction(t) {
                         if (!this._isActiveAction(t)) {
                             if (null === t._cacheIndex) {
@@ -14577,43 +14946,43 @@
                             r = e[i];
                         t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                     }
                     _lendControlInterpolant() {
                         const t = this._controlInterpolants,
                             e = this._nActiveControlInterpolants++;
                         let n = t[e];
-                        return void 0 === n && (n = new Kl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
+                        return void 0 === n && (n = new uh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                     }
                     _takeBackControlInterpolant(t) {
                         const e = this._controlInterpolants,
                             n = t.__cacheIndex,
                             i = --this._nActiveControlInterpolants,
                             r = e[i];
                         t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                     }
                     clipAction(t, e, n) {
                         const i = e || this._root,
                             r = i.uuid;
-                        let s = "string" == typeof t ? oc.findByName(i, t) : t;
+                        let s = "string" == typeof t ? Mh.findByName(i, t) : t;
                         const a = null !== s ? s.uuid : t,
                             o = this._actionsByClip[a];
                         let l = null;
                         if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o) {
                             const t = o.actionByRoot[r];
                             if (void 0 !== t && t.blendMode === n) return t;
                             l = o.knownActions[0], null === s && (s = l._clip)
                         }
                         if (null === s) return null;
-                        const c = new Sh(this, s, e, n);
+                        const c = new zu(this, s, e, n);
                         return this._bindAction(c, l), this._addInactiveAction(c, a, r), c
                     }
                     existingAction(t, e) {
                         const n = e || this._root,
                             i = n.uuid,
-                            r = "string" == typeof t ? oc.findByName(n, t) : t,
+                            r = "string" == typeof t ? Mh.findByName(n, t) : t,
                             s = r ? r.uuid : t,
                             a = this._actionsByClip[s];
                         return void 0 !== a && a.actionByRoot[i] || null
                     }
                     stopAllAction() {
                         const t = this._actions;
                         for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
@@ -14672,24 +15041,24 @@
                             }
                     }
                     uncacheAction(t, e) {
                         const n = this.existingAction(t, e);
                         null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                     }
                 }
-                Eh.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
-                class Th {
+                Hu.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
+                class Gu {
                     constructor(t) {
                         "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                     }
                     clone() {
-                        return new Th(void 0 === this.value.clone ? this.value : this.value.clone())
+                        return new Gu(void 0 === this.value.clone ? this.value : this.value.clone())
                     }
                 }
-                class Ah extends ca {
+                class Vu extends So {
                     constructor(t, e, n = 1) {
                         super(t, e), this.meshPerAttribute = n
                     }
                     copy(t) {
                         return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                     }
                     clone(t) {
@@ -14697,16 +15066,16 @@
                         return e.meshPerAttribute = this.meshPerAttribute, e
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                     }
                 }
-                Ah.prototype.isInstancedInterleavedBuffer = !0;
-                class Rh {
+                Vu.prototype.isInstancedInterleavedBuffer = !0;
+                class ku {
                     constructor(t, e, n, i, r) {
                         this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0
                     }
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                     setBuffer(t) {
@@ -14719,40 +15088,40 @@
                         return this.itemSize = t, this
                     }
                     setCount(t) {
                         return this.count = t, this
                     }
                 }
 
-                function Lh(t, e) {
+                function Wu(t, e) {
                     return t.distance - e.distance
                 }
 
-                function Ch(t, e, n, i) {
+                function ju(t, e, n, i) {
                     if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
                         const i = t.children;
-                        for (let t = 0, r = i.length; t < r; t++) Ch(i[t], e, n, !0)
+                        for (let t = 0, r = i.length; t < r; t++) ju(i[t], e, n, !0)
                     }
                 }
-                Rh.prototype.isGLBufferAttribute = !0;
-                const Ph = new At;
-                class Dh {
-                    constructor(t = new At(1 / 0, 1 / 0), e = new At(-1 / 0, -1 / 0)) {
+                ku.prototype.isGLBufferAttribute = !0;
+                const Xu = new Be;
+                class qu {
+                    constructor(t = new Be(1 / 0, 1 / 0), e = new Be(-1 / 0, -1 / 0)) {
                         this.min = t, this.max = e
                     }
                     set(t, e) {
                         return this.min.copy(t), this.max.copy(e), this
                     }
                     setFromPoints(t) {
                         this.makeEmpty();
                         for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                         return this
                     }
                     setFromCenterAndSize(t, e) {
-                        const n = Ph.copy(e).multiplyScalar(.5);
+                        const n = Xu.copy(e).multiplyScalar(.5);
                         return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     copy(t) {
                         return this.min.copy(t.min), this.max.copy(t.max), this
@@ -14790,34 +15159,34 @@
                     intersectsBox(t) {
                         return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                     }
                     clampPoint(t, e) {
                         return e.copy(t).clamp(this.min, this.max)
                     }
                     distanceToPoint(t) {
-                        return Ph.copy(t).clamp(this.min, this.max).sub(t).length()
+                        return Xu.copy(t).clamp(this.min, this.max).sub(t).length()
                     }
                     intersect(t) {
                         return this.min.max(t.min), this.max.min(t.max), this
                     }
                     union(t) {
                         return this.min.min(t.min), this.max.max(t.max), this
                     }
                     translate(t) {
                         return this.min.add(t), this.max.add(t), this
                     }
                     equals(t) {
                         return t.min.equals(this.min) && t.max.equals(this.max)
                     }
                 }
-                Dh.prototype.isBox2 = !0;
-                const Ih = new Jt,
-                    Nh = new Jt;
-                class Oh {
-                    constructor(t = new Jt, e = new Jt) {
+                qu.prototype.isBox2 = !0;
+                const Yu = new on,
+                    Zu = new on;
+                class Ju {
+                    constructor(t = new on, e = new on) {
                         this.start = t, this.end = e
                     }
                     set(t, e) {
                         return this.start.copy(t), this.end.copy(e), this
                     }
                     copy(t) {
                         return this.start.copy(t.start), this.end.copy(t.end), this
@@ -14834,18 +15203,18 @@
                     distance() {
                         return this.start.distanceTo(this.end)
                     }
                     at(t, e) {
                         return this.delta(e).multiplyScalar(t).add(this.start)
                     }
                     closestPointToPointParameter(t, e) {
-                        Ih.subVectors(t, this.start), Nh.subVectors(this.end, this.start);
-                        const n = Nh.dot(Nh);
-                        let i = Nh.dot(Ih) / n;
-                        return e && (i = _t(i, 0, 1)), i
+                        Yu.subVectors(t, this.start), Zu.subVectors(this.end, this.start);
+                        const n = Zu.dot(Zu);
+                        let i = Zu.dot(Yu) / n;
+                        return e && (i = Ce(i, 0, 1)), i
                     }
                     closestPointToPoint(t, e, n) {
                         const i = this.closestPointToPointParameter(t, e);
                         return this.delta(n).multiplyScalar(i).add(this.start)
                     }
                     applyMatrix4(t) {
                         return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
@@ -14853,304 +15222,304 @@
                     equals(t) {
                         return t.start.equals(this.start) && t.end.equals(this.end)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                const Uh = new Jt,
-                    Bh = new Jt,
-                    Fh = new Ae,
-                    zh = new Ae;
-                class Hh extends io {
+                const Ku = new on,
+                    Qu = new on,
+                    $u = new Fn,
+                    td = new Fn;
+                class ed extends xl {
                     constructor(t) {
-                        const e = Gh(t),
-                            n = new Nn,
+                        const e = nd(t),
+                            n = new Wi,
                             i = [],
                             r = [],
-                            s = new zt(0, 0, 1),
-                            a = new zt(0, 1, 0);
+                            s = new Ze(0, 0, 1),
+                            a = new Ze(0, 1, 0);
                         for (let t = 0; t < e.length; t++) {
                             const n = e[t];
                             n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
                         }
-                        n.setAttribute("position", new En(i, 3)), n.setAttribute("color", new En(r, 3)), super(n, new Ya({
+                        n.setAttribute("position", new Oi(i, 3)), n.setAttribute("color", new Oi(r, 3)), super(n, new cl({
                             vertexColors: !0,
                             depthTest: !1,
                             depthWrite: !1,
                             toneMapped: !1,
                             transparent: !0
                         })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                     }
                     updateMatrixWorld(t) {
                         const e = this.bones,
                             n = this.geometry,
                             i = n.getAttribute("position");
-                        zh.copy(this.root.matrixWorld).invert();
+                        td.copy(this.root.matrixWorld).invert();
                         for (let t = 0, n = 0; t < e.length; t++) {
                             const r = e[t];
-                            r.parent && r.parent.isBone && (Fh.multiplyMatrices(zh, r.matrixWorld), Bh.setFromMatrixPosition(Fh), i.setXYZ(n, Bh.x, Bh.y, Bh.z), Fh.multiplyMatrices(zh, r.parent.matrixWorld), Bh.setFromMatrixPosition(Fh), i.setXYZ(n + 1, Bh.x, Bh.y, Bh.z), n += 2)
+                            r.parent && r.parent.isBone && ($u.multiplyMatrices(td, r.matrixWorld), Qu.setFromMatrixPosition($u), i.setXYZ(n, Qu.x, Qu.y, Qu.z), $u.multiplyMatrices(td, r.parent.matrixWorld), Qu.setFromMatrixPosition($u), i.setXYZ(n + 1, Qu.x, Qu.y, Qu.z), n += 2)
                         }
                         n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                     }
                 }
 
-                function Gh(t) {
+                function nd(t) {
                     const e = [];
                     t && t.isBone && e.push(t);
-                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, Gh(t.children[n]));
+                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, nd(t.children[n]));
                     return e
                 }
-                const Vh = new Jt,
-                    kh = new zt,
-                    Wh = new zt;
-                class jh extends io {
+                const id = new on,
+                    rd = new Ze,
+                    sd = new Ze;
+                class ad extends xl {
                     constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
-                        n = new zt(n), i = new zt(i);
+                        n = new Ze(n), i = new Ze(i);
                         const r = e / 2,
                             s = t / e,
                             a = t / 2,
                             o = [],
                             l = [];
                         for (let t = 0, c = 0, h = -a; t <= e; t++, h += s) {
                             o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
                             const e = t === r ? n : i;
                             e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3
                         }
-                        const c = new Nn;
-                        c.setAttribute("position", new En(o, 3)), c.setAttribute("color", new En(l, 3)), super(c, new Ya({
+                        const c = new Wi;
+                        c.setAttribute("position", new Oi(o, 3)), c.setAttribute("color", new Oi(l, 3)), super(c, new cl({
                             vertexColors: !0,
                             toneMapped: !1
                         })), this.type = "GridHelper"
                     }
                 }
-                const Xh = new Jt,
-                    qh = new Jt,
-                    Yh = new Jt,
-                    Zh = new Jt,
-                    Jh = new si;
+                const od = new on,
+                    ld = new on,
+                    cd = new on,
+                    hd = new on,
+                    ud = new fr;
 
-                function Kh(t, e, n, i, r, s, a) {
-                    Zh.set(r, s, a).unproject(i);
+                function dd(t, e, n, i, r, s, a) {
+                    hd.set(r, s, a).unproject(i);
                     const o = e[t];
                     if (void 0 !== o) {
                         const t = n.getAttribute("position");
-                        for (let e = 0, n = o.length; e < n; e++) t.setXYZ(o[e], Zh.x, Zh.y, Zh.z)
+                        for (let e = 0, n = o.length; e < n; e++) t.setXYZ(o[e], hd.x, hd.y, hd.z)
                     }
                 }
-                const Qh = new $t;
-                class $h extends io {
+                const pd = new hn;
+                class md extends xl {
                     constructor(t, e = 16776960) {
                         const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                             i = new Float32Array(24),
-                            r = new Nn;
-                        r.setIndex(new gn(n, 1)), r.setAttribute("position", new gn(i, 3)), super(r, new Ya({
+                            r = new Wi;
+                        r.setIndex(new Ti(n, 1)), r.setAttribute("position", new Ti(i, 3)), super(r, new cl({
                             color: e,
                             toneMapped: !1
                         })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                     }
                     update(t) {
-                        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Qh.setFromObject(this.object), Qh.isEmpty()) return;
-                        const e = Qh.min,
-                            n = Qh.max,
+                        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && pd.setFromObject(this.object), pd.isEmpty()) return;
+                        const e = pd.min,
+                            n = pd.max,
                             i = this.geometry.attributes.position,
                             r = i.array;
                         r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                     }
                     setFromObject(t) {
                         return this.object = t, this.update(), this
                     }
                     copy(t) {
-                        return io.prototype.copy.call(this, t), this.object = t.object, this
+                        return xl.prototype.copy.call(this, t), this.object = t.object, this
                     }
                 }
-                const tu = new Jt;
-                let eu, nu;
-                class iu extends io {
+                const fd = new on;
+                let gd, vd;
+                class xd extends xl {
                     constructor(t = 1) {
                         const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
-                            n = new Nn;
-                        n.setAttribute("position", new En(e, 3)), n.setAttribute("color", new En([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new Ya({
+                            n = new Wi;
+                        n.setAttribute("position", new Oi(e, 3)), n.setAttribute("color", new Oi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new cl({
                             vertexColors: !0,
                             toneMapped: !1
                         })), this.type = "AxesHelper"
                     }
                     setColors(t, e, n) {
-                        const i = new zt,
+                        const i = new Ze,
                             r = this.geometry.attributes.color.array;
                         return i.set(t), i.toArray(r, 0), i.toArray(r, 3), i.set(e), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this
                     }
                     dispose() {
                         this.geometry.dispose(), this.material.dispose()
                     }
                 }
-                const ru = new Float32Array(1),
-                    su = new Int32Array(ru.buffer);
-                Ao.create = function(t, e) {
-                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ao.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
-                }, Yo.prototype.fromPoints = function(t) {
+                const yd = new Float32Array(1),
+                    _d = new Int32Array(yd.buffer);
+                Gl.create = function(t, e) {
+                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Gl.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
+                }, lc.prototype.fromPoints = function(t) {
                     return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
-                }, jh.prototype.setColors = function() {
+                }, ad.prototype.setColors = function() {
                     console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
-                }, Hh.prototype.update = function() {
+                }, ed.prototype.update = function() {
                     console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
-                }, dc.prototype.extractUrlBase = function(t) {
-                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), zc.extractUrlBase(t)
-                }, dc.Handlers = {
+                }, Th.prototype.extractUrlBase = function(t) {
+                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), $h.extractUrlBase(t)
+                }, Th.Handlers = {
                     add: function() {
                         console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                     },
                     get: function() {
                         console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                     }
-                }, Dh.prototype.center = function(t) {
+                }, qu.prototype.center = function(t) {
                     return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
-                }, Dh.prototype.empty = function() {
+                }, qu.prototype.empty = function() {
                     return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, Dh.prototype.isIntersectionBox = function(t) {
+                }, qu.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, Dh.prototype.size = function(t) {
+                }, qu.prototype.size = function(t) {
                     return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
-                }, $t.prototype.center = function(t) {
+                }, hn.prototype.center = function(t) {
                     return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
-                }, $t.prototype.empty = function() {
+                }, hn.prototype.empty = function() {
                     return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, $t.prototype.isIntersectionBox = function(t) {
+                }, hn.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, $t.prototype.isIntersectionSphere = function(t) {
+                }, hn.prototype.isIntersectionSphere = function(t) {
                     return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
-                }, $t.prototype.size = function(t) {
+                }, hn.prototype.size = function(t) {
                     return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
-                }, xe.prototype.empty = function() {
+                }, Ln.prototype.empty = function() {
                     return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, vi.prototype.setFromMatrix = function(t) {
+                }, Ar.prototype.setFromMatrix = function(t) {
                     return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
-                }, Oh.prototype.center = function(t) {
+                }, Ju.prototype.center = function(t) {
                     return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
-                }, Rt.prototype.flattenToArrayOffset = function(t, e) {
+                }, Fe.prototype.flattenToArrayOffset = function(t, e) {
                     return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
-                }, Rt.prototype.multiplyVector3 = function(t) {
+                }, Fe.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
-                }, Rt.prototype.multiplyVector3Array = function() {
+                }, Fe.prototype.multiplyVector3Array = function() {
                     console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
-                }, Rt.prototype.applyToBufferAttribute = function(t) {
+                }, Fe.prototype.applyToBufferAttribute = function(t) {
                     return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
-                }, Rt.prototype.applyToVector3Array = function() {
+                }, Fe.prototype.applyToVector3Array = function() {
                     console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
-                }, Rt.prototype.getInverse = function(t) {
+                }, Fe.prototype.getInverse = function(t) {
                     return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
-                }, Ae.prototype.extractPosition = function(t) {
+                }, Fn.prototype.extractPosition = function(t) {
                     return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
-                }, Ae.prototype.flattenToArrayOffset = function(t, e) {
+                }, Fn.prototype.flattenToArrayOffset = function(t, e) {
                     return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
-                }, Ae.prototype.getPosition = function() {
-                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Jt).setFromMatrixColumn(this, 3)
-                }, Ae.prototype.setRotationFromQuaternion = function(t) {
+                }, Fn.prototype.getPosition = function() {
+                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new on).setFromMatrixColumn(this, 3)
+                }, Fn.prototype.setRotationFromQuaternion = function(t) {
                     return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
-                }, Ae.prototype.multiplyToArray = function() {
+                }, Fn.prototype.multiplyToArray = function() {
                     console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
-                }, Ae.prototype.multiplyVector3 = function(t) {
+                }, Fn.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, Ae.prototype.multiplyVector4 = function(t) {
+                }, Fn.prototype.multiplyVector4 = function(t) {
                     return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, Ae.prototype.multiplyVector3Array = function() {
+                }, Fn.prototype.multiplyVector3Array = function() {
                     console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
-                }, Ae.prototype.rotateAxis = function(t) {
+                }, Fn.prototype.rotateAxis = function(t) {
                     console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
-                }, Ae.prototype.crossVector = function(t) {
+                }, Fn.prototype.crossVector = function(t) {
                     return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, Ae.prototype.translate = function() {
+                }, Fn.prototype.translate = function() {
                     console.error("THREE.Matrix4: .translate() has been removed.")
-                }, Ae.prototype.rotateX = function() {
+                }, Fn.prototype.rotateX = function() {
                     console.error("THREE.Matrix4: .rotateX() has been removed.")
-                }, Ae.prototype.rotateY = function() {
+                }, Fn.prototype.rotateY = function() {
                     console.error("THREE.Matrix4: .rotateY() has been removed.")
-                }, Ae.prototype.rotateZ = function() {
+                }, Fn.prototype.rotateZ = function() {
                     console.error("THREE.Matrix4: .rotateZ() has been removed.")
-                }, Ae.prototype.rotateByAxis = function() {
+                }, Fn.prototype.rotateByAxis = function() {
                     console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
-                }, Ae.prototype.applyToBufferAttribute = function(t) {
+                }, Fn.prototype.applyToBufferAttribute = function(t) {
                     return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, Ae.prototype.applyToVector3Array = function() {
+                }, Fn.prototype.applyToVector3Array = function() {
                     console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
-                }, Ae.prototype.makeFrustum = function(t, e, n, i, r, s) {
+                }, Fn.prototype.makeFrustum = function(t, e, n, i, r, s) {
                     return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, s)
-                }, Ae.prototype.getInverse = function(t) {
+                }, Fn.prototype.getInverse = function(t) {
                     return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
-                }, mi.prototype.isIntersectionLine = function(t) {
+                }, Sr.prototype.isIntersectionLine = function(t) {
                     return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
-                }, Zt.prototype.multiplyVector3 = function(t) {
+                }, an.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
-                }, Zt.prototype.inverse = function() {
+                }, an.prototype.inverse = function() {
                     return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
-                }, Te.prototype.isIntersectionBox = function(t) {
+                }, Bn.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, Te.prototype.isIntersectionPlane = function(t) {
+                }, Bn.prototype.isIntersectionPlane = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
-                }, Te.prototype.isIntersectionSphere = function(t) {
+                }, Bn.prototype.isIntersectionSphere = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
-                }, hn.prototype.area = function() {
+                }, _i.prototype.area = function() {
                     return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
-                }, hn.prototype.barycoordFromPoint = function(t, e) {
+                }, _i.prototype.barycoordFromPoint = function(t, e) {
                     return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
-                }, hn.prototype.midpoint = function(t) {
+                }, _i.prototype.midpoint = function(t) {
                     return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
-                }, hn.prototypenormal = function(t) {
+                }, _i.prototypenormal = function(t) {
                     return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
-                }, hn.prototype.plane = function(t) {
+                }, _i.prototype.plane = function(t) {
                     return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
-                }, hn.barycoordFromPoint = function(t, e, n, i, r) {
-                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), hn.getBarycoord(t, e, n, i, r)
-                }, hn.normal = function(t, e, n, i) {
-                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), hn.getNormal(t, e, n, i)
-                }, Zo.prototype.extractAllPoints = function(t) {
+                }, _i.barycoordFromPoint = function(t, e, n, i, r) {
+                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), _i.getBarycoord(t, e, n, i, r)
+                }, _i.normal = function(t, e, n, i) {
+                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), _i.getNormal(t, e, n, i)
+                }, cc.prototype.extractAllPoints = function(t) {
                     return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
-                }, Zo.prototype.extrude = function(t) {
-                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new wl(this, t)
-                }, Zo.prototype.makeGeometry = function(t) {
-                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ll(this, t)
-                }, At.prototype.fromAttribute = function(t, e, n) {
+                }, cc.prototype.extrude = function(t) {
+                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Bc(this, t)
+                }, cc.prototype.makeGeometry = function(t) {
+                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new kc(this, t)
+                }, Be.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, At.prototype.distanceToManhattan = function(t) {
+                }, Be.prototype.distanceToManhattan = function(t) {
                     return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
-                }, At.prototype.lengthManhattan = function() {
+                }, Be.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, Jt.prototype.setEulerFromRotationMatrix = function() {
+                }, on.prototype.setEulerFromRotationMatrix = function() {
                     console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
-                }, Jt.prototype.setEulerFromQuaternion = function() {
+                }, on.prototype.setEulerFromQuaternion = function() {
                     console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
-                }, Jt.prototype.getPositionFromMatrix = function(t) {
+                }, on.prototype.getPositionFromMatrix = function(t) {
                     return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
-                }, Jt.prototype.getScaleFromMatrix = function(t) {
+                }, on.prototype.getScaleFromMatrix = function(t) {
                     return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
-                }, Jt.prototype.getColumnFromMatrix = function(t, e) {
+                }, on.prototype.getColumnFromMatrix = function(t, e) {
                     return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
-                }, Jt.prototype.applyProjection = function(t) {
+                }, on.prototype.applyProjection = function(t) {
                     return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
-                }, Jt.prototype.fromAttribute = function(t, e, n) {
+                }, on.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, Jt.prototype.distanceToManhattan = function(t) {
+                }, on.prototype.distanceToManhattan = function(t) {
                     return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
-                }, Jt.prototype.lengthManhattan = function() {
+                }, on.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, jt.prototype.fromAttribute = function(t, e, n) {
+                }, en.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, jt.prototype.lengthManhattan = function() {
+                }, en.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, Qe.prototype.getChildByName = function(t) {
+                }, ci.prototype.getChildByName = function(t) {
                     return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
-                }, Qe.prototype.renderDepth = function() {
+                }, ci.prototype.renderDepth = function() {
                     console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
-                }, Qe.prototype.translate = function(t, e) {
+                }, ci.prototype.translate = function(t, e) {
                     return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
-                }, Qe.prototype.getWorldRotation = function() {
+                }, ci.prototype.getWorldRotation = function() {
                     console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
-                }, Qe.prototype.applyMatrix = function(t) {
+                }, ci.prototype.applyMatrix = function(t) {
                     return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
-                }, Object.defineProperties(Qe.prototype, {
+                }, Object.defineProperties(ci.prototype, {
                     eulerOrder: {
                         get: function() {
                             return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                         },
                         set: function(t) {
                             console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                         }
@@ -15159,30 +15528,30 @@
                         get: function() {
                             console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                         },
                         set: function() {
                             console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                         }
                     }
-                }), Qn.prototype.setDrawMode = function() {
+                }), lr.prototype.setDrawMode = function() {
                     console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
-                }, Object.defineProperties(Qn.prototype, {
+                }, Object.defineProperties(lr.prototype, {
                     drawMode: {
                         get: function() {
                             return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                         },
                         set: function() {
                             console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                         }
                     }
-                }), Ua.prototype.initBones = function() {
+                }), Ko.prototype.initBones = function() {
                     console.error("THREE.SkinnedMesh: initBones() has been removed.")
-                }, ai.prototype.setLens = function(t, e) {
+                }, gr.prototype.setLens = function(t, e) {
                     console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
-                }, Object.defineProperties(yc.prototype, {
+                }, Object.defineProperties(Ih.prototype, {
                     onlyShadow: {
                         set: function() {
                             console.warn("THREE.Light: .onlyShadow has been removed.")
                         }
                     },
                     shadowCameraFov: {
                         set: function(t) {
@@ -15240,74 +15609,74 @@
                         }
                     },
                     shadowMapHeight: {
                         set: function(t) {
                             console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                         }
                     }
-                }), Object.defineProperties(gn.prototype, {
+                }), Object.defineProperties(Ti.prototype, {
                     length: {
                         get: function() {
                             return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                         }
                     },
                     dynamic: {
                         get: function() {
-                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === ut
+                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Me
                         },
                         set: function() {
-                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(ut)
+                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Me)
                         }
                     }
-                }), gn.prototype.setDynamic = function(t) {
-                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? ut : ht), this
-                }, gn.prototype.copyIndicesArray = function() {
+                }), Ti.prototype.setDynamic = function(t) {
+                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Me : _e), this
+                }, Ti.prototype.copyIndicesArray = function() {
                     console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
-                }, gn.prototype.setArray = function() {
+                }, Ti.prototype.setArray = function() {
                     console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
-                }, Nn.prototype.addIndex = function(t) {
+                }, Wi.prototype.addIndex = function(t) {
                     console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
-                }, Nn.prototype.addAttribute = function(t, e) {
-                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new gn(arguments[1], arguments[2])))
-                }, Nn.prototype.addDrawCall = function(t, e, n) {
+                }, Wi.prototype.addAttribute = function(t, e) {
+                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Ti(arguments[1], arguments[2])))
+                }, Wi.prototype.addDrawCall = function(t, e, n) {
                     void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
-                }, Nn.prototype.clearDrawCalls = function() {
+                }, Wi.prototype.clearDrawCalls = function() {
                     console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
-                }, Nn.prototype.computeOffsets = function() {
+                }, Wi.prototype.computeOffsets = function() {
                     console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
-                }, Nn.prototype.removeAttribute = function(t) {
+                }, Wi.prototype.removeAttribute = function(t) {
                     return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
-                }, Nn.prototype.applyMatrix = function(t) {
+                }, Wi.prototype.applyMatrix = function(t) {
                     return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
-                }, Object.defineProperties(Nn.prototype, {
+                }, Object.defineProperties(Wi.prototype, {
                     drawcalls: {
                         get: function() {
                             return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                         }
                     },
                     offsets: {
                         get: function() {
                             return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                         }
                     }
-                }), ca.prototype.setDynamic = function(t) {
-                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? ut : ht), this
-                }, ca.prototype.setArray = function() {
+                }), So.prototype.setDynamic = function(t) {
+                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Me : _e), this
+                }, So.prototype.setArray = function() {
                     console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
-                }, wl.prototype.getArrays = function() {
+                }, Bc.prototype.getArrays = function() {
                     console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
-                }, wl.prototype.addShapeList = function() {
+                }, Bc.prototype.addShapeList = function() {
                     console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
-                }, wl.prototype.addShape = function() {
+                }, Bc.prototype.addShape = function() {
                     console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
-                }, la.prototype.dispose = function() {
+                }, wo.prototype.dispose = function() {
                     console.error("THREE.Scene: .dispose() has been removed.")
-                }, Th.prototype.onUpdate = function() {
+                }, Gu.prototype.onUpdate = function() {
                     return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
-                }, Object.defineProperties(dn.prototype, {
+                }, Object.defineProperties(bi.prototype, {
                     wrapAround: {
                         get: function() {
                             console.warn("THREE.Material: .wrapAround has been removed.")
                         },
                         set: function() {
                             console.warn("THREE.Material: .wrapAround has been removed.")
                         }
@@ -15318,15 +15687,15 @@
                         },
                         set: function() {
                             console.warn("THREE.Material: .overdraw has been removed.")
                         }
                     },
                     wrapRGB: {
                         get: function() {
-                            return console.warn("THREE.Material: .wrapRGB has been removed."), new zt
+                            return console.warn("THREE.Material: .wrapRGB has been removed."), new Ze
                         }
                     },
                     shading: {
                         get: function() {
                             console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                         },
                         set: function(t) {
@@ -15345,74 +15714,74 @@
                         get: function() {
                             console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                         },
                         set: function() {
                             console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                         }
                     }
-                }), Object.defineProperties(ri.prototype, {
+                }), Object.defineProperties(mr.prototype, {
                     derivatives: {
                         get: function() {
                             return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                         },
                         set: function(t) {
                             console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                         }
                     }
-                }), ra.prototype.clearTarget = function(t, e, n, i) {
+                }), yo.prototype.clearTarget = function(t, e, n, i) {
                     console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
-                }, ra.prototype.animate = function(t) {
+                }, yo.prototype.animate = function(t) {
                     console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
-                }, ra.prototype.getCurrentRenderTarget = function() {
+                }, yo.prototype.getCurrentRenderTarget = function() {
                     return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
-                }, ra.prototype.getMaxAnisotropy = function() {
+                }, yo.prototype.getMaxAnisotropy = function() {
                     return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
-                }, ra.prototype.getPrecision = function() {
+                }, yo.prototype.getPrecision = function() {
                     return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
-                }, ra.prototype.resetGLState = function() {
+                }, yo.prototype.resetGLState = function() {
                     return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
-                }, ra.prototype.supportsFloatTextures = function() {
+                }, yo.prototype.supportsFloatTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
-                }, ra.prototype.supportsHalfFloatTextures = function() {
+                }, yo.prototype.supportsHalfFloatTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
-                }, ra.prototype.supportsStandardDerivatives = function() {
+                }, yo.prototype.supportsStandardDerivatives = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
-                }, ra.prototype.supportsCompressedTextureS3TC = function() {
+                }, yo.prototype.supportsCompressedTextureS3TC = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
-                }, ra.prototype.supportsCompressedTexturePVRTC = function() {
+                }, yo.prototype.supportsCompressedTexturePVRTC = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
-                }, ra.prototype.supportsBlendMinMax = function() {
+                }, yo.prototype.supportsBlendMinMax = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
-                }, ra.prototype.supportsVertexTextures = function() {
+                }, yo.prototype.supportsVertexTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
-                }, ra.prototype.supportsInstancedArrays = function() {
+                }, yo.prototype.supportsInstancedArrays = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
-                }, ra.prototype.enableScissorTest = function(t) {
+                }, yo.prototype.enableScissorTest = function(t) {
                     console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
-                }, ra.prototype.initMaterial = function() {
+                }, yo.prototype.initMaterial = function() {
                     console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
-                }, ra.prototype.addPrePlugin = function() {
+                }, yo.prototype.addPrePlugin = function() {
                     console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
-                }, ra.prototype.addPostPlugin = function() {
+                }, yo.prototype.addPostPlugin = function() {
                     console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
-                }, ra.prototype.updateShadowMap = function() {
+                }, yo.prototype.updateShadowMap = function() {
                     console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
-                }, ra.prototype.setFaceCulling = function() {
+                }, yo.prototype.setFaceCulling = function() {
                     console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
-                }, ra.prototype.allocTextureUnit = function() {
+                }, yo.prototype.allocTextureUnit = function() {
                     console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
-                }, ra.prototype.setTexture = function() {
+                }, yo.prototype.setTexture = function() {
                     console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
-                }, ra.prototype.setTexture2D = function() {
+                }, yo.prototype.setTexture2D = function() {
                     console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
-                }, ra.prototype.setTextureCube = function() {
+                }, yo.prototype.setTextureCube = function() {
                     console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
-                }, ra.prototype.getActiveMipMapLevel = function() {
+                }, yo.prototype.getActiveMipMapLevel = function() {
                     return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
-                }, Object.defineProperties(ra.prototype, {
+                }, Object.defineProperties(yo.prototype, {
                     shadowMapEnabled: {
                         get: function() {
                             return this.shadowMap.enabled
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                         }
@@ -15452,15 +15821,15 @@
                         }
                     },
                     gammaOutput: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                         },
                         set: function(t) {
-                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? lt : ot
+                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? fe : me
                         }
                     },
                     toneMappingWhitePoint: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                         },
                         set: function() {
@@ -15471,15 +15840,15 @@
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                         }
                     }
-                }), Object.defineProperties(qs.prototype, {
+                }), Object.defineProperties(oo.prototype, {
                     cullFace: {
                         get: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                         }
@@ -15496,15 +15865,15 @@
                         get: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                         }
                     }
-                }), Object.defineProperties(Xt.prototype, {
+                }), Object.defineProperties(nn.prototype, {
                     wrapS: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                         }
@@ -15577,112 +15946,112 @@
                         get: function() {
                             return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                         }
                     }
-                }), ah.prototype.load = function(t) {
+                }), _u.prototype.load = function(t) {
                     console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                     const e = this;
-                    return (new Yc).load(t, (function(t) {
+                    return (new lu).load(t, (function(t) {
                         e.setBuffer(t)
                     })), this
-                }, uh.prototype.getData = function() {
+                }, Eu.prototype.getData = function() {
                     return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
-                }, li.prototype.updateCubeMap = function(t, e) {
+                }, xr.prototype.updateCubeMap = function(t, e) {
                     return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
-                }, li.prototype.clear = function(t, e, n, i) {
+                }, xr.prototype.clear = function(t, e, n, i) {
                     return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i)
-                }, Gt.crossOrigin = void 0, Gt.loadTexture = function(t, e, n, i) {
+                }, Ke.crossOrigin = void 0, Ke.loadTexture = function(t, e, n, i) {
                     console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
-                    const r = new xc;
+                    const r = new Dh;
                     r.setCrossOrigin(this.crossOrigin);
                     const s = r.load(t, n, void 0, i);
                     return e && (s.mapping = e), s
-                }, Gt.loadTextureCube = function(t, e, n, i) {
+                }, Ke.loadTextureCube = function(t, e, n, i) {
                     console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
-                    const r = new gc;
+                    const r = new Ch;
                     r.setCrossOrigin(this.crossOrigin);
                     const s = r.load(t, n, void 0, i);
                     return e && (s.mapping = e), s
-                }, Gt.loadCompressedTexture = function() {
+                }, Ke.loadCompressedTexture = function() {
                     console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
-                }, Gt.loadCompressedTextureCube = function() {
+                }, Ke.loadCompressedTextureCube = function() {
                     console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                 };
-                const au = {
+                const Md = {
                     createMultiMaterialObject: function() {
                         console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                     },
                     detach: function() {
                         console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                     },
                     attach: function() {
                         console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                     }
                 };
                 "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                     detail: {
                         revision: n
                     }
-                })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = n), e.ACESFilmicToneMapping = 4, e.AddEquation = i, e.AddOperation = 2, e.AdditiveAnimationBlendMode = at, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AlwaysStencilFunc = 519, e.AmbientLight = Nc, e.AmbientLightProbe = Jc, e.AnimationClip = oc, e.AnimationLoader = class extends dc {
+                })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = n), e.ACESFilmicToneMapping = Z, e.AddEquation = x, e.AddOperation = W, e.AdditiveAnimationBlendMode = pe, e.AdditiveBlending = m, e.AlphaFormat = St, e.AlwaysDepth = O, e.AlwaysStencilFunc = 519, e.AmbientLight = Yh, e.AmbientLightProbe = hu, e.AnimationClip = Mh, e.AnimationLoader = class extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new mc(this.manager);
+                            s = new Rh(this.manager);
                         s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                             try {
                                 e(r.parse(JSON.parse(n)))
                             } catch (e) {
                                 i ? i(e) : console.error(e), r.manager.itemError(t)
                             }
                         }), n, i)
                     }
                     parse(t) {
                         const e = [];
                         for (let n = 0; n < t.length; n++) {
-                            const i = oc.parse(t[n]);
+                            const i = Mh.parse(t[n]);
                             e.push(i)
                         }
                         return e
                     }
-                }, e.AnimationMixer = Eh, e.AnimationObjectGroup = wh, e.AnimationUtils = Yl, e.ArcCurve = Lo, e.ArrayCamera = Ks, e.ArrowHelper = class extends Qe {
-                    constructor(t = new Jt(0, 0, 1), e = new Jt(0, 0, 0), n = 1, i = 16776960, r = .2 * n, s = .2 * r) {
-                        super(), this.type = "ArrowHelper", void 0 === eu && (eu = new Nn, eu.setAttribute("position", new En([0, 0, 0, 0, 1, 0], 3)), nu = new xo(0, .5, 1, 5, 1), nu.translate(0, -.5, 0)), this.position.copy(e), this.line = new to(eu, new Ya({
+                }, e.AnimationMixer = Hu, e.AnimationObjectGroup = Fu, e.AnimationUtils = lh, e.ArcCurve = kl, e.ArrayCamera = uo, e.ArrowHelper = class extends ci {
+                    constructor(t = new on(0, 0, 1), e = new on(0, 0, 0), n = 1, i = 16776960, r = .2 * n, s = .2 * r) {
+                        super(), this.type = "ArrowHelper", void 0 === gd && (gd = new Wi, gd.setAttribute("position", new Oi([0, 0, 0, 0, 1, 0], 3)), vd = new Dl(0, .5, 1, 5, 1), vd.translate(0, -.5, 0)), this.position.copy(e), this.line = new fl(gd, new cl({
                             color: i,
                             toneMapped: !1
-                        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Qn(nu, new pn({
+                        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new lr(vd, new wi({
                             color: i,
                             toneMapped: !1
                         })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, s)
                     }
                     setDirection(t) {
                         if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
                         else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                         else {
-                            tu.set(t.z, 0, -t.x).normalize();
+                            fd.set(t.z, 0, -t.x).normalize();
                             const e = Math.acos(t.y);
-                            this.quaternion.setFromAxisAngle(tu, e)
+                            this.quaternion.setFromAxisAngle(fd, e)
                         }
                     }
                     setLength(t, e = .2 * t, n = .2 * e) {
                         this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
                     }
                     setColor(t) {
                         this.line.material.color.set(t), this.cone.material.color.set(t)
                     }
                     copy(t) {
                         return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
                     }
-                }, e.Audio = ah, e.AudioAnalyser = uh, e.AudioContext = qc, e.AudioListener = class extends Qe {
+                }, e.Audio = _u, e.AudioAnalyser = Eu, e.AudioContext = ou, e.AudioListener = class extends ci {
                     constructor() {
-                        super(), this.type = "AudioListener", this.context = qc.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new th
+                        super(), this.type = "AudioListener", this.context = ou.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new mu
                     }
                     getInput() {
                         return this.gain
                     }
                     removeFilter() {
                         return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                     }
@@ -15698,95 +16067,95 @@
                     setMasterVolume(t) {
                         return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                     }
                     updateMatrixWorld(t) {
                         super.updateMatrixWorld(t);
                         const e = this.context.listener,
                             n = this.up;
-                        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(nh, ih, rh), sh.set(0, 0, -1).applyQuaternion(ih), e.positionX) {
+                        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(gu, vu, xu), yu.set(0, 0, -1).applyQuaternion(vu), e.positionX) {
                             const t = this.context.currentTime + this.timeDelta;
-                            e.positionX.linearRampToValueAtTime(nh.x, t), e.positionY.linearRampToValueAtTime(nh.y, t), e.positionZ.linearRampToValueAtTime(nh.z, t), e.forwardX.linearRampToValueAtTime(sh.x, t), e.forwardY.linearRampToValueAtTime(sh.y, t), e.forwardZ.linearRampToValueAtTime(sh.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
-                        } else e.setPosition(nh.x, nh.y, nh.z), e.setOrientation(sh.x, sh.y, sh.z, n.x, n.y, n.z)
+                            e.positionX.linearRampToValueAtTime(gu.x, t), e.positionY.linearRampToValueAtTime(gu.y, t), e.positionZ.linearRampToValueAtTime(gu.z, t), e.forwardX.linearRampToValueAtTime(yu.x, t), e.forwardY.linearRampToValueAtTime(yu.y, t), e.forwardZ.linearRampToValueAtTime(yu.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
+                        } else e.setPosition(gu.x, gu.y, gu.z), e.setOrientation(yu.x, yu.y, yu.z, n.x, n.y, n.z)
                     }
-                }, e.AudioLoader = Yc, e.AxesHelper = iu, e.AxisHelper = function(t) {
-                    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new iu(t)
-                }, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function(t) {
-                    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new vc(t)
-                }, e.Bone = Ba, e.BooleanKeyframeTrack = tc, e.BoundingBoxHelper = function(t, e) {
-                    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new $h(t, e)
-                }, e.Box2 = Dh, e.Box3 = $t, e.Box3Helper = class extends io {
+                }, e.AudioLoader = lu, e.AxesHelper = xd, e.AxisHelper = function(t) {
+                    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new xd(t)
+                }, e.BackSide = h, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function(t) {
+                    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ph(t)
+                }, e.Bone = Qo, e.BooleanKeyframeTrack = mh, e.BoundingBoxHelper = function(t, e) {
+                    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new md(t, e)
+                }, e.Box2 = qu, e.Box3 = hn, e.Box3Helper = class extends xl {
                     constructor(t, e = 16776960) {
                         const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
-                            i = new Nn;
-                        i.setIndex(new gn(n, 1)), i.setAttribute("position", new En([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i, new Ya({
+                            i = new Wi;
+                        i.setIndex(new Ti(n, 1)), i.setAttribute("position", new Oi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i, new cl({
                             color: e,
                             toneMapped: !1
                         })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                     }
                     updateMatrixWorld(t) {
                         const e = this.box;
                         e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t))
                     }
-                }, e.BoxBufferGeometry = ti, e.BoxGeometry = ti, e.BoxHelper = $h, e.BufferAttribute = gn, e.BufferGeometry = Nn, e.BufferGeometryLoader = Gc, e.ByteType = 1010, e.Cache = cc, e.Camera = si, e.CameraHelper = class extends io {
+                }, e.BoxBufferGeometry = hr, e.BoxGeometry = hr, e.BoxHelper = md, e.BufferAttribute = Ti, e.BufferGeometry = Wi, e.BufferGeometryLoader = eu, e.ByteType = mt, e.Cache = wh, e.Camera = fr, e.CameraHelper = class extends xl {
                     constructor(t) {
-                        const e = new Nn,
-                            n = new Ya({
+                        const e = new Wi,
+                            n = new cl({
                                 color: 16777215,
                                 vertexColors: !0,
                                 toneMapped: !1
                             }),
                             i = [],
                             r = [],
                             s = {},
-                            a = new zt(16755200),
-                            o = new zt(16711680),
-                            l = new zt(43775),
-                            c = new zt(16777215),
-                            h = new zt(3355443);
+                            a = new Ze(16755200),
+                            o = new Ze(16711680),
+                            l = new Ze(43775),
+                            c = new Ze(16777215),
+                            h = new Ze(3355443);
 
                         function u(t, e, n) {
                             d(t, n), d(e, n)
                         }
 
                         function d(t, e) {
                             i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(i.length / 3 - 1)
                         }
-                        u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", o), u("p", "n2", o), u("p", "n3", o), u("p", "n4", o), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new En(i, 3)), e.setAttribute("color", new En(r, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
+                        u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", o), u("p", "n2", o), u("p", "n3", o), u("p", "n4", o), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new Oi(i, 3)), e.setAttribute("color", new Oi(r, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
                     }
                     update() {
                         const t = this.geometry,
                             e = this.pointMap;
-                        Jh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Kh("c", e, t, Jh, 0, 0, -1), Kh("t", e, t, Jh, 0, 0, 1), Kh("n1", e, t, Jh, -1, -1, -1), Kh("n2", e, t, Jh, 1, -1, -1), Kh("n3", e, t, Jh, -1, 1, -1), Kh("n4", e, t, Jh, 1, 1, -1), Kh("f1", e, t, Jh, -1, -1, 1), Kh("f2", e, t, Jh, 1, -1, 1), Kh("f3", e, t, Jh, -1, 1, 1), Kh("f4", e, t, Jh, 1, 1, 1), Kh("u1", e, t, Jh, .7, 1.1, -1), Kh("u2", e, t, Jh, -.7, 1.1, -1), Kh("u3", e, t, Jh, 0, 2, -1), Kh("cf1", e, t, Jh, -1, 0, 1), Kh("cf2", e, t, Jh, 1, 0, 1), Kh("cf3", e, t, Jh, 0, -1, 1), Kh("cf4", e, t, Jh, 0, 1, 1), Kh("cn1", e, t, Jh, -1, 0, -1), Kh("cn2", e, t, Jh, 1, 0, -1), Kh("cn3", e, t, Jh, 0, -1, -1), Kh("cn4", e, t, Jh, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
+                        ud.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), dd("c", e, t, ud, 0, 0, -1), dd("t", e, t, ud, 0, 0, 1), dd("n1", e, t, ud, -1, -1, -1), dd("n2", e, t, ud, 1, -1, -1), dd("n3", e, t, ud, -1, 1, -1), dd("n4", e, t, ud, 1, 1, -1), dd("f1", e, t, ud, -1, -1, 1), dd("f2", e, t, ud, 1, -1, 1), dd("f3", e, t, ud, -1, 1, 1), dd("f4", e, t, ud, 1, 1, 1), dd("u1", e, t, ud, .7, 1.1, -1), dd("u2", e, t, ud, -.7, 1.1, -1), dd("u3", e, t, ud, 0, 2, -1), dd("cf1", e, t, ud, -1, 0, 1), dd("cf2", e, t, ud, 1, 0, 1), dd("cf3", e, t, ud, 0, -1, 1), dd("cf4", e, t, ud, 0, 1, 1), dd("cn1", e, t, ud, -1, 0, -1), dd("cn2", e, t, ud, 1, 0, -1), dd("cn3", e, t, ud, 0, -1, -1), dd("cn4", e, t, ud, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                     }
                     dispose() {
                         this.geometry.dispose(), this.material.dispose()
                     }
                 }, e.CanvasRenderer = function() {
                     console.error("THREE.CanvasRenderer has been removed")
-                }, e.CanvasTexture = go, e.CatmullRomCurve3 = Oo, e.CineonToneMapping = 3, e.CircleBufferGeometry = vo, e.CircleGeometry = vo, e.ClampToEdgeWrapping = d, e.Clock = th, e.Color = zt, e.ColorKeyframeTrack = ec, e.CompressedTexture = fo, e.CompressedTextureLoader = class extends dc {
+                }, e.CanvasTexture = Cl, e.CatmullRomCurve3 = Zl, e.CineonToneMapping = Y, e.CircleBufferGeometry = Pl, e.CircleGeometry = Pl, e.ClampToEdgeWrapping = st, e.Clock = mu, e.Color = Ze, e.ColorKeyframeTrack = fh, e.CompressedTexture = Ll, e.CompressedTextureLoader = class extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
                             s = [],
-                            a = new fo,
-                            o = new mc(this.manager);
+                            a = new Ll,
+                            o = new Rh(this.manager);
                         o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials);
                         let l = 0;
 
                         function c(c) {
                             o.load(t[c], (function(t) {
                                 const n = r.parse(t, !0);
                                 s[c] = {
                                     width: n.width,
                                     height: n.height,
                                     format: n.format,
                                     mipmaps: n.mipmaps
-                                }, l += 1, 6 === l && (1 === n.mipmapCount && (a.minFilter = v), a.image = s, a.format = n.format, a.needsUpdate = !0, e && e(a))
+                                }, l += 1, 6 === l && (1 === n.mipmapCount && (a.minFilter = ht), a.image = s, a.format = n.format, a.needsUpdate = !0, e && e(a))
                             }), n, i)
                         }
                         if (Array.isArray(t))
                             for (let e = 0, n = t.length; e < n; ++e) c(e);
                         else o.load(t, (function(t) {
                             const n = r.parse(t, !0);
                             if (n.isCubemap) {
@@ -15795,19 +16164,19 @@
                                     s[e] = {
                                         mipmaps: []
                                     };
                                     for (let t = 0; t < n.mipmapCount; t++) s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), s[e].format = n.format, s[e].width = n.width, s[e].height = n.height
                                 }
                                 a.image = s
                             } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
-                            1 === n.mipmapCount && (a.minFilter = v), a.format = n.format, a.needsUpdate = !0, e && e(a)
+                            1 === n.mipmapCount && (a.minFilter = ht), a.format = n.format, a.needsUpdate = !0, e && e(a)
                         }), n, i);
                         return a
                     }
-                }, e.ConeBufferGeometry = yo, e.ConeGeometry = yo, e.CubeCamera = li, e.CubeReflectionMapping = s, e.CubeRefractionMapping = a, e.CubeTexture = ci, e.CubeTextureLoader = gc, e.CubeUVReflectionMapping = c, e.CubeUVRefractionMapping = h, e.CubicBezierCurve = zo, e.CubicBezierCurve3 = Ho, e.CubicInterpolant = Jl, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = Ao, e.CurvePath = qo, e.CustomBlending = 5, e.CustomToneMapping = 5, e.CylinderBufferGeometry = xo, e.CylinderGeometry = xo, e.Cylindrical = class {
+                }, e.ConeBufferGeometry = Il, e.ConeGeometry = Il, e.CubeCamera = xr, e.CubeReflectionMapping = Q, e.CubeRefractionMapping = $, e.CubeTexture = yr, e.CubeTextureLoader = Ch, e.CubeUVReflectionMapping = nt, e.CubeUVRefractionMapping = it, e.CubicBezierCurve = $l, e.CubicBezierCurve3 = tc, e.CubicInterpolant = hh, e.CullFaceBack = r, e.CullFaceFront = s, e.CullFaceFrontBack = 3, e.CullFaceNone = i, e.Curve = Gl, e.CurvePath = oc, e.CustomBlending = v, e.CustomToneMapping = J, e.CylinderBufferGeometry = Dl, e.CylinderGeometry = Dl, e.Cylindrical = class {
                     constructor(t = 1, e = 0, n = 0) {
                         return this.radius = t, this.theta = e, this.y = n, this
                     }
                     set(t, e, n) {
                         return this.radius = t, this.theta = e, this.y = n, this
                     }
                     copy(t) {
@@ -15818,133 +16187,133 @@
                     }
                     setFromCartesianCoords(t, e, n) {
                         return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
-                }, e.DataTexture = Fa, e.DataTexture2DArray = er, e.DataTexture3D = or, e.DataTextureLoader = vc, e.DataUtils = class {
+                }, e.DataTexture = $o, e.DataTexture2DArray = ps, e.DataTexture3D = ys, e.DataTextureLoader = Ph, e.DataUtils = class {
                     static toHalfFloat(t) {
-                        t > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), t = 65504), ru[0] = t;
-                        const e = su[0];
+                        t > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), t = 65504), yd[0] = t;
+                        const e = _d[0];
                         let n = e >> 16 & 32768,
                             i = e >> 12 & 2047;
                         const r = e >> 23 & 255;
                         return r < 103 ? n : r > 142 ? (n |= 31744, n |= (255 == r ? 0 : 1) && 8388607 & e, n) : r < 113 ? (i |= 2048, n |= (i >> 114 - r) + (i >> 113 - r & 1), n) : (n |= r - 112 << 10 | i >> 1, n += 1 & i, n)
                     }
-                }, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = uc, e.DepthFormat = A, e.DepthStencilFormat = R, e.DepthTexture = ea, e.DirectionalLight = Ic, e.DirectionalLightHelper = class extends Qe {
+                }, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = Eh, e.DepthFormat = Rt, e.DepthStencilFormat = Lt, e.DepthTexture = go, e.DirectionalLight = qh, e.DirectionalLightHelper = class extends ci {
                     constructor(t, e, n) {
                         super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
-                        let i = new Nn;
-                        i.setAttribute("position", new En([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
-                        const r = new Ya({
+                        let i = new Wi;
+                        i.setAttribute("position", new Oi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
+                        const r = new cl({
                             fog: !1,
                             toneMapped: !1
                         });
-                        this.lightPlane = new to(i, r), this.add(this.lightPlane), i = new Nn, i.setAttribute("position", new En([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new to(i, r), this.add(this.targetLine), this.update()
+                        this.lightPlane = new fl(i, r), this.add(this.lightPlane), i = new Wi, i.setAttribute("position", new Oi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new fl(i, r), this.add(this.targetLine), this.update()
                     }
                     dispose() {
                         this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                     }
                     update() {
-                        Xh.setFromMatrixPosition(this.light.matrixWorld), qh.setFromMatrixPosition(this.light.target.matrixWorld), Yh.subVectors(qh, Xh), this.lightPlane.lookAt(qh), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(qh), this.targetLine.scale.z = Yh.length()
+                        od.setFromMatrixPosition(this.light.matrixWorld), ld.setFromMatrixPosition(this.light.target.matrixWorld), cd.subVectors(ld, od), this.lightPlane.lookAt(ld), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(ld), this.targetLine.scale.z = cd.length()
                     }
-                }, e.DiscreteInterpolant = Ql, e.DodecahedronBufferGeometry = Mo, e.DodecahedronGeometry = Mo, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function(t, e) {
-                    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new gn(t, e).setUsage(ut)
-                }, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = ut, e.DynamicReadUsage = 35049, e.EdgesGeometry = To, e.EdgesHelper = function(t, e) {
-                    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new io(new To(t.geometry), new Ya({
+                }, e.DiscreteInterpolant = dh, e.DodecahedronBufferGeometry = Ol, e.DodecahedronGeometry = Ol, e.DoubleSide = u, e.DstAlphaFactor = L, e.DstColorFactor = P, e.DynamicBufferAttribute = function(t, e) {
+                    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new Ti(t, e).setUsage(Me)
+                }, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = Me, e.DynamicReadUsage = 35049, e.EdgesGeometry = Hl, e.EdgesHelper = function(t, e) {
+                    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new xl(new Hl(t.geometry), new cl({
                         color: void 0 !== e ? e : 16777215
                     }))
-                }, e.EllipseCurve = Ro, e.EqualDepth = 4, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = o, e.EquirectangularRefractionMapping = l, e.Euler = Be, e.EventDispatcher = mt, e.ExtrudeBufferGeometry = wl, e.ExtrudeGeometry = wl, e.FaceColors = 1, e.FileLoader = mc, e.FlatShading = 1, e.Float16BufferAttribute = Sn, e.Float32Attribute = function(t, e) {
-                    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new En(t, e)
-                }, e.Float32BufferAttribute = En, e.Float64Attribute = function(t, e) {
-                    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Tn(t, e)
-                }, e.Float64BufferAttribute = Tn, e.FloatType = w, e.Fog = oa, e.FogExp2 = aa, e.Font = function() {
+                }, e.EllipseCurve = Vl, e.EqualDepth = F, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = tt, e.EquirectangularRefractionMapping = et, e.Euler = Yn, e.EventDispatcher = Se, e.ExtrudeBufferGeometry = Bc, e.ExtrudeGeometry = Bc, e.FaceColors = 1, e.FileLoader = Rh, e.FlatShading = 1, e.Float16BufferAttribute = Ni, e.Float32Attribute = function(t, e) {
+                    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Oi(t, e)
+                }, e.Float32BufferAttribute = Oi, e.Float64Attribute = function(t, e) {
+                    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Ui(t, e)
+                }, e.Float64BufferAttribute = Ui, e.FloatType = yt, e.Fog = bo, e.FogExp2 = Mo, e.Font = function() {
                     console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")
                 }, e.FontLoader = function() {
                     console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")
-                }, e.FramebufferTexture = mo, e.FrontSide = 0, e.Frustum = vi, e.GLBufferAttribute = Rh, e.GLSL1 = "100", e.GLSL3 = dt, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = jh, e.Group = Qs, e.HalfFloatType = S, e.HemisphereLight = _c, e.HemisphereLightHelper = class extends Qe {
+                }, e.FramebufferTexture = Rl, e.FrontSide = c, e.Frustum = Ar, e.GLBufferAttribute = ku, e.GLSL1 = "100", e.GLSL3 = be, e.GreaterDepth = H, e.GreaterEqualDepth = z, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = ad, e.Group = po, e.HalfFloatType = _t, e.HemisphereLight = Nh, e.HemisphereLightHelper = class extends ci {
                     constructor(t, e, n) {
                         super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
-                        const i = new Al(e);
-                        i.rotateY(.5 * Math.PI), this.material = new pn({
+                        const i = new Gc(e);
+                        i.rotateY(.5 * Math.PI), this.material = new wi({
                             wireframe: !0,
                             fog: !1,
                             toneMapped: !1
                         }), void 0 === this.color && (this.material.vertexColors = !0);
                         const r = i.getAttribute("position"),
                             s = new Float32Array(3 * r.count);
-                        i.setAttribute("color", new gn(s, 3)), this.add(new Qn(i, this.material)), this.update()
+                        i.setAttribute("color", new Ti(s, 3)), this.add(new lr(i, this.material)), this.update()
                     }
                     dispose() {
                         this.children[0].geometry.dispose(), this.children[0].material.dispose()
                     }
                     update() {
                         const t = this.children[0];
                         if (void 0 !== this.color) this.material.color.set(this.color);
                         else {
                             const e = t.geometry.getAttribute("color");
-                            kh.copy(this.light.color), Wh.copy(this.light.groundColor);
+                            rd.copy(this.light.color), sd.copy(this.light.groundColor);
                             for (let t = 0, n = e.count; t < n; t++) {
-                                const i = t < n / 2 ? kh : Wh;
+                                const i = t < n / 2 ? rd : sd;
                                 e.setXYZ(t, i.r, i.g, i.b)
                             }
                             e.needsUpdate = !0
                         }
-                        t.lookAt(Vh.setFromMatrixPosition(this.light.matrixWorld).negate())
+                        t.lookAt(id.setFromMatrixPosition(this.light.matrixWorld).negate())
                     }
-                }, e.HemisphereLightProbe = Zc, e.IcosahedronBufferGeometry = El, e.IcosahedronGeometry = El, e.ImageBitmapLoader = jc, e.ImageLoader = fc, e.ImageUtils = Gt, e.ImmediateRenderObject = function() {
+                }, e.HemisphereLightProbe = cu, e.IcosahedronBufferGeometry = zc, e.IcosahedronGeometry = zc, e.ImageBitmapLoader = su, e.ImageLoader = Lh, e.ImageUtils = Ke, e.ImmediateRenderObject = function() {
                     console.error("THREE.ImmediateRenderObject has been removed.")
-                }, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = Va, e.InstancedBufferGeometry = Hc, e.InstancedInterleavedBuffer = Ah, e.InstancedMesh = qa, e.Int16Attribute = function(t, e) {
-                    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new _n(t, e)
-                }, e.Int16BufferAttribute = _n, e.Int32Attribute = function(t, e) {
-                    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new bn(t, e)
-                }, e.Int32BufferAttribute = bn, e.Int8Attribute = function(t, e) {
-                    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new vn(t, e)
-                }, e.Int8BufferAttribute = vn, e.IntType = 1013, e.InterleavedBuffer = ca, e.InterleavedBufferAttribute = ua, e.Interpolant = Zl, e.InterpolateDiscrete = tt, e.InterpolateLinear = et, e.InterpolateSmooth = nt, e.InvertStencilOp = 5386, e.JSONLoader = function() {
+                }, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = il, e.InstancedBufferGeometry = tu, e.InstancedInterleavedBuffer = Vu, e.InstancedMesh = ll, e.Int16Attribute = function(t, e) {
+                    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Ci(t, e)
+                }, e.Int16BufferAttribute = Ci, e.Int32Attribute = function(t, e) {
+                    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Di(t, e)
+                }, e.Int32BufferAttribute = Di, e.Int8Attribute = function(t, e) {
+                    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Ai(t, e)
+                }, e.Int8BufferAttribute = Ai, e.IntType = vt, e.InterleavedBuffer = So, e.InterleavedBufferAttribute = To, e.Interpolant = ch, e.InterpolateDiscrete = oe, e.InterpolateLinear = le, e.InterpolateSmooth = ce, e.InvertStencilOp = 5386, e.JSONLoader = function() {
                     console.error("THREE.JSONLoader has been removed.")
-                }, e.KeepStencilOp = ct, e.KeyframeTrack = $l, e.LOD = Ca, e.LatheBufferGeometry = Tl, e.LatheGeometry = Tl, e.Layers = Fe, e.LensFlare = function() {
+                }, e.KeepStencilOp = ye, e.KeyframeTrack = ph, e.LOD = jo, e.LatheBufferGeometry = Hc, e.LatheGeometry = Hc, e.Layers = Zn, e.LensFlare = function() {
                     console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
-                }, e.LessDepth = 2, e.LessEqualDepth = 3, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = yc, e.LightProbe = Bc, e.Line = to, e.Line3 = Oh, e.LineBasicMaterial = Ya, e.LineCurve = Go, e.LineCurve3 = Vo, e.LineDashedMaterial = Xl, e.LineLoop = ro, e.LinePieces = 1, e.LineSegments = io, e.LineStrip = 0, e.LinearEncoding = ot, e.LinearFilter = v, e.LinearInterpolant = Kl, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = y, e.LinearMipmapNearestFilter = x, e.LinearToneMapping = 1, e.Loader = dc, e.LoaderUtils = zc, e.LoadingManager = hc, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = {
+                }, e.LessDepth = U, e.LessEqualDepth = B, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = Ih, e.LightProbe = Kh, e.Line = fl, e.Line3 = Ju, e.LineBasicMaterial = cl, e.LineCurve = ec, e.LineCurve3 = nc, e.LineDashedMaterial = ah, e.LineLoop = yl, e.LinePieces = 1, e.LineSegments = xl, e.LineStrip = 0, e.LinearEncoding = me, e.LinearFilter = ht, e.LinearInterpolant = uh, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = dt, e.LinearMipmapNearestFilter = ut, e.LinearToneMapping = X, e.Loader = Th, e.LoaderUtils = $h, e.LoadingManager = Sh, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = At, e.LuminanceFormat = Tt, e.MOUSE = {
                     LEFT: 0,
                     MIDDLE: 1,
                     RIGHT: 2,
                     ROTATE: 0,
                     DOLLY: 1,
                     PAN: 2
-                }, e.Material = dn, e.MaterialLoader = Fc, e.Math = Tt, e.MathUtils = Tt, e.Matrix3 = Rt, e.Matrix4 = Ae, e.MaxEquation = 104, e.Mesh = Qn, e.MeshBasicMaterial = pn, e.MeshDepthMaterial = js, e.MeshDistanceMaterial = Xs, e.MeshFaceMaterial = function(t) {
+                }, e.Material = bi, e.MaterialLoader = Qh, e.Math = Ue, e.MathUtils = Ue, e.Matrix3 = Fe, e.Matrix4 = Fn, e.MaxEquation = b, e.Mesh = lr, e.MeshBasicMaterial = wi, e.MeshDepthMaterial = io, e.MeshDistanceMaterial = ro, e.MeshFaceMaterial = function(t) {
                     return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
-                }, e.MeshLambertMaterial = Wl, e.MeshMatcapMaterial = jl, e.MeshNormalMaterial = kl, e.MeshPhongMaterial = Gl, e.MeshPhysicalMaterial = Hl, e.MeshStandardMaterial = zl, e.MeshToonMaterial = Vl, e.MinEquation = 103, e.MirroredRepeatWrapping = p, e.MixOperation = 1, e.MultiMaterial = function(t = []) {
+                }, e.MeshLambertMaterial = rh, e.MeshMatcapMaterial = sh, e.MeshNormalMaterial = ih, e.MeshPhongMaterial = eh, e.MeshPhysicalMaterial = th, e.MeshStandardMaterial = $c, e.MeshToonMaterial = nh, e.MinEquation = M, e.MirroredRepeatWrapping = at, e.MixOperation = k, e.MultiMaterial = function(t = []) {
                     return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                         return t.slice()
                     }, t
-                }, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = m, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = g, e.NearestMipmapNearestFilter = f, e.NeverDepth = 0, e.NeverStencilFunc = 512, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, e.NormalAnimationBlendMode = 2500, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = nc, e.Object3D = Qe, e.ObjectLoader = class extends dc {
+                }, e.MultiplyBlending = g, e.MultiplyOperation = V, e.NearestFilter = ot, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = ct, e.NearestMipmapNearestFilter = lt, e.NeverDepth = N, e.NeverStencilFunc = 512, e.NoBlending = d, e.NoColors = 0, e.NoToneMapping = j, e.NormalAnimationBlendMode = 2500, e.NormalBlending = p, e.NotEqualDepth = G, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = gh, e.Object3D = ci, e.ObjectLoader = class extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = "" === this.path ? zc.extractUrlBase(t) : this.path;
+                            s = "" === this.path ? $h.extractUrlBase(t) : this.path;
                         this.resourcePath = this.resourcePath || s;
-                        const a = new mc(this.manager);
+                        const a = new Rh(this.manager);
                         a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function(n) {
                             let s = null;
                             try {
                                 s = JSON.parse(n)
                             } catch (e) {
                                 return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                             }
                             const a = s.metadata;
                             void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(s, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                         }), n, i)
                     }
                     async loadAsync(t, e) {
-                        const n = "" === this.path ? zc.extractUrlBase(t) : this.path;
+                        const n = "" === this.path ? $h.extractUrlBase(t) : this.path;
                         this.resourcePath = this.resourcePath || n;
-                        const i = new mc(this.manager);
+                        const i = new Rh(this.manager);
                         i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials);
                         const r = await i.loadAsync(t, e),
                             s = JSON.parse(r),
                             a = s.metadata;
                         if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + t);
                         return await this.parseAsync(s)
                     }
@@ -15980,59 +16349,59 @@
                             l = this.parseSkeletons(t.skeletons, o);
                         return this.bindSkeletons(o, l), o
                     }
                     parseShapes(t) {
                         const e = {};
                         if (void 0 !== t)
                             for (let n = 0, i = t.length; n < i; n++) {
-                                const i = (new Zo).fromJSON(t[n]);
+                                const i = (new cc).fromJSON(t[n]);
                                 e[i.uuid] = i
                             }
                         return e
                     }
                     parseSkeletons(t, e) {
                         const n = {},
                             i = {};
                         if (e.traverse((function(t) {
                                 t.isBone && (i[t.uuid] = t)
                             })), void 0 !== t)
                             for (let e = 0, r = t.length; e < r; e++) {
-                                const r = (new Ga).fromJSON(t[e], i);
+                                const r = (new nl).fromJSON(t[e], i);
                                 n[r.uuid] = r
                             }
                         return n
                     }
                     parseGeometries(t, e) {
                         const n = {};
                         if (void 0 !== t) {
-                            const i = new Gc;
+                            const i = new eu;
                             for (let r = 0, s = t.length; r < s; r++) {
                                 let s;
                                 const a = t[r];
                                 switch (a.type) {
                                     case "BufferGeometry":
                                     case "InstancedBufferGeometry":
                                         s = i.parse(a);
                                         break;
                                     case "Geometry":
                                         console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                                         break;
                                     default:
-                                        a.type in Bl ? s = Bl[a.type].fromJSON(a, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)
+                                        a.type in Kc ? s = Kc[a.type].fromJSON(a, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)
                                 }
                                 s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), n[a.uuid] = s
                             }
                         }
                         return n
                     }
                     parseMaterials(t, e) {
                         const n = {},
                             i = {};
                         if (void 0 !== t) {
-                            const r = new Fc;
+                            const r = new Qh;
                             r.setTextures(e);
                             for (let e = 0, s = t.length; e < s; e++) {
                                 const s = t[e];
                                 if ("MultiMaterial" === s.type) {
                                     const t = [];
                                     for (let e = 0; e < s.materials.length; e++) {
                                         const i = s.materials[e];
@@ -16045,15 +16414,15 @@
                         return i
                     }
                     parseAnimations(t) {
                         const e = {};
                         if (void 0 !== t)
                             for (let n = 0; n < t.length; n++) {
                                 const i = t[n],
-                                    r = oc.parse(i);
+                                    r = Mh.parse(i);
                                 e[r.uuid] = r
                             }
                         return e
                     }
                     parseImages(t, e) {
                         const n = this,
                             i = {};
@@ -16067,30 +16436,30 @@
                                         n.manager.itemEnd(t)
                                     }), void 0, (function() {
                                         n.manager.itemError(t), n.manager.itemEnd(t)
                                     }))
                                 }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e)
                             }
                             return t.data ? {
-                                data: Pt(t.type, t.data),
+                                data: Ge(t.type, t.data),
                                 width: t.width,
                                 height: t.height
                             } : null
                         }
                         if (void 0 !== t && t.length > 0) {
-                            const n = new hc(e);
-                            r = new fc(n), r.setCrossOrigin(this.crossOrigin);
+                            const n = new Sh(e);
+                            r = new Lh(n), r.setCrossOrigin(this.crossOrigin);
                             for (let e = 0, n = t.length; e < n; e++) {
                                 const n = t[e],
                                     r = n.url;
                                 if (Array.isArray(r)) {
                                     i[n.uuid] = [];
                                     for (let t = 0, e = r.length; t < e; t++) {
                                         const e = s(r[t]);
-                                        null !== e && (e instanceof HTMLImageElement ? i[n.uuid].push(e) : i[n.uuid].push(new Fa(e.data, e.width, e.height)))
+                                        null !== e && (e instanceof HTMLImageElement ? i[n.uuid].push(e) : i[n.uuid].push(new $o(e.data, e.width, e.height)))
                                     }
                                 } else {
                                     const t = s(n.url);
                                     null !== t && (i[n.uuid] = t)
                                 }
                             }
                         }
@@ -16103,30 +16472,30 @@
                         async function r(t) {
                             if ("string" == typeof t) {
                                 const n = t,
                                     r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : e.resourcePath + n;
                                 return await i.loadAsync(r)
                             }
                             return t.data ? {
-                                data: Pt(t.type, t.data),
+                                data: Ge(t.type, t.data),
                                 width: t.width,
                                 height: t.height
                             } : null
                         }
                         if (void 0 !== t && t.length > 0) {
-                            i = new fc(this.manager), i.setCrossOrigin(this.crossOrigin);
+                            i = new Lh(this.manager), i.setCrossOrigin(this.crossOrigin);
                             for (let e = 0, i = t.length; e < i; e++) {
                                 const i = t[e],
                                     s = i.url;
                                 if (Array.isArray(s)) {
                                     n[i.uuid] = [];
                                     for (let t = 0, e = s.length; t < e; t++) {
                                         const e = s[t],
                                             a = await r(e);
-                                        null !== a && (a instanceof HTMLImageElement ? n[i.uuid].push(a) : n[i.uuid].push(new Fa(a.data, a.width, a.height)))
+                                        null !== a && (a instanceof HTMLImageElement ? n[i.uuid].push(a) : n[i.uuid].push(new $o(a.data, a.width, a.height)))
                                     }
                                 } else {
                                     const t = await r(i.url);
                                     null !== t && (n[i.uuid] = t)
                                 }
                             }
                         }
@@ -16139,15 +16508,15 @@
                         const i = {};
                         if (void 0 !== t)
                             for (let r = 0, s = t.length; r < s; r++) {
                                 const s = t[r];
                                 let a;
                                 void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                                 const o = e[s.image];
-                                Array.isArray(o) ? (a = new ci(o), 6 === o.length && (a.needsUpdate = !0)) : (a = o && o.data ? new Fa(o.data, o.width, o.height) : new kt(o), o && (a.needsUpdate = !0)), a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, Vc)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], kc), a.wrapT = n(s.wrap[1], kc)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, Wc)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, Wc)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), void 0 !== s.userData && (a.userData = s.userData), i[s.uuid] = a
+                                Array.isArray(o) ? (a = new yr(o), 6 === o.length && (a.needsUpdate = !0)) : (a = o && o.data ? new $o(o.data, o.width, o.height) : new $e(o), o && (a.needsUpdate = !0)), a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, nu)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], iu), a.wrapT = n(s.wrap[1], iu)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, ru)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, ru)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), void 0 !== s.userData && (a.userData = s.userData), i[s.uuid] = a
                             }
                         return i
                     }
                     parseObject(t, e, n, i, r) {
                         let s, a, o;
 
                         function l(t) {
@@ -16169,83 +16538,83 @@
                         }
 
                         function h(t) {
                             return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined texture", t), i[t]
                         }
                         switch (t.type) {
                             case "Scene":
-                                s = new la, void 0 !== t.background && (Number.isInteger(t.background) ? s.background = new zt(t.background) : s.background = h(t.background)), void 0 !== t.environment && (s.environment = h(t.environment)), void 0 !== t.fog && ("Fog" === t.fog.type ? s.fog = new oa(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (s.fog = new aa(t.fog.color, t.fog.density)));
+                                s = new wo, void 0 !== t.background && (Number.isInteger(t.background) ? s.background = new Ze(t.background) : s.background = h(t.background)), void 0 !== t.environment && (s.environment = h(t.environment)), void 0 !== t.fog && ("Fog" === t.fog.type ? s.fog = new bo(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (s.fog = new Mo(t.fog.color, t.fog.density)));
                                 break;
                             case "PerspectiveCamera":
-                                s = new ai(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (s.focus = t.focus), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset), void 0 !== t.view && (s.view = Object.assign({}, t.view));
+                                s = new gr(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (s.focus = t.focus), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                                 break;
                             case "OrthographicCamera":
-                                s = new Ci(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.view && (s.view = Object.assign({}, t.view));
+                                s = new Hr(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                                 break;
                             case "AmbientLight":
-                                s = new Nc(t.color, t.intensity);
+                                s = new Yh(t.color, t.intensity);
                                 break;
                             case "DirectionalLight":
-                                s = new Ic(t.color, t.intensity);
+                                s = new qh(t.color, t.intensity);
                                 break;
                             case "PointLight":
-                                s = new Pc(t.color, t.intensity, t.distance, t.decay);
+                                s = new jh(t.color, t.intensity, t.distance, t.decay);
                                 break;
                             case "RectAreaLight":
-                                s = new Oc(t.color, t.intensity, t.width, t.height);
+                                s = new Zh(t.color, t.intensity, t.width, t.height);
                                 break;
                             case "SpotLight":
-                                s = new Tc(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
+                                s = new Hh(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                                 break;
                             case "HemisphereLight":
-                                s = new _c(t.color, t.groundColor, t.intensity);
+                                s = new Nh(t.color, t.groundColor, t.intensity);
                                 break;
                             case "LightProbe":
-                                s = (new Bc).fromJSON(t);
+                                s = (new Kh).fromJSON(t);
                                 break;
                             case "SkinnedMesh":
-                                a = l(t.geometry), o = c(t.material), s = new Ua(a, o), void 0 !== t.bindMode && (s.bindMode = t.bindMode), void 0 !== t.bindMatrix && s.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (s.skeleton = t.skeleton);
+                                a = l(t.geometry), o = c(t.material), s = new Ko(a, o), void 0 !== t.bindMode && (s.bindMode = t.bindMode), void 0 !== t.bindMatrix && s.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (s.skeleton = t.skeleton);
                                 break;
                             case "Mesh":
-                                a = l(t.geometry), o = c(t.material), s = new Qn(a, o);
+                                a = l(t.geometry), o = c(t.material), s = new lr(a, o);
                                 break;
                             case "InstancedMesh":
                                 a = l(t.geometry), o = c(t.material);
                                 const e = t.count,
                                     n = t.instanceMatrix,
                                     i = t.instanceColor;
-                                s = new qa(a, o, e), s.instanceMatrix = new Va(new Float32Array(n.array), 16), void 0 !== i && (s.instanceColor = new Va(new Float32Array(i.array), i.itemSize));
+                                s = new ll(a, o, e), s.instanceMatrix = new il(new Float32Array(n.array), 16), void 0 !== i && (s.instanceColor = new il(new Float32Array(i.array), i.itemSize));
                                 break;
                             case "LOD":
-                                s = new Ca;
+                                s = new jo;
                                 break;
                             case "Line":
-                                s = new to(l(t.geometry), c(t.material));
+                                s = new fl(l(t.geometry), c(t.material));
                                 break;
                             case "LineLoop":
-                                s = new ro(l(t.geometry), c(t.material));
+                                s = new yl(l(t.geometry), c(t.material));
                                 break;
                             case "LineSegments":
-                                s = new io(l(t.geometry), c(t.material));
+                                s = new xl(l(t.geometry), c(t.material));
                                 break;
                             case "PointCloud":
                             case "Points":
-                                s = new ho(l(t.geometry), c(t.material));
+                                s = new El(l(t.geometry), c(t.material));
                                 break;
                             case "Sprite":
-                                s = new Ta(c(t.material));
+                                s = new Go(c(t.material));
                                 break;
                             case "Group":
-                                s = new Qs;
+                                s = new po;
                                 break;
                             case "Bone":
-                                s = new Ba;
+                                s = new Qo;
                                 break;
                             default:
-                                s = new Qe
+                                s = new ci
                         }
                         if (s.uuid = t.uuid, void 0 !== t.name && (s.name = t.name), void 0 !== t.matrix ? (s.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== t.position && s.position.fromArray(t.position), void 0 !== t.rotation && s.rotation.fromArray(t.rotation), void 0 !== t.quaternion && s.quaternion.fromArray(t.quaternion), void 0 !== t.scale && s.scale.fromArray(t.scale)), void 0 !== t.castShadow && (s.castShadow = t.castShadow), void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (s.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (s.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && s.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (s.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.layers && (s.layers.mask = t.layers), void 0 !== t.children) {
                             const a = t.children;
                             for (let t = 0; t < a.length; t++) s.add(this.parseObject(a[t], e, n, i, r))
                         }
                         if (void 0 !== t.animations) {
                             const e = t.animations;
@@ -16272,66 +16641,66 @@
                                 void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(n, t.bindMatrix)
                             }
                         }))
                     }
                     setTexturePath(t) {
                         return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
                     }
-                }, e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = Al, e.OctahedronGeometry = Al, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = Ci, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.PMREMGenerator = Wi, e.ParametricGeometry = function() {
-                    return console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), new Nn
+                }, e.ObjectSpaceNormalMap = xe, e.OctahedronBufferGeometry = Gc, e.OctahedronGeometry = Gc, e.OneFactor = S, e.OneMinusDstAlphaFactor = C, e.OneMinusDstColorFactor = D, e.OneMinusSrcAlphaFactor = R, e.OneMinusSrcColorFactor = T, e.OrthographicCamera = Hr, e.PCFShadowMap = a, e.PCFSoftShadowMap = o, e.PMREMGenerator = ns, e.ParametricGeometry = function() {
+                    return console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), new Wi
                 }, e.Particle = function(t) {
-                    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ta(t)
+                    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Go(t)
                 }, e.ParticleBasicMaterial = function(t) {
-                    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new so(t)
+                    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new _l(t)
                 }, e.ParticleSystem = function(t, e) {
-                    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new ho(t, e)
+                    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new El(t, e)
                 }, e.ParticleSystemMaterial = function(t) {
-                    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new so(t)
-                }, e.Path = Yo, e.PerspectiveCamera = ai, e.Plane = mi, e.PlaneBufferGeometry = _i, e.PlaneGeometry = _i, e.PlaneHelper = class extends to {
+                    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new _l(t)
+                }, e.Path = lc, e.PerspectiveCamera = gr, e.Plane = Sr, e.PlaneBufferGeometry = Cr, e.PlaneGeometry = Cr, e.PlaneHelper = class extends fl {
                     constructor(t, e = 1, n = 16776960) {
                         const i = n,
-                            r = new Nn;
-                        r.setAttribute("position", new En([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), super(r, new Ya({
+                            r = new Wi;
+                        r.setAttribute("position", new Oi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), super(r, new cl({
                             color: i,
                             toneMapped: !1
                         })), this.type = "PlaneHelper", this.plane = t, this.size = e;
-                        const s = new Nn;
-                        s.setAttribute("position", new En([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new Qn(s, new pn({
+                        const s = new Wi;
+                        s.setAttribute("position", new Oi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new lr(s, new wi({
                             color: i,
                             opacity: .2,
                             transparent: !0,
                             depthWrite: !1,
                             toneMapped: !1
                         })))
                     }
                     updateMatrixWorld(t) {
                         let e = -this.plane.constant;
-                        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? 1 : 0, this.lookAt(this.plane.normal), super.updateMatrixWorld(t)
+                        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? h : c, this.lookAt(this.plane.normal), super.updateMatrixWorld(t)
                     }
                 }, e.PointCloud = function(t, e) {
-                    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new ho(t, e)
+                    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new El(t, e)
                 }, e.PointCloudMaterial = function(t) {
-                    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new so(t)
-                }, e.PointLight = Pc, e.PointLightHelper = class extends Qn {
+                    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new _l(t)
+                }, e.PointLight = jh, e.PointLightHelper = class extends lr {
                     constructor(t, e, n) {
-                        super(new Cl(e, 4, 2), new pn({
+                        super(new Wc(e, 4, 2), new wi({
                             wireframe: !0,
                             fog: !1,
                             toneMapped: !1
                         })), this.light = t, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                     }
                     dispose() {
                         this.geometry.dispose(), this.material.dispose()
                     }
                     update() {
                         void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                     }
-                }, e.Points = ho, e.PointsMaterial = so, e.PolarGridHelper = class extends io {
+                }, e.Points = El, e.PointsMaterial = _l, e.PolarGridHelper = class extends xl {
                     constructor(t = 10, e = 16, n = 8, i = 64, r = 4473924, s = 8947848) {
-                        r = new zt(r), s = new zt(s);
+                        r = new Ze(r), s = new Ze(s);
                         const a = [],
                             o = [];
                         for (let n = 0; n <= e; n++) {
                             const i = n / e * (2 * Math.PI),
                                 l = Math.sin(i) * t,
                                 c = Math.cos(i) * t;
                             a.push(0, 0, 0), a.push(l, 0, c);
@@ -16344,21 +16713,21 @@
                             for (let t = 0; t < i; t++) {
                                 let e = t / i * (2 * Math.PI),
                                     n = Math.sin(e) * c,
                                     r = Math.cos(e) * c;
                                 a.push(n, 0, r), o.push(l.r, l.g, l.b), e = (t + 1) / i * (2 * Math.PI), n = Math.sin(e) * c, r = Math.cos(e) * c, a.push(n, 0, r), o.push(l.r, l.g, l.b)
                             }
                         }
-                        const l = new Nn;
-                        l.setAttribute("position", new En(a, 3)), l.setAttribute("color", new En(o, 3)), super(l, new Ya({
+                        const l = new Wi;
+                        l.setAttribute("position", new Oi(a, 3)), l.setAttribute("color", new Oi(o, 3)), super(l, new cl({
                             vertexColors: !0,
                             toneMapped: !1
                         })), this.type = "PolarGridHelper"
                     }
-                }, e.PolyhedronBufferGeometry = _o, e.PolyhedronGeometry = _o, e.PositionalAudio = class extends ah {
+                }, e.PolyhedronBufferGeometry = Nl, e.PolyhedronGeometry = Nl, e.PositionalAudio = class extends _u {
                     constructor(t) {
                         super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                     }
                     getOutput() {
                         return this.panner
                     }
                     getRefDistance() {
@@ -16386,24 +16755,24 @@
                         return this.panner.maxDistance = t, this
                     }
                     setDirectionalCone(t, e, n) {
                         return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
                     }
                     updateMatrixWorld(t) {
                         if (super.updateMatrixWorld(t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
-                        this.matrixWorld.decompose(oh, lh, ch), hh.set(0, 0, 1).applyQuaternion(lh);
+                        this.matrixWorld.decompose(Mu, bu, wu), Su.set(0, 0, 1).applyQuaternion(bu);
                         const e = this.panner;
                         if (e.positionX) {
                             const t = this.context.currentTime + this.listener.timeDelta;
-                            e.positionX.linearRampToValueAtTime(oh.x, t), e.positionY.linearRampToValueAtTime(oh.y, t), e.positionZ.linearRampToValueAtTime(oh.z, t), e.orientationX.linearRampToValueAtTime(hh.x, t), e.orientationY.linearRampToValueAtTime(hh.y, t), e.orientationZ.linearRampToValueAtTime(hh.z, t)
-                        } else e.setPosition(oh.x, oh.y, oh.z), e.setOrientation(hh.x, hh.y, hh.z)
+                            e.positionX.linearRampToValueAtTime(Mu.x, t), e.positionY.linearRampToValueAtTime(Mu.y, t), e.positionZ.linearRampToValueAtTime(Mu.z, t), e.orientationX.linearRampToValueAtTime(Su.x, t), e.orientationY.linearRampToValueAtTime(Su.y, t), e.orientationZ.linearRampToValueAtTime(Su.z, t)
+                        } else e.setPosition(Mu.x, Mu.y, Mu.z), e.setOrientation(Su.x, Su.y, Su.z)
                     }
-                }, e.PropertyBinding = bh, e.PropertyMixer = dh, e.QuadraticBezierCurve = ko, e.QuadraticBezierCurve3 = Wo, e.Quaternion = Zt, e.QuaternionKeyframeTrack = rc, e.QuaternionLinearInterpolant = ic, e.REVISION = n, e.RGBADepthPacking = 3201, e.RGBAFormat = T, e.RGBAIntegerFormat = 1033, e.RGBA_ASTC_10x10_Format = J, e.RGBA_ASTC_10x5_Format = q, e.RGBA_ASTC_10x6_Format = Y, e.RGBA_ASTC_10x8_Format = Z, e.RGBA_ASTC_12x10_Format = K, e.RGBA_ASTC_12x12_Format = Q, e.RGBA_ASTC_4x4_Format = z, e.RGBA_ASTC_5x4_Format = H, e.RGBA_ASTC_5x5_Format = G, e.RGBA_ASTC_6x5_Format = V, e.RGBA_ASTC_6x6_Format = k, e.RGBA_ASTC_8x5_Format = W, e.RGBA_ASTC_8x6_Format = j, e.RGBA_ASTC_8x8_Format = X, e.RGBA_BPTC_Format = $, e.RGBA_ETC2_EAC_Format = F, e.RGBA_PVRTC_2BPPV1_Format = U, e.RGBA_PVRTC_4BPPV1_Format = O, e.RGBA_S3TC_DXT1_Format = C, e.RGBA_S3TC_DXT3_Format = P, e.RGBA_S3TC_DXT5_Format = D, e.RGB_ETC1_Format = 36196, e.RGB_ETC2_Format = B, e.RGB_PVRTC_2BPPV1_Format = N, e.RGB_PVRTC_4BPPV1_Format = I, e.RGB_S3TC_DXT1_Format = L, e.RGFormat = 1030, e.RGIntegerFormat = 1031, e.RawShaderMaterial = Pi, e.Ray = Te, e.Raycaster = class {
+                }, e.PropertyBinding = Bu, e.PropertyMixer = Tu, e.QuadraticBezierCurve = ic, e.QuadraticBezierCurve3 = rc, e.Quaternion = an, e.QuaternionKeyframeTrack = xh, e.QuaternionLinearInterpolant = vh, e.REVISION = n, e.RGBADepthPacking = ge, e.RGBAFormat = Et, e.RGBAIntegerFormat = Nt, e.RGBA_ASTC_10x10_Format = ie, e.RGBA_ASTC_10x5_Format = te, e.RGBA_ASTC_10x6_Format = ee, e.RGBA_ASTC_10x8_Format = ne, e.RGBA_ASTC_12x10_Format = re, e.RGBA_ASTC_12x12_Format = se, e.RGBA_ASTC_4x4_Format = Xt, e.RGBA_ASTC_5x4_Format = qt, e.RGBA_ASTC_5x5_Format = Yt, e.RGBA_ASTC_6x5_Format = Zt, e.RGBA_ASTC_6x6_Format = Jt, e.RGBA_ASTC_8x5_Format = Kt, e.RGBA_ASTC_8x6_Format = Qt, e.RGBA_ASTC_8x8_Format = $t, e.RGBA_BPTC_Format = ae, e.RGBA_ETC2_EAC_Format = jt, e.RGBA_PVRTC_2BPPV1_Format = Vt, e.RGBA_PVRTC_4BPPV1_Format = Gt, e.RGBA_S3TC_DXT1_Format = Ut, e.RGBA_S3TC_DXT3_Format = Bt, e.RGBA_S3TC_DXT5_Format = Ft, e.RGB_ETC1_Format = kt, e.RGB_ETC2_Format = Wt, e.RGB_PVRTC_2BPPV1_Format = Ht, e.RGB_PVRTC_4BPPV1_Format = zt, e.RGB_S3TC_DXT1_Format = Ot, e.RGFormat = Dt, e.RGIntegerFormat = It, e.RawShaderMaterial = Gr, e.Ray = Bn, e.Raycaster = class {
                     constructor(t, e, n = 0, i = 1 / 0) {
-                        this.ray = new Te(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new Fe, this.params = {
+                        this.ray = new Bn(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new Zn, this.params = {
                             Mesh: {},
                             Line: {
                                 threshold: 1
                             },
                             LOD: {},
                             Points: {
                                 threshold: 1
@@ -16414,26 +16783,26 @@
                     set(t, e) {
                         this.ray.set(t, e)
                     }
                     setFromCamera(t, e) {
                         e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
                     }
                     intersectObject(t, e = !0, n = []) {
-                        return Ch(t, this, n, e), n.sort(Lh), n
+                        return ju(t, this, n, e), n.sort(Wu), n
                     }
                     intersectObjects(t, e = !0, n = []) {
-                        for (let i = 0, r = t.length; i < r; i++) Ch(t[i], this, n, e);
-                        return n.sort(Lh), n
+                        for (let i = 0, r = t.length; i < r; i++) ju(t[i], this, n, e);
+                        return n.sort(Wu), n
                     }
-                }, e.RectAreaLight = Oc, e.RedFormat = 1028, e.RedIntegerFormat = 1029, e.ReinhardToneMapping = 2, e.RepeatWrapping = u, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = 102, e.RingBufferGeometry = Rl, e.RingGeometry = Rl, e.Scene = la, e.SceneUtils = au, e.ShaderChunk = Mi, e.ShaderLib = wi, e.ShaderMaterial = ri, e.ShadowMaterial = Fl, e.Shape = Zo, e.ShapeBufferGeometry = Ll, e.ShapeGeometry = Ll, e.ShapePath = class {
+                }, e.RectAreaLight = Zh, e.RedFormat = Ct, e.RedIntegerFormat = Pt, e.ReinhardToneMapping = q, e.RepeatWrapping = rt, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = _, e.RingBufferGeometry = Vc, e.RingGeometry = Vc, e.Scene = wo, e.SceneUtils = Md, e.ShaderChunk = Pr, e.ShaderLib = Ir, e.ShaderMaterial = mr, e.ShadowMaterial = Qc, e.Shape = cc, e.ShapeBufferGeometry = kc, e.ShapeGeometry = kc, e.ShapePath = class {
                     constructor() {
-                        this.type = "ShapePath", this.color = new zt, this.subPaths = [], this.currentPath = null
+                        this.type = "ShapePath", this.color = new Ze, this.subPaths = [], this.currentPath = null
                     }
                     moveTo(t, e) {
-                        return this.currentPath = new Yo, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
+                        return this.currentPath = new lc, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
                     }
                     lineTo(t, e) {
                         return this.currentPath.lineTo(t, e), this
                     }
                     quadraticCurveTo(t, e, n, i) {
                         return this.currentPath.quadraticCurveTo(t, e, n, i), this
                     }
@@ -16444,15 +16813,15 @@
                         return this.currentPath.splineThru(t), this
                     }
                     toShapes(t, e) {
                         function n(t) {
                             const e = [];
                             for (let n = 0, i = t.length; n < i; n++) {
                                 const i = t[n],
-                                    r = new Zo;
+                                    r = new cc;
                                 r.curves = i.curves, e.push(r)
                             }
                             return e
                         }
 
                         function i(t, e) {
                             const n = e.length;
@@ -16475,30 +16844,30 @@
                                 } else {
                                     if (t.y !== n.y) continue;
                                     if (a.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= a.x) return !0
                                 }
                             }
                             return i
                         }
-                        const r = _l.isClockWise,
+                        const r = Nc.isClockWise,
                             s = this.subPaths;
                         if (0 === s.length) return [];
                         if (!0 === e) return n(s);
                         let a, o, l;
                         const c = [];
-                        if (1 === s.length) return o = s[0], l = new Zo, l.curves = o.curves, c.push(l), c;
+                        if (1 === s.length) return o = s[0], l = new cc, l.curves = o.curves, c.push(l), c;
                         let h = !r(s[0].getPoints());
                         h = t ? !h : h;
                         const u = [],
                             d = [];
                         let p, m, f = [],
                             g = 0;
                         d[g] = void 0, f[g] = [];
                         for (let e = 0, n = s.length; e < n; e++) o = s[e], p = o.getPoints(), a = r(p), a = t ? !a : a, a ? (!h && d[g] && g++, d[g] = {
-                            s: new Zo,
+                            s: new cc,
                             p
                         }, d[g].s.curves = o.curves, h && g++, f[g] = []) : f[g].push({
                             h: o,
                             p: p[0]
                         });
                         if (!d[0]) return n(s);
                         if (d.length > 1) {
@@ -16522,15 +16891,15 @@
                         }
                         for (let t = 0, e = d.length; t < e; t++) {
                             l = d[t].s, c.push(l), m = f[t];
                             for (let t = 0, e = m.length; t < e; t++) l.holes.push(m[t].h)
                         }
                         return c
                     }
-                }, e.ShapeUtils = _l, e.ShortType = 1011, e.Skeleton = Ga, e.SkeletonHelper = Hh, e.SkinnedMesh = Ua, e.SmoothShading = 2, e.Sphere = xe, e.SphereBufferGeometry = Cl, e.SphereGeometry = Cl, e.Spherical = class {
+                }, e.ShapeUtils = Nc, e.ShortType = ft, e.Skeleton = nl, e.SkeletonHelper = ed, e.SkinnedMesh = Ko, e.SmoothShading = 2, e.Sphere = Ln, e.SphereBufferGeometry = Wc, e.SphereGeometry = Wc, e.Spherical = class {
                     constructor(t = 1, e = 0, n = 0) {
                         return this.radius = t, this.phi = e, this.theta = n, this
                     }
                     set(t, e, n) {
                         return this.radius = t, this.phi = e, this.theta = n, this
                     }
                     copy(t) {
@@ -16540,138 +16909,230 @@
                         const t = 1e-6;
                         return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
                     }
                     setFromVector3(t) {
                         return this.setFromCartesianCoords(t.x, t.y, t.z)
                     }
                     setFromCartesianCoords(t, e, n) {
-                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(_t(e / this.radius, -1, 1))), this
+                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Ce(e / this.radius, -1, 1))), this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
-                }, e.SphericalHarmonics3 = Uc, e.SplineCurve = jo, e.SpotLight = Tc, e.SpotLightHelper = class extends Qe {
+                }, e.SphericalHarmonics3 = Jh, e.SplineCurve = sc, e.SpotLight = Hh, e.SpotLightHelper = class extends ci {
                     constructor(t, e) {
                         super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
-                        const n = new Nn,
+                        const n = new Wi,
                             i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                         for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
                             const r = t / n * Math.PI * 2,
                                 s = e / n * Math.PI * 2;
                             i.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1)
                         }
-                        n.setAttribute("position", new En(i, 3));
-                        const r = new Ya({
+                        n.setAttribute("position", new Oi(i, 3));
+                        const r = new cl({
                             fog: !1,
                             toneMapped: !1
                         });
-                        this.cone = new io(n, r), this.add(this.cone), this.update()
+                        this.cone = new xl(n, r), this.add(this.cone), this.update()
                     }
                     dispose() {
                         this.cone.geometry.dispose(), this.cone.material.dispose()
                     }
                     update() {
                         this.light.updateMatrixWorld();
                         const t = this.light.distance ? this.light.distance : 1e3,
                             e = t * Math.tan(this.light.angle);
-                        this.cone.scale.set(e, e, t), Uh.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Uh), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
+                        this.cone.scale.set(e, e, t), Ku.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Ku), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                     }
-                }, e.Sprite = Ta, e.SpriteMaterial = da, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StaticCopyUsage = 35046, e.StaticDrawUsage = ht, e.StaticReadUsage = 35045, e.StereoCamera = class {
+                }, e.Sprite = Go, e.SpriteMaterial = Ao, e.SrcAlphaFactor = A, e.SrcAlphaSaturateFactor = I, e.SrcColorFactor = E, e.StaticCopyUsage = 35046, e.StaticDrawUsage = _e, e.StaticReadUsage = 35045, e.StereoCamera = class {
                     constructor() {
-                        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ai, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ai, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
+                        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new gr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new gr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                             focus: null,
                             fov: null,
                             aspect: null,
                             near: null,
                             far: null,
                             zoom: null,
                             eyeSep: null
                         }
                     }
                     update(t) {
                         const e = this._cache;
                         if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
-                            e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep, $c.copy(t.projectionMatrix);
+                            e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep, pu.copy(t.projectionMatrix);
                             const n = e.eyeSep / 2,
                                 i = n * e.near / e.focus,
-                                r = e.near * Math.tan(vt * e.fov * .5) / e.zoom;
+                                r = e.near * Math.tan(Ae * e.fov * .5) / e.zoom;
                             let s, a;
-                            Qc.elements[12] = -n, Kc.elements[12] = n, s = -r * e.aspect + i, a = r * e.aspect + i, $c.elements[0] = 2 * e.near / (a - s), $c.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy($c), s = -r * e.aspect - i, a = r * e.aspect - i, $c.elements[0] = 2 * e.near / (a - s), $c.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy($c)
+                            du.elements[12] = -n, uu.elements[12] = n, s = -r * e.aspect + i, a = r * e.aspect + i, pu.elements[0] = 2 * e.near / (a - s), pu.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(pu), s = -r * e.aspect - i, a = r * e.aspect - i, pu.elements[0] = 2 * e.near / (a - s), pu.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(pu)
                         }
-                        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Qc), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Kc)
+                        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(du), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(uu)
                     }
-                }, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = sc, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TOUCH = {
+                }, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = yh, e.SubtractEquation = y, e.SubtractiveBlending = f, e.TOUCH = {
                     ROTATE: 0,
                     PAN: 1,
                     DOLLY_PAN: 2,
                     DOLLY_ROTATE: 3
-                }, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = Pl, e.TetrahedronGeometry = Pl, e.TextGeometry = function() {
-                    return console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), new Nn
-                }, e.Texture = kt, e.TextureLoader = xc, e.TorusBufferGeometry = Dl, e.TorusGeometry = Dl, e.TorusKnotBufferGeometry = Il, e.TorusKnotGeometry = Il, e.Triangle = hn, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = Nl, e.TubeGeometry = Nl, e.UVMapping = r, e.Uint16Attribute = function(t, e) {
-                    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Mn(t, e)
-                }, e.Uint16BufferAttribute = Mn, e.Uint32Attribute = function(t, e) {
-                    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new wn(t, e)
-                }, e.Uint32BufferAttribute = wn, e.Uint8Attribute = function(t, e) {
-                    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new xn(t, e)
-                }, e.Uint8BufferAttribute = xn, e.Uint8ClampedAttribute = function(t, e) {
-                    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new yn(t, e)
-                }, e.Uint8ClampedBufferAttribute = yn, e.Uniform = Th, e.UniformsLib = bi, e.UniformsUtils = ii, e.UnsignedByteType = _, e.UnsignedInt248Type = E, e.UnsignedIntType = b, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShortType = M, e.VSMShadowMap = 3, e.Vector2 = At, e.Vector3 = Jt, e.Vector4 = jt, e.VectorKeyframeTrack = ac, e.Vertex = function(t, e, n) {
-                    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Jt(t, e, n)
-                }, e.VertexColors = 2, e.VideoTexture = po, e.WebGL1Renderer = sa, e.WebGLCubeRenderTarget = hi, e.WebGLMultipleRenderTargets = qt, e.WebGLMultisampleRenderTarget = Yt, e.WebGLRenderTarget = Xt, e.WebGLRenderTargetCube = function(t, e, n) {
-                    return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new hi(t, n)
-                }, e.WebGLRenderer = ra, e.WebGLUtils = Js, e.WireframeGeometry = Ol, e.WireframeHelper = function(t, e) {
-                    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new io(new Ol(t.geometry), new Ya({
+                }, e.TangentSpaceNormalMap = ve, e.TetrahedronBufferGeometry = jc, e.TetrahedronGeometry = jc, e.TextGeometry = function() {
+                    return console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), new Wi
+                }, e.Texture = $e, e.TextureLoader = Dh, e.TorusBufferGeometry = Xc, e.TorusGeometry = Xc, e.TorusKnotBufferGeometry = qc, e.TorusKnotGeometry = qc, e.Triangle = _i, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = Yc, e.TubeGeometry = Yc, e.UVMapping = K, e.Uint16Attribute = function(t, e) {
+                    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Pi(t, e)
+                }, e.Uint16BufferAttribute = Pi, e.Uint32Attribute = function(t, e) {
+                    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Ii(t, e)
+                }, e.Uint32BufferAttribute = Ii, e.Uint8Attribute = function(t, e) {
+                    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Ri(t, e)
+                }, e.Uint8BufferAttribute = Ri, e.Uint8ClampedAttribute = function(t, e) {
+                    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Li(t, e)
+                }, e.Uint8ClampedBufferAttribute = Li, e.Uniform = Gu, e.UniformsLib = Dr, e.UniformsUtils = pr, e.UnsignedByteType = pt, e.UnsignedInt248Type = wt, e.UnsignedIntType = xt, e.UnsignedShort4444Type = Mt, e.UnsignedShort5551Type = bt, e.UnsignedShortType = gt, e.VSMShadowMap = l, e.Vector2 = Be, e.Vector3 = on, e.Vector4 = en, e.VectorKeyframeTrack = _h, e.Vertex = function(t, e, n) {
+                    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new on(t, e, n)
+                }, e.VertexColors = 2, e.VideoTexture = Al, e.WebGL1Renderer = _o, e.WebGLCubeRenderTarget = _r, e.WebGLMultipleRenderTargets = rn, e.WebGLMultisampleRenderTarget = sn, e.WebGLRenderTarget = nn, e.WebGLRenderTargetCube = function(t, e, n) {
+                    return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new _r(t, n)
+                }, e.WebGLRenderer = yo, e.WebGLUtils = ho, e.WireframeGeometry = Zc, e.WireframeHelper = function(t, e) {
+                    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new xl(new Zc(t.geometry), new cl({
                         color: void 0 !== e ? e : 16777215
                     }))
-                }, e.WrapAroundEnding = st, e.XHRLoader = function(t) {
-                    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new mc(t)
-                }, e.ZeroCurvatureEnding = it, e.ZeroFactor = 200, e.ZeroSlopeEnding = rt, e.ZeroStencilOp = 0, e._SRGBAFormat = pt, e.sRGBEncoding = lt
+                }, e.WrapAroundEnding = de, e.XHRLoader = function(t) {
+                    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Rh(t)
+                }, e.ZeroCurvatureEnding = he, e.ZeroFactor = w, e.ZeroSlopeEnding = ue, e.ZeroStencilOp = 0, e._SRGBAFormat = we, e.sRGBEncoding = fe
             },
-            296: (t, e, n) => {
+            379: (t, e, n) => {
                 n.r(e), n.d(e, {
-                    MapControls: () => _l,
-                    OrbitControls: () => yl
+                    MapControls: () => ch,
+                    OrbitControls: () => lh
                 });
-                const i = 100,
-                    r = 301,
-                    s = 302,
-                    a = 306,
-                    o = 1e3,
-                    l = 1001,
-                    c = 1002,
-                    h = 1003,
-                    u = 1006,
-                    d = 1008,
-                    p = 1009,
-                    m = 1012,
-                    f = 1014,
-                    g = 1015,
-                    v = 1016,
-                    x = 1020,
-                    y = 1023,
-                    _ = 1026,
-                    M = 1027,
-                    b = 33776,
-                    w = 33777,
-                    S = 33778,
-                    E = 33779,
-                    T = 2300,
-                    A = 2301,
-                    R = 2302,
-                    L = 2400,
-                    C = 2401,
-                    P = 2402,
-                    D = 3e3,
-                    I = 3001,
-                    N = 7680,
-                    O = 35044,
-                    U = 35048,
-                    B = "300 es",
-                    F = 1035;
-                class z {
+                const i = "137",
+                    r = 0,
+                    s = 1,
+                    a = 2,
+                    o = 1,
+                    l = 2,
+                    c = 3,
+                    h = 0,
+                    u = 1,
+                    d = 2,
+                    p = 0,
+                    m = 1,
+                    f = 2,
+                    g = 3,
+                    v = 4,
+                    x = 5,
+                    y = 100,
+                    _ = 101,
+                    M = 102,
+                    b = 103,
+                    w = 104,
+                    S = 200,
+                    E = 201,
+                    T = 202,
+                    A = 203,
+                    R = 204,
+                    L = 205,
+                    C = 206,
+                    P = 207,
+                    D = 208,
+                    I = 209,
+                    N = 210,
+                    O = 0,
+                    U = 1,
+                    B = 2,
+                    F = 3,
+                    z = 4,
+                    H = 5,
+                    G = 6,
+                    V = 7,
+                    k = 0,
+                    W = 1,
+                    j = 2,
+                    X = 0,
+                    q = 1,
+                    Y = 2,
+                    Z = 3,
+                    J = 4,
+                    K = 5,
+                    Q = 301,
+                    $ = 302,
+                    tt = 303,
+                    et = 304,
+                    nt = 306,
+                    it = 307,
+                    rt = 1e3,
+                    st = 1001,
+                    at = 1002,
+                    ot = 1003,
+                    lt = 1004,
+                    ct = 1005,
+                    ht = 1006,
+                    ut = 1007,
+                    dt = 1008,
+                    pt = 1009,
+                    mt = 1010,
+                    ft = 1011,
+                    gt = 1012,
+                    vt = 1013,
+                    xt = 1014,
+                    yt = 1015,
+                    _t = 1016,
+                    Mt = 1017,
+                    bt = 1018,
+                    wt = 1020,
+                    St = 1021,
+                    Et = 1023,
+                    Tt = 1024,
+                    At = 1025,
+                    Rt = 1026,
+                    Lt = 1027,
+                    Ct = 1028,
+                    Pt = 1029,
+                    Dt = 1030,
+                    It = 1031,
+                    Nt = 1033,
+                    Ot = 33776,
+                    Ut = 33777,
+                    Bt = 33778,
+                    Ft = 33779,
+                    zt = 35840,
+                    Ht = 35841,
+                    Gt = 35842,
+                    Vt = 35843,
+                    kt = 36196,
+                    Wt = 37492,
+                    jt = 37496,
+                    Xt = 37808,
+                    qt = 37809,
+                    Yt = 37810,
+                    Zt = 37811,
+                    Jt = 37812,
+                    Kt = 37813,
+                    Qt = 37814,
+                    $t = 37815,
+                    te = 37816,
+                    ee = 37817,
+                    ne = 37818,
+                    ie = 37819,
+                    re = 37820,
+                    se = 37821,
+                    ae = 36492,
+                    oe = 2300,
+                    le = 2301,
+                    ce = 2302,
+                    he = 2400,
+                    ue = 2401,
+                    de = 2402,
+                    pe = 3e3,
+                    me = 3001,
+                    fe = 3201,
+                    ge = 0,
+                    ve = 1,
+                    xe = 7680,
+                    ye = 35044,
+                    _e = 35048,
+                    Me = "300 es",
+                    be = 1035;
+                class we {
                     addEventListener(t, e) {
                         void 0 === this._listeners && (this._listeners = {});
                         const n = this._listeners;
                         void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                     }
                     hasEventListener(t, e) {
                         if (void 0 === this._listeners) return !1;
@@ -16692,43 +17153,43 @@
                             t.target = this;
                             const n = e.slice(0);
                             for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                             t.target = null
                         }
                     }
                 }
-                const H = [];
-                for (let t = 0; t < 256; t++) H[t] = (t < 16 ? "0" : "") + t.toString(16);
-                const G = Math.PI / 180,
-                    V = 180 / Math.PI;
+                const Se = [];
+                for (let t = 0; t < 256; t++) Se[t] = (t < 16 ? "0" : "") + t.toString(16);
+                const Ee = Math.PI / 180,
+                    Te = 180 / Math.PI;
 
-                function k() {
+                function Ae() {
                     const t = 4294967295 * Math.random() | 0,
                         e = 4294967295 * Math.random() | 0,
                         n = 4294967295 * Math.random() | 0,
                         i = 4294967295 * Math.random() | 0;
-                    return (H[255 & t] + H[t >> 8 & 255] + H[t >> 16 & 255] + H[t >> 24 & 255] + "-" + H[255 & e] + H[e >> 8 & 255] + "-" + H[e >> 16 & 15 | 64] + H[e >> 24 & 255] + "-" + H[63 & n | 128] + H[n >> 8 & 255] + "-" + H[n >> 16 & 255] + H[n >> 24 & 255] + H[255 & i] + H[i >> 8 & 255] + H[i >> 16 & 255] + H[i >> 24 & 255]).toUpperCase()
+                    return (Se[255 & t] + Se[t >> 8 & 255] + Se[t >> 16 & 255] + Se[t >> 24 & 255] + "-" + Se[255 & e] + Se[e >> 8 & 255] + "-" + Se[e >> 16 & 15 | 64] + Se[e >> 24 & 255] + "-" + Se[63 & n | 128] + Se[n >> 8 & 255] + "-" + Se[n >> 16 & 255] + Se[n >> 24 & 255] + Se[255 & i] + Se[i >> 8 & 255] + Se[i >> 16 & 255] + Se[i >> 24 & 255]).toUpperCase()
                 }
 
-                function W(t, e, n) {
+                function Re(t, e, n) {
                     return Math.max(e, Math.min(n, t))
                 }
 
-                function j(t, e, n) {
+                function Le(t, e, n) {
                     return (1 - n) * t + n * e
                 }
 
-                function X(t) {
+                function Ce(t) {
                     return 0 == (t & t - 1) && 0 !== t
                 }
 
-                function q(t) {
+                function Pe(t) {
                     return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                 }
-                class Y {
+                class De {
                     constructor(t = 0, e = 0) {
                         this.x = t, this.y = e
                     }
                     get width() {
                         return this.x
                     }
                     set width(t) {
@@ -16913,16 +17374,16 @@
                     }
                     random() {
                         return this.x = Math.random(), this.y = Math.random(), this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y
                     }
                 }
-                Y.prototype.isVector2 = !0;
-                class Z {
+                De.prototype.isVector2 = !0;
+                class Ie {
                     constructor() {
                         this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                     }
                     set(t, e, n, i, r, s, a, o, l) {
                         const c = this.elements;
                         return c[0] = t, c[1] = i, c[2] = a, c[3] = e, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this
                     }
@@ -17060,25 +17521,25 @@
                         return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                     }
                     clone() {
                         return (new this.constructor).fromArray(this.elements)
                     }
                 }
 
-                function J(t) {
+                function Ne(t) {
                     for (let e = t.length - 1; e >= 0; --e)
                         if (t[e] > 65535) return !0;
                     return !1
                 }
 
-                function K(t) {
+                function Oe(t) {
                     return document.createElementNS("http://www.w3.org/1999/xhtml", t)
                 }
-                Z.prototype.isMatrix3 = !0, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
-                const Q = {
+                Ie.prototype.isMatrix3 = !0, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
+                const Ue = {
                         aliceblue: 15792383,
                         antiquewhite: 16444375,
                         aqua: 65535,
                         aquamarine: 8388564,
                         azure: 15794175,
                         beige: 16119260,
                         bisque: 16770244,
@@ -17220,37 +17681,37 @@
                         violet: 15631086,
                         wheat: 16113331,
                         white: 16777215,
                         whitesmoke: 16119285,
                         yellow: 16776960,
                         yellowgreen: 10145074
                     },
-                    $ = {
+                    Be = {
                         h: 0,
                         s: 0,
                         l: 0
                     },
-                    tt = {
+                    Fe = {
                         h: 0,
                         s: 0,
                         l: 0
                     };
 
-                function et(t, e, n) {
+                function ze(t, e, n) {
                     return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                 }
 
-                function nt(t) {
+                function He(t) {
                     return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                 }
 
-                function it(t) {
+                function Ge(t) {
                     return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                 }
-                class rt {
+                class Ve {
                     constructor(t, e, n) {
                         return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
                     }
                     set(t) {
                         return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                     }
                     setScalar(t) {
@@ -17259,19 +17720,19 @@
                     setHex(t) {
                         return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                     }
                     setRGB(t, e, n) {
                         return this.r = t, this.g = e, this.b = n, this
                     }
                     setHSL(t, e, n) {
-                        if (t = (t % (i = 1) + i) % i, e = W(e, 0, 1), n = W(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
+                        if (t = (t % (i = 1) + i) % i, e = Re(e, 0, 1), n = Re(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                         else {
                             const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                                 r = 2 * n - i;
-                            this.r = et(r, i, t + 1 / 3), this.g = et(r, i, t), this.b = et(r, i, t - 1 / 3)
+                            this.r = ze(r, i, t + 1 / 3), this.g = ze(r, i, t), this.b = ze(r, i, t - 1 / 3)
                         }
                         var i;
                         return this
                     }
                     setStyle(t) {
                         function e(e) {
                             void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
@@ -17301,28 +17762,28 @@
                                 e = t.length;
                             if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                             if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                         }
                         return t && t.length > 0 ? this.setColorName(t) : this
                     }
                     setColorName(t) {
-                        const e = Q[t.toLowerCase()];
+                        const e = Ue[t.toLowerCase()];
                         return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
                     }
                     clone() {
                         return new this.constructor(this.r, this.g, this.b)
                     }
                     copy(t) {
                         return this.r = t.r, this.g = t.g, this.b = t.b, this
                     }
                     copySRGBToLinear(t) {
-                        return this.r = nt(t.r), this.g = nt(t.g), this.b = nt(t.b), this
+                        return this.r = He(t.r), this.g = He(t.g), this.b = He(t.b), this
                     }
                     copyLinearToSRGB(t) {
-                        return this.r = it(t.r), this.g = it(t.g), this.b = it(t.b), this
+                        return this.r = Ge(t.r), this.g = Ge(t.g), this.b = Ge(t.b), this
                     }
                     convertSRGBToLinear() {
                         return this.copySRGBToLinear(this), this
                     }
                     convertLinearToSRGB() {
                         return this.copyLinearToSRGB(this), this
                     }
@@ -17357,15 +17818,15 @@
                         }
                         return t.h = a, t.s = o, t.l = l, t
                     }
                     getStyle() {
                         return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                     }
                     offsetHSL(t, e, n) {
-                        return this.getHSL($), $.h += t, $.s += e, $.l += n, this.setHSL($.h, $.s, $.l), this
+                        return this.getHSL(Be), Be.h += t, Be.s += e, Be.l += n, this.setHSL(Be.h, Be.s, Be.l), this
                     }
                     add(t) {
                         return this.r += t.r, this.g += t.g, this.b += t.b, this
                     }
                     addColors(t, e) {
                         return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                     }
@@ -17384,18 +17845,18 @@
                     lerp(t, e) {
                         return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                     }
                     lerpColors(t, e, n) {
                         return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
                     }
                     lerpHSL(t, e) {
-                        this.getHSL($), t.getHSL(tt);
-                        const n = j($.h, tt.h, e),
-                            i = j($.s, tt.s, e),
-                            r = j($.l, tt.l, e);
+                        this.getHSL(Be), t.getHSL(Fe);
+                        const n = Le(Be.h, Fe.h, e),
+                            i = Le(Be.s, Fe.s, e),
+                            r = Le(Be.l, Fe.l, e);
                         return this.setHSL(n, i, r), this
                     }
                     equals(t) {
                         return t.r === this.r && t.g === this.g && t.b === this.b
                     }
                     fromArray(t, e = 0) {
                         return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
@@ -17406,58 +17867,58 @@
                     fromBufferAttribute(t, e) {
                         return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                     }
                     toJSON() {
                         return this.getHex()
                     }
                 }
-                let st;
-                rt.NAMES = Q, rt.prototype.isColor = !0, rt.prototype.r = 1, rt.prototype.g = 1, rt.prototype.b = 1;
-                class at {
+                let ke;
+                Ve.NAMES = Ue, Ve.prototype.isColor = !0, Ve.prototype.r = 1, Ve.prototype.g = 1, Ve.prototype.b = 1;
+                class We {
                     static getDataURL(t) {
                         if (/^data:/i.test(t.src)) return t.src;
                         if ("undefined" == typeof HTMLCanvasElement) return t.src;
                         let e;
                         if (t instanceof HTMLCanvasElement) e = t;
                         else {
-                            void 0 === st && (st = K("canvas")), st.width = t.width, st.height = t.height;
-                            const n = st.getContext("2d");
-                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = st
+                            void 0 === ke && (ke = Oe("canvas")), ke.width = t.width, ke.height = t.height;
+                            const n = ke.getContext("2d");
+                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = ke
                         }
                         return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                     }
                     static sRGBToLinear(t) {
                         if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
-                            const e = K("canvas");
+                            const e = Oe("canvas");
                             e.width = t.width, e.height = t.height;
                             const n = e.getContext("2d");
                             n.drawImage(t, 0, 0, t.width, t.height);
                             const i = n.getImageData(0, 0, t.width, t.height),
                                 r = i.data;
-                            for (let t = 0; t < r.length; t++) r[t] = 255 * nt(r[t] / 255);
+                            for (let t = 0; t < r.length; t++) r[t] = 255 * He(r[t] / 255);
                             return n.putImageData(i, 0, 0), e
                         }
                         if (t.data) {
                             const e = t.data.slice(0);
-                            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * nt(e[t] / 255)) : e[t] = nt(e[t]);
+                            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * He(e[t] / 255)) : e[t] = He(e[t]);
                             return {
                                 data: e,
                                 width: t.width,
                                 height: t.height
                             }
                         }
                         return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
                     }
                 }
-                let ot = 0;
-                class lt extends z {
-                    constructor(t = lt.DEFAULT_IMAGE, e = lt.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = 1, c = 3e3) {
+                let je = 0;
+                class Xe extends we {
+                    constructor(t = Xe.DEFAULT_IMAGE, e = Xe.DEFAULT_MAPPING, n = st, i = st, r = ht, s = dt, a = Et, o = pt, l = 1, c = pe) {
                         super(), Object.defineProperty(this, "id", {
-                            value: ot++
-                        }), this.uuid = k(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new Y(0, 0), this.repeat = new Y(1, 1), this.center = new Y(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Z, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
+                            value: je++
+                        }), this.uuid = Ae(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new De(0, 0), this.repeat = new De(1, 1), this.center = new De(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ie, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                     }
                     updateMatrix() {
                         this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
@@ -17489,20 +17950,20 @@
                             anisotropy: this.anisotropy,
                             flipY: this.flipY,
                             premultiplyAlpha: this.premultiplyAlpha,
                             unpackAlignment: this.unpackAlignment
                         };
                         if (void 0 !== this.image) {
                             const i = this.image;
-                            if (void 0 === i.uuid && (i.uuid = k()), !e && void 0 === t.images[i.uuid]) {
+                            if (void 0 === i.uuid && (i.uuid = Ae()), !e && void 0 === t.images[i.uuid]) {
                                 let e;
                                 if (Array.isArray(i)) {
                                     e = [];
-                                    for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(ct(i[t].image)) : e.push(ct(i[t]))
-                                } else e = ct(i);
+                                    for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(qe(i[t].image)) : e.push(qe(i[t]))
+                                } else e = qe(i);
                                 t.images[i.uuid] = {
                                     uuid: i.uuid,
                                     url: e
                                 }
                             }
                             n.image = i.uuid
                         }
@@ -17512,50 +17973,50 @@
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                     transformUv(t) {
                         if (300 !== this.mapping) return t;
                         if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
-                            case o:
+                            case rt:
                                 t.x = t.x - Math.floor(t.x);
                                 break;
-                            case l:
+                            case st:
                                 t.x = t.x < 0 ? 0 : 1;
                                 break;
-                            case c:
+                            case at:
                                 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                         }
                         if (t.y < 0 || t.y > 1) switch (this.wrapT) {
-                            case o:
+                            case rt:
                                 t.y = t.y - Math.floor(t.y);
                                 break;
-                            case l:
+                            case st:
                                 t.y = t.y < 0 ? 0 : 1;
                                 break;
-                            case c:
+                            case at:
                                 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                         }
                         return this.flipY && (t.y = 1 - t.y), t
                     }
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                 }
 
-                function ct(t) {
-                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? at.getDataURL(t) : t.data ? {
+                function qe(t) {
+                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? We.getDataURL(t) : t.data ? {
                         data: Array.prototype.slice.call(t.data),
                         width: t.width,
                         height: t.height,
                         type: t.data.constructor.name
                     } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
                 }
-                lt.DEFAULT_IMAGE = void 0, lt.DEFAULT_MAPPING = 300, lt.prototype.isTexture = !0;
-                class ht {
+                Xe.DEFAULT_IMAGE = void 0, Xe.DEFAULT_MAPPING = 300, Xe.prototype.isTexture = !0;
+                class Ye {
                     constructor(t = 0, e = 0, n = 0, i = 1) {
                         this.x = t, this.y = e, this.z = n, this.w = i
                     }
                     get width() {
                         return this.z
                     }
                     set width(t) {
@@ -17764,22 +18225,22 @@
                     }
                     random() {
                         return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y, yield this.z, yield this.w
                     }
                 }
-                ht.prototype.isVector4 = !0;
-                class ut extends z {
+                Ye.prototype.isVector4 = !0;
+                class Ze extends we {
                     constructor(t, e, n = {}) {
-                        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new ht(0, 0, t, e), this.scissorTest = !1, this.viewport = new ht(0, 0, t, e), this.texture = new lt(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
+                        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new Ye(0, 0, t, e), this.scissorTest = !1, this.viewport = new Ye(0, 0, t, e), this.texture = new Xe(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                             width: t,
                             height: e,
                             depth: 1
-                        }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : u, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
+                        }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ht, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
                     }
                     setTexture(t) {
                         t.image = {
                             width: this.width,
                             height: this.height,
                             depth: this.depth
                         }, this.texture = t
@@ -17795,15 +18256,15 @@
                     }
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }
-                ut.prototype.isWebGLRenderTarget = !0, class extends ut {
+                Ze.prototype.isWebGLRenderTarget = !0, class extends Ze {
                     constructor(t, e, n) {
                         super(t, e);
                         const i = this.texture;
                         this.texture = [];
                         for (let t = 0; t < n; t++) this.texture[t] = i.clone()
                     }
                     setSize(t, e, n = 1) {
@@ -17816,24 +18277,24 @@
                     }
                     copy(t) {
                         this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
                         for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
                         return this
                     }
                 }.prototype.isWebGLMultipleRenderTargets = !0;
-                class dt extends ut {
+                class Je extends Ze {
                     constructor(t, e, n = {}) {
                         super(t, e, n), this.samples = 4, this.ignoreDepthForMultisampleCopy = void 0 === n.ignoreDepth || n.ignoreDepth, this.useRenderToTexture = void 0 !== n.useRenderToTexture && n.useRenderToTexture, this.useRenderbuffer = !1 === this.useRenderToTexture
                     }
                     copy(t) {
                         return super.copy.call(this, t), this.samples = t.samples, this.useRenderToTexture = t.useRenderToTexture, this.useRenderbuffer = t.useRenderbuffer, this
                     }
                 }
-                dt.prototype.isWebGLMultisampleRenderTarget = !0;
-                class pt {
+                Je.prototype.isWebGLMultisampleRenderTarget = !0;
+                class Ke {
                     constructor(t = 0, e = 0, n = 0, i = 1) {
                         this._x = t, this._y = e, this._z = n, this._w = i
                     }
                     static slerp(t, e, n, i) {
                         return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i)
                     }
                     static slerpFlat(t, e, n, i, r, s, a) {
@@ -17980,15 +18441,15 @@
                         return this._onChangeCallback(), this
                     }
                     setFromUnitVectors(t, e) {
                         let n = t.dot(e) + 1;
                         return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                     }
                     angleTo(t) {
-                        return 2 * Math.acos(Math.abs(W(this.dot(t), -1, 1)))
+                        return 2 * Math.acos(Math.abs(Re(this.dot(t), -1, 1)))
                     }
                     rotateTowards(t, e) {
                         const n = this.angleTo(t);
                         if (0 === n) return this;
                         const i = Math.min(1, e / n);
                         return this.slerp(t, i), this
                     }
@@ -18075,16 +18536,16 @@
                         return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                     }
                     _onChange(t) {
                         return this._onChangeCallback = t, this
                     }
                     _onChangeCallback() {}
                 }
-                pt.prototype.isQuaternion = !0;
-                class mt {
+                Ke.prototype.isQuaternion = !0;
+                class Qe {
                     constructor(t = 0, e = 0, n = 0) {
                         this.x = t, this.y = e, this.z = n
                     }
                     set(t, e, n) {
                         return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
                     }
                     setScalar(t) {
@@ -18160,18 +18621,18 @@
                     multiplyScalar(t) {
                         return this.x *= t, this.y *= t, this.z *= t, this
                     }
                     multiplyVectors(t, e) {
                         return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                     }
                     applyEuler(t) {
-                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(gt.setFromEuler(t))
+                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(tn.setFromEuler(t))
                     }
                     applyAxisAngle(t, e) {
-                        return this.applyQuaternion(gt.setFromAxisAngle(t, e))
+                        return this.applyQuaternion(tn.setFromAxisAngle(t, e))
                     }
                     applyMatrix3(t) {
                         const e = this.x,
                             n = this.y,
                             i = this.z,
                             r = t.elements;
                         return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
@@ -18290,24 +18751,24 @@
                     projectOnVector(t) {
                         const e = t.lengthSq();
                         if (0 === e) return this.set(0, 0, 0);
                         const n = t.dot(this) / e;
                         return this.copy(t).multiplyScalar(n)
                     }
                     projectOnPlane(t) {
-                        return ft.copy(this).projectOnVector(t), this.sub(ft)
+                        return $e.copy(this).projectOnVector(t), this.sub($e)
                     }
                     reflect(t) {
-                        return this.sub(ft.copy(t).multiplyScalar(2 * this.dot(t)))
+                        return this.sub($e.copy(t).multiplyScalar(2 * this.dot(t)))
                     }
                     angleTo(t) {
                         const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                         if (0 === e) return Math.PI / 2;
                         const n = this.dot(t) / e;
-                        return Math.acos(W(n, -1, 1))
+                        return Math.acos(Re(n, -1, 1))
                     }
                     distanceTo(t) {
                         return Math.sqrt(this.distanceToSquared(t))
                     }
                     distanceToSquared(t) {
                         const e = this.x - t.x,
                             n = this.y - t.y,
@@ -18366,19 +18827,19 @@
                             e = Math.random() * Math.PI * 2,
                             n = Math.sqrt(1 - t ** 2);
                         return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y, yield this.z
                     }
                 }
-                mt.prototype.isVector3 = !0;
-                const ft = new mt,
-                    gt = new pt;
-                class vt {
-                    constructor(t = new mt(1 / 0, 1 / 0, 1 / 0), e = new mt(-1 / 0, -1 / 0, -1 / 0)) {
+                Qe.prototype.isVector3 = !0;
+                const $e = new Qe,
+                    tn = new Ke;
+                class en {
+                    constructor(t = new Qe(1 / 0, 1 / 0, 1 / 0), e = new Qe(-1 / 0, -1 / 0, -1 / 0)) {
                         this.min = t, this.max = e
                     }
                     set(t, e) {
                         return this.min.copy(t), this.max.copy(e), this
                     }
                     setFromArray(t) {
                         let e = 1 / 0,
@@ -18412,15 +18873,15 @@
                     }
                     setFromPoints(t) {
                         this.makeEmpty();
                         for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                         return this
                     }
                     setFromCenterAndSize(t, e) {
-                        const n = yt.copy(e).multiplyScalar(.5);
+                        const n = rn.copy(e).multiplyScalar(.5);
                         return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                     }
                     setFromObject(t, e = !1) {
                         return this.makeEmpty(), this.expandByObject(t, e)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
@@ -18451,16 +18912,16 @@
                     }
                     expandByObject(t, e = !1) {
                         t.updateWorldMatrix(!1, !1);
                         const n = t.geometry;
                         if (void 0 !== n)
                             if (e && null != n.attributes && void 0 !== n.attributes.position) {
                                 const e = n.attributes.position;
-                                for (let n = 0, i = e.count; n < i; n++) yt.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(yt)
-                            } else null === n.boundingBox && n.computeBoundingBox(), _t.copy(n.boundingBox), _t.applyMatrix4(t.matrixWorld), this.union(_t);
+                                for (let n = 0, i = e.count; n < i; n++) rn.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(rn)
+                            } else null === n.boundingBox && n.computeBoundingBox(), sn.copy(n.boundingBox), sn.applyMatrix4(t.matrixWorld), this.union(sn);
                         const i = t.children;
                         for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
                         return this
                     }
                     containsPoint(t) {
                         return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                     }
@@ -18470,91 +18931,91 @@
                     getParameter(t, e) {
                         return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                     }
                     intersectsBox(t) {
                         return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                     }
                     intersectsSphere(t) {
-                        return this.clampPoint(t.center, yt), yt.distanceToSquared(t.center) <= t.radius * t.radius
+                        return this.clampPoint(t.center, rn), rn.distanceToSquared(t.center) <= t.radius * t.radius
                     }
                     intersectsPlane(t) {
                         let e, n;
                         return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                     }
                     intersectsTriangle(t) {
                         if (this.isEmpty()) return !1;
-                        this.getCenter(At), Rt.subVectors(this.max, At), Mt.subVectors(t.a, At), bt.subVectors(t.b, At), wt.subVectors(t.c, At), St.subVectors(bt, Mt), Et.subVectors(wt, bt), Tt.subVectors(Mt, wt);
-                        let e = [0, -St.z, St.y, 0, -Et.z, Et.y, 0, -Tt.z, Tt.y, St.z, 0, -St.x, Et.z, 0, -Et.x, Tt.z, 0, -Tt.x, -St.y, St.x, 0, -Et.y, Et.x, 0, -Tt.y, Tt.x, 0];
-                        return !!Pt(e, Mt, bt, wt, Rt) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Pt(e, Mt, bt, wt, Rt) && (Lt.crossVectors(St, Et), e = [Lt.x, Lt.y, Lt.z], Pt(e, Mt, bt, wt, Rt)))
+                        this.getCenter(dn), pn.subVectors(this.max, dn), an.subVectors(t.a, dn), on.subVectors(t.b, dn), ln.subVectors(t.c, dn), cn.subVectors(on, an), hn.subVectors(ln, on), un.subVectors(an, ln);
+                        let e = [0, -cn.z, cn.y, 0, -hn.z, hn.y, 0, -un.z, un.y, cn.z, 0, -cn.x, hn.z, 0, -hn.x, un.z, 0, -un.x, -cn.y, cn.x, 0, -hn.y, hn.x, 0, -un.y, un.x, 0];
+                        return !!gn(e, an, on, ln, pn) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!gn(e, an, on, ln, pn) && (mn.crossVectors(cn, hn), e = [mn.x, mn.y, mn.z], gn(e, an, on, ln, pn)))
                     }
                     clampPoint(t, e) {
                         return e.copy(t).clamp(this.min, this.max)
                     }
                     distanceToPoint(t) {
-                        return yt.copy(t).clamp(this.min, this.max).sub(t).length()
+                        return rn.copy(t).clamp(this.min, this.max).sub(t).length()
                     }
                     getBoundingSphere(t) {
-                        return this.getCenter(t.center), t.radius = .5 * this.getSize(yt).length(), t
+                        return this.getCenter(t.center), t.radius = .5 * this.getSize(rn).length(), t
                     }
                     intersect(t) {
                         return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                     }
                     union(t) {
                         return this.min.min(t.min), this.max.max(t.max), this
                     }
                     applyMatrix4(t) {
-                        return this.isEmpty() || (xt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), xt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), xt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), xt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), xt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), xt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), xt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), xt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(xt)), this
+                        return this.isEmpty() || (nn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), nn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), nn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), nn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), nn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), nn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), nn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), nn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(nn)), this
                     }
                     translate(t) {
                         return this.min.add(t), this.max.add(t), this
                     }
                     equals(t) {
                         return t.min.equals(this.min) && t.max.equals(this.max)
                     }
                 }
-                vt.prototype.isBox3 = !0;
-                const xt = [new mt, new mt, new mt, new mt, new mt, new mt, new mt, new mt],
-                    yt = new mt,
-                    _t = new vt,
-                    Mt = new mt,
-                    bt = new mt,
-                    wt = new mt,
-                    St = new mt,
-                    Et = new mt,
-                    Tt = new mt,
-                    At = new mt,
-                    Rt = new mt,
-                    Lt = new mt,
-                    Ct = new mt;
+                en.prototype.isBox3 = !0;
+                const nn = [new Qe, new Qe, new Qe, new Qe, new Qe, new Qe, new Qe, new Qe],
+                    rn = new Qe,
+                    sn = new en,
+                    an = new Qe,
+                    on = new Qe,
+                    ln = new Qe,
+                    cn = new Qe,
+                    hn = new Qe,
+                    un = new Qe,
+                    dn = new Qe,
+                    pn = new Qe,
+                    mn = new Qe,
+                    fn = new Qe;
 
-                function Pt(t, e, n, i, r) {
+                function gn(t, e, n, i, r) {
                     for (let s = 0, a = t.length - 3; s <= a; s += 3) {
-                        Ct.fromArray(t, s);
-                        const a = r.x * Math.abs(Ct.x) + r.y * Math.abs(Ct.y) + r.z * Math.abs(Ct.z),
-                            o = e.dot(Ct),
-                            l = n.dot(Ct),
-                            c = i.dot(Ct);
+                        fn.fromArray(t, s);
+                        const a = r.x * Math.abs(fn.x) + r.y * Math.abs(fn.y) + r.z * Math.abs(fn.z),
+                            o = e.dot(fn),
+                            l = n.dot(fn),
+                            c = i.dot(fn);
                         if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
                     }
                     return !0
                 }
-                const Dt = new vt,
-                    It = new mt,
-                    Nt = new mt,
-                    Ot = new mt;
-                class Ut {
-                    constructor(t = new mt, e = -1) {
+                const vn = new en,
+                    xn = new Qe,
+                    yn = new Qe,
+                    _n = new Qe;
+                class Mn {
+                    constructor(t = new Qe, e = -1) {
                         this.center = t, this.radius = e
                     }
                     set(t, e) {
                         return this.center.copy(t), this.radius = e, this
                     }
                     setFromPoints(t, e) {
                         const n = this.center;
-                        void 0 !== e ? n.copy(e) : Dt.setFromPoints(t).getCenter(n);
+                        void 0 !== e ? n.copy(e) : vn.setFromPoints(t).getCenter(n);
                         let i = 0;
                         for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                         return this.radius = Math.sqrt(i), this
                     }
                     copy(t) {
                         return this.center.copy(t.center), this.radius = t.radius, this
                     }
@@ -18590,42 +19051,42 @@
                     applyMatrix4(t) {
                         return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                     }
                     translate(t) {
                         return this.center.add(t), this
                     }
                     expandByPoint(t) {
-                        Ot.subVectors(t, this.center);
-                        const e = Ot.lengthSq();
+                        _n.subVectors(t, this.center);
+                        const e = _n.lengthSq();
                         if (e > this.radius * this.radius) {
                             const t = Math.sqrt(e),
                                 n = .5 * (t - this.radius);
-                            this.center.add(Ot.multiplyScalar(n / t)), this.radius += n
+                            this.center.add(_n.multiplyScalar(n / t)), this.radius += n
                         }
                         return this
                     }
                     union(t) {
-                        return !0 === this.center.equals(t.center) ? Nt.set(0, 0, 1).multiplyScalar(t.radius) : Nt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(It.copy(t.center).add(Nt)), this.expandByPoint(It.copy(t.center).sub(Nt)), this
+                        return !0 === this.center.equals(t.center) ? yn.set(0, 0, 1).multiplyScalar(t.radius) : yn.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(xn.copy(t.center).add(yn)), this.expandByPoint(xn.copy(t.center).sub(yn)), this
                     }
                     equals(t) {
                         return t.center.equals(this.center) && t.radius === this.radius
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                const Bt = new mt,
-                    Ft = new mt,
-                    zt = new mt,
-                    Ht = new mt,
-                    Gt = new mt,
-                    Vt = new mt,
-                    kt = new mt;
-                class Wt {
-                    constructor(t = new mt, e = new mt(0, 0, -1)) {
+                const bn = new Qe,
+                    wn = new Qe,
+                    Sn = new Qe,
+                    En = new Qe,
+                    Tn = new Qe,
+                    An = new Qe,
+                    Rn = new Qe;
+                class Ln {
+                    constructor(t = new Qe, e = new Qe(0, 0, -1)) {
                         this.origin = t, this.direction = e
                     }
                     set(t, e) {
                         return this.origin.copy(t), this.direction.copy(e), this
                     }
                     copy(t) {
                         return this.origin.copy(t.origin), this.direction.copy(t.direction), this
@@ -18633,53 +19094,53 @@
                     at(t, e) {
                         return e.copy(this.direction).multiplyScalar(t).add(this.origin)
                     }
                     lookAt(t) {
                         return this.direction.copy(t).sub(this.origin).normalize(), this
                     }
                     recast(t) {
-                        return this.origin.copy(this.at(t, Bt)), this
+                        return this.origin.copy(this.at(t, bn)), this
                     }
                     closestPointToPoint(t, e) {
                         e.subVectors(t, this.origin);
                         const n = e.dot(this.direction);
                         return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                     }
                     distanceToPoint(t) {
                         return Math.sqrt(this.distanceSqToPoint(t))
                     }
                     distanceSqToPoint(t) {
-                        const e = Bt.subVectors(t, this.origin).dot(this.direction);
-                        return e < 0 ? this.origin.distanceToSquared(t) : (Bt.copy(this.direction).multiplyScalar(e).add(this.origin), Bt.distanceToSquared(t))
+                        const e = bn.subVectors(t, this.origin).dot(this.direction);
+                        return e < 0 ? this.origin.distanceToSquared(t) : (bn.copy(this.direction).multiplyScalar(e).add(this.origin), bn.distanceToSquared(t))
                     }
                     distanceSqToSegment(t, e, n, i) {
-                        Ft.copy(t).add(e).multiplyScalar(.5), zt.copy(e).sub(t).normalize(), Ht.copy(this.origin).sub(Ft);
+                        wn.copy(t).add(e).multiplyScalar(.5), Sn.copy(e).sub(t).normalize(), En.copy(this.origin).sub(wn);
                         const r = .5 * t.distanceTo(e),
-                            s = -this.direction.dot(zt),
-                            a = Ht.dot(this.direction),
-                            o = -Ht.dot(zt),
-                            l = Ht.lengthSq(),
+                            s = -this.direction.dot(Sn),
+                            a = En.dot(this.direction),
+                            o = -En.dot(Sn),
+                            l = En.lengthSq(),
                             c = Math.abs(1 - s * s);
                         let h, u, d, p;
                         if (c > 0)
                             if (h = s * o - a, u = s * a - o, p = r * c, h >= 0)
                                 if (u >= -p)
                                     if (u <= p) {
                                         const t = 1 / c;
                                         h *= t, u *= t, d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l
                                     } else u = r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                         else u = -r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                         else u <= -p ? (h = Math.max(0, -(-s * r + a)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
                         else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
-                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(zt).multiplyScalar(u).add(Ft), d
+                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Sn).multiplyScalar(u).add(wn), d
                     }
                     intersectSphere(t, e) {
-                        Bt.subVectors(t.center, this.origin);
-                        const n = Bt.dot(this.direction),
-                            i = Bt.dot(Bt) - n * n,
+                        bn.subVectors(t.center, this.origin);
+                        const n = bn.dot(this.direction),
+                            i = bn.dot(bn) - n * n,
                             r = t.radius * t.radius;
                         if (i > r) return null;
                         const s = Math.sqrt(r - i),
                             a = n - s,
                             o = n + s;
                         return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
                     }
@@ -18705,58 +19166,58 @@
                         const l = 1 / this.direction.x,
                             c = 1 / this.direction.y,
                             h = 1 / this.direction.z,
                             u = this.origin;
                         return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (a = (t.min.z - u.z) * h, o = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, o = (t.min.z - u.z) * h), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                     }
                     intersectsBox(t) {
-                        return null !== this.intersectBox(t, Bt)
+                        return null !== this.intersectBox(t, bn)
                     }
                     intersectTriangle(t, e, n, i, r) {
-                        Gt.subVectors(e, t), Vt.subVectors(n, t), kt.crossVectors(Gt, Vt);
-                        let s, a = this.direction.dot(kt);
+                        Tn.subVectors(e, t), An.subVectors(n, t), Rn.crossVectors(Tn, An);
+                        let s, a = this.direction.dot(Rn);
                         if (a > 0) {
                             if (i) return null;
                             s = 1
                         } else {
                             if (!(a < 0)) return null;
                             s = -1, a = -a
                         }
-                        Ht.subVectors(this.origin, t);
-                        const o = s * this.direction.dot(Vt.crossVectors(Ht, Vt));
+                        En.subVectors(this.origin, t);
+                        const o = s * this.direction.dot(An.crossVectors(En, An));
                         if (o < 0) return null;
-                        const l = s * this.direction.dot(Gt.cross(Ht));
+                        const l = s * this.direction.dot(Tn.cross(En));
                         if (l < 0) return null;
                         if (o + l > a) return null;
-                        const c = -s * Ht.dot(kt);
+                        const c = -s * En.dot(Rn);
                         return c < 0 ? null : this.at(c / a, r)
                     }
                     applyMatrix4(t) {
                         return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                     }
                     equals(t) {
                         return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                class jt {
+                class Cn {
                     constructor() {
                         this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                     }
                     set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
                         const g = this.elements;
                         return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
                     }
                     identity() {
                         return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                     }
                     clone() {
-                        return (new jt).fromArray(this.elements)
+                        return (new Cn).fromArray(this.elements)
                     }
                     copy(t) {
                         const e = this.elements,
                             n = t.elements;
                         return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                     }
                     copyPosition(t) {
@@ -18773,17 +19234,17 @@
                     }
                     makeBasis(t, e, n) {
                         return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                     }
                     extractRotation(t) {
                         const e = this.elements,
                             n = t.elements,
-                            i = 1 / Xt.setFromMatrixColumn(t, 0).length(),
-                            r = 1 / Xt.setFromMatrixColumn(t, 1).length(),
-                            s = 1 / Xt.setFromMatrixColumn(t, 2).length();
+                            i = 1 / Pn.setFromMatrixColumn(t, 0).length(),
+                            r = 1 / Pn.setFromMatrixColumn(t, 1).length(),
+                            s = 1 / Pn.setFromMatrixColumn(t, 2).length();
                         return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                     }
                     makeRotationFromEuler(t) {
                         t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                         const e = this.elements,
                             n = t.x,
                             i = t.y,
@@ -18830,19 +19291,19 @@
                                 i = a * o,
                                 r = a * l;
                             e[0] = o * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = s * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = a * c, e[10] = r * h + t
                         }
                         return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                     }
                     makeRotationFromQuaternion(t) {
-                        return this.compose(Yt, t, Zt)
+                        return this.compose(In, t, Nn)
                     }
                     lookAt(t, e, n) {
                         const i = this.elements;
-                        return Qt.subVectors(t, e), 0 === Qt.lengthSq() && (Qt.z = 1), Qt.normalize(), Jt.crossVectors(n, Qt), 0 === Jt.lengthSq() && (1 === Math.abs(n.z) ? Qt.x += 1e-4 : Qt.z += 1e-4, Qt.normalize(), Jt.crossVectors(n, Qt)), Jt.normalize(), Kt.crossVectors(Qt, Jt), i[0] = Jt.x, i[4] = Kt.x, i[8] = Qt.x, i[1] = Jt.y, i[5] = Kt.y, i[9] = Qt.y, i[2] = Jt.z, i[6] = Kt.z, i[10] = Qt.z, this
+                        return Bn.subVectors(t, e), 0 === Bn.lengthSq() && (Bn.z = 1), Bn.normalize(), On.crossVectors(n, Bn), 0 === On.lengthSq() && (1 === Math.abs(n.z) ? Bn.x += 1e-4 : Bn.z += 1e-4, Bn.normalize(), On.crossVectors(n, Bn)), On.normalize(), Un.crossVectors(Bn, On), i[0] = On.x, i[4] = Un.x, i[8] = Bn.x, i[1] = On.y, i[5] = Un.y, i[9] = Bn.y, i[2] = On.z, i[6] = Un.z, i[10] = Bn.z, this
                     }
                     multiply(t, e) {
                         return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                     }
                     premultiply(t) {
                         return this.multiplyMatrices(t, this)
                     }
@@ -19010,22 +19471,22 @@
                             _ = n.x,
                             M = n.y,
                             b = n.z;
                         return i[0] = (1 - (m + g)) * _, i[1] = (d + y) * _, i[2] = (p - x) * _, i[3] = 0, i[4] = (d - y) * M, i[5] = (1 - (u + g)) * M, i[6] = (f + v) * M, i[7] = 0, i[8] = (p + x) * b, i[9] = (f - v) * b, i[10] = (1 - (u + m)) * b, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                     }
                     decompose(t, e, n) {
                         const i = this.elements;
-                        let r = Xt.set(i[0], i[1], i[2]).length();
-                        const s = Xt.set(i[4], i[5], i[6]).length(),
-                            a = Xt.set(i[8], i[9], i[10]).length();
-                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], qt.copy(this);
+                        let r = Pn.set(i[0], i[1], i[2]).length();
+                        const s = Pn.set(i[4], i[5], i[6]).length(),
+                            a = Pn.set(i[8], i[9], i[10]).length();
+                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Dn.copy(this);
                         const o = 1 / r,
                             l = 1 / s,
                             c = 1 / a;
-                        return qt.elements[0] *= o, qt.elements[1] *= o, qt.elements[2] *= o, qt.elements[4] *= l, qt.elements[5] *= l, qt.elements[6] *= l, qt.elements[8] *= c, qt.elements[9] *= c, qt.elements[10] *= c, e.setFromRotationMatrix(qt), n.x = r, n.y = s, n.z = a, this
+                        return Dn.elements[0] *= o, Dn.elements[1] *= o, Dn.elements[2] *= o, Dn.elements[4] *= l, Dn.elements[5] *= l, Dn.elements[6] *= l, Dn.elements[8] *= c, Dn.elements[9] *= c, Dn.elements[10] *= c, e.setFromRotationMatrix(Dn), n.x = r, n.y = s, n.z = a, this
                     }
                     makePerspective(t, e, n, i, r, s) {
                         void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                         const a = this.elements,
                             o = 2 * r / (e - t),
                             l = 2 * r / (n - i),
                             c = (e + t) / (e - t),
@@ -19056,26 +19517,26 @@
                         return this
                     }
                     toArray(t = [], e = 0) {
                         const n = this.elements;
                         return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                     }
                 }
-                jt.prototype.isMatrix4 = !0;
-                const Xt = new mt,
-                    qt = new jt,
-                    Yt = new mt(0, 0, 0),
-                    Zt = new mt(1, 1, 1),
-                    Jt = new mt,
-                    Kt = new mt,
-                    Qt = new mt,
-                    $t = new jt,
-                    te = new pt;
-                class ee {
-                    constructor(t = 0, e = 0, n = 0, i = ee.DefaultOrder) {
+                Cn.prototype.isMatrix4 = !0;
+                const Pn = new Qe,
+                    Dn = new Cn,
+                    In = new Qe(0, 0, 0),
+                    Nn = new Qe(1, 1, 1),
+                    On = new Qe,
+                    Un = new Qe,
+                    Bn = new Qe,
+                    Fn = new Cn,
+                    zn = new Ke;
+                class Hn {
+                    constructor(t = 0, e = 0, n = 0, i = Hn.DefaultOrder) {
                         this._x = t, this._y = e, this._z = n, this._order = i
                     }
                     get x() {
                         return this._x
                     }
                     set x(t) {
                         this._x = t, this._onChangeCallback()
@@ -19116,64 +19577,64 @@
                             l = i[5],
                             c = i[9],
                             h = i[2],
                             u = i[6],
                             d = i[10];
                         switch (e) {
                             case "XYZ":
-                                this._y = Math.asin(W(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
+                                this._y = Math.asin(Re(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                                 break;
                             case "YXZ":
-                                this._x = Math.asin(-W(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
+                                this._x = Math.asin(-Re(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                                 break;
                             case "ZXY":
-                                this._x = Math.asin(W(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
+                                this._x = Math.asin(Re(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                                 break;
                             case "ZYX":
-                                this._y = Math.asin(-W(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
+                                this._y = Math.asin(-Re(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                                 break;
                             case "YZX":
-                                this._z = Math.asin(W(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
+                                this._z = Math.asin(Re(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                                 break;
                             case "XZY":
-                                this._z = Math.asin(-W(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
+                                this._z = Math.asin(-Re(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                                 break;
                             default:
                                 console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                         }
                         return this._order = e, !0 === n && this._onChangeCallback(), this
                     }
                     setFromQuaternion(t, e, n) {
-                        return $t.makeRotationFromQuaternion(t), this.setFromRotationMatrix($t, e, n)
+                        return Fn.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Fn, e, n)
                     }
                     setFromVector3(t, e = this._order) {
                         return this.set(t.x, t.y, t.z, e)
                     }
                     reorder(t) {
-                        return te.setFromEuler(this), this.setFromQuaternion(te, t)
+                        return zn.setFromEuler(this), this.setFromQuaternion(zn, t)
                     }
                     equals(t) {
                         return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                     }
                     fromArray(t) {
                         return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                     }
                     toArray(t = [], e = 0) {
                         return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                     }
                     toVector3(t) {
-                        return t ? t.set(this._x, this._y, this._z) : new mt(this._x, this._y, this._z)
+                        return t ? t.set(this._x, this._y, this._z) : new Qe(this._x, this._y, this._z)
                     }
                     _onChange(t) {
                         return this._onChangeCallback = t, this
                     }
                     _onChangeCallback() {}
                 }
-                ee.prototype.isEuler = !0, ee.DefaultOrder = "XYZ", ee.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
-                class ne {
+                Hn.prototype.isEuler = !0, Hn.DefaultOrder = "XYZ", Hn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
+                class Gn {
                     constructor() {
                         this.mask = 1
                     }
                     set(t) {
                         this.mask = (1 << t | 0) >>> 0
                     }
                     enable(t) {
@@ -19194,40 +19655,40 @@
                     test(t) {
                         return 0 != (this.mask & t.mask)
                     }
                     isEnabled(t) {
                         return 0 != (this.mask & (1 << t | 0))
                     }
                 }
-                let ie = 0;
-                const re = new mt,
-                    se = new pt,
-                    ae = new jt,
-                    oe = new mt,
-                    le = new mt,
-                    ce = new mt,
-                    he = new pt,
-                    ue = new mt(1, 0, 0),
-                    de = new mt(0, 1, 0),
-                    pe = new mt(0, 0, 1),
-                    me = {
+                let Vn = 0;
+                const kn = new Qe,
+                    Wn = new Ke,
+                    jn = new Cn,
+                    Xn = new Qe,
+                    qn = new Qe,
+                    Yn = new Qe,
+                    Zn = new Ke,
+                    Jn = new Qe(1, 0, 0),
+                    Kn = new Qe(0, 1, 0),
+                    Qn = new Qe(0, 0, 1),
+                    $n = {
                         type: "added"
                     },
-                    fe = {
+                    ti = {
                         type: "removed"
                     };
-                class ge extends z {
+                class ei extends we {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: ie++
-                        }), this.uuid = k(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ge.DefaultUp.clone();
-                        const t = new mt,
-                            e = new ee,
-                            n = new pt,
-                            i = new mt(1, 1, 1);
+                            value: Vn++
+                        }), this.uuid = Ae(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ei.DefaultUp.clone();
+                        const t = new Qe,
+                            e = new Hn,
+                            n = new Ke,
+                            i = new Qe(1, 1, 1);
                         e._onChange((function() {
                             n.setFromEuler(e, !1)
                         })), n._onChange((function() {
                             e.setFromQuaternion(n, void 0, !1)
                         })), Object.defineProperties(this, {
                             position: {
                                 configurable: !0,
@@ -19246,20 +19707,20 @@
                             },
                             scale: {
                                 configurable: !0,
                                 enumerable: !0,
                                 value: i
                             },
                             modelViewMatrix: {
-                                value: new jt
+                                value: new Cn
                             },
                             normalMatrix: {
-                                value: new Z
+                                value: new Ie
                             }
-                        }), this.matrix = new jt, this.matrixWorld = new jt, this.matrixAutoUpdate = ge.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ne, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
+                        }), this.matrix = new Cn, this.matrixWorld = new Cn, this.matrixAutoUpdate = ei.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Gn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                     }
                     onBeforeRender() {}
                     onAfterRender() {}
                     applyMatrix4(t) {
                         this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                     }
                     applyQuaternion(t) {
@@ -19274,79 +19735,79 @@
                     setRotationFromMatrix(t) {
                         this.quaternion.setFromRotationMatrix(t)
                     }
                     setRotationFromQuaternion(t) {
                         this.quaternion.copy(t)
                     }
                     rotateOnAxis(t, e) {
-                        return se.setFromAxisAngle(t, e), this.quaternion.multiply(se), this
+                        return Wn.setFromAxisAngle(t, e), this.quaternion.multiply(Wn), this
                     }
                     rotateOnWorldAxis(t, e) {
-                        return se.setFromAxisAngle(t, e), this.quaternion.premultiply(se), this
+                        return Wn.setFromAxisAngle(t, e), this.quaternion.premultiply(Wn), this
                     }
                     rotateX(t) {
-                        return this.rotateOnAxis(ue, t)
+                        return this.rotateOnAxis(Jn, t)
                     }
                     rotateY(t) {
-                        return this.rotateOnAxis(de, t)
+                        return this.rotateOnAxis(Kn, t)
                     }
                     rotateZ(t) {
-                        return this.rotateOnAxis(pe, t)
+                        return this.rotateOnAxis(Qn, t)
                     }
                     translateOnAxis(t, e) {
-                        return re.copy(t).applyQuaternion(this.quaternion), this.position.add(re.multiplyScalar(e)), this
+                        return kn.copy(t).applyQuaternion(this.quaternion), this.position.add(kn.multiplyScalar(e)), this
                     }
                     translateX(t) {
-                        return this.translateOnAxis(ue, t)
+                        return this.translateOnAxis(Jn, t)
                     }
                     translateY(t) {
-                        return this.translateOnAxis(de, t)
+                        return this.translateOnAxis(Kn, t)
                     }
                     translateZ(t) {
-                        return this.translateOnAxis(pe, t)
+                        return this.translateOnAxis(Qn, t)
                     }
                     localToWorld(t) {
                         return t.applyMatrix4(this.matrixWorld)
                     }
                     worldToLocal(t) {
-                        return t.applyMatrix4(ae.copy(this.matrixWorld).invert())
+                        return t.applyMatrix4(jn.copy(this.matrixWorld).invert())
                     }
                     lookAt(t, e, n) {
-                        t.isVector3 ? oe.copy(t) : oe.set(t, e, n);
+                        t.isVector3 ? Xn.copy(t) : Xn.set(t, e, n);
                         const i = this.parent;
-                        this.updateWorldMatrix(!0, !1), le.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ae.lookAt(le, oe, this.up) : ae.lookAt(oe, le, this.up), this.quaternion.setFromRotationMatrix(ae), i && (ae.extractRotation(i.matrixWorld), se.setFromRotationMatrix(ae), this.quaternion.premultiply(se.invert()))
+                        this.updateWorldMatrix(!0, !1), qn.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? jn.lookAt(qn, Xn, this.up) : jn.lookAt(Xn, qn, this.up), this.quaternion.setFromRotationMatrix(jn), i && (jn.extractRotation(i.matrixWorld), Wn.setFromRotationMatrix(jn), this.quaternion.premultiply(Wn.invert()))
                     }
                     add(t) {
                         if (arguments.length > 1) {
                             for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                             return this
                         }
-                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(me)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
+                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent($n)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                     }
                     remove(t) {
                         if (arguments.length > 1) {
                             for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                             return this
                         }
                         const e = this.children.indexOf(t);
-                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(fe)), this
+                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(ti)), this
                     }
                     removeFromParent() {
                         const t = this.parent;
                         return null !== t && t.remove(this), this
                     }
                     clear() {
                         for (let t = 0; t < this.children.length; t++) {
                             const e = this.children[t];
-                            e.parent = null, e.dispatchEvent(fe)
+                            e.parent = null, e.dispatchEvent(ti)
                         }
                         return this.children.length = 0, this
                     }
                     attach(t) {
-                        return this.updateWorldMatrix(!0, !1), ae.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), ae.multiply(t.parent.matrixWorld)), t.applyMatrix4(ae), this.add(t), t.updateWorldMatrix(!1, !0), this
+                        return this.updateWorldMatrix(!0, !1), jn.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), jn.multiply(t.parent.matrixWorld)), t.applyMatrix4(jn), this.add(t), t.updateWorldMatrix(!1, !0), this
                     }
                     getObjectById(t) {
                         return this.getObjectByProperty("id", t)
                     }
                     getObjectByName(t) {
                         return this.getObjectByProperty("name", t)
                     }
@@ -19357,18 +19818,18 @@
                             if (void 0 !== i) return i
                         }
                     }
                     getWorldPosition(t) {
                         return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                     }
                     getWorldQuaternion(t) {
-                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(le, t, ce), t
+                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(qn, t, Yn), t
                     }
                     getWorldScale(t) {
-                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(le, he, t), t
+                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(qn, Zn, t), t
                     }
                     getWorldDirection(t) {
                         this.updateWorldMatrix(!0, !1);
                         const e = this.matrixWorld.elements;
                         return t.set(e[8], e[9], e[10]).normalize()
                     }
                     raycast() {}
@@ -19482,56 +19943,56 @@
                             for (let e = 0; e < t.children.length; e++) {
                                 const n = t.children[e];
                                 this.add(n.clone())
                             }
                         return this
                     }
                 }
-                ge.DefaultUp = new mt(0, 1, 0), ge.DefaultMatrixAutoUpdate = !0, ge.prototype.isObject3D = !0;
-                const ve = new mt,
-                    xe = new mt,
-                    ye = new mt,
-                    _e = new mt,
-                    Me = new mt,
-                    be = new mt,
-                    we = new mt,
-                    Se = new mt,
-                    Ee = new mt,
-                    Te = new mt;
-                class Ae {
-                    constructor(t = new mt, e = new mt, n = new mt) {
+                ei.DefaultUp = new Qe(0, 1, 0), ei.DefaultMatrixAutoUpdate = !0, ei.prototype.isObject3D = !0;
+                const ni = new Qe,
+                    ii = new Qe,
+                    ri = new Qe,
+                    si = new Qe,
+                    ai = new Qe,
+                    oi = new Qe,
+                    li = new Qe,
+                    ci = new Qe,
+                    hi = new Qe,
+                    ui = new Qe;
+                class di {
+                    constructor(t = new Qe, e = new Qe, n = new Qe) {
                         this.a = t, this.b = e, this.c = n
                     }
                     static getNormal(t, e, n, i) {
-                        i.subVectors(n, e), ve.subVectors(t, e), i.cross(ve);
+                        i.subVectors(n, e), ni.subVectors(t, e), i.cross(ni);
                         const r = i.lengthSq();
                         return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                     }
                     static getBarycoord(t, e, n, i, r) {
-                        ve.subVectors(i, e), xe.subVectors(n, e), ye.subVectors(t, e);
-                        const s = ve.dot(ve),
-                            a = ve.dot(xe),
-                            o = ve.dot(ye),
-                            l = xe.dot(xe),
-                            c = xe.dot(ye),
+                        ni.subVectors(i, e), ii.subVectors(n, e), ri.subVectors(t, e);
+                        const s = ni.dot(ni),
+                            a = ni.dot(ii),
+                            o = ni.dot(ri),
+                            l = ii.dot(ii),
+                            c = ii.dot(ri),
                             h = s * l - a * a;
                         if (0 === h) return r.set(-2, -1, -1);
                         const u = 1 / h,
                             d = (l * o - a * c) * u,
                             p = (s * c - a * o) * u;
                         return r.set(1 - d - p, p, d)
                     }
                     static containsPoint(t, e, n, i) {
-                        return this.getBarycoord(t, e, n, i, _e), _e.x >= 0 && _e.y >= 0 && _e.x + _e.y <= 1
+                        return this.getBarycoord(t, e, n, i, si), si.x >= 0 && si.y >= 0 && si.x + si.y <= 1
                     }
                     static getUV(t, e, n, i, r, s, a, o) {
-                        return this.getBarycoord(t, e, n, i, _e), o.set(0, 0), o.addScaledVector(r, _e.x), o.addScaledVector(s, _e.y), o.addScaledVector(a, _e.z), o
+                        return this.getBarycoord(t, e, n, i, si), o.set(0, 0), o.addScaledVector(r, si.x), o.addScaledVector(s, si.y), o.addScaledVector(a, si.z), o
                     }
                     static isFrontFacing(t, e, n, i) {
-                        return ve.subVectors(n, e), xe.subVectors(t, e), ve.cross(xe).dot(i) < 0
+                        return ni.subVectors(n, e), ii.subVectors(t, e), ni.cross(ii).dot(i) < 0
                     }
                     set(t, e, n) {
                         return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                     }
                     setFromPointsAndIndices(t, e, n, i) {
                         return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                     }
@@ -19541,76 +20002,76 @@
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     copy(t) {
                         return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                     }
                     getArea() {
-                        return ve.subVectors(this.c, this.b), xe.subVectors(this.a, this.b), .5 * ve.cross(xe).length()
+                        return ni.subVectors(this.c, this.b), ii.subVectors(this.a, this.b), .5 * ni.cross(ii).length()
                     }
                     getMidpoint(t) {
                         return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                     }
                     getNormal(t) {
-                        return Ae.getNormal(this.a, this.b, this.c, t)
+                        return di.getNormal(this.a, this.b, this.c, t)
                     }
                     getPlane(t) {
                         return t.setFromCoplanarPoints(this.a, this.b, this.c)
                     }
                     getBarycoord(t, e) {
-                        return Ae.getBarycoord(t, this.a, this.b, this.c, e)
+                        return di.getBarycoord(t, this.a, this.b, this.c, e)
                     }
                     getUV(t, e, n, i, r) {
-                        return Ae.getUV(t, this.a, this.b, this.c, e, n, i, r)
+                        return di.getUV(t, this.a, this.b, this.c, e, n, i, r)
                     }
                     containsPoint(t) {
-                        return Ae.containsPoint(t, this.a, this.b, this.c)
+                        return di.containsPoint(t, this.a, this.b, this.c)
                     }
                     isFrontFacing(t) {
-                        return Ae.isFrontFacing(this.a, this.b, this.c, t)
+                        return di.isFrontFacing(this.a, this.b, this.c, t)
                     }
                     intersectsBox(t) {
                         return t.intersectsTriangle(this)
                     }
                     closestPointToPoint(t, e) {
                         const n = this.a,
                             i = this.b,
                             r = this.c;
                         let s, a;
-                        Me.subVectors(i, n), be.subVectors(r, n), Se.subVectors(t, n);
-                        const o = Me.dot(Se),
-                            l = be.dot(Se);
+                        ai.subVectors(i, n), oi.subVectors(r, n), ci.subVectors(t, n);
+                        const o = ai.dot(ci),
+                            l = oi.dot(ci);
                         if (o <= 0 && l <= 0) return e.copy(n);
-                        Ee.subVectors(t, i);
-                        const c = Me.dot(Ee),
-                            h = be.dot(Ee);
+                        hi.subVectors(t, i);
+                        const c = ai.dot(hi),
+                            h = oi.dot(hi);
                         if (c >= 0 && h <= c) return e.copy(i);
                         const u = o * h - c * l;
-                        if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector(Me, s);
-                        Te.subVectors(t, r);
-                        const d = Me.dot(Te),
-                            p = be.dot(Te);
+                        if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector(ai, s);
+                        ui.subVectors(t, r);
+                        const d = ai.dot(ui),
+                            p = oi.dot(ui);
                         if (p >= 0 && d <= p) return e.copy(r);
                         const m = d * l - o * p;
-                        if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(be, a);
+                        if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(oi, a);
                         const f = c * p - d * h;
-                        if (f <= 0 && h - c >= 0 && d - p >= 0) return we.subVectors(r, i), a = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(we, a);
+                        if (f <= 0 && h - c >= 0 && d - p >= 0) return li.subVectors(r, i), a = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(li, a);
                         const g = 1 / (f + m + u);
-                        return s = m * g, a = u * g, e.copy(n).addScaledVector(Me, s).addScaledVector(be, a)
+                        return s = m * g, a = u * g, e.copy(n).addScaledVector(ai, s).addScaledVector(oi, a)
                     }
                     equals(t) {
                         return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                     }
                 }
-                let Re = 0;
-                class Le extends z {
+                let pi = 0;
+                class mi extends we {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: Re++
-                        }), this.uuid = k(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = i, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = N, this.stencilZFail = N, this.stencilZPass = N, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.alphaWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
+                            value: pi++
+                        }), this.uuid = Ae(), this.name = "", this.type = "Material", this.fog = !0, this.blending = m, this.side = h, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = R, this.blendDst = L, this.blendEquation = y, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = F, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = xe, this.stencilZFail = xe, this.stencilZPass = xe, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.alphaWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                     }
                     get alphaTest() {
                         return this._alphaTest
                     }
                     set alphaTest(t) {
                         this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
                     }
@@ -19654,15 +20115,15 @@
                             const e = [];
                             for (const n in t) {
                                 const i = t[n];
                                 delete i.metadata, e.push(i)
                             }
                             return e
                         }
-                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.alphaWrite = this.alphaWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
+                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== m && (n.blending = this.blending), this.side !== h && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.alphaWrite = this.alphaWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                             const e = i(t.textures),
                                 r = i(t.images);
                             e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                         }
                         return n
                     }
                     clone() {
@@ -19684,30 +20145,30 @@
                             type: "dispose"
                         })
                     }
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                 }
-                Le.prototype.isMaterial = !0;
-                class Ce extends Le {
+                mi.prototype.isMaterial = !0;
+                class fi extends mi {
                     constructor(t) {
-                        super(), this.type = "MeshBasicMaterial", this.color = new rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        super(), this.type = "MeshBasicMaterial", this.color = new Ve(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = k, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }
-                Ce.prototype.isMeshBasicMaterial = !0;
-                const Pe = new mt,
-                    De = new Y;
-                class Ie {
+                fi.prototype.isMeshBasicMaterial = !0;
+                const gi = new Qe,
+                    vi = new De;
+                class xi {
                     constructor(t, e, n) {
                         if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
-                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = O, this.updateRange = {
+                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = ye, this.updateRange = {
                             offset: 0,
                             count: -1
                         }, this.version = 0
                     }
                     onUploadCallback() {}
                     set needsUpdate(t) {
                         !0 === t && this.version++
@@ -19727,62 +20188,62 @@
                         return this.array.set(t), this
                     }
                     copyColorsArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new rt), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Ve), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                         }
                         return this
                     }
                     copyVector2sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Y), e[n++] = r.x, e[n++] = r.y
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new De), e[n++] = r.x, e[n++] = r.y
                         }
                         return this
                     }
                     copyVector3sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new mt), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Qe), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                         }
                         return this
                     }
                     copyVector4sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new ht), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new Ye), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                         }
                         return this
                     }
                     applyMatrix3(t) {
                         if (2 === this.itemSize)
-                            for (let e = 0, n = this.count; e < n; e++) De.fromBufferAttribute(this, e), De.applyMatrix3(t), this.setXY(e, De.x, De.y);
+                            for (let e = 0, n = this.count; e < n; e++) vi.fromBufferAttribute(this, e), vi.applyMatrix3(t), this.setXY(e, vi.x, vi.y);
                         else if (3 === this.itemSize)
-                            for (let e = 0, n = this.count; e < n; e++) Pe.fromBufferAttribute(this, e), Pe.applyMatrix3(t), this.setXYZ(e, Pe.x, Pe.y, Pe.z);
+                            for (let e = 0, n = this.count; e < n; e++) gi.fromBufferAttribute(this, e), gi.applyMatrix3(t), this.setXYZ(e, gi.x, gi.y, gi.z);
                         return this
                     }
                     applyMatrix4(t) {
-                        for (let e = 0, n = this.count; e < n; e++) Pe.x = this.getX(e), Pe.y = this.getY(e), Pe.z = this.getZ(e), Pe.applyMatrix4(t), this.setXYZ(e, Pe.x, Pe.y, Pe.z);
+                        for (let e = 0, n = this.count; e < n; e++) gi.x = this.getX(e), gi.y = this.getY(e), gi.z = this.getZ(e), gi.applyMatrix4(t), this.setXYZ(e, gi.x, gi.y, gi.z);
                         return this
                     }
                     applyNormalMatrix(t) {
-                        for (let e = 0, n = this.count; e < n; e++) Pe.x = this.getX(e), Pe.y = this.getY(e), Pe.z = this.getZ(e), Pe.applyNormalMatrix(t), this.setXYZ(e, Pe.x, Pe.y, Pe.z);
+                        for (let e = 0, n = this.count; e < n; e++) gi.x = this.getX(e), gi.y = this.getY(e), gi.z = this.getZ(e), gi.applyNormalMatrix(t), this.setXYZ(e, gi.x, gi.y, gi.z);
                         return this
                     }
                     transformDirection(t) {
-                        for (let e = 0, n = this.count; e < n; e++) Pe.x = this.getX(e), Pe.y = this.getY(e), Pe.z = this.getZ(e), Pe.transformDirection(t), this.setXYZ(e, Pe.x, Pe.y, Pe.z);
+                        for (let e = 0, n = this.count; e < n; e++) gi.x = this.getX(e), gi.y = this.getY(e), gi.z = this.getZ(e), gi.transformDirection(t), this.setXYZ(e, gi.x, gi.y, gi.z);
                         return this
                     }
                     set(t, e = 0) {
                         return this.array.set(t, e), this
                     }
                     getX(t) {
                         return this.array[t * this.itemSize]
@@ -19826,58 +20287,58 @@
                     toJSON() {
                         const t = {
                             itemSize: this.itemSize,
                             type: this.array.constructor.name,
                             array: Array.prototype.slice.call(this.array),
                             normalized: this.normalized
                         };
-                        return "" !== this.name && (t.name = this.name), this.usage !== O && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
+                        return "" !== this.name && (t.name = this.name), this.usage !== ye && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
                     }
                 }
-                Ie.prototype.isBufferAttribute = !0;
-                class Ne extends Ie {
+                xi.prototype.isBufferAttribute = !0;
+                class yi extends xi {
                     constructor(t, e, n) {
                         super(new Uint16Array(t), e, n)
                     }
                 }
-                class Oe extends Ie {
+                class _i extends xi {
                     constructor(t, e, n) {
                         super(new Uint32Array(t), e, n)
                     }
-                }(class extends Ie {
+                }(class extends xi {
                     constructor(t, e, n) {
                         super(new Uint16Array(t), e, n)
                     }
                 }).prototype.isFloat16BufferAttribute = !0;
-                class Ue extends Ie {
+                class Mi extends xi {
                     constructor(t, e, n) {
                         super(new Float32Array(t), e, n)
                     }
                 }
-                let Be = 0;
-                const Fe = new jt,
-                    ze = new ge,
-                    He = new mt,
-                    Ge = new vt,
-                    Ve = new vt,
-                    ke = new mt;
-                class We extends z {
+                let bi = 0;
+                const wi = new Cn,
+                    Si = new ei,
+                    Ei = new Qe,
+                    Ti = new en,
+                    Ai = new en,
+                    Ri = new Qe;
+                class Li extends we {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: Be++
-                        }), this.uuid = k(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
+                            value: bi++
+                        }), this.uuid = Ae(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                             start: 0,
                             count: 1 / 0
                         }, this.userData = {}
                     }
                     getIndex() {
                         return this.index
                     }
                     setIndex(t) {
-                        return Array.isArray(t) ? this.index = new(J(t) ? Oe : Ne)(t, 1) : this.index = t, this
+                        return Array.isArray(t) ? this.index = new(Ne(t) ? _i : yi)(t, 1) : this.index = t, this
                     }
                     getAttribute(t) {
                         return this.attributes[t]
                     }
                     setAttribute(t, e) {
                         return this.attributes[t] = e, this
                     }
@@ -19901,112 +20362,112 @@
                         this.drawRange.start = t, this.drawRange.count = e
                     }
                     applyMatrix4(t) {
                         const e = this.attributes.position;
                         void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                         const n = this.attributes.normal;
                         if (void 0 !== n) {
-                            const e = (new Z).getNormalMatrix(t);
+                            const e = (new Ie).getNormalMatrix(t);
                             n.applyNormalMatrix(e), n.needsUpdate = !0
                         }
                         const i = this.attributes.tangent;
                         return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                     }
                     applyQuaternion(t) {
-                        return Fe.makeRotationFromQuaternion(t), this.applyMatrix4(Fe), this
+                        return wi.makeRotationFromQuaternion(t), this.applyMatrix4(wi), this
                     }
                     rotateX(t) {
-                        return Fe.makeRotationX(t), this.applyMatrix4(Fe), this
+                        return wi.makeRotationX(t), this.applyMatrix4(wi), this
                     }
                     rotateY(t) {
-                        return Fe.makeRotationY(t), this.applyMatrix4(Fe), this
+                        return wi.makeRotationY(t), this.applyMatrix4(wi), this
                     }
                     rotateZ(t) {
-                        return Fe.makeRotationZ(t), this.applyMatrix4(Fe), this
+                        return wi.makeRotationZ(t), this.applyMatrix4(wi), this
                     }
                     translate(t, e, n) {
-                        return Fe.makeTranslation(t, e, n), this.applyMatrix4(Fe), this
+                        return wi.makeTranslation(t, e, n), this.applyMatrix4(wi), this
                     }
                     scale(t, e, n) {
-                        return Fe.makeScale(t, e, n), this.applyMatrix4(Fe), this
+                        return wi.makeScale(t, e, n), this.applyMatrix4(wi), this
                     }
                     lookAt(t) {
-                        return ze.lookAt(t), ze.updateMatrix(), this.applyMatrix4(ze.matrix), this
+                        return Si.lookAt(t), Si.updateMatrix(), this.applyMatrix4(Si.matrix), this
                     }
                     center() {
-                        return this.computeBoundingBox(), this.boundingBox.getCenter(He).negate(), this.translate(He.x, He.y, He.z), this
+                        return this.computeBoundingBox(), this.boundingBox.getCenter(Ei).negate(), this.translate(Ei.x, Ei.y, Ei.z), this
                     }
                     setFromPoints(t) {
                         const e = [];
                         for (let n = 0, i = t.length; n < i; n++) {
                             const i = t[n];
                             e.push(i.x, i.y, i.z || 0)
                         }
-                        return this.setAttribute("position", new Ue(e, 3)), this
+                        return this.setAttribute("position", new Mi(e, 3)), this
                     }
                     computeBoundingBox() {
-                        null === this.boundingBox && (this.boundingBox = new vt);
+                        null === this.boundingBox && (this.boundingBox = new en);
                         const t = this.attributes.position,
                             e = this.morphAttributes.position;
-                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new mt(-1 / 0, -1 / 0, -1 / 0), new mt(1 / 0, 1 / 0, 1 / 0));
+                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Qe(-1 / 0, -1 / 0, -1 / 0), new Qe(1 / 0, 1 / 0, 1 / 0));
                         if (void 0 !== t) {
                             if (this.boundingBox.setFromBufferAttribute(t), e)
                                 for (let t = 0, n = e.length; t < n; t++) {
                                     const n = e[t];
-                                    Ge.setFromBufferAttribute(n), this.morphTargetsRelative ? (ke.addVectors(this.boundingBox.min, Ge.min), this.boundingBox.expandByPoint(ke), ke.addVectors(this.boundingBox.max, Ge.max), this.boundingBox.expandByPoint(ke)) : (this.boundingBox.expandByPoint(Ge.min), this.boundingBox.expandByPoint(Ge.max))
+                                    Ti.setFromBufferAttribute(n), this.morphTargetsRelative ? (Ri.addVectors(this.boundingBox.min, Ti.min), this.boundingBox.expandByPoint(Ri), Ri.addVectors(this.boundingBox.max, Ti.max), this.boundingBox.expandByPoint(Ri)) : (this.boundingBox.expandByPoint(Ti.min), this.boundingBox.expandByPoint(Ti.max))
                                 }
                         } else this.boundingBox.makeEmpty();
                         (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                     }
                     computeBoundingSphere() {
-                        null === this.boundingSphere && (this.boundingSphere = new Ut);
+                        null === this.boundingSphere && (this.boundingSphere = new Mn);
                         const t = this.attributes.position,
                             e = this.morphAttributes.position;
-                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new mt, 1 / 0);
+                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Qe, 1 / 0);
                         if (t) {
                             const n = this.boundingSphere.center;
-                            if (Ge.setFromBufferAttribute(t), e)
+                            if (Ti.setFromBufferAttribute(t), e)
                                 for (let t = 0, n = e.length; t < n; t++) {
                                     const n = e[t];
-                                    Ve.setFromBufferAttribute(n), this.morphTargetsRelative ? (ke.addVectors(Ge.min, Ve.min), Ge.expandByPoint(ke), ke.addVectors(Ge.max, Ve.max), Ge.expandByPoint(ke)) : (Ge.expandByPoint(Ve.min), Ge.expandByPoint(Ve.max))
+                                    Ai.setFromBufferAttribute(n), this.morphTargetsRelative ? (Ri.addVectors(Ti.min, Ai.min), Ti.expandByPoint(Ri), Ri.addVectors(Ti.max, Ai.max), Ti.expandByPoint(Ri)) : (Ti.expandByPoint(Ai.min), Ti.expandByPoint(Ai.max))
                                 }
-                            Ge.getCenter(n);
+                            Ti.getCenter(n);
                             let i = 0;
-                            for (let e = 0, r = t.count; e < r; e++) ke.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(ke));
+                            for (let e = 0, r = t.count; e < r; e++) Ri.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Ri));
                             if (e)
                                 for (let r = 0, s = e.length; r < s; r++) {
                                     const s = e[r],
                                         a = this.morphTargetsRelative;
-                                    for (let e = 0, r = s.count; e < r; e++) ke.fromBufferAttribute(s, e), a && (He.fromBufferAttribute(t, e), ke.add(He)), i = Math.max(i, n.distanceToSquared(ke))
+                                    for (let e = 0, r = s.count; e < r; e++) Ri.fromBufferAttribute(s, e), a && (Ei.fromBufferAttribute(t, e), Ri.add(Ei)), i = Math.max(i, n.distanceToSquared(Ri))
                                 }
                             this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                         }
                     }
                     computeTangents() {
                         const t = this.index,
                             e = this.attributes;
                         if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                         const n = t.array,
                             i = e.position.array,
                             r = e.normal.array,
                             s = e.uv.array,
                             a = i.length / 3;
-                        void 0 === e.tangent && this.setAttribute("tangent", new Ie(new Float32Array(4 * a), 4));
+                        void 0 === e.tangent && this.setAttribute("tangent", new xi(new Float32Array(4 * a), 4));
                         const o = e.tangent.array,
                             l = [],
                             c = [];
-                        for (let t = 0; t < a; t++) l[t] = new mt, c[t] = new mt;
-                        const h = new mt,
-                            u = new mt,
-                            d = new mt,
-                            p = new Y,
-                            m = new Y,
-                            f = new Y,
-                            g = new mt,
-                            v = new mt;
+                        for (let t = 0; t < a; t++) l[t] = new Qe, c[t] = new Qe;
+                        const h = new Qe,
+                            u = new Qe,
+                            d = new Qe,
+                            p = new De,
+                            m = new De,
+                            f = new De,
+                            g = new Qe,
+                            v = new Qe;
 
                         function x(t, e, n) {
                             h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * n), u.sub(h), d.sub(h), m.sub(p), f.sub(p);
                             const r = 1 / (m.x * f.y - f.x * m.y);
                             isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                         }
                         let y = this.groups;
@@ -20015,18 +20476,18 @@
                             count: n.length
                         }]);
                         for (let t = 0, e = y.length; t < e; ++t) {
                             const e = y[t],
                                 i = e.start;
                             for (let t = i, r = i + e.count; t < r; t += 3) x(n[t + 0], n[t + 1], n[t + 2])
                         }
-                        const _ = new mt,
-                            M = new mt,
-                            b = new mt,
-                            w = new mt;
+                        const _ = new Qe,
+                            M = new Qe,
+                            b = new Qe,
+                            w = new Qe;
 
                         function S(t) {
                             b.fromArray(r, 3 * t), w.copy(b);
                             const e = l[t];
                             _.copy(e), _.sub(b.multiplyScalar(b.dot(e))).normalize(), M.crossVectors(w, e);
                             const n = M.dot(c[t]) < 0 ? -1 : 1;
                             o[4 * t] = _.x, o[4 * t + 1] = _.y, o[4 * t + 2] = _.z, o[4 * t + 3] = n
@@ -20038,25 +20499,25 @@
                         }
                     }
                     computeVertexNormals() {
                         const t = this.index,
                             e = this.getAttribute("position");
                         if (void 0 !== e) {
                             let n = this.getAttribute("normal");
-                            if (void 0 === n) n = new Ie(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
+                            if (void 0 === n) n = new xi(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                             else
                                 for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
-                            const i = new mt,
-                                r = new mt,
-                                s = new mt,
-                                a = new mt,
-                                o = new mt,
-                                l = new mt,
-                                c = new mt,
-                                h = new mt;
+                            const i = new Qe,
+                                r = new Qe,
+                                s = new Qe,
+                                a = new Qe,
+                                o = new Qe,
+                                l = new Qe,
+                                c = new Qe,
+                                h = new Qe;
                             if (t)
                                 for (let u = 0, d = t.count; u < d; u += 3) {
                                     const d = t.getX(u + 0),
                                         p = t.getX(u + 1),
                                         m = t.getX(u + 2);
                                     i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(m, l.x, l.y, l.z)
                                 } else
@@ -20077,32 +20538,32 @@
                                 l = Math.min(a.length, r.length - o);
                             for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t]
                         }
                         return this
                     }
                     normalizeNormals() {
                         const t = this.attributes.normal;
-                        for (let e = 0, n = t.count; e < n; e++) ke.fromBufferAttribute(t, e), ke.normalize(), t.setXYZ(e, ke.x, ke.y, ke.z)
+                        for (let e = 0, n = t.count; e < n; e++) Ri.fromBufferAttribute(t, e), Ri.normalize(), t.setXYZ(e, Ri.x, Ri.y, Ri.z)
                     }
                     toNonIndexed() {
                         function t(t, e) {
                             const n = t.array,
                                 i = t.itemSize,
                                 r = t.normalized,
                                 s = new n.constructor(e.length * i);
                             let a = 0,
                                 o = 0;
                             for (let r = 0, l = e.length; r < l; r++) {
                                 a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                                 for (let t = 0; t < i; t++) s[o++] = n[a++]
                             }
-                            return new Ie(s, i, r)
+                            return new xi(s, i, r)
                         }
                         if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
-                        const e = new We,
+                        const e = new Li,
                             n = this.index.array,
                             i = this.attributes;
                         for (const r in i) {
                             const s = t(i[r], n);
                             e.setAttribute(r, s)
                         }
                         const r = this.morphAttributes;
@@ -20203,34 +20664,34 @@
                     }
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }
-                We.prototype.isBufferGeometry = !0;
-                const je = new jt,
-                    Xe = new Wt,
-                    qe = new Ut,
-                    Ye = new mt,
-                    Ze = new mt,
-                    Je = new mt,
-                    Ke = new mt,
-                    Qe = new mt,
-                    $e = new mt,
-                    tn = new mt,
-                    en = new mt,
-                    nn = new mt,
-                    rn = new Y,
-                    sn = new Y,
-                    an = new Y,
-                    on = new mt,
-                    ln = new mt;
-                class cn extends ge {
-                    constructor(t = new We, e = new Ce) {
+                Li.prototype.isBufferGeometry = !0;
+                const Ci = new Cn,
+                    Pi = new Ln,
+                    Di = new Mn,
+                    Ii = new Qe,
+                    Ni = new Qe,
+                    Oi = new Qe,
+                    Ui = new Qe,
+                    Bi = new Qe,
+                    Fi = new Qe,
+                    zi = new Qe,
+                    Hi = new Qe,
+                    Gi = new Qe,
+                    Vi = new De,
+                    ki = new De,
+                    Wi = new De,
+                    ji = new Qe,
+                    Xi = new Qe;
+                class qi extends ei {
+                    constructor(t = new Li, e = new fi) {
                         super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                     }
                     updateMorphTargets() {
                         const t = this.geometry;
@@ -20253,16 +20714,16 @@
                         }
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.material,
                             r = this.matrixWorld;
                         if (void 0 === i) return;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), qe.copy(n.boundingSphere), qe.applyMatrix4(r), !1 === t.ray.intersectsSphere(qe)) return;
-                        if (je.copy(r).invert(), Xe.copy(t.ray).applyMatrix4(je), null !== n.boundingBox && !1 === Xe.intersectsBox(n.boundingBox)) return;
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), Di.copy(n.boundingSphere), Di.applyMatrix4(r), !1 === t.ray.intersectsSphere(Di)) return;
+                        if (Ci.copy(r).invert(), Pi.copy(t.ray).applyMatrix4(Ci), null !== n.boundingBox && !1 === Pi.intersectsBox(n.boundingBox)) return;
                         let s;
                         if (n.isBufferGeometry) {
                             const r = n.index,
                                 a = n.attributes.position,
                                 o = n.morphAttributes.position,
                                 l = n.morphTargetsRelative,
                                 c = n.attributes.uv,
@@ -20274,73 +20735,73 @@
                                     for (let n = 0, p = u.length; n < p; n++) {
                                         const p = u[n],
                                             m = i[p.materialIndex];
                                         for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                                             const i = r.getX(n),
                                                 u = r.getX(n + 1),
                                                 d = r.getX(n + 2);
-                                            s = hn(this, m, t, Xe, a, o, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
+                                            s = Yi(this, m, t, Pi, a, o, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                         }
                                     } else
                                         for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                                             const u = r.getX(n),
                                                 d = r.getX(n + 1),
                                                 p = r.getX(n + 2);
-                                            s = hn(this, i, t, Xe, a, o, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
+                                            s = Yi(this, i, t, Pi, a, o, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                         } else if (void 0 !== a)
                                             if (Array.isArray(i))
                                                 for (let n = 0, r = u.length; n < r; n++) {
                                                     const r = u[n],
                                                         p = i[r.materialIndex];
-                                                    for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) s = hn(this, p, t, Xe, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
+                                                    for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) s = Yi(this, p, t, Pi, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                                 } else
-                                                    for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) s = hn(this, i, t, Xe, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
+                                                    for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) s = Yi(this, i, t, Pi, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                         } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                     }
                 }
 
-                function hn(t, e, n, i, r, s, a, o, l, c, h, u) {
-                    Ye.fromBufferAttribute(r, c), Ze.fromBufferAttribute(r, h), Je.fromBufferAttribute(r, u);
-                    const d = t.morphTargetInfluences;
-                    if (s && d) {
-                        tn.set(0, 0, 0), en.set(0, 0, 0), nn.set(0, 0, 0);
+                function Yi(t, e, n, i, r, s, a, o, l, c, h, p) {
+                    Ii.fromBufferAttribute(r, c), Ni.fromBufferAttribute(r, h), Oi.fromBufferAttribute(r, p);
+                    const m = t.morphTargetInfluences;
+                    if (s && m) {
+                        zi.set(0, 0, 0), Hi.set(0, 0, 0), Gi.set(0, 0, 0);
                         for (let t = 0, e = s.length; t < e; t++) {
-                            const e = d[t],
+                            const e = m[t],
                                 n = s[t];
-                            0 !== e && (Ke.fromBufferAttribute(n, c), Qe.fromBufferAttribute(n, h), $e.fromBufferAttribute(n, u), a ? (tn.addScaledVector(Ke, e), en.addScaledVector(Qe, e), nn.addScaledVector($e, e)) : (tn.addScaledVector(Ke.sub(Ye), e), en.addScaledVector(Qe.sub(Ze), e), nn.addScaledVector($e.sub(Je), e)))
+                            0 !== e && (Ui.fromBufferAttribute(n, c), Bi.fromBufferAttribute(n, h), Fi.fromBufferAttribute(n, p), a ? (zi.addScaledVector(Ui, e), Hi.addScaledVector(Bi, e), Gi.addScaledVector(Fi, e)) : (zi.addScaledVector(Ui.sub(Ii), e), Hi.addScaledVector(Bi.sub(Ni), e), Gi.addScaledVector(Fi.sub(Oi), e)))
                         }
-                        Ye.add(tn), Ze.add(en), Je.add(nn)
+                        Ii.add(zi), Ni.add(Hi), Oi.add(Gi)
                     }
-                    t.isSkinnedMesh && (t.boneTransform(c, Ye), t.boneTransform(h, Ze), t.boneTransform(u, Je));
-                    const p = function(t, e, n, i, r, s, a, o) {
+                    t.isSkinnedMesh && (t.boneTransform(c, Ii), t.boneTransform(h, Ni), t.boneTransform(p, Oi));
+                    const f = function(t, e, n, i, r, s, a, o) {
                         let l;
-                        if (l = 1 === e.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, 2 !== e.side, o), null === l) return null;
-                        ln.copy(o), ln.applyMatrix4(t.matrixWorld);
-                        const c = n.ray.origin.distanceTo(ln);
+                        if (l = e.side === u ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, e.side !== d, o), null === l) return null;
+                        Xi.copy(o), Xi.applyMatrix4(t.matrixWorld);
+                        const c = n.ray.origin.distanceTo(Xi);
                         return c < n.near || c > n.far ? null : {
                             distance: c,
-                            point: ln.clone(),
+                            point: Xi.clone(),
                             object: t
                         }
-                    }(t, e, n, i, Ye, Ze, Je, on);
-                    if (p) {
-                        o && (rn.fromBufferAttribute(o, c), sn.fromBufferAttribute(o, h), an.fromBufferAttribute(o, u), p.uv = Ae.getUV(on, Ye, Ze, Je, rn, sn, an, new Y)), l && (rn.fromBufferAttribute(l, c), sn.fromBufferAttribute(l, h), an.fromBufferAttribute(l, u), p.uv2 = Ae.getUV(on, Ye, Ze, Je, rn, sn, an, new Y));
+                    }(t, e, n, i, Ii, Ni, Oi, ji);
+                    if (f) {
+                        o && (Vi.fromBufferAttribute(o, c), ki.fromBufferAttribute(o, h), Wi.fromBufferAttribute(o, p), f.uv = di.getUV(ji, Ii, Ni, Oi, Vi, ki, Wi, new De)), l && (Vi.fromBufferAttribute(l, c), ki.fromBufferAttribute(l, h), Wi.fromBufferAttribute(l, p), f.uv2 = di.getUV(ji, Ii, Ni, Oi, Vi, ki, Wi, new De));
                         const t = {
                             a: c,
                             b: h,
-                            c: u,
-                            normal: new mt,
+                            c: p,
+                            normal: new Qe,
                             materialIndex: 0
                         };
-                        Ae.getNormal(Ye, Ze, Je, t.normal), p.face = t
+                        di.getNormal(Ii, Ni, Oi, t.normal), f.face = t
                     }
-                    return p
+                    return f
                 }
-                cn.prototype.isMesh = !0;
-                class un extends We {
+                qi.prototype.isMesh = !0;
+                class Zi extends Li {
                     constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                         super(), this.type = "BoxGeometry", this.parameters = {
                             width: t,
                             height: e,
                             depth: n,
                             widthSegments: i,
                             heightSegments: r,
@@ -20361,15 +20822,15 @@
                                 _ = s / 2,
                                 M = p / 2,
                                 b = m / 2,
                                 w = f + 1,
                                 S = g + 1;
                             let E = 0,
                                 T = 0;
-                            const A = new mt;
+                            const A = new Qe;
                             for (let s = 0; s < S; s++) {
                                 const a = s * y - M;
                                 for (let o = 0; o < w; o++) {
                                     const u = o * x - _;
                                     A[t] = u * i, A[e] = a * r, A[n] = b, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(o / f), h.push(1 - s / g), E += 1
                                 }
                             }
@@ -20379,60 +20840,60 @@
                                         i = u + e + w * (t + 1),
                                         r = u + (e + 1) + w * (t + 1),
                                         s = u + (e + 1) + w * t;
                                     o.push(n, i, s), o.push(i, r, s), T += 6
                                 }
                             a.addGroup(d, T, v), d += T, u += E
                         }
-                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Ue(l, 3)), this.setAttribute("normal", new Ue(c, 3)), this.setAttribute("uv", new Ue(h, 2))
+                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Mi(l, 3)), this.setAttribute("normal", new Mi(c, 3)), this.setAttribute("uv", new Mi(h, 2))
                     }
                     static fromJSON(t) {
-                        return new un(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
+                        return new Zi(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
                     }
                 }
 
-                function dn(t) {
+                function Ji(t) {
                     const e = {};
                     for (const n in t) {
                         e[n] = {};
                         for (const i in t[n]) {
                             const r = t[n][i];
                             r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                         }
                     }
                     return e
                 }
 
-                function pn(t) {
+                function Ki(t) {
                     const e = {};
                     for (let n = 0; n < t.length; n++) {
-                        const i = dn(t[n]);
+                        const i = Ji(t[n]);
                         for (const t in i) e[t] = i[t]
                     }
                     return e
                 }
-                const mn = {
-                    clone: dn,
-                    merge: pn
+                const Qi = {
+                    clone: Ji,
+                    merge: Ki
                 };
-                class fn extends Le {
+                class $i extends mi {
                     constructor(t) {
                         super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                             derivatives: !1,
                             fragDepth: !1,
                             drawBuffers: !1,
                             shaderTextureLOD: !1
                         }, this.defaultAttributeValues = {
                             color: [1, 1, 1],
                             uv: [0, 0],
                             uv2: [0, 0]
                         }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
                     }
                     copy(t) {
-                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = dn(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
+                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ji(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         e.glslVersion = this.glslVersion, e.uniforms = {};
                         for (const n in this.uniforms) {
                             const i = this.uniforms[n].value;
                             i && i.isTexture ? e.uniforms[n] = {
@@ -20462,18 +20923,18 @@
                         }
                         Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                         const n = {};
                         for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                         return Object.keys(n).length > 0 && (e.extensions = n), e
                     }
                 }
-                fn.prototype.isShaderMaterial = !0;
-                class gn extends ge {
+                $i.prototype.isShaderMaterial = !0;
+                class tr extends ei {
                     constructor() {
-                        super(), this.type = "Camera", this.matrixWorldInverse = new jt, this.projectionMatrix = new jt, this.projectionMatrixInverse = new jt
+                        super(), this.type = "Camera", this.matrixWorldInverse = new Cn, this.projectionMatrix = new Cn, this.projectionMatrixInverse = new Cn
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                     }
                     getWorldDirection(t) {
                         this.updateWorldMatrix(!0, !1);
                         const e = this.matrixWorld.elements;
@@ -20485,32 +20946,32 @@
                     updateWorldMatrix(t, e) {
                         super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                gn.prototype.isCamera = !0;
-                class vn extends gn {
+                tr.prototype.isCamera = !0;
+                class er extends tr {
                     constructor(t = 50, e = 1, n = .1, i = 2e3) {
                         super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                     }
                     setFocalLength(t) {
                         const e = .5 * this.getFilmHeight() / t;
-                        this.fov = 2 * V * Math.atan(e), this.updateProjectionMatrix()
+                        this.fov = 2 * Te * Math.atan(e), this.updateProjectionMatrix()
                     }
                     getFocalLength() {
-                        const t = Math.tan(.5 * G * this.fov);
+                        const t = Math.tan(.5 * Ee * this.fov);
                         return .5 * this.getFilmHeight() / t
                     }
                     getEffectiveFOV() {
-                        return 2 * V * Math.atan(Math.tan(.5 * G * this.fov) / this.zoom)
+                        return 2 * Te * Math.atan(Math.tan(.5 * Ee * this.fov) / this.zoom)
                     }
                     getFilmWidth() {
                         return this.filmGauge * Math.min(this.aspect, 1)
                     }
                     getFilmHeight() {
                         return this.filmGauge / Math.max(this.aspect, 1)
                     }
@@ -20526,15 +20987,15 @@
                         }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                     }
                     clearViewOffset() {
                         null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                     }
                     updateProjectionMatrix() {
                         const t = this.near;
-                        let e = t * Math.tan(.5 * G * this.fov) / this.zoom,
+                        let e = t * Math.tan(.5 * Ee * this.fov) / this.zoom,
                             n = 2 * e,
                             i = this.aspect * n,
                             r = -.5 * i;
                         const s = this.view;
                         if (null !== this.view && this.view.enabled) {
                             const t = s.fullWidth,
                                 a = s.fullHeight;
@@ -20544,108 +21005,108 @@
                         0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                     }
                 }
-                vn.prototype.isPerspectiveCamera = !0;
-                const xn = 90;
-                class yn extends ge {
+                er.prototype.isPerspectiveCamera = !0;
+                const nr = 90;
+                class ir extends ei {
                     constructor(t, e, n) {
                         if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                         this.renderTarget = n;
-                        const i = new vn(xn, 1, t, e);
-                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new mt(1, 0, 0)), this.add(i);
-                        const r = new vn(xn, 1, t, e);
-                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new mt(-1, 0, 0)), this.add(r);
-                        const s = new vn(xn, 1, t, e);
-                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new mt(0, 1, 0)), this.add(s);
-                        const a = new vn(xn, 1, t, e);
-                        a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new mt(0, -1, 0)), this.add(a);
-                        const o = new vn(xn, 1, t, e);
-                        o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new mt(0, 0, 1)), this.add(o);
-                        const l = new vn(xn, 1, t, e);
-                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new mt(0, 0, -1)), this.add(l)
+                        const i = new er(nr, 1, t, e);
+                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Qe(1, 0, 0)), this.add(i);
+                        const r = new er(nr, 1, t, e);
+                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Qe(-1, 0, 0)), this.add(r);
+                        const s = new er(nr, 1, t, e);
+                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Qe(0, 1, 0)), this.add(s);
+                        const a = new er(nr, 1, t, e);
+                        a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new Qe(0, -1, 0)), this.add(a);
+                        const o = new er(nr, 1, t, e);
+                        o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Qe(0, 0, 1)), this.add(o);
+                        const l = new er(nr, 1, t, e);
+                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Qe(0, 0, -1)), this.add(l)
                     }
                     update(t, e) {
                         null === this.parent && this.updateMatrixWorld();
                         const n = this.renderTarget,
                             [i, r, s, a, o, l] = this.children,
                             c = t.xr.enabled,
                             h = t.getRenderTarget();
                         t.xr.enabled = !1;
                         const u = n.texture.generateMipmaps;
                         n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, a), t.setRenderTarget(n, 4), t.render(e, o), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c, n.texture.needsPMREMUpdate = !0
                     }
                 }
-                class _n extends lt {
-                    constructor(t, e, n, i, s, a, o, l, c, h) {
-                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : r, n, i, s, a, o, l, c, h), this.flipY = !1
+                class rr extends Xe {
+                    constructor(t, e, n, i, r, s, a, o, l, c) {
+                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : Q, n, i, r, s, a, o, l, c), this.flipY = !1
                     }
                     get images() {
                         return this.image
                     }
                     set images(t) {
                         this.image = t
                     }
                 }
-                _n.prototype.isCubeTexture = !0;
-                class Mn extends ut {
+                rr.prototype.isCubeTexture = !0;
+                class sr extends Ze {
                     constructor(t, e, n) {
-                        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new _n(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : u
+                        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new rr(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : ht
                     }
                     fromEquirectangularTexture(t, e) {
-                        this.texture.type = e.type, this.texture.format = y, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
+                        this.texture.type = e.type, this.texture.format = Et, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                         const n = {
                                 tEquirect: {
                                     value: null
                                 }
                             },
                             i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                             r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
-                            s = new un(5, 5, 5),
-                            a = new fn({
+                            s = new Zi(5, 5, 5),
+                            a = new $i({
                                 name: "CubemapFromEquirect",
-                                uniforms: dn(n),
+                                uniforms: Ji(n),
                                 vertexShader: i,
                                 fragmentShader: r,
-                                side: 1,
-                                blending: 0
+                                side: u,
+                                blending: p
                             });
                         a.uniforms.tEquirect.value = e;
-                        const o = new cn(s, a),
+                        const o = new qi(s, a),
                             l = e.minFilter;
-                        return e.minFilter === d && (e.minFilter = u), new yn(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
+                        return e.minFilter === dt && (e.minFilter = ht), new ir(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
                     }
                     clear(t, e, n, i) {
                         const r = t.getRenderTarget();
                         for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                         t.setRenderTarget(r)
                     }
                 }
-                Mn.prototype.isWebGLCubeRenderTarget = !0;
-                const bn = new mt,
-                    wn = new mt,
-                    Sn = new Z;
-                class En {
-                    constructor(t = new mt(1, 0, 0), e = 0) {
+                sr.prototype.isWebGLCubeRenderTarget = !0;
+                const ar = new Qe,
+                    or = new Qe,
+                    lr = new Ie;
+                class cr {
+                    constructor(t = new Qe(1, 0, 0), e = 0) {
                         this.normal = t, this.constant = e
                     }
                     set(t, e) {
                         return this.normal.copy(t), this.constant = e, this
                     }
                     setComponents(t, e, n, i) {
                         return this.normal.set(t, e, n), this.constant = i, this
                     }
                     setFromNormalAndCoplanarPoint(t, e) {
                         return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                     }
                     setFromCoplanarPoints(t, e, n) {
-                        const i = bn.subVectors(n, e).cross(wn.subVectors(t, e)).normalize();
+                        const i = ar.subVectors(n, e).cross(or.subVectors(t, e)).normalize();
                         return this.setFromNormalAndCoplanarPoint(i, t), this
                     }
                     copy(t) {
                         return this.normal.copy(t.normal), this.constant = t.constant, this
                     }
                     normalize() {
                         const t = 1 / this.normal.length();
@@ -20660,15 +21121,15 @@
                     distanceToSphere(t) {
                         return this.distanceToPoint(t.center) - t.radius
                     }
                     projectPoint(t, e) {
                         return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                     }
                     intersectLine(t, e) {
-                        const n = t.delta(bn),
+                        const n = t.delta(ar),
                             i = this.normal.dot(n);
                         if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                         const r = -(t.start.dot(this.normal) + this.constant) / i;
                         return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
                     }
                     intersectsLine(t) {
                         const e = this.distanceToPoint(t.start),
@@ -20681,34 +21142,34 @@
                     intersectsSphere(t) {
                         return t.intersectsPlane(this)
                     }
                     coplanarPoint(t) {
                         return t.copy(this.normal).multiplyScalar(-this.constant)
                     }
                     applyMatrix4(t, e) {
-                        const n = e || Sn.getNormalMatrix(t),
-                            i = this.coplanarPoint(bn).applyMatrix4(t),
+                        const n = e || lr.getNormalMatrix(t),
+                            i = this.coplanarPoint(ar).applyMatrix4(t),
                             r = this.normal.applyMatrix3(n).normalize();
                         return this.constant = -i.dot(r), this
                     }
                     translate(t) {
                         return this.constant -= t.dot(this.normal), this
                     }
                     equals(t) {
                         return t.normal.equals(this.normal) && t.constant === this.constant
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                En.prototype.isPlane = !0;
-                const Tn = new Ut,
-                    An = new mt;
-                class Rn {
-                    constructor(t = new En, e = new En, n = new En, i = new En, r = new En, s = new En) {
+                cr.prototype.isPlane = !0;
+                const hr = new Mn,
+                    ur = new Qe;
+                class dr {
+                    constructor(t = new cr, e = new cr, n = new cr, i = new cr, r = new cr, s = new cr) {
                         this.planes = [t, e, n, i, r, s]
                     }
                     set(t, e, n, i, r, s) {
                         const a = this.planes;
                         return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this
                     }
                     copy(t) {
@@ -20735,47 +21196,47 @@
                             g = n[13],
                             v = n[14],
                             x = n[15];
                         return e[0].setComponents(a - i, h - o, m - u, x - f).normalize(), e[1].setComponents(a + i, h + o, m + u, x + f).normalize(), e[2].setComponents(a + r, h + l, m + d, x + g).normalize(), e[3].setComponents(a - r, h - l, m - d, x - g).normalize(), e[4].setComponents(a - s, h - c, m - p, x - v).normalize(), e[5].setComponents(a + s, h + c, m + p, x + v).normalize(), this
                     }
                     intersectsObject(t) {
                         const e = t.geometry;
-                        return null === e.boundingSphere && e.computeBoundingSphere(), Tn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Tn)
+                        return null === e.boundingSphere && e.computeBoundingSphere(), hr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(hr)
                     }
                     intersectsSprite(t) {
-                        return Tn.center.set(0, 0, 0), Tn.radius = .7071067811865476, Tn.applyMatrix4(t.matrixWorld), this.intersectsSphere(Tn)
+                        return hr.center.set(0, 0, 0), hr.radius = .7071067811865476, hr.applyMatrix4(t.matrixWorld), this.intersectsSphere(hr)
                     }
                     intersectsSphere(t) {
                         const e = this.planes,
                             n = t.center,
                             i = -t.radius;
                         for (let t = 0; t < 6; t++)
                             if (e[t].distanceToPoint(n) < i) return !1;
                         return !0
                     }
                     intersectsBox(t) {
                         const e = this.planes;
                         for (let n = 0; n < 6; n++) {
                             const i = e[n];
-                            if (An.x = i.normal.x > 0 ? t.max.x : t.min.x, An.y = i.normal.y > 0 ? t.max.y : t.min.y, An.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(An) < 0) return !1
+                            if (ur.x = i.normal.x > 0 ? t.max.x : t.min.x, ur.y = i.normal.y > 0 ? t.max.y : t.min.y, ur.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(ur) < 0) return !1
                         }
                         return !0
                     }
                     containsPoint(t) {
                         const e = this.planes;
                         for (let n = 0; n < 6; n++)
                             if (e[n].distanceToPoint(t) < 0) return !1;
                         return !0
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
 
-                function Ln() {
+                function pr() {
                     let t = null,
                         e = !1,
                         n = null,
                         i = null;
 
                     function r(e, s) {
                         n(e, s), i = t.requestAnimationFrame(r)
@@ -20792,15 +21253,15 @@
                         },
                         setContext: function(e) {
                             t = e
                         }
                     }
                 }
 
-                function Cn(t, e) {
+                function mr(t, e) {
                     const n = e.isWebGL2,
                         i = new WeakMap;
                     return {
                         get: function(t) {
                             return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                         },
                         remove: function(e) {
@@ -20836,15 +21297,15 @@
                                 const s = i.array,
                                     a = i.updateRange;
                                 t.bindBuffer(r, e), -1 === a.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1)
                             }(s.buffer, e, r), s.version = e.version)
                         }
                     }
                 }
-                class Pn extends We {
+                class fr extends Li {
                     constructor(t = 1, e = 1, n = 1, i = 1) {
                         super(), this.type = "PlaneGeometry", this.parameters = {
                             width: t,
                             height: e,
                             widthSegments: n,
                             heightSegments: i
                         };
@@ -20871,21 +21332,21 @@
                             for (let e = 0; e < a; e++) {
                                 const n = e + l * t,
                                     i = e + l * (t + 1),
                                     r = e + 1 + l * (t + 1),
                                     s = e + 1 + l * t;
                                 d.push(n, i, s), d.push(i, r, s)
                             }
-                        this.setIndex(d), this.setAttribute("position", new Ue(p, 3)), this.setAttribute("normal", new Ue(m, 3)), this.setAttribute("uv", new Ue(f, 2))
+                        this.setIndex(d), this.setAttribute("position", new Mi(p, 3)), this.setAttribute("normal", new Mi(m, 3)), this.setAttribute("uv", new Mi(f, 2))
                     }
                     static fromJSON(t) {
-                        return new Pn(t.width, t.height, t.widthSegments, t.heightSegments)
+                        return new fr(t.width, t.height, t.widthSegments, t.heightSegments)
                     }
                 }
-                const Dn = {
+                const gr = {
                         alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                         alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                         alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                         alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                         aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                         aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                         begin_vertex: "vec3 transformed = vec3( position );",
@@ -21013,30 +21474,30 @@
                         points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                         points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                         shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                         shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                         sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                         sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
                     },
-                    In = {
+                    vr = {
                         common: {
                             diffuse: {
-                                value: new rt(16777215)
+                                value: new Ve(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             map: {
                                 value: null
                             },
                             uvTransform: {
-                                value: new Z
+                                value: new Ie
                             },
                             uv2Transform: {
-                                value: new Z
+                                value: new Ie
                             },
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             }
@@ -21093,15 +21554,15 @@
                             }
                         },
                         normalmap: {
                             normalMap: {
                                 value: null
                             },
                             normalScale: {
-                                value: new Y(1, 1)
+                                value: new De(1, 1)
                             }
                         },
                         displacementmap: {
                             displacementMap: {
                                 value: null
                             },
                             displacementScale: {
@@ -21133,15 +21594,15 @@
                             fogNear: {
                                 value: 1
                             },
                             fogFar: {
                                 value: 2e3
                             },
                             fogColor: {
-                                value: new rt(16777215)
+                                value: new Ve(16777215)
                             }
                         },
                         lights: {
                             ambientLightColor: {
                                 value: []
                             },
                             lightProbe: {
@@ -21244,15 +21705,15 @@
                             },
                             ltc_2: {
                                 value: null
                             }
                         },
                         points: {
                             diffuse: {
-                                value: new rt(16777215)
+                                value: new Ve(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             size: {
                                 value: 1
                             },
@@ -21265,271 +21726,271 @@
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             },
                             uvTransform: {
-                                value: new Z
+                                value: new Ie
                             }
                         },
                         sprite: {
                             diffuse: {
-                                value: new rt(16777215)
+                                value: new Ve(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             center: {
-                                value: new Y(.5, .5)
+                                value: new De(.5, .5)
                             },
                             rotation: {
                                 value: 0
                             },
                             map: {
                                 value: null
                             },
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             },
                             uvTransform: {
-                                value: new Z
+                                value: new Ie
                             }
                         }
                     },
-                    Nn = {
+                    xr = {
                         basic: {
-                            uniforms: pn([In.common, In.specularmap, In.envmap, In.aomap, In.lightmap, In.fog]),
-                            vertexShader: Dn.meshbasic_vert,
-                            fragmentShader: Dn.meshbasic_frag
+                            uniforms: Ki([vr.common, vr.specularmap, vr.envmap, vr.aomap, vr.lightmap, vr.fog]),
+                            vertexShader: gr.meshbasic_vert,
+                            fragmentShader: gr.meshbasic_frag
                         },
                         lambert: {
-                            uniforms: pn([In.common, In.specularmap, In.envmap, In.aomap, In.lightmap, In.emissivemap, In.fog, In.lights, {
+                            uniforms: Ki([vr.common, vr.specularmap, vr.envmap, vr.aomap, vr.lightmap, vr.emissivemap, vr.fog, vr.lights, {
                                 emissive: {
-                                    value: new rt(0)
+                                    value: new Ve(0)
                                 }
                             }]),
-                            vertexShader: Dn.meshlambert_vert,
-                            fragmentShader: Dn.meshlambert_frag
+                            vertexShader: gr.meshlambert_vert,
+                            fragmentShader: gr.meshlambert_frag
                         },
                         phong: {
-                            uniforms: pn([In.common, In.specularmap, In.envmap, In.aomap, In.lightmap, In.emissivemap, In.bumpmap, In.normalmap, In.displacementmap, In.fog, In.lights, {
+                            uniforms: Ki([vr.common, vr.specularmap, vr.envmap, vr.aomap, vr.lightmap, vr.emissivemap, vr.bumpmap, vr.normalmap, vr.displacementmap, vr.fog, vr.lights, {
                                 emissive: {
-                                    value: new rt(0)
+                                    value: new Ve(0)
                                 },
                                 specular: {
-                                    value: new rt(1118481)
+                                    value: new Ve(1118481)
                                 },
                                 shininess: {
                                     value: 30
                                 }
                             }]),
-                            vertexShader: Dn.meshphong_vert,
-                            fragmentShader: Dn.meshphong_frag
+                            vertexShader: gr.meshphong_vert,
+                            fragmentShader: gr.meshphong_frag
                         },
                         standard: {
-                            uniforms: pn([In.common, In.envmap, In.aomap, In.lightmap, In.emissivemap, In.bumpmap, In.normalmap, In.displacementmap, In.roughnessmap, In.metalnessmap, In.fog, In.lights, {
+                            uniforms: Ki([vr.common, vr.envmap, vr.aomap, vr.lightmap, vr.emissivemap, vr.bumpmap, vr.normalmap, vr.displacementmap, vr.roughnessmap, vr.metalnessmap, vr.fog, vr.lights, {
                                 emissive: {
-                                    value: new rt(0)
+                                    value: new Ve(0)
                                 },
                                 roughness: {
                                     value: 1
                                 },
                                 metalness: {
                                     value: 0
                                 },
                                 envMapIntensity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Dn.meshphysical_vert,
-                            fragmentShader: Dn.meshphysical_frag
+                            vertexShader: gr.meshphysical_vert,
+                            fragmentShader: gr.meshphysical_frag
                         },
                         toon: {
-                            uniforms: pn([In.common, In.aomap, In.lightmap, In.emissivemap, In.bumpmap, In.normalmap, In.displacementmap, In.gradientmap, In.fog, In.lights, {
+                            uniforms: Ki([vr.common, vr.aomap, vr.lightmap, vr.emissivemap, vr.bumpmap, vr.normalmap, vr.displacementmap, vr.gradientmap, vr.fog, vr.lights, {
                                 emissive: {
-                                    value: new rt(0)
+                                    value: new Ve(0)
                                 }
                             }]),
-                            vertexShader: Dn.meshtoon_vert,
-                            fragmentShader: Dn.meshtoon_frag
+                            vertexShader: gr.meshtoon_vert,
+                            fragmentShader: gr.meshtoon_frag
                         },
                         matcap: {
-                            uniforms: pn([In.common, In.bumpmap, In.normalmap, In.displacementmap, In.fog, {
+                            uniforms: Ki([vr.common, vr.bumpmap, vr.normalmap, vr.displacementmap, vr.fog, {
                                 matcap: {
                                     value: null
                                 }
                             }]),
-                            vertexShader: Dn.meshmatcap_vert,
-                            fragmentShader: Dn.meshmatcap_frag
+                            vertexShader: gr.meshmatcap_vert,
+                            fragmentShader: gr.meshmatcap_frag
                         },
                         points: {
-                            uniforms: pn([In.points, In.fog]),
-                            vertexShader: Dn.points_vert,
-                            fragmentShader: Dn.points_frag
+                            uniforms: Ki([vr.points, vr.fog]),
+                            vertexShader: gr.points_vert,
+                            fragmentShader: gr.points_frag
                         },
                         dashed: {
-                            uniforms: pn([In.common, In.fog, {
+                            uniforms: Ki([vr.common, vr.fog, {
                                 scale: {
                                     value: 1
                                 },
                                 dashSize: {
                                     value: 1
                                 },
                                 totalSize: {
                                     value: 2
                                 }
                             }]),
-                            vertexShader: Dn.linedashed_vert,
-                            fragmentShader: Dn.linedashed_frag
+                            vertexShader: gr.linedashed_vert,
+                            fragmentShader: gr.linedashed_frag
                         },
                         depth: {
-                            uniforms: pn([In.common, In.displacementmap]),
-                            vertexShader: Dn.depth_vert,
-                            fragmentShader: Dn.depth_frag
+                            uniforms: Ki([vr.common, vr.displacementmap]),
+                            vertexShader: gr.depth_vert,
+                            fragmentShader: gr.depth_frag
                         },
                         normal: {
-                            uniforms: pn([In.common, In.bumpmap, In.normalmap, In.displacementmap, {
+                            uniforms: Ki([vr.common, vr.bumpmap, vr.normalmap, vr.displacementmap, {
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Dn.meshnormal_vert,
-                            fragmentShader: Dn.meshnormal_frag
+                            vertexShader: gr.meshnormal_vert,
+                            fragmentShader: gr.meshnormal_frag
                         },
                         sprite: {
-                            uniforms: pn([In.sprite, In.fog]),
-                            vertexShader: Dn.sprite_vert,
-                            fragmentShader: Dn.sprite_frag
+                            uniforms: Ki([vr.sprite, vr.fog]),
+                            vertexShader: gr.sprite_vert,
+                            fragmentShader: gr.sprite_frag
                         },
                         background: {
                             uniforms: {
                                 uvTransform: {
-                                    value: new Z
+                                    value: new Ie
                                 },
                                 t2D: {
                                     value: null
                                 }
                             },
-                            vertexShader: Dn.background_vert,
-                            fragmentShader: Dn.background_frag
+                            vertexShader: gr.background_vert,
+                            fragmentShader: gr.background_frag
                         },
                         cube: {
-                            uniforms: pn([In.envmap, {
+                            uniforms: Ki([vr.envmap, {
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Dn.cube_vert,
-                            fragmentShader: Dn.cube_frag
+                            vertexShader: gr.cube_vert,
+                            fragmentShader: gr.cube_frag
                         },
                         equirect: {
                             uniforms: {
                                 tEquirect: {
                                     value: null
                                 }
                             },
-                            vertexShader: Dn.equirect_vert,
-                            fragmentShader: Dn.equirect_frag
+                            vertexShader: gr.equirect_vert,
+                            fragmentShader: gr.equirect_frag
                         },
                         distanceRGBA: {
-                            uniforms: pn([In.common, In.displacementmap, {
+                            uniforms: Ki([vr.common, vr.displacementmap, {
                                 referencePosition: {
-                                    value: new mt
+                                    value: new Qe
                                 },
                                 nearDistance: {
                                     value: 1
                                 },
                                 farDistance: {
                                     value: 1e3
                                 }
                             }]),
-                            vertexShader: Dn.distanceRGBA_vert,
-                            fragmentShader: Dn.distanceRGBA_frag
+                            vertexShader: gr.distanceRGBA_vert,
+                            fragmentShader: gr.distanceRGBA_frag
                         },
                         shadow: {
-                            uniforms: pn([In.lights, In.fog, {
+                            uniforms: Ki([vr.lights, vr.fog, {
                                 color: {
-                                    value: new rt(0)
+                                    value: new Ve(0)
                                 },
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Dn.shadow_vert,
-                            fragmentShader: Dn.shadow_frag
+                            vertexShader: gr.shadow_vert,
+                            fragmentShader: gr.shadow_frag
                         }
                     };
 
-                function On(t, e, n, i, r, s) {
-                    const o = new rt(0);
-                    let l, c, h = !0 === r ? 0 : 1,
-                        u = null,
-                        d = 0,
-                        p = null;
+                function yr(t, e, n, i, r, s) {
+                    const a = new Ve(0);
+                    let o, l, c = !0 === r ? 0 : 1,
+                        d = null,
+                        p = 0,
+                        m = null;
 
-                    function m(t, e) {
+                    function f(t, e) {
                         n.buffers.color.setClear(t.r, t.g, t.b, e, s)
                     }
                     return {
                         getClearColor: function() {
-                            return o
+                            return a
                         },
                         setClearColor: function(t, e = 1) {
-                            o.set(t), h = e, m(o, h)
+                            a.set(t), c = e, f(a, c)
                         },
                         getClearAlpha: function() {
-                            return h
+                            return c
                         },
                         setClearAlpha: function(t) {
-                            h = t, m(o, h)
+                            c = t, f(a, c)
                         },
                         render: function(n, r) {
                             let s = !1,
-                                f = !0 === r.isScene ? r.background : null;
-                            f && f.isTexture && (f = e.get(f));
-                            const g = t.xr,
-                                v = g.getSession && g.getSession();
-                            v && "additive" === v.environmentBlendMode && (f = null), null === f ? m(o, h) : f && f.isColor && (m(f, 1), s = !0), (t.autoClear || s) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.mapping === a) ? (void 0 === c && (c = new cn(new un(1, 1, 1), new fn({
+                                g = !0 === r.isScene ? r.background : null;
+                            g && g.isTexture && (g = e.get(g));
+                            const v = t.xr,
+                                x = v.getSession && v.getSession();
+                            x && "additive" === x.environmentBlendMode && (g = null), null === g ? f(a, c) : g && g.isColor && (f(g, 1), s = !0), (t.autoClear || s) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.mapping === nt) ? (void 0 === l && (l = new qi(new Zi(1, 1, 1), new $i({
                                 name: "BackgroundCubeMaterial",
-                                uniforms: dn(Nn.cube.uniforms),
-                                vertexShader: Nn.cube.vertexShader,
-                                fragmentShader: Nn.cube.fragmentShader,
-                                side: 1,
+                                uniforms: Ji(xr.cube.uniforms),
+                                vertexShader: xr.cube.vertexShader,
+                                fragmentShader: xr.cube.fragmentShader,
+                                side: u,
                                 depthTest: !1,
                                 depthWrite: !1,
                                 fog: !1
-                            })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(t, e, n) {
+                            })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(t, e, n) {
                                 this.matrixWorld.copyPosition(n.matrixWorld)
-                            }, Object.defineProperty(c.material, "envMap", {
+                            }, Object.defineProperty(l.material, "envMap", {
                                 get: function() {
                                     return this.uniforms.envMap.value
                                 }
-                            }), i.update(c)), c.material.uniforms.envMap.value = f, c.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, u === f && d === f.version && p === t.toneMapping || (c.material.needsUpdate = !0, u = f, d = f.version, p = t.toneMapping), n.unshift(c, c.geometry, c.material, 0, 0, null)) : f && f.isTexture && (void 0 === l && (l = new cn(new Pn(2, 2), new fn({
+                            }), i.update(l)), l.material.uniforms.envMap.value = g, l.material.uniforms.flipEnvMap.value = g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1, d === g && p === g.version && m === t.toneMapping || (l.material.needsUpdate = !0, d = g, p = g.version, m = t.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null)) : g && g.isTexture && (void 0 === o && (o = new qi(new fr(2, 2), new $i({
                                 name: "BackgroundMaterial",
-                                uniforms: dn(Nn.background.uniforms),
-                                vertexShader: Nn.background.vertexShader,
-                                fragmentShader: Nn.background.fragmentShader,
-                                side: 0,
+                                uniforms: Ji(xr.background.uniforms),
+                                vertexShader: xr.background.vertexShader,
+                                fragmentShader: xr.background.fragmentShader,
+                                side: h,
                                 depthTest: !1,
                                 depthWrite: !1,
                                 fog: !1
-                            })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
+                            })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                                 get: function() {
                                     return this.uniforms.t2D.value
                                 }
-                            }), i.update(l)), l.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), l.material.uniforms.uvTransform.value.copy(f.matrix), u === f && d === f.version && p === t.toneMapping || (l.material.needsUpdate = !0, u = f, d = f.version, p = t.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null))
+                            }), i.update(o)), o.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), o.material.uniforms.uvTransform.value.copy(g.matrix), d === g && p === g.version && m === t.toneMapping || (o.material.needsUpdate = !0, d = g, p = g.version, m = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                         }
                     }
                 }
 
-                function Un(t, e, n, i) {
+                function _r(t, e, n, i) {
                     const r = t.getParameter(34921),
                         s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                         a = i.isWebGL2 || null !== s,
                         o = {},
                         l = d(null);
                     let c = l;
 
@@ -21726,15 +22187,15 @@
                         },
                         initAttributes: p,
                         enableAttribute: m,
                         disableUnusedAttributes: g
                     }
                 }
 
-                function Bn(t, e, n, i) {
+                function Mr(t, e, n, i) {
                     const r = i.isWebGL2;
                     let s;
                     this.setMode = function(t) {
                         s = t
                     }, this.render = function(e, i) {
                         t.drawArrays(s, e, i), n.update(i, s, 1)
                     }, this.renderInstances = function(i, a, o) {
@@ -21742,15 +22203,15 @@
                         let l, c;
                         if (r) l = t, c = "drawArraysInstanced";
                         else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                         l[c](s, i, a, o), n.update(a, s, o)
                     }
                 }
 
-                function Fn(t, e, n) {
+                function br(t, e, n) {
                     let i;
 
                     function r(e) {
                         if ("highp" === e) {
                             if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                             e = "mediump"
                         }
@@ -21797,22 +22258,22 @@
                         vertexTextures: x,
                         floatFragmentTextures: y,
                         floatVertexTextures: x && y,
                         maxSamples: s ? t.getParameter(36183) : 0
                     }
                 }
 
-                function zn(t) {
+                function wr(t) {
                     const e = this;
                     let n = null,
                         i = 0,
                         r = !1,
                         s = !1;
-                    const a = new En,
-                        o = new Z,
+                    const a = new cr,
+                        o = new Ie,
                         l = {
                             value: null,
                             needsUpdate: !1
                         };
 
                     function c() {
                         l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
@@ -21852,74 +22313,74 @@
                             l.value = r, r = h(u, a, e, o);
                             for (let t = 0; t !== e; ++t) r[t] = n[t];
                             m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                         }
                     }
                 }
 
-                function Hn(t) {
+                function Sr(t) {
                     let e = new WeakMap;
 
                     function n(t, e) {
-                        return 303 === e ? t.mapping = r : 304 === e && (t.mapping = s), t
+                        return e === tt ? t.mapping = Q : e === et && (t.mapping = $), t
                     }
 
                     function i(t) {
                         const n = t.target;
                         n.removeEventListener("dispose", i);
                         const r = e.get(n);
                         void 0 !== r && (e.delete(n), r.dispose())
                     }
                     return {
                         get: function(r) {
                             if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                                 const s = r.mapping;
-                                if (303 === s || 304 === s) {
+                                if (s === tt || s === et) {
                                     if (e.has(r)) return n(e.get(r).texture, r.mapping); {
                                         const s = r.image;
                                         if (s && s.height > 0) {
-                                            const a = new Mn(s.height / 2);
+                                            const a = new sr(s.height / 2);
                                             return a.fromEquirectangularTexture(t, r), e.set(r, a), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                         }
                                         return null
                                     }
                                 }
                             }
                             return r
                         },
                         dispose: function() {
                             e = new WeakMap
                         }
                     }
                 }
-                Nn.physical = {
-                    uniforms: pn([Nn.standard.uniforms, {
+                xr.physical = {
+                    uniforms: Ki([xr.standard.uniforms, {
                         clearcoat: {
                             value: 0
                         },
                         clearcoatMap: {
                             value: null
                         },
                         clearcoatRoughness: {
                             value: 0
                         },
                         clearcoatRoughnessMap: {
                             value: null
                         },
                         clearcoatNormalScale: {
-                            value: new Y(1, 1)
+                            value: new De(1, 1)
                         },
                         clearcoatNormalMap: {
                             value: null
                         },
                         sheen: {
                             value: 0
                         },
                         sheenColor: {
-                            value: new rt(0)
+                            value: new Ve(0)
                         },
                         sheenColorMap: {
                             value: null
                         },
                         sheenRoughness: {
                             value: 1
                         },
@@ -21929,48 +22390,48 @@
                         transmission: {
                             value: 0
                         },
                         transmissionMap: {
                             value: null
                         },
                         transmissionSamplerSize: {
-                            value: new Y
+                            value: new De
                         },
                         transmissionSamplerMap: {
                             value: null
                         },
                         thickness: {
                             value: 0
                         },
                         thicknessMap: {
                             value: null
                         },
                         attenuationDistance: {
                             value: 0
                         },
                         attenuationColor: {
-                            value: new rt(0)
+                            value: new Ve(0)
                         },
                         specularIntensity: {
                             value: 1
                         },
                         specularIntensityMap: {
                             value: null
                         },
                         specularColor: {
-                            value: new rt(1, 1, 1)
+                            value: new Ve(1, 1, 1)
                         },
                         specularColorMap: {
                             value: null
                         }
                     }]),
-                    vertexShader: Dn.meshphysical_vert,
-                    fragmentShader: Dn.meshphysical_frag
+                    vertexShader: gr.meshphysical_vert,
+                    fragmentShader: gr.meshphysical_frag
                 };
-                class Gn extends gn {
+                class Er extends tr {
                     constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) {
                         super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                     }
                     setViewOffset(t, e, n, i, r, s) {
@@ -22004,41 +22465,43 @@
                         this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                     }
                 }
-                Gn.prototype.isOrthographicCamera = !0;
-                class Vn extends fn {
+                Er.prototype.isOrthographicCamera = !0;
+                class Tr extends $i {
                     constructor(t) {
                         super(t), this.type = "RawShaderMaterial"
                     }
                 }
-                Vn.prototype.isRawShaderMaterial = !0;
-                const kn = Math.pow(2, 8),
-                    Wn = [.125, .215, .35, .446, .526, .582],
-                    jn = 5 + Wn.length,
-                    Xn = new Gn,
+                Tr.prototype.isRawShaderMaterial = !0;
+                const Ar = 4,
+                    Rr = 8,
+                    Lr = Math.pow(2, Rr),
+                    Cr = [.125, .215, .35, .446, .526, .582],
+                    Pr = Rr - Ar + 1 + Cr.length,
+                    Dr = new Er,
                     {
-                        _lodPlanes: qn,
-                        _sizeLods: Yn,
-                        _sigmas: Zn
-                    } = ni(),
-                    Jn = new rt;
-                let Kn = null;
-                const Qn = (1 + Math.sqrt(5)) / 2,
-                    $n = 1 / Qn,
-                    ti = [new mt(1, 1, 1), new mt(-1, 1, 1), new mt(1, 1, -1), new mt(-1, 1, -1), new mt(0, Qn, $n), new mt(0, Qn, -$n), new mt($n, 0, Qn), new mt(-$n, 0, Qn), new mt(Qn, $n, 0), new mt(-Qn, $n, 0)];
-                class ei {
+                        _lodPlanes: Ir,
+                        _sizeLods: Nr,
+                        _sigmas: Or
+                    } = Vr(),
+                    Ur = new Ve;
+                let Br = null;
+                const Fr = (1 + Math.sqrt(5)) / 2,
+                    zr = 1 / Fr,
+                    Hr = [new Qe(1, 1, 1), new Qe(-1, 1, 1), new Qe(1, 1, -1), new Qe(-1, 1, -1), new Qe(0, Fr, zr), new Qe(0, Fr, -zr), new Qe(zr, 0, Fr), new Qe(-zr, 0, Fr), new Qe(Fr, zr, 0), new Qe(-Fr, zr, 0)];
+                class Gr {
                     constructor(t) {
                         this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
                             const e = new Float32Array(20),
-                                n = new mt(0, 1, 0);
-                            return new Vn({
+                                n = new Qe(0, 1, 0);
+                            return new Tr({
                                 name: "SphericalGaussianBlur",
                                 defines: {
                                     n: 20
                                 },
                                 uniforms: {
                                     envMap: {
                                         value: null
@@ -22060,149 +22523,149 @@
                                     },
                                     poleAxis: {
                                         value: n
                                     }
                                 },
                                 vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                 fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
-                                blending: 0,
+                                blending: p,
                                 depthTest: !1,
                                 depthWrite: !1
                             })
                         }(), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                     }
                     fromScene(t, e = 0, n = .1, i = 100) {
-                        Kn = this._renderer.getRenderTarget();
+                        Br = this._renderer.getRenderTarget();
                         const r = this._allocateTargets();
                         return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
                     }
                     fromEquirectangular(t, e = null) {
                         return this._fromTexture(t, e)
                     }
                     fromCubemap(t, e = null) {
                         return this._fromTexture(t, e)
                     }
                     compileCubemapShader() {
-                        null === this._cubemapShader && (this._cubemapShader = ai(), this._compileMaterial(this._cubemapShader))
+                        null === this._cubemapShader && (this._cubemapShader = Xr(), this._compileMaterial(this._cubemapShader))
                     }
                     compileEquirectangularShader() {
-                        null === this._equirectShader && (this._equirectShader = si(), this._compileMaterial(this._equirectShader))
+                        null === this._equirectShader && (this._equirectShader = jr(), this._compileMaterial(this._equirectShader))
                     }
                     dispose() {
                         this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
-                        for (let t = 0; t < qn.length; t++) qn[t].dispose()
+                        for (let t = 0; t < Ir.length; t++) Ir[t].dispose()
                     }
                     _cleanup(t) {
-                        this._renderer.setRenderTarget(Kn), t.scissorTest = !1, ri(t, 0, 0, t.width, t.height)
+                        this._renderer.setRenderTarget(Br), t.scissorTest = !1, Wr(t, 0, 0, t.width, t.height)
                     }
                     _fromTexture(t, e) {
-                        Kn = this._renderer.getRenderTarget();
+                        Br = this._renderer.getRenderTarget();
                         const n = e || this._allocateTargets(t);
                         return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
                     }
                     _allocateTargets(t) {
                         const e = {
-                                magFilter: u,
-                                minFilter: u,
+                                magFilter: ht,
+                                minFilter: ht,
                                 generateMipmaps: !1,
-                                type: v,
-                                format: y,
-                                encoding: D,
+                                type: _t,
+                                format: Et,
+                                encoding: pe,
                                 depthBuffer: !1
                             },
-                            n = ii(e);
-                        return n.depthBuffer = !t, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = ii(e)), n
+                            n = kr(e);
+                        return n.depthBuffer = !t, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = kr(e)), n
                     }
                     _compileMaterial(t) {
-                        const e = new cn(qn[0], t);
-                        this._renderer.compile(e, Xn)
+                        const e = new qi(Ir[0], t);
+                        this._renderer.compile(e, Dr)
                     }
                     _sceneToCubeUV(t, e, n, i) {
-                        const r = new vn(90, 1, e, n),
+                        const r = new er(90, 1, e, n),
                             s = [1, -1, 1, 1, 1, 1],
                             a = [1, 1, 1, -1, -1, -1],
                             o = this._renderer,
                             l = o.autoClear,
                             c = o.toneMapping;
-                        o.getClearColor(Jn), o.toneMapping = 0, o.autoClear = !1;
-                        const h = new Ce({
+                        o.getClearColor(Ur), o.toneMapping = X, o.autoClear = !1;
+                        const h = new fi({
                                 name: "PMREM.Background",
-                                side: 1,
+                                side: u,
                                 depthWrite: !1,
                                 depthTest: !1
                             }),
-                            u = new cn(new un, h);
-                        let d = !1;
-                        const p = t.background;
-                        p ? p.isColor && (h.color.copy(p), t.background = null, d = !0) : (h.color.copy(Jn), d = !0);
+                            d = new qi(new Zi, h);
+                        let p = !1;
+                        const m = t.background;
+                        m ? m.isColor && (h.color.copy(m), t.background = null, p = !0) : (h.color.copy(Ur), p = !0);
                         for (let e = 0; e < 6; e++) {
                             const n = e % 3;
-                            0 === n ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])), ri(i, n * kn, e > 2 ? kn : 0, kn, kn), o.setRenderTarget(i), d && o.render(u, r), o.render(t, r)
+                            0 === n ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])), Wr(i, n * Lr, e > 2 ? Lr : 0, Lr, Lr), o.setRenderTarget(i), p && o.render(d, r), o.render(t, r)
                         }
-                        u.geometry.dispose(), u.material.dispose(), o.toneMapping = c, o.autoClear = l, t.background = p
+                        d.geometry.dispose(), d.material.dispose(), o.toneMapping = c, o.autoClear = l, t.background = m
                     }
                     _textureToCubeUV(t, e) {
                         const n = this._renderer,
-                            i = t.mapping === r || t.mapping === s;
-                        i ? (null === this._cubemapShader && (this._cubemapShader = ai()), this._cubemapShader.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = si());
-                        const a = i ? this._cubemapShader : this._equirectShader,
-                            o = new cn(qn[0], a),
-                            l = a.uniforms;
-                        l.envMap.value = t, i || l.texelSize.value.set(1 / t.image.width, 1 / t.image.height), ri(e, 0, 0, 3 * kn, 2 * kn), n.setRenderTarget(e), n.render(o, Xn)
+                            i = t.mapping === Q || t.mapping === $;
+                        i ? (null === this._cubemapShader && (this._cubemapShader = Xr()), this._cubemapShader.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = jr());
+                        const r = i ? this._cubemapShader : this._equirectShader,
+                            s = new qi(Ir[0], r),
+                            a = r.uniforms;
+                        a.envMap.value = t, i || a.texelSize.value.set(1 / t.image.width, 1 / t.image.height), Wr(e, 0, 0, 3 * Lr, 2 * Lr), n.setRenderTarget(e), n.render(s, Dr)
                     }
                     _applyPMREM(t) {
                         const e = this._renderer,
                             n = e.autoClear;
                         e.autoClear = !1;
-                        for (let e = 1; e < jn; e++) {
-                            const n = Math.sqrt(Zn[e] * Zn[e] - Zn[e - 1] * Zn[e - 1]),
-                                i = ti[(e - 1) % ti.length];
+                        for (let e = 1; e < Pr; e++) {
+                            const n = Math.sqrt(Or[e] * Or[e] - Or[e - 1] * Or[e - 1]),
+                                i = Hr[(e - 1) % Hr.length];
                             this._blur(t, e - 1, e, n, i)
                         }
                         e.autoClear = n
                     }
                     _blur(t, e, n, i, r) {
                         const s = this._pingPongRenderTarget;
                         this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r)
                     }
                     _halfBlur(t, e, n, i, r, s, a) {
                         const o = this._renderer,
                             l = this._blurMaterial;
                         "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
-                        const c = new cn(qn[i], l),
+                        const c = new qi(Ir[i], l),
                             h = l.uniforms,
-                            u = Yn[n] - 1,
+                            u = Nr[n] - 1,
                             d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                             p = r / d,
                             m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                         m > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
                         const f = [];
                         let g = 0;
                         for (let t = 0; t < 20; ++t) {
                             const e = t / p,
                                 n = Math.exp(-e * e / 2);
                             f.push(n), 0 === t ? g += n : t < m && (g += 2 * n)
                         }
                         for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
-                        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = 8 - n;
-                        const v = Yn[i];
-                        ri(e, 3 * Math.max(0, kn - 2 * v), (0 === i ? 0 : 2 * kn) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), o.setRenderTarget(e), o.render(c, Xn)
+                        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = Rr - n;
+                        const v = Nr[i];
+                        Wr(e, 3 * Math.max(0, Lr - 2 * v), (0 === i ? 0 : 2 * Lr) + 2 * v * (i > Rr - Ar ? i - Rr + Ar : 0), 3 * v, 2 * v), o.setRenderTarget(e), o.render(c, Dr)
                     }
                 }
 
-                function ni() {
+                function Vr() {
                     const t = [],
                         e = [],
                         n = [];
-                    let i = 8;
-                    for (let r = 0; r < jn; r++) {
+                    let i = Rr;
+                    for (let r = 0; r < Pr; r++) {
                         const s = Math.pow(2, i);
                         e.push(s);
                         let a = 1 / s;
-                        r > 4 ? a = Wn[r - 8 + 4 - 1] : 0 === r && (a = 0), n.push(a);
+                        r > Rr - Ar ? a = Cr[r - Rr + Ar - 1] : 0 === r && (a = 0), n.push(a);
                         const o = 1 / (s - 1),
                             l = -o / 2,
                             c = 1 + o / 2,
                             h = [l, l, c, l, c, c, l, l, c, c, l, c],
                             u = 6,
                             d = 6,
                             p = 3,
@@ -22215,118 +22678,118 @@
                             const e = t % 3 * 2 / 3 - 1,
                                 n = t > 2 ? 0 : -1,
                                 i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                             g.set(i, p * d * t), v.set(h, m * d * t);
                             const r = [t, t, t, t, t, t];
                             x.set(r, f * d * t)
                         }
-                        const y = new We;
-                        y.setAttribute("position", new Ie(g, p)), y.setAttribute("uv", new Ie(v, m)), y.setAttribute("faceIndex", new Ie(x, f)), t.push(y), i > 4 && i--
+                        const y = new Li;
+                        y.setAttribute("position", new xi(g, p)), y.setAttribute("uv", new xi(v, m)), y.setAttribute("faceIndex", new xi(x, f)), t.push(y), i > Ar && i--
                     }
                     return {
                         _lodPlanes: t,
                         _sizeLods: e,
                         _sigmas: n
                     }
                 }
 
-                function ii(t) {
-                    const e = new ut(3 * kn, 3 * kn, t);
-                    return e.texture.mapping = a, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
+                function kr(t) {
+                    const e = new Ze(3 * Lr, 3 * Lr, t);
+                    return e.texture.mapping = nt, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
                 }
 
-                function ri(t, e, n, i, r) {
+                function Wr(t, e, n, i, r) {
                     t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
                 }
 
-                function si() {
-                    const t = new Y(1, 1);
-                    return new Vn({
+                function jr() {
+                    const t = new De(1, 1);
+                    return new Tr({
                         name: "EquirectangularToCubeUV",
                         uniforms: {
                             envMap: {
                                 value: null
                             },
                             texelSize: {
                                 value: t
                             }
                         },
                         vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                         fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",
-                        blending: 0,
+                        blending: p,
                         depthTest: !1,
                         depthWrite: !1
                     })
                 }
 
-                function ai() {
-                    return new Vn({
+                function Xr() {
+                    return new Tr({
                         name: "CubemapToCubeUV",
                         uniforms: {
                             envMap: {
                                 value: null
                             },
                             flipEnvMap: {
                                 value: -1
                             }
                         },
                         vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                         fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
-                        blending: 0,
+                        blending: p,
                         depthTest: !1,
                         depthWrite: !1
                     })
                 }
 
-                function oi(t) {
+                function qr(t) {
                     let e = new WeakMap,
                         n = null;
 
                     function i(t) {
                         const n = t.target;
                         n.removeEventListener("dispose", i);
                         const r = e.get(n);
                         void 0 !== r && (e.delete(n), r.dispose())
                     }
                     return {
-                        get: function(a) {
-                            if (a && a.isTexture) {
-                                const o = a.mapping,
-                                    l = 303 === o || 304 === o,
-                                    c = o === r || o === s;
-                                if (l || c) {
-                                    if (a.isRenderTargetTexture && !0 === a.needsPMREMUpdate) {
-                                        a.needsPMREMUpdate = !1;
-                                        let i = e.get(a);
-                                        return null === n && (n = new ei(t)), i = l ? n.fromEquirectangular(a, i) : n.fromCubemap(a, i), e.set(a, i), i.texture
-                                    }
-                                    if (e.has(a)) return e.get(a).texture; {
-                                        const r = a.image;
-                                        if (l && r && r.height > 0 || c && r && function(t) {
+                        get: function(r) {
+                            if (r && r.isTexture) {
+                                const s = r.mapping,
+                                    a = s === tt || s === et,
+                                    o = s === Q || s === $;
+                                if (a || o) {
+                                    if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
+                                        r.needsPMREMUpdate = !1;
+                                        let i = e.get(r);
+                                        return null === n && (n = new Gr(t)), i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture
+                                    }
+                                    if (e.has(r)) return e.get(r).texture; {
+                                        const s = r.image;
+                                        if (a && s && s.height > 0 || o && s && function(t) {
                                                 let e = 0;
                                                 for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                                 return 6 === e
-                                            }(r)) {
-                                            null === n && (n = new ei(t));
-                                            const r = l ? n.fromEquirectangular(a) : n.fromCubemap(a);
-                                            return e.set(a, r), a.addEventListener("dispose", i), r.texture
+                                            }(s)) {
+                                            null === n && (n = new Gr(t));
+                                            const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
+                                            return e.set(r, s), r.addEventListener("dispose", i), s.texture
                                         }
                                         return null
                                     }
                                 }
                             }
-                            return a
+                            return r
                         },
                         dispose: function() {
                             e = new WeakMap, null !== n && (n.dispose(), n = null)
                         }
                     }
                 }
 
-                function li(t) {
+                function Yr(t) {
                     const e = {};
 
                     function n(n) {
                         if (void 0 !== e[n]) return e[n];
                         let i;
                         switch (n) {
                             case "WEBGL_depth_texture":
@@ -22356,15 +22819,15 @@
                         get: function(t) {
                             const e = n(t);
                             return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                         }
                     }
                 }
 
-                function ci(t, e, n, i) {
+                function Zr(t, e, n, i) {
                     const r = {},
                         s = new WeakMap;
 
                     function a(t) {
                         const o = t.target;
                         null !== o.index && e.remove(o.index);
                         for (const t in o.attributes) e.remove(o.attributes[t]);
@@ -22393,15 +22856,15 @@
                             for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                                 const t = e + 0,
                                     i = e + 1,
                                     r = e + 2;
                                 n.push(t, i, i, r, r, t)
                             }
                         }
-                        const o = new(J(n) ? Oe : Ne)(n, 1);
+                        const o = new(Ne(n) ? _i : yi)(n, 1);
                         o.version = a;
                         const l = s.get(t);
                         l && e.remove(l), s.set(t, o)
                     }
                     return {
                         get: function(t, e) {
                             return !0 === r[e.id] || (e.addEventListener("dispose", a), r[e.id] = !0, n.memory.geometries++), e
@@ -22422,15 +22885,15 @@
                                 null !== n && e.version < n.version && o(t)
                             } else o(t);
                             return s.get(t)
                         }
                     }
                 }
 
-                function hi(t, e, n, i) {
+                function Jr(t, e, n, i) {
                     const r = i.isWebGL2;
                     let s, a, o;
                     this.setMode = function(t) {
                         s = t
                     }, this.setIndex = function(t) {
                         a = t.type, o = t.bytesPerElement
                     }, this.render = function(e, i) {
@@ -22440,15 +22903,15 @@
                         let h, u;
                         if (r) h = t, u = "drawElementsInstanced";
                         else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                         h[u](s, l, a, i * o, c), n.update(l, s, c)
                     }
                 }
 
-                function ui(t) {
+                function Kr(t) {
                     const e = {
                         frame: 0,
                         calls: 0,
                         triangles: 0,
                         points: 0,
                         lines: 0
                     };
@@ -22482,121 +22945,121 @@
                                     break;
                                 default:
                                     console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                             }
                         }
                     }
                 }
-                class di extends lt {
+                class Qr extends Xe {
                     constructor(t = null, e = 1, n = 1, i = 1) {
                         super(null), this.image = {
                             data: t,
                             width: e,
                             height: n,
                             depth: i
-                        }, this.magFilter = h, this.minFilter = h, this.wrapR = l, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
+                        }, this.magFilter = ot, this.minFilter = ot, this.wrapR = st, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }
 
-                function pi(t, e) {
+                function $r(t, e) {
                     return t[0] - e[0]
                 }
 
-                function mi(t, e) {
+                function ts(t, e) {
                     return Math.abs(e[1]) - Math.abs(t[1])
                 }
 
-                function fi(t, e) {
+                function es(t, e) {
                     let n = 1;
                     const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
                     i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), t.divideScalar(n)
                 }
 
-                function gi(t, e, n) {
+                function ns(t, e, n) {
                     const i = {},
                         r = new Float32Array(8),
                         s = new WeakMap,
-                        a = new mt,
+                        a = new Qe,
                         o = [];
                     for (let t = 0; t < 8; t++) o[t] = [t, 0];
                     return {
                         update: function(l, c, h, u) {
                             const d = l.morphTargetInfluences;
                             if (!0 === e.isWebGL2) {
                                 const p = c.morphAttributes.position.length;
                                 let m = s.get(c);
                                 if (void 0 === m || m.count !== p) {
                                     void 0 !== m && m.texture.dispose();
-                                    const x = void 0 !== c.morphAttributes.normal,
-                                        _ = c.morphAttributes.position,
-                                        M = c.morphAttributes.normal || [],
-                                        b = !0 === x ? 2 : 1;
-                                    let w = c.attributes.position.count * b,
-                                        S = 1;
-                                    w > e.maxTextureSize && (S = Math.ceil(w / e.maxTextureSize), w = e.maxTextureSize);
-                                    const E = new Float32Array(w * S * 4 * p),
-                                        T = new di(E, w, S, p);
-                                    T.format = y, T.type = g, T.needsUpdate = !0;
-                                    const A = 4 * b;
-                                    for (let L = 0; L < p; L++) {
-                                        const C = _[L],
-                                            P = M[L],
-                                            D = w * S * 4 * L;
-                                        for (let I = 0; I < C.count; I++) {
-                                            a.fromBufferAttribute(C, I), !0 === C.normalized && fi(a, C);
-                                            const N = I * A;
-                                            E[D + N + 0] = a.x, E[D + N + 1] = a.y, E[D + N + 2] = a.z, E[D + N + 3] = 0, !0 === x && (a.fromBufferAttribute(P, I), !0 === P.normalized && fi(a, P), E[D + N + 4] = a.x, E[D + N + 5] = a.y, E[D + N + 6] = a.z, E[D + N + 7] = 0)
+                                    const v = void 0 !== c.morphAttributes.normal,
+                                        x = c.morphAttributes.position,
+                                        y = c.morphAttributes.normal || [],
+                                        _ = !0 === v ? 2 : 1;
+                                    let M = c.attributes.position.count * _,
+                                        b = 1;
+                                    M > e.maxTextureSize && (b = Math.ceil(M / e.maxTextureSize), M = e.maxTextureSize);
+                                    const w = new Float32Array(M * b * 4 * p),
+                                        S = new Qr(w, M, b, p);
+                                    S.format = Et, S.type = yt, S.needsUpdate = !0;
+                                    const E = 4 * _;
+                                    for (let A = 0; A < p; A++) {
+                                        const R = x[A],
+                                            L = y[A],
+                                            C = M * b * 4 * A;
+                                        for (let P = 0; P < R.count; P++) {
+                                            a.fromBufferAttribute(R, P), !0 === R.normalized && es(a, R);
+                                            const D = P * E;
+                                            w[C + D + 0] = a.x, w[C + D + 1] = a.y, w[C + D + 2] = a.z, w[C + D + 3] = 0, !0 === v && (a.fromBufferAttribute(L, P), !0 === L.normalized && es(a, L), w[C + D + 4] = a.x, w[C + D + 5] = a.y, w[C + D + 6] = a.z, w[C + D + 7] = 0)
                                         }
                                     }
 
-                                    function R() {
-                                        T.dispose(), s.delete(c), c.removeEventListener("dispose", R)
+                                    function T() {
+                                        S.dispose(), s.delete(c), c.removeEventListener("dispose", T)
                                     }
                                     m = {
                                         count: p,
-                                        texture: T,
-                                        size: new Y(w, S)
-                                    }, s.set(c, m), c.addEventListener("dispose", R)
+                                        texture: S,
+                                        size: new De(M, b)
+                                    }, s.set(c, m), c.addEventListener("dispose", T)
                                 }
                                 let f = 0;
-                                for (let O = 0; O < d.length; O++) f += d[O];
-                                const v = c.morphTargetsRelative ? 1 : 1 - f;
-                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", v), u.getUniforms().setValue(t, "morphTargetInfluences", d), u.getUniforms().setValue(t, "morphTargetsTexture", m.texture, n), u.getUniforms().setValue(t, "morphTargetsTextureSize", m.size)
+                                for (let I = 0; I < d.length; I++) f += d[I];
+                                const g = c.morphTargetsRelative ? 1 : 1 - f;
+                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", g), u.getUniforms().setValue(t, "morphTargetInfluences", d), u.getUniforms().setValue(t, "morphTargetsTexture", m.texture, n), u.getUniforms().setValue(t, "morphTargetsTextureSize", m.size)
                             } else {
-                                const U = void 0 === d ? 0 : d.length;
-                                let B = i[c.id];
-                                if (void 0 === B || B.length !== U) {
-                                    B = [];
-                                    for (let V = 0; V < U; V++) B[V] = [V, 0];
-                                    i[c.id] = B
+                                const N = void 0 === d ? 0 : d.length;
+                                let O = i[c.id];
+                                if (void 0 === O || O.length !== N) {
+                                    O = [];
+                                    for (let H = 0; H < N; H++) O[H] = [H, 0];
+                                    i[c.id] = O
                                 }
-                                for (let k = 0; k < U; k++) {
-                                    const W = B[k];
-                                    W[0] = k, W[1] = d[k]
+                                for (let G = 0; G < N; G++) {
+                                    const V = O[G];
+                                    V[0] = G, V[1] = d[G]
                                 }
-                                B.sort(mi);
-                                for (let j = 0; j < 8; j++) j < U && B[j][1] ? (o[j][0] = B[j][0], o[j][1] = B[j][1]) : (o[j][0] = Number.MAX_SAFE_INTEGER, o[j][1] = 0);
-                                o.sort(pi);
-                                const F = c.morphAttributes.position,
-                                    z = c.morphAttributes.normal;
-                                let H = 0;
-                                for (let X = 0; X < 8; X++) {
-                                    const q = o[X],
-                                        Z = q[0],
-                                        J = q[1];
-                                    Z !== Number.MAX_SAFE_INTEGER && J ? (F && c.getAttribute("morphTarget" + X) !== F[Z] && c.setAttribute("morphTarget" + X, F[Z]), z && c.getAttribute("morphNormal" + X) !== z[Z] && c.setAttribute("morphNormal" + X, z[Z]), r[X] = J, H += J) : (F && !0 === c.hasAttribute("morphTarget" + X) && c.deleteAttribute("morphTarget" + X), z && !0 === c.hasAttribute("morphNormal" + X) && c.deleteAttribute("morphNormal" + X), r[X] = 0)
+                                O.sort(ts);
+                                for (let k = 0; k < 8; k++) k < N && O[k][1] ? (o[k][0] = O[k][0], o[k][1] = O[k][1]) : (o[k][0] = Number.MAX_SAFE_INTEGER, o[k][1] = 0);
+                                o.sort($r);
+                                const U = c.morphAttributes.position,
+                                    B = c.morphAttributes.normal;
+                                let F = 0;
+                                for (let W = 0; W < 8; W++) {
+                                    const j = o[W],
+                                        X = j[0],
+                                        q = j[1];
+                                    X !== Number.MAX_SAFE_INTEGER && q ? (U && c.getAttribute("morphTarget" + W) !== U[X] && c.setAttribute("morphTarget" + W, U[X]), B && c.getAttribute("morphNormal" + W) !== B[X] && c.setAttribute("morphNormal" + W, B[X]), r[W] = q, F += q) : (U && !0 === c.hasAttribute("morphTarget" + W) && c.deleteAttribute("morphTarget" + W), B && !0 === c.hasAttribute("morphNormal" + W) && c.deleteAttribute("morphNormal" + W), r[W] = 0)
                                 }
-                                const G = c.morphTargetsRelative ? 1 : 1 - H;
-                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", G), u.getUniforms().setValue(t, "morphTargetInfluences", r)
+                                const z = c.morphTargetsRelative ? 1 : 1 - F;
+                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", z), u.getUniforms().setValue(t, "morphTargetInfluences", r)
                             }
                         }
                     }
                 }
 
-                function vi(t, e, n, i) {
+                function is(t, e, n, i) {
                     let r = new WeakMap;
 
                     function s(t) {
                         const e = t.target;
                         e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                     }
                     return {
@@ -22607,670 +23070,670 @@
                             return r.get(l) !== a && (e.update(l), r.set(l, a)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
                         },
                         dispose: function() {
                             r = new WeakMap
                         }
                     }
                 }
-                di.prototype.isDataTexture2DArray = !0;
-                class xi extends lt {
+                Qr.prototype.isDataTexture2DArray = !0;
+                class rs extends Xe {
                     constructor(t = null, e = 1, n = 1, i = 1) {
                         super(null), this.image = {
                             data: t,
                             width: e,
                             height: n,
                             depth: i
-                        }, this.magFilter = h, this.minFilter = h, this.wrapR = l, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
+                        }, this.magFilter = ot, this.minFilter = ot, this.wrapR = st, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }
-                xi.prototype.isDataTexture3D = !0;
-                const yi = new lt,
-                    _i = new di,
-                    Mi = new xi,
-                    bi = new _n,
-                    wi = [],
-                    Si = [],
-                    Ei = new Float32Array(16),
-                    Ti = new Float32Array(9),
-                    Ai = new Float32Array(4);
+                rs.prototype.isDataTexture3D = !0;
+                const ss = new Xe,
+                    as = new Qr,
+                    os = new rs,
+                    ls = new rr,
+                    cs = [],
+                    hs = [],
+                    us = new Float32Array(16),
+                    ds = new Float32Array(9),
+                    ps = new Float32Array(4);
 
-                function Ri(t, e, n) {
+                function ms(t, e, n) {
                     const i = t[0];
                     if (i <= 0 || i > 0) return t;
                     const r = e * n;
-                    let s = wi[r];
-                    if (void 0 === s && (s = new Float32Array(r), wi[r] = s), 0 !== e) {
+                    let s = cs[r];
+                    if (void 0 === s && (s = new Float32Array(r), cs[r] = s), 0 !== e) {
                         i.toArray(s, 0);
                         for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r)
                     }
                     return s
                 }
 
-                function Li(t, e) {
+                function fs(t, e) {
                     if (t.length !== e.length) return !1;
                     for (let n = 0, i = t.length; n < i; n++)
                         if (t[n] !== e[n]) return !1;
                     return !0
                 }
 
-                function Ci(t, e) {
+                function gs(t, e) {
                     for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
                 }
 
-                function Pi(t, e) {
-                    let n = Si[e];
-                    void 0 === n && (n = new Int32Array(e), Si[e] = n);
+                function vs(t, e) {
+                    let n = hs[e];
+                    void 0 === n && (n = new Int32Array(e), hs[e] = n);
                     for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                     return n
                 }
 
-                function Di(t, e) {
+                function xs(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
                 }
 
-                function Ii(t, e) {
+                function ys(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                     else {
-                        if (Li(n, e)) return;
-                        t.uniform2fv(this.addr, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniform2fv(this.addr, e), gs(n, e)
                     }
                 }
 
-                function Ni(t, e) {
+                function _s(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                     else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                     else {
-                        if (Li(n, e)) return;
-                        t.uniform3fv(this.addr, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniform3fv(this.addr, e), gs(n, e)
                     }
                 }
 
-                function Oi(t, e) {
+                function Ms(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                     else {
-                        if (Li(n, e)) return;
-                        t.uniform4fv(this.addr, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniform4fv(this.addr, e), gs(n, e)
                     }
                 }
 
-                function Ui(t, e) {
+                function bs(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (Li(n, e)) return;
-                        t.uniformMatrix2fv(this.addr, !1, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniformMatrix2fv(this.addr, !1, e), gs(n, e)
                     } else {
-                        if (Li(n, i)) return;
-                        Ai.set(i), t.uniformMatrix2fv(this.addr, !1, Ai), Ci(n, i)
+                        if (fs(n, i)) return;
+                        ps.set(i), t.uniformMatrix2fv(this.addr, !1, ps), gs(n, i)
                     }
                 }
 
-                function Bi(t, e) {
+                function ws(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (Li(n, e)) return;
-                        t.uniformMatrix3fv(this.addr, !1, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniformMatrix3fv(this.addr, !1, e), gs(n, e)
                     } else {
-                        if (Li(n, i)) return;
-                        Ti.set(i), t.uniformMatrix3fv(this.addr, !1, Ti), Ci(n, i)
+                        if (fs(n, i)) return;
+                        ds.set(i), t.uniformMatrix3fv(this.addr, !1, ds), gs(n, i)
                     }
                 }
 
-                function Fi(t, e) {
+                function Ss(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (Li(n, e)) return;
-                        t.uniformMatrix4fv(this.addr, !1, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniformMatrix4fv(this.addr, !1, e), gs(n, e)
                     } else {
-                        if (Li(n, i)) return;
-                        Ei.set(i), t.uniformMatrix4fv(this.addr, !1, Ei), Ci(n, i)
+                        if (fs(n, i)) return;
+                        us.set(i), t.uniformMatrix4fv(this.addr, !1, us), gs(n, i)
                     }
                 }
 
-                function zi(t, e) {
+                function Es(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
                 }
 
-                function Hi(t, e) {
+                function Ts(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform2iv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform2iv(this.addr, e), gs(n, e))
                 }
 
-                function Gi(t, e) {
+                function As(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform3iv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform3iv(this.addr, e), gs(n, e))
                 }
 
-                function Vi(t, e) {
+                function Rs(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform4iv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform4iv(this.addr, e), gs(n, e))
                 }
 
-                function ki(t, e) {
+                function Ls(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
                 }
 
-                function Wi(t, e) {
+                function Cs(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform2uiv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform2uiv(this.addr, e), gs(n, e))
                 }
 
-                function ji(t, e) {
+                function Ps(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform3uiv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform3uiv(this.addr, e), gs(n, e))
                 }
 
-                function Xi(t, e) {
+                function Ds(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform4uiv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform4uiv(this.addr, e), gs(n, e))
                 }
 
-                function qi(t, e, n) {
+                function Is(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || yi, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || ss, r)
                 }
 
-                function Yi(t, e, n) {
+                function Ns(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Mi, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || os, r)
                 }
 
-                function Zi(t, e, n) {
+                function Os(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || bi, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || ls, r)
                 }
 
-                function Ji(t, e, n) {
+                function Us(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || _i, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || as, r)
                 }
 
-                function Ki(t, e) {
+                function Bs(t, e) {
                     t.uniform1fv(this.addr, e)
                 }
 
-                function Qi(t, e) {
-                    const n = Ri(e, this.size, 2);
+                function Fs(t, e) {
+                    const n = ms(e, this.size, 2);
                     t.uniform2fv(this.addr, n)
                 }
 
-                function $i(t, e) {
-                    const n = Ri(e, this.size, 3);
+                function zs(t, e) {
+                    const n = ms(e, this.size, 3);
                     t.uniform3fv(this.addr, n)
                 }
 
-                function tr(t, e) {
-                    const n = Ri(e, this.size, 4);
+                function Hs(t, e) {
+                    const n = ms(e, this.size, 4);
                     t.uniform4fv(this.addr, n)
                 }
 
-                function er(t, e) {
-                    const n = Ri(e, this.size, 4);
+                function Gs(t, e) {
+                    const n = ms(e, this.size, 4);
                     t.uniformMatrix2fv(this.addr, !1, n)
                 }
 
-                function nr(t, e) {
-                    const n = Ri(e, this.size, 9);
+                function Vs(t, e) {
+                    const n = ms(e, this.size, 9);
                     t.uniformMatrix3fv(this.addr, !1, n)
                 }
 
-                function ir(t, e) {
-                    const n = Ri(e, this.size, 16);
+                function ks(t, e) {
+                    const n = ms(e, this.size, 16);
                     t.uniformMatrix4fv(this.addr, !1, n)
                 }
 
-                function rr(t, e) {
+                function Ws(t, e) {
                     t.uniform1iv(this.addr, e)
                 }
 
-                function sr(t, e) {
+                function js(t, e) {
                     t.uniform2iv(this.addr, e)
                 }
 
-                function ar(t, e) {
+                function Xs(t, e) {
                     t.uniform3iv(this.addr, e)
                 }
 
-                function or(t, e) {
+                function qs(t, e) {
                     t.uniform4iv(this.addr, e)
                 }
 
-                function lr(t, e) {
+                function Ys(t, e) {
                     t.uniform1uiv(this.addr, e)
                 }
 
-                function cr(t, e) {
+                function Zs(t, e) {
                     t.uniform2uiv(this.addr, e)
                 }
 
-                function hr(t, e) {
+                function Js(t, e) {
                     t.uniform3uiv(this.addr, e)
                 }
 
-                function ur(t, e) {
+                function Ks(t, e) {
                     t.uniform4uiv(this.addr, e)
                 }
 
-                function dr(t, e, n) {
+                function Qs(t, e, n) {
                     const i = e.length,
-                        r = Pi(n, i);
+                        r = vs(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || yi, r[t])
+                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || ss, r[t])
                 }
 
-                function pr(t, e, n) {
+                function $s(t, e, n) {
                     const i = e.length,
-                        r = Pi(n, i);
+                        r = vs(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || Mi, r[t])
+                    for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || os, r[t])
                 }
 
-                function mr(t, e, n) {
+                function ta(t, e, n) {
                     const i = e.length,
-                        r = Pi(n, i);
+                        r = vs(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || bi, r[t])
+                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || ls, r[t])
                 }
 
-                function fr(t, e, n) {
+                function ea(t, e, n) {
                     const i = e.length,
-                        r = Pi(n, i);
+                        r = vs(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || _i, r[t])
+                    for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || as, r[t])
                 }
 
-                function gr(t, e, n) {
+                function na(t, e, n) {
                     this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                         switch (t) {
                             case 5126:
-                                return Di;
+                                return xs;
                             case 35664:
-                                return Ii;
+                                return ys;
                             case 35665:
-                                return Ni;
+                                return _s;
                             case 35666:
-                                return Oi;
+                                return Ms;
                             case 35674:
-                                return Ui;
+                                return bs;
                             case 35675:
-                                return Bi;
+                                return ws;
                             case 35676:
-                                return Fi;
+                                return Ss;
                             case 5124:
                             case 35670:
-                                return zi;
+                                return Es;
                             case 35667:
                             case 35671:
-                                return Hi;
+                                return Ts;
                             case 35668:
                             case 35672:
-                                return Gi;
+                                return As;
                             case 35669:
                             case 35673:
-                                return Vi;
+                                return Rs;
                             case 5125:
-                                return ki;
+                                return Ls;
                             case 36294:
-                                return Wi;
+                                return Cs;
                             case 36295:
-                                return ji;
+                                return Ps;
                             case 36296:
-                                return Xi;
+                                return Ds;
                             case 35678:
                             case 36198:
                             case 36298:
                             case 36306:
                             case 35682:
-                                return qi;
+                                return Is;
                             case 35679:
                             case 36299:
                             case 36307:
-                                return Yi;
+                                return Ns;
                             case 35680:
                             case 36300:
                             case 36308:
                             case 36293:
-                                return Zi;
+                                return Os;
                             case 36289:
                             case 36303:
                             case 36311:
                             case 36292:
-                                return Ji
+                                return Us
                         }
                     }(e.type)
                 }
 
-                function vr(t, e, n) {
+                function ia(t, e, n) {
                     this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                         switch (t) {
                             case 5126:
-                                return Ki;
+                                return Bs;
                             case 35664:
-                                return Qi;
+                                return Fs;
                             case 35665:
-                                return $i;
+                                return zs;
                             case 35666:
-                                return tr;
+                                return Hs;
                             case 35674:
-                                return er;
+                                return Gs;
                             case 35675:
-                                return nr;
+                                return Vs;
                             case 35676:
-                                return ir;
+                                return ks;
                             case 5124:
                             case 35670:
-                                return rr;
+                                return Ws;
                             case 35667:
                             case 35671:
-                                return sr;
+                                return js;
                             case 35668:
                             case 35672:
-                                return ar;
+                                return Xs;
                             case 35669:
                             case 35673:
-                                return or;
+                                return qs;
                             case 5125:
-                                return lr;
+                                return Ys;
                             case 36294:
-                                return cr;
+                                return Zs;
                             case 36295:
-                                return hr;
+                                return Js;
                             case 36296:
-                                return ur;
+                                return Ks;
                             case 35678:
                             case 36198:
                             case 36298:
                             case 36306:
                             case 35682:
-                                return dr;
+                                return Qs;
                             case 35679:
                             case 36299:
                             case 36307:
-                                return pr;
+                                return $s;
                             case 35680:
                             case 36300:
                             case 36308:
                             case 36293:
-                                return mr;
+                                return ta;
                             case 36289:
                             case 36303:
                             case 36311:
                             case 36292:
-                                return fr
+                                return ea
                         }
                     }(e.type)
                 }
 
-                function xr(t) {
+                function ra(t) {
                     this.id = t, this.seq = [], this.map = {}
                 }
-                vr.prototype.updateCache = function(t) {
+                ia.prototype.updateCache = function(t) {
                     const e = this.cache;
-                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Ci(e, t)
-                }, xr.prototype.setValue = function(t, e, n) {
+                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), gs(e, t)
+                }, ra.prototype.setValue = function(t, e, n) {
                     const i = this.seq;
                     for (let r = 0, s = i.length; r !== s; ++r) {
                         const s = i[r];
                         s.setValue(t, e[s.id], n)
                     }
                 };
-                const yr = /(\w+)(\])?(\[|\.)?/g;
+                const sa = /(\w+)(\])?(\[|\.)?/g;
 
-                function _r(t, e) {
+                function aa(t, e) {
                     t.seq.push(e), t.map[e.id] = e
                 }
 
-                function Mr(t, e, n) {
+                function oa(t, e, n) {
                     const i = t.name,
                         r = i.length;
-                    for (yr.lastIndex = 0;;) {
-                        const s = yr.exec(i),
-                            a = yr.lastIndex;
+                    for (sa.lastIndex = 0;;) {
+                        const s = sa.exec(i),
+                            a = sa.lastIndex;
                         let o = s[1];
                         const l = "]" === s[2],
                             c = s[3];
                         if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === r) {
-                            _r(n, void 0 === c ? new gr(o, t, e) : new vr(o, t, e));
+                            aa(n, void 0 === c ? new na(o, t, e) : new ia(o, t, e));
                             break
                         } {
                             let t = n.map[o];
-                            void 0 === t && (t = new xr(o), _r(n, t)), n = t
+                            void 0 === t && (t = new ra(o), aa(n, t)), n = t
                         }
                     }
                 }
 
-                function br(t, e) {
+                function la(t, e) {
                     this.seq = [], this.map = {};
                     const n = t.getProgramParameter(e, 35718);
                     for (let i = 0; i < n; ++i) {
                         const n = t.getActiveUniform(e, i);
-                        Mr(n, t.getUniformLocation(e, n.name), this)
+                        oa(n, t.getUniformLocation(e, n.name), this)
                     }
                 }
 
-                function wr(t, e, n) {
+                function ca(t, e, n) {
                     const i = t.createShader(e);
                     return t.shaderSource(i, n), t.compileShader(i), i
                 }
-                br.prototype.setValue = function(t, e, n, i) {
+                la.prototype.setValue = function(t, e, n, i) {
                     const r = this.map[e];
                     void 0 !== r && r.setValue(t, n, i)
-                }, br.prototype.setOptional = function(t, e, n) {
+                }, la.prototype.setOptional = function(t, e, n) {
                     const i = e[n];
                     void 0 !== i && this.setValue(t, n, i)
-                }, br.upload = function(t, e, n, i) {
+                }, la.upload = function(t, e, n, i) {
                     for (let r = 0, s = e.length; r !== s; ++r) {
                         const s = e[r],
                             a = n[s.id];
                         !1 !== a.needsUpdate && s.setValue(t, a.value, i)
                     }
-                }, br.seqWithValue = function(t, e) {
+                }, la.seqWithValue = function(t, e) {
                     const n = [];
                     for (let i = 0, r = t.length; i !== r; ++i) {
                         const r = t[i];
                         r.id in e && n.push(r)
                     }
                     return n
                 };
-                let Sr = 0;
+                let ha = 0;
 
-                function Er(t, e, n) {
+                function ua(t, e, n) {
                     const i = t.getShaderParameter(e, 35713),
                         r = t.getShaderInfoLog(e).trim();
                     return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function(t) {
                         const e = t.split("\n");
                         for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                         return e.join("\n")
                     }(t.getShaderSource(e))
                 }
 
-                function Tr(t, e) {
+                function da(t, e) {
                     const n = function(t) {
                         switch (t) {
-                            case D:
+                            case pe:
                                 return ["Linear", "( value )"];
-                            case I:
+                            case me:
                                 return ["sRGB", "( value )"];
                             default:
                                 return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                         }
                     }(e);
                     return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                 }
 
-                function Ar(t, e) {
+                function pa(t, e) {
                     let n;
                     switch (e) {
-                        case 1:
+                        case q:
                             n = "Linear";
                             break;
-                        case 2:
+                        case Y:
                             n = "Reinhard";
                             break;
-                        case 3:
+                        case Z:
                             n = "OptimizedCineon";
                             break;
-                        case 4:
+                        case J:
                             n = "ACESFilmic";
                             break;
-                        case 5:
+                        case K:
                             n = "Custom";
                             break;
                         default:
                             console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                     }
                     return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                 }
 
-                function Rr(t) {
+                function ma(t) {
                     return "" !== t
                 }
 
-                function Lr(t, e) {
+                function fa(t, e) {
                     return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
                 }
 
-                function Cr(t, e) {
+                function ga(t, e) {
                     return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
                 }
-                const Pr = /^[ \t]*#include +<([\w\d./]+)>/gm;
+                const va = /^[ \t]*#include +<([\w\d./]+)>/gm;
 
-                function Dr(t) {
-                    return t.replace(Pr, Ir)
+                function xa(t) {
+                    return t.replace(va, ya)
                 }
 
-                function Ir(t, e) {
-                    const n = Dn[e];
+                function ya(t, e) {
+                    const n = gr[e];
                     if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
-                    return Dr(n)
+                    return xa(n)
                 }
-                const Nr = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
-                    Or = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
+                const _a = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
+                    Ma = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
 
-                function Ur(t) {
-                    return t.replace(Or, Fr).replace(Nr, Br)
+                function ba(t) {
+                    return t.replace(Ma, Sa).replace(_a, wa)
                 }
 
-                function Br(t, e, n, i) {
-                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Fr(0, e, n, i)
+                function wa(t, e, n, i) {
+                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Sa(0, e, n, i)
                 }
 
-                function Fr(t, e, n, i) {
+                function Sa(t, e, n, i) {
                     let r = "";
                     for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
                     return r
                 }
 
-                function zr(t) {
+                function Ea(t) {
                     let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                     return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
                 }
 
-                function Hr(t, e, n, i) {
-                    const o = t.getContext(),
-                        l = n.defines;
-                    let c = n.vertexShader,
+                function Ta(t, e, n, i) {
+                    const r = t.getContext(),
+                        s = n.defines;
+                    let a = n.vertexShader,
                         h = n.fragmentShader;
                     const u = function(t) {
                             let e = "SHADOWMAP_TYPE_BASIC";
-                            return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
+                            return t.shadowMapType === o ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === l ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === c && (e = "SHADOWMAP_TYPE_VSM"), e
                         }(n),
                         d = function(t) {
                             let e = "ENVMAP_TYPE_CUBE";
                             if (t.envMap) switch (t.envMapMode) {
-                                case r:
-                                case s:
+                                case Q:
+                                case $:
                                     e = "ENVMAP_TYPE_CUBE";
                                     break;
-                                case a:
-                                case 307:
+                                case nt:
+                                case it:
                                     e = "ENVMAP_TYPE_CUBE_UV"
                             }
                             return e
                         }(n),
                         p = function(t) {
                             let e = "ENVMAP_MODE_REFLECTION";
                             if (t.envMap) switch (t.envMapMode) {
-                                case s:
-                                case 307:
+                                case $:
+                                case it:
                                     e = "ENVMAP_MODE_REFRACTION"
                             }
                             return e
                         }(n),
                         m = function(t) {
                             let e = "ENVMAP_BLENDING_NONE";
                             if (t.envMap) switch (t.combine) {
-                                case 0:
+                                case k:
                                     e = "ENVMAP_BLENDING_MULTIPLY";
                                     break;
-                                case 1:
+                                case W:
                                     e = "ENVMAP_BLENDING_MIX";
                                     break;
-                                case 2:
+                                case j:
                                     e = "ENVMAP_BLENDING_ADD"
                             }
                             return e
                         }(n),
                         f = n.isWebGL2 ? "" : function(t) {
-                            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Rr).join("\n")
+                            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ma).join("\n")
                         }(n),
                         g = function(t) {
                             const e = [];
                             for (const n in t) {
                                 const i = t[n];
                                 !1 !== i && e.push("#define " + n + " " + i)
                             }
                             return e.join("\n")
-                        }(l),
-                        v = o.createProgram();
+                        }(s),
+                        v = r.createProgram();
                     let x, y, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
-                    n.isRawShaderMaterial ? (x = [g].filter(Rr).join("\n"), x.length > 0 && (x += "\n"), y = [f, g].filter(Rr).join("\n"), y.length > 0 && (y += "\n")) : (x = [zr(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Rr).join("\n"), y = [f, zr(n), "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Dn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Ar("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.alphaWrite ? "" : "#define OPAQUE", Dn.encodings_pars_fragment, Tr("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Rr).join("\n")), c = Dr(c), c = Lr(c, n), c = Cr(c, n), h = Dr(h), h = Lr(h, n), h = Cr(h, n), c = Ur(c), h = Ur(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, y = ["#define varying in", n.glslVersion === B ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === B ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
+                    n.isRawShaderMaterial ? (x = [g].filter(ma).join("\n"), x.length > 0 && (x += "\n"), y = [f, g].filter(ma).join("\n"), y.length > 0 && (y += "\n")) : (x = [Ea(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ma).join("\n"), y = [f, Ea(n), "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== X ? "#define TONE_MAPPING" : "", n.toneMapping !== X ? gr.tonemapping_pars_fragment : "", n.toneMapping !== X ? pa("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.alphaWrite ? "" : "#define OPAQUE", gr.encodings_pars_fragment, da("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ma).join("\n")), a = xa(a), a = fa(a, n), a = ga(a, n), h = xa(h), h = fa(h, n), h = ga(h, n), a = ba(a), h = ba(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, y = ["#define varying in", n.glslVersion === Me ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Me ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
                     const M = _ + y + h,
-                        b = wr(o, 35633, _ + x + c),
-                        w = wr(o, 35632, M);
-                    if (o.attachShader(v, b), o.attachShader(v, w), void 0 !== n.index0AttributeName ? o.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && o.bindAttribLocation(v, 0, "position"), o.linkProgram(v), t.debug.checkShaderErrors) {
-                        const t = o.getProgramInfoLog(v).trim(),
-                            e = o.getShaderInfoLog(b).trim(),
-                            n = o.getShaderInfoLog(w).trim();
+                        b = ca(r, 35633, _ + x + a),
+                        w = ca(r, 35632, M);
+                    if (r.attachShader(v, b), r.attachShader(v, w), void 0 !== n.index0AttributeName ? r.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(v, 0, "position"), r.linkProgram(v), t.debug.checkShaderErrors) {
+                        const t = r.getProgramInfoLog(v).trim(),
+                            e = r.getShaderInfoLog(b).trim(),
+                            n = r.getShaderInfoLog(w).trim();
                         let i = !0,
-                            r = !0;
-                        if (!1 === o.getProgramParameter(v, 35714)) {
+                            s = !0;
+                        if (!1 === r.getProgramParameter(v, 35714)) {
                             i = !1;
-                            const e = Er(o, b, "vertex"),
-                                n = Er(o, w, "fragment");
-                            console.error("THREE.WebGLProgram: Shader Error " + o.getError() + " - VALIDATE_STATUS " + o.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
-                        } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (r = !1);
-                        r && (this.diagnostics = {
+                            const e = ua(r, b, "vertex"),
+                                n = ua(r, w, "fragment");
+                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
+                        } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (s = !1);
+                        s && (this.diagnostics = {
                             runnable: i,
                             programLog: t,
                             vertexShader: {
                                 log: e,
                                 prefix: x
                             },
                             fragmentShader: {
                                 log: n,
                                 prefix: y
                             }
                         })
                     }
                     let S, E;
-                    return o.deleteShader(b), o.deleteShader(w), this.getUniforms = function() {
-                        return void 0 === S && (S = new br(o, v)), S
+                    return r.deleteShader(b), r.deleteShader(w), this.getUniforms = function() {
+                        return void 0 === S && (S = new la(r, v)), S
                     }, this.getAttributes = function() {
                         return void 0 === E && (E = function(t, e) {
                             const n = {},
                                 i = t.getProgramParameter(e, 35721);
                             for (let r = 0; r < i; r++) {
                                 const i = t.getActiveAttrib(e, r),
                                     s = i.name;
@@ -23278,21 +23741,21 @@
                                 35674 === i.type && (a = 2), 35675 === i.type && (a = 3), 35676 === i.type && (a = 4), n[s] = {
                                     type: i.type,
                                     location: t.getAttribLocation(e, s),
                                     locationSize: a
                                 }
                             }
                             return n
-                        }(o, v)), E
+                        }(r, v)), E
                     }, this.destroy = function() {
-                        i.releaseStatesOfProgram(this), o.deleteProgram(v), this.program = void 0
-                    }, this.name = n.shaderName, this.id = Sr++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = b, this.fragmentShader = w, this
+                        i.releaseStatesOfProgram(this), r.deleteProgram(v), this.program = void 0
+                    }, this.name = n.shaderName, this.id = ha++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = b, this.fragmentShader = w, this
                 }
-                let Gr = 0;
-                class Vr {
+                let Aa = 0;
+                class Ra {
                     constructor() {
                         this.shaderCache = new Map, this.materialCache = new Map
                     }
                     update(t) {
                         const e = t.vertexShader,
                             n = t.fragmentShader,
                             i = this._getShaderStage(e),
@@ -23317,37 +23780,37 @@
                     _getShaderCacheForMaterial(t) {
                         const e = this.materialCache;
                         return !1 === e.has(t) && e.set(t, new Set), e.get(t)
                     }
                     _getShaderStage(t) {
                         const e = this.shaderCache;
                         if (!1 === e.has(t)) {
-                            const n = new kr;
+                            const n = new La;
                             e.set(t, n)
                         }
                         return e.get(t)
                     }
                 }
-                class kr {
+                class La {
                     constructor() {
-                        this.id = Gr++, this.usedTimes = 0
+                        this.id = Aa++, this.usedTimes = 0
                     }
                 }
 
-                function Wr(t, e, n, i, r, s, o) {
-                    const l = new ne,
-                        c = new Vr,
-                        h = [],
-                        u = r.isWebGL2,
-                        d = r.logarithmicDepthBuffer,
-                        p = r.floatVertexTextures,
-                        m = r.maxVertexUniforms,
-                        f = r.vertexTextures;
-                    let g = r.precision;
-                    const v = {
+                function Ca(t, e, n, i, r, s, a) {
+                    const o = new Gn,
+                        l = new Ra,
+                        c = [],
+                        h = r.isWebGL2,
+                        p = r.logarithmicDepthBuffer,
+                        m = r.floatVertexTextures,
+                        f = r.maxVertexUniforms,
+                        g = r.vertexTextures;
+                    let v = r.precision;
+                    const x = {
                         MeshDepthMaterial: "depth",
                         MeshDistanceMaterial: "distanceRGBA",
                         MeshNormalMaterial: "normal",
                         MeshBasicMaterial: "basic",
                         MeshLambertMaterial: "lambert",
                         MeshPhongMaterial: "phong",
                         MeshToonMaterial: "toon",
@@ -23357,180 +23820,180 @@
                         LineBasicMaterial: "basic",
                         LineDashedMaterial: "dashed",
                         PointsMaterial: "points",
                         ShadowMaterial: "shadow",
                         SpriteMaterial: "sprite"
                     };
                     return {
-                        getParameters: function(s, l, h, x, y) {
-                            const _ = x.fog,
-                                M = s.isMeshStandardMaterial ? x.environment : null,
-                                b = (s.isMeshStandardMaterial ? n : e).get(s.envMap || M),
-                                w = v[s.type],
-                                S = y.isSkinnedMesh ? function(t) {
+                        getParameters: function(s, o, c, y, _) {
+                            const M = y.fog,
+                                b = s.isMeshStandardMaterial ? y.environment : null,
+                                w = (s.isMeshStandardMaterial ? n : e).get(s.envMap || b),
+                                S = x[s.type],
+                                E = _.isSkinnedMesh ? function(t) {
                                     const e = t.skeleton.bones;
-                                    if (p) return 1024; {
-                                        const t = m,
+                                    if (m) return 1024; {
+                                        const t = f,
                                             n = Math.floor((t - 20) / 4),
                                             i = Math.min(n, e.length);
                                         return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                                     }
-                                }(y) : 0;
-                            let E, T, A, R;
-                            if (null !== s.precision && (g = r.getMaxPrecision(s.precision), g !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", g, "instead.")), w) {
-                                const t = Nn[w];
-                                E = t.vertexShader, T = t.fragmentShader
-                            } else E = s.vertexShader, T = s.fragmentShader, c.update(s), A = c.getVertexShaderID(s), R = c.getFragmentShaderID(s);
-                            const L = t.getRenderTarget(),
-                                C = s.alphaTest > 0,
-                                P = s.clearcoat > 0;
+                                }(_) : 0;
+                            let T, A, R, L;
+                            if (null !== s.precision && (v = r.getMaxPrecision(s.precision), v !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", v, "instead.")), S) {
+                                const t = xr[S];
+                                T = t.vertexShader, A = t.fragmentShader
+                            } else T = s.vertexShader, A = s.fragmentShader, l.update(s), R = l.getVertexShaderID(s), L = l.getFragmentShaderID(s);
+                            const C = t.getRenderTarget(),
+                                P = s.alphaTest > 0,
+                                D = s.clearcoat > 0;
                             return {
-                                isWebGL2: u,
-                                shaderID: w,
+                                isWebGL2: h,
+                                shaderID: S,
                                 shaderName: s.type,
-                                vertexShader: E,
-                                fragmentShader: T,
+                                vertexShader: T,
+                                fragmentShader: A,
                                 defines: s.defines,
-                                customVertexShaderID: A,
-                                customFragmentShaderID: R,
+                                customVertexShaderID: R,
+                                customFragmentShaderID: L,
                                 isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                                 glslVersion: s.glslVersion,
-                                precision: g,
-                                instancing: !0 === y.isInstancedMesh,
-                                instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor,
-                                supportsVertexTextures: f,
-                                outputEncoding: null === L ? t.outputEncoding : !0 === L.isXRRenderTarget ? L.texture.encoding : D,
+                                precision: v,
+                                instancing: !0 === _.isInstancedMesh,
+                                instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
+                                supportsVertexTextures: g,
+                                outputEncoding: null === C ? t.outputEncoding : !0 === C.isXRRenderTarget ? C.texture.encoding : pe,
                                 map: !!s.map,
                                 matcap: !!s.matcap,
-                                envMap: !!b,
-                                envMapMode: b && b.mapping,
-                                envMapCubeUV: !!b && (b.mapping === a || 307 === b.mapping),
+                                envMap: !!w,
+                                envMapMode: w && w.mapping,
+                                envMapCubeUV: !!w && (w.mapping === nt || w.mapping === it),
                                 lightMap: !!s.lightMap,
                                 aoMap: !!s.aoMap,
                                 emissiveMap: !!s.emissiveMap,
                                 bumpMap: !!s.bumpMap,
                                 normalMap: !!s.normalMap,
-                                objectSpaceNormalMap: 1 === s.normalMapType,
-                                tangentSpaceNormalMap: 0 === s.normalMapType,
-                                decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === I,
-                                clearcoat: P,
-                                clearcoatMap: P && !!s.clearcoatMap,
-                                clearcoatRoughnessMap: P && !!s.clearcoatRoughnessMap,
-                                clearcoatNormalMap: P && !!s.clearcoatNormalMap,
+                                objectSpaceNormalMap: s.normalMapType === ve,
+                                tangentSpaceNormalMap: s.normalMapType === ge,
+                                decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === me,
+                                clearcoat: D,
+                                clearcoatMap: D && !!s.clearcoatMap,
+                                clearcoatRoughnessMap: D && !!s.clearcoatRoughnessMap,
+                                clearcoatNormalMap: D && !!s.clearcoatNormalMap,
                                 displacementMap: !!s.displacementMap,
                                 roughnessMap: !!s.roughnessMap,
                                 metalnessMap: !!s.metalnessMap,
                                 specularMap: !!s.specularMap,
                                 specularIntensityMap: !!s.specularIntensityMap,
                                 specularColorMap: !!s.specularColorMap,
                                 alphaMap: !!s.alphaMap,
-                                alphaTest: C,
+                                alphaTest: P,
                                 alphaWrite: s.alphaWrite || s.transparent,
                                 gradientMap: !!s.gradientMap,
                                 sheen: s.sheen > 0,
                                 sheenColorMap: !!s.sheenColorMap,
                                 sheenRoughnessMap: !!s.sheenRoughnessMap,
                                 transmission: s.transmission > 0,
                                 transmissionMap: !!s.transmissionMap,
                                 thicknessMap: !!s.thicknessMap,
                                 combine: s.combine,
-                                vertexTangents: !!s.normalMap && !!y.geometry && !!y.geometry.attributes.tangent,
+                                vertexTangents: !!s.normalMap && !!_.geometry && !!_.geometry.attributes.tangent,
                                 vertexColors: s.vertexColors,
-                                vertexAlphas: !0 === s.vertexColors && !!y.geometry && !!y.geometry.attributes.color && 4 === y.geometry.attributes.color.itemSize,
+                                vertexAlphas: !0 === s.vertexColors && !!_.geometry && !!_.geometry.attributes.color && 4 === _.geometry.attributes.color.itemSize,
                                 vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
                                 uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
-                                fog: !!_,
+                                fog: !!M,
                                 useFog: s.fog,
-                                fogExp2: _ && _.isFogExp2,
+                                fogExp2: M && M.isFogExp2,
                                 flatShading: !!s.flatShading,
                                 sizeAttenuation: s.sizeAttenuation,
-                                logarithmicDepthBuffer: d,
-                                skinning: !0 === y.isSkinnedMesh && S > 0,
-                                maxBones: S,
-                                useVertexTexture: p,
-                                morphTargets: !!y.geometry && !!y.geometry.morphAttributes.position,
-                                morphNormals: !!y.geometry && !!y.geometry.morphAttributes.normal,
-                                morphTargetsCount: y.geometry && y.geometry.morphAttributes.position ? y.geometry.morphAttributes.position.length : 0,
-                                numDirLights: l.directional.length,
-                                numPointLights: l.point.length,
-                                numSpotLights: l.spot.length,
-                                numRectAreaLights: l.rectArea.length,
-                                numHemiLights: l.hemi.length,
-                                numDirLightShadows: l.directionalShadowMap.length,
-                                numPointLightShadows: l.pointShadowMap.length,
-                                numSpotLightShadows: l.spotShadowMap.length,
-                                numClippingPlanes: o.numPlanes,
-                                numClipIntersection: o.numIntersection,
+                                logarithmicDepthBuffer: p,
+                                skinning: !0 === _.isSkinnedMesh && E > 0,
+                                maxBones: E,
+                                useVertexTexture: m,
+                                morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position,
+                                morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
+                                morphTargetsCount: _.geometry && _.geometry.morphAttributes.position ? _.geometry.morphAttributes.position.length : 0,
+                                numDirLights: o.directional.length,
+                                numPointLights: o.point.length,
+                                numSpotLights: o.spot.length,
+                                numRectAreaLights: o.rectArea.length,
+                                numHemiLights: o.hemi.length,
+                                numDirLightShadows: o.directionalShadowMap.length,
+                                numPointLightShadows: o.pointShadowMap.length,
+                                numSpotLightShadows: o.spotShadowMap.length,
+                                numClippingPlanes: a.numPlanes,
+                                numClipIntersection: a.numIntersection,
                                 dithering: s.dithering,
-                                shadowMapEnabled: t.shadowMap.enabled && h.length > 0,
+                                shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                                 shadowMapType: t.shadowMap.type,
-                                toneMapping: s.toneMapped ? t.toneMapping : 0,
+                                toneMapping: s.toneMapped ? t.toneMapping : X,
                                 physicallyCorrectLights: t.physicallyCorrectLights,
                                 premultipliedAlpha: s.premultipliedAlpha,
-                                doubleSided: 2 === s.side,
-                                flipSided: 1 === s.side,
+                                doubleSided: s.side === d,
+                                flipSided: s.side === u,
                                 depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                                 index0AttributeName: s.index0AttributeName,
                                 extensionDerivatives: s.extensions && s.extensions.derivatives,
                                 extensionFragDepth: s.extensions && s.extensions.fragDepth,
                                 extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                                 extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
-                                rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
-                                rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
-                                rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
+                                rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
+                                rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
+                                rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
                                 customProgramCacheKey: s.customProgramCacheKey()
                             }
                         },
                         getProgramCacheKey: function(e) {
                             const n = [];
                             if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
                                 for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                             return !1 === e.isRawShaderMaterial && (function(t, e) {
                                 t.push(e.precision), t.push(e.outputEncoding), t.push(e.envMapMode), t.push(e.combine), t.push(e.vertexUvs), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.maxBones), t.push(e.morphTargetsCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.alphaWrite)
                             }(n, e), function(t, e) {
-                                l.disableAll(), e.isWebGL2 && l.enable(0), e.supportsVertexTextures && l.enable(1), e.instancing && l.enable(2), e.instancingColor && l.enable(3), e.map && l.enable(4), e.matcap && l.enable(5), e.envMap && l.enable(6), e.envMapCubeUV && l.enable(7), e.lightMap && l.enable(8), e.aoMap && l.enable(9), e.emissiveMap && l.enable(10), e.bumpMap && l.enable(11), e.normalMap && l.enable(12), e.objectSpaceNormalMap && l.enable(13), e.tangentSpaceNormalMap && l.enable(14), e.clearcoat && l.enable(15), e.clearcoatMap && l.enable(16), e.clearcoatRoughnessMap && l.enable(17), e.clearcoatNormalMap && l.enable(18), e.displacementMap && l.enable(19), e.specularMap && l.enable(20), e.roughnessMap && l.enable(21), e.metalnessMap && l.enable(22), e.gradientMap && l.enable(23), e.alphaMap && l.enable(24), e.alphaTest && l.enable(25), e.vertexColors && l.enable(26), e.vertexAlphas && l.enable(27), e.vertexUvs && l.enable(28), e.vertexTangents && l.enable(29), e.uvsVertexOnly && l.enable(30), e.fog && l.enable(31), t.push(l.mask), l.disableAll(), e.useFog && l.enable(0), e.flatShading && l.enable(1), e.logarithmicDepthBuffer && l.enable(2), e.skinning && l.enable(3), e.useVertexTexture && l.enable(4), e.morphTargets && l.enable(5), e.morphNormals && l.enable(6), e.premultipliedAlpha && l.enable(7), e.shadowMapEnabled && l.enable(8), e.physicallyCorrectLights && l.enable(9), e.doubleSided && l.enable(10), e.flipSided && l.enable(11), e.depthPacking && l.enable(12), e.dithering && l.enable(13), e.specularIntensityMap && l.enable(14), e.specularColorMap && l.enable(15), e.transmission && l.enable(16), e.transmissionMap && l.enable(17), e.thicknessMap && l.enable(18), e.sheen && l.enable(19), e.sheenColorMap && l.enable(20), e.sheenRoughnessMap && l.enable(21), e.decodeVideoTexture && l.enable(22), t.push(l.mask)
+                                o.disableAll(), e.isWebGL2 && o.enable(0), e.supportsVertexTextures && o.enable(1), e.instancing && o.enable(2), e.instancingColor && o.enable(3), e.map && o.enable(4), e.matcap && o.enable(5), e.envMap && o.enable(6), e.envMapCubeUV && o.enable(7), e.lightMap && o.enable(8), e.aoMap && o.enable(9), e.emissiveMap && o.enable(10), e.bumpMap && o.enable(11), e.normalMap && o.enable(12), e.objectSpaceNormalMap && o.enable(13), e.tangentSpaceNormalMap && o.enable(14), e.clearcoat && o.enable(15), e.clearcoatMap && o.enable(16), e.clearcoatRoughnessMap && o.enable(17), e.clearcoatNormalMap && o.enable(18), e.displacementMap && o.enable(19), e.specularMap && o.enable(20), e.roughnessMap && o.enable(21), e.metalnessMap && o.enable(22), e.gradientMap && o.enable(23), e.alphaMap && o.enable(24), e.alphaTest && o.enable(25), e.vertexColors && o.enable(26), e.vertexAlphas && o.enable(27), e.vertexUvs && o.enable(28), e.vertexTangents && o.enable(29), e.uvsVertexOnly && o.enable(30), e.fog && o.enable(31), t.push(o.mask), o.disableAll(), e.useFog && o.enable(0), e.flatShading && o.enable(1), e.logarithmicDepthBuffer && o.enable(2), e.skinning && o.enable(3), e.useVertexTexture && o.enable(4), e.morphTargets && o.enable(5), e.morphNormals && o.enable(6), e.premultipliedAlpha && o.enable(7), e.shadowMapEnabled && o.enable(8), e.physicallyCorrectLights && o.enable(9), e.doubleSided && o.enable(10), e.flipSided && o.enable(11), e.depthPacking && o.enable(12), e.dithering && o.enable(13), e.specularIntensityMap && o.enable(14), e.specularColorMap && o.enable(15), e.transmission && o.enable(16), e.transmissionMap && o.enable(17), e.thicknessMap && o.enable(18), e.sheen && o.enable(19), e.sheenColorMap && o.enable(20), e.sheenRoughnessMap && o.enable(21), e.decodeVideoTexture && o.enable(22), t.push(o.mask)
                             }(n, e), n.push(t.outputEncoding)), n.push(e.customProgramCacheKey), n.join()
                         },
                         getUniforms: function(t) {
-                            const e = v[t.type];
+                            const e = x[t.type];
                             let n;
                             if (e) {
-                                const t = Nn[e];
-                                n = mn.clone(t.uniforms)
+                                const t = xr[e];
+                                n = Qi.clone(t.uniforms)
                             } else n = t.uniforms;
                             return n
                         },
                         acquireProgram: function(e, n) {
                             let i;
-                            for (let t = 0, e = h.length; t < e; t++) {
-                                const e = h[t];
+                            for (let t = 0, e = c.length; t < e; t++) {
+                                const e = c[t];
                                 if (e.cacheKey === n) {
                                     i = e, ++i.usedTimes;
                                     break
                                 }
                             }
-                            return void 0 === i && (i = new Hr(t, n, e, s), h.push(i)), i
+                            return void 0 === i && (i = new Ta(t, n, e, s), c.push(i)), i
                         },
                         releaseProgram: function(t) {
                             if (0 == --t.usedTimes) {
-                                const e = h.indexOf(t);
-                                h[e] = h[h.length - 1], h.pop(), t.destroy()
+                                const e = c.indexOf(t);
+                                c[e] = c[c.length - 1], c.pop(), t.destroy()
                             }
                         },
                         releaseShaderCache: function(t) {
-                            c.remove(t)
+                            l.remove(t)
                         },
-                        programs: h,
+                        programs: c,
                         dispose: function() {
-                            c.dispose()
+                            l.dispose()
                         }
                     }
                 }
 
-                function jr() {
+                function Pa() {
                     let t = new WeakMap;
                     return {
                         get: function(e) {
                             let n = t.get(e);
                             return void 0 === n && (n = {}, t.set(e, n)), n
                         },
                         remove: function(e) {
@@ -23541,23 +24004,23 @@
                         },
                         dispose: function() {
                             t = new WeakMap
                         }
                     }
                 }
 
-                function Xr(t, e) {
+                function Da(t, e) {
                     return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                 }
 
-                function qr(t, e) {
+                function Ia(t, e) {
                     return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                 }
 
-                function Yr() {
+                function Na() {
                     const t = [];
                     let e = 0;
                     const n = [],
                         i = [],
                         r = [];
 
                     function s(n, i, r, s, a, o) {
@@ -23592,113 +24055,113 @@
                             for (let n = e, i = t.length; n < i; n++) {
                                 const e = t[n];
                                 if (null === e.id) break;
                                 e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                             }
                         },
                         sort: function(t, e) {
-                            n.length > 1 && n.sort(t || Xr), i.length > 1 && i.sort(e || qr), r.length > 1 && r.sort(e || qr)
+                            n.length > 1 && n.sort(t || Da), i.length > 1 && i.sort(e || Ia), r.length > 1 && r.sort(e || Ia)
                         }
                     }
                 }
 
-                function Zr() {
+                function Oa() {
                     let t = new WeakMap;
                     return {
                         get: function(e, n) {
                             let i;
-                            return !1 === t.has(e) ? (i = new Yr, t.set(e, [i])) : n >= t.get(e).length ? (i = new Yr, t.get(e).push(i)) : i = t.get(e)[n], i
+                            return !1 === t.has(e) ? (i = new Na, t.set(e, [i])) : n >= t.get(e).length ? (i = new Na, t.get(e).push(i)) : i = t.get(e)[n], i
                         },
                         dispose: function() {
                             t = new WeakMap
                         }
                     }
                 }
 
-                function Jr() {
+                function Ua() {
                     const t = {};
                     return {
                         get: function(e) {
                             if (void 0 !== t[e.id]) return t[e.id];
                             let n;
                             switch (e.type) {
                                 case "DirectionalLight":
                                     n = {
-                                        direction: new mt,
-                                        color: new rt
+                                        direction: new Qe,
+                                        color: new Ve
                                     };
                                     break;
                                 case "SpotLight":
                                     n = {
-                                        position: new mt,
-                                        direction: new mt,
-                                        color: new rt,
+                                        position: new Qe,
+                                        direction: new Qe,
+                                        color: new Ve,
                                         distance: 0,
                                         coneCos: 0,
                                         penumbraCos: 0,
                                         decay: 0
                                     };
                                     break;
                                 case "PointLight":
                                     n = {
-                                        position: new mt,
-                                        color: new rt,
+                                        position: new Qe,
+                                        color: new Ve,
                                         distance: 0,
                                         decay: 0
                                     };
                                     break;
                                 case "HemisphereLight":
                                     n = {
-                                        direction: new mt,
-                                        skyColor: new rt,
-                                        groundColor: new rt
+                                        direction: new Qe,
+                                        skyColor: new Ve,
+                                        groundColor: new Ve
                                     };
                                     break;
                                 case "RectAreaLight":
                                     n = {
-                                        color: new rt,
-                                        position: new mt,
-                                        halfWidth: new mt,
-                                        halfHeight: new mt
+                                        color: new Ve,
+                                        position: new Qe,
+                                        halfWidth: new Qe,
+                                        halfHeight: new Qe
                                     }
                             }
                             return t[e.id] = n, n
                         }
                     }
                 }
-                let Kr = 0;
+                let Ba = 0;
 
-                function Qr(t, e) {
+                function Fa(t, e) {
                     return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
                 }
 
-                function $r(t, e) {
-                    const n = new Jr,
+                function za(t, e) {
+                    const n = new Ua,
                         i = function() {
                             const t = {};
                             return {
                                 get: function(e) {
                                     if (void 0 !== t[e.id]) return t[e.id];
                                     let n;
                                     switch (e.type) {
                                         case "DirectionalLight":
                                         case "SpotLight":
                                             n = {
                                                 shadowBias: 0,
                                                 shadowNormalBias: 0,
                                                 shadowRadius: 1,
-                                                shadowMapSize: new Y
+                                                shadowMapSize: new De
                                             };
                                             break;
                                         case "PointLight":
                                             n = {
                                                 shadowBias: 0,
                                                 shadowNormalBias: 0,
                                                 shadowRadius: 1,
-                                                shadowMapSize: new Y,
+                                                shadowMapSize: new De,
                                                 shadowCameraNear: 1,
                                                 shadowCameraFar: 1e3
                                             }
                                     }
                                     return t[e.id] = n, n
                                 }
                             }
@@ -23730,33 +24193,33 @@
                             rectAreaLTC2: null,
                             point: [],
                             pointShadow: [],
                             pointShadowMap: [],
                             pointShadowMatrix: [],
                             hemi: []
                         };
-                    for (let t = 0; t < 9; t++) r.probe.push(new mt);
-                    const s = new mt,
-                        a = new jt,
-                        o = new jt;
+                    for (let t = 0; t < 9; t++) r.probe.push(new Qe);
+                    const s = new Qe,
+                        a = new Cn,
+                        o = new Cn;
                     return {
                         setup: function(s, a) {
                             let o = 0,
                                 l = 0,
                                 c = 0;
                             for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                             let h = 0,
                                 u = 0,
                                 d = 0,
                                 p = 0,
                                 m = 0,
                                 f = 0,
                                 g = 0,
                                 v = 0;
-                            s.sort(Qr);
+                            s.sort(Fa);
                             const x = !0 !== a ? Math.PI : 1;
                             for (let t = 0, e = s.length; t < e; t++) {
                                 const e = s[t],
                                     a = e.color,
                                     y = e.intensity,
                                     _ = e.distance,
                                     M = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
@@ -23791,17 +24254,17 @@
                                     }
                                     r.point[u] = t, u++
                                 } else if (e.isHemisphereLight) {
                                     const t = n.get(e);
                                     t.skyColor.copy(e.color).multiplyScalar(y * x), t.groundColor.copy(e.groundColor).multiplyScalar(y * x), r.hemi[m] = t, m++
                                 }
                             }
-                            p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = In.LTC_FLOAT_1, r.rectAreaLTC2 = In.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = In.LTC_HALF_1, r.rectAreaLTC2 = In.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
+                            p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = vr.LTC_FLOAT_1, r.rectAreaLTC2 = vr.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = vr.LTC_HALF_1, r.rectAreaLTC2 = vr.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
                             const y = r.hash;
-                            y.directionalLength === h && y.pointLength === u && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === m && y.numDirectionalShadows === f && y.numPointShadows === g && y.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, y.directionalLength = h, y.pointLength = u, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = m, y.numDirectionalShadows = f, y.numPointShadows = g, y.numSpotShadows = v, r.version = Kr++)
+                            y.directionalLength === h && y.pointLength === u && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === m && y.numDirectionalShadows === f && y.numPointShadows === g && y.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, y.directionalLength = h, y.pointLength = u, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = m, y.numDirectionalShadows = f, y.numPointShadows = g, y.numSpotShadows = v, r.version = Ba++)
                         },
                         setupView: function(t, e) {
                             let n = 0,
                                 i = 0,
                                 l = 0,
                                 c = 0,
                                 h = 0;
@@ -23826,16 +24289,16 @@
                                 }
                             }
                         },
                         state: r
                     }
                 }
 
-                function ts(t, e) {
-                    const n = new $r(t, e),
+                function Ha(t, e) {
+                    const n = new za(t, e),
                         i = [],
                         r = [];
                     return {
                         init: function() {
                             i.length = 0, r.length = 0
                         },
                         state: {
@@ -23854,182 +24317,185 @@
                         },
                         pushShadow: function(t) {
                             r.push(t)
                         }
                     }
                 }
 
-                function es(t, e) {
+                function Ga(t, e) {
                     let n = new WeakMap;
                     return {
                         get: function(i, r = 0) {
                             let s;
-                            return !1 === n.has(i) ? (s = new ts(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new ts(t, e), n.get(i).push(s)) : s = n.get(i)[r], s
+                            return !1 === n.has(i) ? (s = new Ha(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new Ha(t, e), n.get(i).push(s)) : s = n.get(i)[r], s
                         },
                         dispose: function() {
                             n = new WeakMap
                         }
                     }
                 }
-                class ns extends Le {
+                class Va extends mi {
                     constructor(t) {
                         super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                     }
                 }
-                ns.prototype.isMeshDepthMaterial = !0;
-                class is extends Le {
+                Va.prototype.isMeshDepthMaterial = !0;
+                class ka extends mi {
                     constructor(t) {
-                        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new mt, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
+                        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Qe, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                     }
                 }
+                ka.prototype.isMeshDistanceMaterial = !0;
+                const Wa = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
+                    ja = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
 
-                function rs(t, e, n) {
-                    let i = new Rn;
-                    const r = new Y,
-                        s = new Y,
-                        a = new ht,
-                        o = new ns({
-                            depthPacking: 3201
+                function Xa(t, e, n) {
+                    let i = new dr;
+                    const r = new De,
+                        s = new De,
+                        a = new Ye,
+                        l = new Va({
+                            depthPacking: fe
                         }),
-                        l = new is,
-                        c = {},
-                        d = n.maxTextureSize,
-                        p = {
-                            0: 1,
-                            1: 0,
-                            2: 2
+                        m = new ka,
+                        f = {},
+                        g = n.maxTextureSize,
+                        v = {
+                            0: u,
+                            1: h,
+                            2: d
                         },
-                        m = new fn({
+                        x = new $i({
                             defines: {
                                 VSM_SAMPLES: 8
                             },
                             uniforms: {
                                 shadow_pass: {
                                     value: null
                                 },
                                 resolution: {
-                                    value: new Y
+                                    value: new De
                                 },
                                 radius: {
                                     value: 4
                                 }
                             },
-                            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
-                            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
+                            vertexShader: Wa,
+                            fragmentShader: ja
                         }),
-                        f = m.clone();
-                    f.defines.HORIZONTAL_PASS = 1;
-                    const g = new We;
-                    g.setAttribute("position", new Ie(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
-                    const v = new cn(g, m),
-                        x = this;
-
-                    function _(n, i) {
-                        const r = e.update(v);
-                        m.defines.VSM_SAMPLES !== n.blurSamples && (m.defines.VSM_SAMPLES = n.blurSamples, f.defines.VSM_SAMPLES = n.blurSamples, m.needsUpdate = !0, f.needsUpdate = !0), m.uniforms.shadow_pass.value = n.map.texture, m.uniforms.resolution.value = n.mapSize, m.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, m, v, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, f, v, null)
-                    }
-
-                    function M(e, n, i, r, s, a, h) {
-                        let u = null;
-                        const d = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
-                        if (u = void 0 !== d ? d : !0 === r.isPointLight ? l : o, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
-                            const t = u.uuid,
+                        y = x.clone();
+                    y.defines.HORIZONTAL_PASS = 1;
+                    const _ = new Li;
+                    _.setAttribute("position", new xi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
+                    const M = new qi(_, x),
+                        b = this;
+
+                    function w(n, i) {
+                        const r = e.update(M);
+                        x.defines.VSM_SAMPLES !== n.blurSamples && (x.defines.VSM_SAMPLES = n.blurSamples, y.defines.VSM_SAMPLES = n.blurSamples, x.needsUpdate = !0, y.needsUpdate = !0), x.uniforms.shadow_pass.value = n.map.texture, x.uniforms.resolution.value = n.mapSize, x.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, x, M, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, y, M, null)
+                    }
+
+                    function S(e, n, i, r, s, a, o) {
+                        let h = null;
+                        const u = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
+                        if (h = void 0 !== u ? u : !0 === r.isPointLight ? m : l, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
+                            const t = h.uuid,
                                 e = i.uuid;
-                            let n = c[t];
-                            void 0 === n && (n = {}, c[t] = n);
+                            let n = f[t];
+                            void 0 === n && (n = {}, f[t] = n);
                             let r = n[e];
-                            void 0 === r && (r = u.clone(), n[e] = r), u = r
+                            void 0 === r && (r = h.clone(), n[e] = r), h = r
                         }
-                        return u.visible = i.visible, u.wireframe = i.wireframe, u.side = 3 === h ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : p[i.side], u.alphaMap = i.alphaMap, u.alphaTest = i.alphaTest, u.clipShadows = i.clipShadows, u.clippingPlanes = i.clippingPlanes, u.clipIntersection = i.clipIntersection, u.displacementMap = i.displacementMap, u.displacementScale = i.displacementScale, u.displacementBias = i.displacementBias, u.wireframeLinewidth = i.wireframeLinewidth, u.linewidth = i.linewidth, !0 === r.isPointLight && !0 === u.isMeshDistanceMaterial && (u.referencePosition.setFromMatrixPosition(r.matrixWorld), u.nearDistance = s, u.farDistance = a), u
+                        return h.visible = i.visible, h.wireframe = i.wireframe, h.side = o === c ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : v[i.side], h.alphaMap = i.alphaMap, h.alphaTest = i.alphaTest, h.clipShadows = i.clipShadows, h.clippingPlanes = i.clippingPlanes, h.clipIntersection = i.clipIntersection, h.displacementMap = i.displacementMap, h.displacementScale = i.displacementScale, h.displacementBias = i.displacementBias, h.wireframeLinewidth = i.wireframeLinewidth, h.linewidth = i.linewidth, !0 === r.isPointLight && !0 === h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(r.matrixWorld), h.nearDistance = s, h.farDistance = a), h
                     }
 
-                    function b(n, r, s, a, o) {
+                    function E(n, r, s, a, o) {
                         if (!1 === n.visible) return;
-                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
+                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && o === c) && (!n.frustumCulled || i.intersectsObject(n))) {
                             n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                             const i = e.update(n),
                                 r = n.material;
                             if (Array.isArray(r)) {
                                 const e = i.groups;
                                 for (let l = 0, c = e.length; l < c; l++) {
                                     const c = e[l],
                                         h = r[c.materialIndex];
                                     if (h && h.visible) {
-                                        const e = M(n, 0, h, a, s.near, s.far, o);
+                                        const e = S(n, 0, h, a, s.near, s.far, o);
                                         t.renderBufferDirect(s, null, i, e, n, c)
                                     }
                                 }
                             } else if (r.visible) {
-                                const e = M(n, 0, r, a, s.near, s.far, o);
+                                const e = S(n, 0, r, a, s.near, s.far, o);
                                 t.renderBufferDirect(s, null, i, e, n, null)
                             }
                         }
                         const l = n.children;
-                        for (let t = 0, e = l.length; t < e; t++) b(l[t], r, s, a, o)
+                        for (let t = 0, e = l.length; t < e; t++) E(l[t], r, s, a, o)
                     }
-                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, n, o) {
-                        if (!1 === x.enabled) return;
-                        if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
+                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = o, this.render = function(e, n, o) {
+                        if (!1 === b.enabled) return;
+                        if (!1 === b.autoUpdate && !1 === b.needsUpdate) return;
                         if (0 === e.length) return;
                         const l = t.getRenderTarget(),
-                            c = t.getActiveCubeFace(),
-                            p = t.getActiveMipmapLevel(),
-                            m = t.state;
-                        m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), m.setScissorTest(!1);
-                        for (let l = 0, c = e.length; l < c; l++) {
-                            const c = e[l],
-                                p = c.shadow;
-                            if (void 0 === p) {
-                                console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
+                            h = t.getActiveCubeFace(),
+                            u = t.getActiveMipmapLevel(),
+                            d = t.state;
+                        d.setBlending(p), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
+                        for (let l = 0, h = e.length; l < h; l++) {
+                            const h = e[l],
+                                u = h.shadow;
+                            if (void 0 === u) {
+                                console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
                                 continue
                             }
-                            if (!1 === p.autoUpdate && !1 === p.needsUpdate) continue;
-                            r.copy(p.mapSize);
-                            const f = p.getFrameExtents();
-                            if (r.multiply(f), s.copy(p.mapSize), (r.x > d || r.y > d) && (r.x > d && (s.x = Math.floor(d / f.x), r.x = s.x * f.x, p.mapSize.x = s.x), r.y > d && (s.y = Math.floor(d / f.y), r.y = s.y * f.y, p.mapSize.y = s.y)), null === p.map && !p.isPointLightShadow && 3 === this.type) {
+                            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
+                            r.copy(u.mapSize);
+                            const p = u.getFrameExtents();
+                            if (r.multiply(p), s.copy(u.mapSize), (r.x > g || r.y > g) && (r.x > g && (s.x = Math.floor(g / p.x), r.x = s.x * p.x, u.mapSize.x = s.x), r.y > g && (s.y = Math.floor(g / p.y), r.y = s.y * p.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && this.type === c) {
                                 const t = {
-                                    minFilter: u,
-                                    magFilter: u,
-                                    format: y
+                                    minFilter: ht,
+                                    magFilter: ht,
+                                    format: Et
                                 };
-                                p.map = new ut(r.x, r.y, t), p.map.texture.name = c.name + ".shadowMap", p.mapPass = new ut(r.x, r.y, t), p.camera.updateProjectionMatrix()
+                                u.map = new Ze(r.x, r.y, t), u.map.texture.name = h.name + ".shadowMap", u.mapPass = new Ze(r.x, r.y, t), u.camera.updateProjectionMatrix()
                             }
-                            if (null === p.map) {
+                            if (null === u.map) {
                                 const t = {
-                                    minFilter: h,
-                                    magFilter: h,
-                                    format: y
+                                    minFilter: ot,
+                                    magFilter: ot,
+                                    format: Et
                                 };
-                                p.map = new ut(r.x, r.y, t), p.map.texture.name = c.name + ".shadowMap", p.camera.updateProjectionMatrix()
+                                u.map = new Ze(r.x, r.y, t), u.map.texture.name = h.name + ".shadowMap", u.camera.updateProjectionMatrix()
                             }
-                            t.setRenderTarget(p.map), t.clear();
-                            const g = p.getViewportCount();
-                            for (let t = 0; t < g; t++) {
-                                const e = p.getViewport(t);
-                                a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), m.viewport(a), p.updateMatrices(c, t), i = p.getFrustum(), b(n, o, p.camera, c, this.type)
+                            t.setRenderTarget(u.map), t.clear();
+                            const m = u.getViewportCount();
+                            for (let t = 0; t < m; t++) {
+                                const e = u.getViewport(t);
+                                a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(a), u.updateMatrices(h, t), i = u.getFrustum(), E(n, o, u.camera, h, this.type)
                             }
-                            p.isPointLightShadow || 3 !== this.type || _(p, o), p.needsUpdate = !1
+                            u.isPointLightShadow || this.type !== c || w(u, o), u.needsUpdate = !1
                         }
-                        x.needsUpdate = !1, t.setRenderTarget(l, c, p)
+                        b.needsUpdate = !1, t.setRenderTarget(l, h, u)
                     }
                 }
 
-                function ss(t, e, n) {
-                    const r = n.isWebGL2,
-                        s = new function() {
+                function qa(t, e, n) {
+                    const i = n.isWebGL2,
+                        o = new function() {
                             let e = !1;
-                            const n = new ht;
+                            const n = new Ye;
                             let i = null;
-                            const r = new ht(0, 0, 0, 0);
+                            const r = new Ye(0, 0, 0, 0);
                             return {
                                 setMask: function(n) {
                                     i === n || e || (t.colorMask(n, n, n, n), i = n)
                                 },
                                 setLocked: function(t) {
                                     e = t
                                 },
@@ -24037,53 +24503,55 @@
                                     !0 === o && (e *= a, i *= a, s *= a), n.set(e, i, s, a), !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n))
                                 },
                                 reset: function() {
                                     e = !1, i = null, r.set(-1, 0, 0, 0)
                                 }
                             }
                         },
-                        a = new function() {
+                        l = new function() {
                             let e = !1,
                                 n = null,
                                 i = null,
                                 r = null;
                             return {
                                 setTest: function(t) {
-                                    t ? z(2929) : H(2929)
+                                    t ? yt(2929) : _t(2929)
                                 },
                                 setMask: function(i) {
                                     n === i || e || (t.depthMask(i), n = i)
                                 },
                                 setFunc: function(e) {
                                     if (i !== e) {
                                         if (e) switch (e) {
-                                            case 0:
+                                            case O:
                                                 t.depthFunc(512);
                                                 break;
-                                            case 1:
+                                            case U:
                                                 t.depthFunc(519);
                                                 break;
-                                            case 2:
+                                            case B:
                                                 t.depthFunc(513);
                                                 break;
-                                            case 3:
-                                            default:
+                                            case F:
                                                 t.depthFunc(515);
                                                 break;
-                                            case 4:
+                                            case z:
                                                 t.depthFunc(514);
                                                 break;
-                                            case 5:
+                                            case H:
                                                 t.depthFunc(518);
                                                 break;
-                                            case 6:
+                                            case G:
                                                 t.depthFunc(516);
                                                 break;
-                                            case 7:
-                                                t.depthFunc(517)
+                                            case V:
+                                                t.depthFunc(517);
+                                                break;
+                                            default:
+                                                t.depthFunc(515)
                                         } else t.depthFunc(515);
                                         i = e
                                     }
                                 },
                                 setLocked: function(t) {
                                     e = t
                                 },
@@ -24091,27 +24559,27 @@
                                     r !== e && (t.clearDepth(e), r = e)
                                 },
                                 reset: function() {
                                     e = !1, n = null, i = null, r = null
                                 }
                             }
                         },
-                        o = new function() {
+                        c = new function() {
                             let e = !1,
                                 n = null,
                                 i = null,
                                 r = null,
                                 s = null,
                                 a = null,
                                 o = null,
                                 l = null,
                                 c = null;
                             return {
                                 setTest: function(t) {
-                                    e || (t ? z(2960) : H(2960))
+                                    e || (t ? yt(2960) : _t(2960))
                                 },
                                 setMask: function(i) {
                                     n === i || e || (t.stencilMask(i), n = i)
                                 },
                                 setFunc: function(e, n, a) {
                                     i === e && r === n && s === a || (t.stencilFunc(e, n, a), i = e, r = n, s = a)
                                 },
@@ -24125,196 +24593,196 @@
                                     c !== e && (t.clearStencil(e), c = e)
                                 },
                                 reset: function() {
                                     e = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null
                                 }
                             }
                         };
-                    let l = {},
-                        c = {},
-                        h = new WeakMap,
-                        u = [],
-                        d = null,
-                        p = !1,
-                        m = null,
-                        f = null,
-                        g = null,
-                        v = null,
-                        x = null,
-                        y = null,
-                        _ = null,
-                        M = !1,
-                        b = null,
-                        w = null,
-                        S = null,
-                        E = null,
-                        T = null;
-                    const A = t.getParameter(35661);
-                    let R = !1,
-                        L = 0;
-                    const C = t.getParameter(7938); - 1 !== C.indexOf("WebGL") ? (L = parseFloat(/^WebGL (\d)/.exec(C)[1]), R = L >= 1) : -1 !== C.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL ES (\d)/.exec(C)[1]), R = L >= 2);
-                    let P = null,
-                        D = {};
-                    const I = t.getParameter(3088),
-                        N = t.getParameter(2978),
-                        O = (new ht).fromArray(I),
-                        U = (new ht).fromArray(N);
+                    let h = {},
+                        k = {},
+                        W = new WeakMap,
+                        j = [],
+                        X = null,
+                        q = !1,
+                        Y = null,
+                        Z = null,
+                        J = null,
+                        K = null,
+                        Q = null,
+                        $ = null,
+                        tt = null,
+                        et = !1,
+                        nt = null,
+                        it = null,
+                        rt = null,
+                        st = null,
+                        at = null;
+                    const ot = t.getParameter(35661);
+                    let lt = !1,
+                        ct = 0;
+                    const ht = t.getParameter(7938); - 1 !== ht.indexOf("WebGL") ? (ct = parseFloat(/^WebGL (\d)/.exec(ht)[1]), lt = ct >= 1) : -1 !== ht.indexOf("OpenGL ES") && (ct = parseFloat(/^OpenGL ES (\d)/.exec(ht)[1]), lt = ct >= 2);
+                    let ut = null,
+                        dt = {};
+                    const pt = t.getParameter(3088),
+                        mt = t.getParameter(2978),
+                        ft = (new Ye).fromArray(pt),
+                        gt = (new Ye).fromArray(mt);
 
-                    function B(e, n, i) {
+                    function vt(e, n, i) {
                         const r = new Uint8Array(4),
                             s = t.createTexture();
                         t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                         for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                         return s
                     }
-                    const F = {};
+                    const xt = {};
 
-                    function z(e) {
-                        !0 !== l[e] && (t.enable(e), l[e] = !0)
+                    function yt(e) {
+                        !0 !== h[e] && (t.enable(e), h[e] = !0)
                     }
 
-                    function H(e) {
-                        !1 !== l[e] && (t.disable(e), l[e] = !1)
+                    function _t(e) {
+                        !1 !== h[e] && (t.disable(e), h[e] = !1)
                     }
-                    F[3553] = B(3553, 3553, 1), F[34067] = B(34067, 34069, 6), s.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), z(2929), a.setFunc(3), W(!1), j(1), z(2884), k(0);
-                    const G = {
-                        [i]: 32774,
-                        101: 32778,
-                        102: 32779
+                    xt[3553] = vt(3553, 3553, 1), xt[34067] = vt(34067, 34069, 6), o.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), yt(2929), l.setFunc(F), St(!1), Et(s), yt(2884), wt(p);
+                    const Mt = {
+                        [y]: 32774,
+                        [_]: 32778,
+                        [M]: 32779
                     };
-                    if (r) G[103] = 32775, G[104] = 32776;
+                    if (i) Mt[b] = 32775, Mt[w] = 32776;
                     else {
                         const t = e.get("EXT_blend_minmax");
-                        null !== t && (G[103] = t.MIN_EXT, G[104] = t.MAX_EXT)
+                        null !== t && (Mt[b] = t.MIN_EXT, Mt[w] = t.MAX_EXT)
                     }
-                    const V = {
-                        200: 0,
-                        201: 1,
-                        202: 768,
-                        204: 770,
-                        210: 776,
-                        208: 774,
-                        206: 772,
-                        203: 769,
-                        205: 771,
-                        209: 775,
-                        207: 773
+                    const bt = {
+                        [S]: 0,
+                        [E]: 1,
+                        [T]: 768,
+                        [R]: 770,
+                        [N]: 776,
+                        [D]: 774,
+                        [C]: 772,
+                        [A]: 769,
+                        [L]: 771,
+                        [I]: 775,
+                        [P]: 773
                     };
 
-                    function k(e, n, r, s, a, o, l, c) {
-                        if (0 !== e) {
-                            if (!1 === p && (z(3042), p = !0), 5 === e) a = a || n, o = o || r, l = l || s, n === f && a === x || (t.blendEquationSeparate(G[n], G[a]), f = n, x = a), r === g && s === v && o === y && l === _ || (t.blendFuncSeparate(V[r], V[s], V[o], V[l]), g = r, v = s, y = o, _ = l), m = e, M = null;
-                            else if (e !== m || c !== M) {
-                                if (f === i && x === i || (t.blendEquation(32774), f = i, x = i), c) switch (e) {
-                                    case 1:
+                    function wt(e, n, i, r, s, a, o, l) {
+                        if (e !== p) {
+                            if (!1 === q && (yt(3042), q = !0), e === x) s = s || n, a = a || i, o = o || r, n === Z && s === Q || (t.blendEquationSeparate(Mt[n], Mt[s]), Z = n, Q = s), i === J && r === K && a === $ && o === tt || (t.blendFuncSeparate(bt[i], bt[r], bt[a], bt[o]), J = i, K = r, $ = a, tt = o), Y = e, et = null;
+                            else if (e !== Y || l !== et) {
+                                if (Z === y && Q === y || (t.blendEquation(32774), Z = y, Q = y), l) switch (e) {
+                                    case m:
                                         t.blendFuncSeparate(1, 771, 1, 771);
                                         break;
-                                    case 2:
+                                    case f:
                                         t.blendFunc(1, 1);
                                         break;
-                                    case 3:
+                                    case g:
                                         t.blendFuncSeparate(0, 769, 0, 1);
                                         break;
-                                    case 4:
+                                    case v:
                                         t.blendFuncSeparate(0, 768, 0, 770);
                                         break;
                                     default:
                                         console.error("THREE.WebGLState: Invalid blending: ", e)
                                 } else switch (e) {
-                                    case 1:
+                                    case m:
                                         t.blendFuncSeparate(770, 771, 1, 771);
                                         break;
-                                    case 2:
+                                    case f:
                                         t.blendFunc(770, 1);
                                         break;
-                                    case 3:
+                                    case g:
                                         t.blendFuncSeparate(0, 769, 0, 1);
                                         break;
-                                    case 4:
+                                    case v:
                                         t.blendFunc(0, 768);
                                         break;
                                     default:
                                         console.error("THREE.WebGLState: Invalid blending: ", e)
                                 }
-                                g = null, v = null, y = null, _ = null, m = e, M = c
+                                J = null, K = null, $ = null, tt = null, Y = e, et = l
                             }
-                        } else !0 === p && (H(3042), p = !1)
+                        } else !0 === q && (_t(3042), q = !1)
                     }
 
-                    function W(e) {
-                        b !== e && (e ? t.frontFace(2304) : t.frontFace(2305), b = e)
+                    function St(e) {
+                        nt !== e && (e ? t.frontFace(2304) : t.frontFace(2305), nt = e)
                     }
 
-                    function j(e) {
-                        0 !== e ? (z(2884), e !== w && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : H(2884), w = e
+                    function Et(e) {
+                        e !== r ? (yt(2884), e !== it && (e === s ? t.cullFace(1029) : e === a ? t.cullFace(1028) : t.cullFace(1032))) : _t(2884), it = e
                     }
 
-                    function X(e, n, i) {
-                        e ? (z(32823), E === n && T === i || (t.polygonOffset(n, i), E = n, T = i)) : H(32823)
+                    function Tt(e, n, i) {
+                        e ? (yt(32823), st === n && at === i || (t.polygonOffset(n, i), st = n, at = i)) : _t(32823)
                     }
 
-                    function q(e) {
-                        void 0 === e && (e = 33984 + A - 1), P !== e && (t.activeTexture(e), P = e)
+                    function At(e) {
+                        void 0 === e && (e = 33984 + ot - 1), ut !== e && (t.activeTexture(e), ut = e)
                     }
                     return {
                         buffers: {
-                            color: s,
-                            depth: a,
-                            stencil: o
+                            color: o,
+                            depth: l,
+                            stencil: c
                         },
-                        enable: z,
-                        disable: H,
+                        enable: yt,
+                        disable: _t,
                         bindFramebuffer: function(e, n) {
-                            return c[e] !== n && (t.bindFramebuffer(e, n), c[e] = n, r && (36009 === e && (c[36160] = n), 36160 === e && (c[36009] = n)), !0)
+                            return k[e] !== n && (t.bindFramebuffer(e, n), k[e] = n, i && (36009 === e && (k[36160] = n), 36160 === e && (k[36009] = n)), !0)
                         },
                         drawBuffers: function(i, r) {
-                            let s = u,
+                            let s = j,
                                 a = !1;
                             if (i)
-                                if (s = h.get(r), void 0 === s && (s = [], h.set(r, s)), i.isWebGLMultipleRenderTargets) {
+                                if (s = W.get(r), void 0 === s && (s = [], W.set(r, s)), i.isWebGLMultipleRenderTargets) {
                                     const t = i.texture;
                                     if (s.length !== t.length || 36064 !== s[0]) {
                                         for (let e = 0, n = t.length; e < n; e++) s[e] = 36064 + e;
                                         s.length = t.length, a = !0
                                     }
                                 } else 36064 !== s[0] && (s[0] = 36064, a = !0);
                             else 1029 !== s[0] && (s[0] = 1029, a = !0);
                             a && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                         },
                         useProgram: function(e) {
-                            return d !== e && (t.useProgram(e), d = e, !0)
+                            return X !== e && (t.useProgram(e), X = e, !0)
                         },
-                        setBlending: k,
+                        setBlending: wt,
                         setMaterial: function(t, e) {
-                            2 === t.side ? H(2884) : z(2884);
-                            let n = 1 === t.side;
-                            e && (n = !n), W(n), 1 === t.blending && !1 === t.transparent ? k(0) : k(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), a.setFunc(t.depthFunc), a.setTest(t.depthTest), a.setMask(t.depthWrite), s.setMask(t.colorWrite);
+                            t.side === d ? _t(2884) : yt(2884);
+                            let n = t.side === u;
+                            e && (n = !n), St(n), t.blending === m && !1 === t.transparent ? wt(p) : wt(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), l.setFunc(t.depthFunc), l.setTest(t.depthTest), l.setMask(t.depthWrite), o.setMask(t.colorWrite);
                             const i = t.stencilWrite;
-                            o.setTest(i), i && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), X(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? z(32926) : H(32926)
+                            c.setTest(i), i && (c.setMask(t.stencilWriteMask), c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Tt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? yt(32926) : _t(32926)
                         },
-                        setFlipSided: W,
-                        setCullFace: j,
+                        setFlipSided: St,
+                        setCullFace: Et,
                         setLineWidth: function(e) {
-                            e !== S && (R && t.lineWidth(e), S = e)
+                            e !== rt && (lt && t.lineWidth(e), rt = e)
                         },
-                        setPolygonOffset: X,
+                        setPolygonOffset: Tt,
                         setScissorTest: function(t) {
-                            t ? z(3089) : H(3089)
+                            t ? yt(3089) : _t(3089)
                         },
-                        activeTexture: q,
+                        activeTexture: At,
                         bindTexture: function(e, n) {
-                            null === P && q();
-                            let i = D[P];
+                            null === ut && At();
+                            let i = dt[ut];
                             void 0 === i && (i = {
                                 type: void 0,
                                 texture: void 0
-                            }, D[P] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || F[e]), i.type = e, i.texture = n)
+                            }, dt[ut] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || xt[e]), i.type = e, i.texture = n)
                         },
                         unbindTexture: function() {
-                            const e = D[P];
+                            const e = dt[ut];
                             void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                         },
                         compressedTexImage2D: function() {
                             try {
                                 t.compressedTexImage2D.apply(t, arguments)
                             } catch (t) {
                                 console.error("THREE.WebGLState:", t)
@@ -24366,100 +24834,100 @@
                             try {
                                 t.compressedTexSubImage2D.apply(t, arguments)
                             } catch (t) {
                                 console.error("THREE.WebGLState:", t)
                             }
                         },
                         scissor: function(e) {
-                            !1 === O.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), O.copy(e))
+                            !1 === ft.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ft.copy(e))
                         },
                         viewport: function(e) {
-                            !1 === U.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), U.copy(e))
+                            !1 === gt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), gt.copy(e))
                         },
                         reset: function() {
-                            t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === r && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), l = {}, P = null, D = {}, c = {}, h = new WeakMap, u = [], d = null, p = !1, m = null, f = null, g = null, v = null, x = null, y = null, _ = null, M = !1, b = null, w = null, S = null, E = null, T = null, O.set(0, 0, t.canvas.width, t.canvas.height), U.set(0, 0, t.canvas.width, t.canvas.height), s.reset(), a.reset(), o.reset()
+                            t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), h = {}, ut = null, dt = {}, k = {}, W = new WeakMap, j = [], X = null, q = !1, Y = null, Z = null, J = null, K = null, Q = null, $ = null, tt = null, et = !1, nt = null, it = null, rt = null, st = null, at = null, ft.set(0, 0, t.canvas.width, t.canvas.height), gt.set(0, 0, t.canvas.width, t.canvas.height), o.reset(), l.reset(), c.reset()
                         }
                     }
                 }
 
-                function as(t, e, n, i, r, s, a) {
-                    const b = r.isWebGL2,
-                        w = r.maxTextures,
-                        S = r.maxCubemapSize,
-                        E = r.maxTextureSize,
-                        T = r.maxSamples,
-                        A = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
-                        R = new WeakMap;
-                    let L, C = !1;
+                function Ya(t, e, n, i, r, s, a) {
+                    const o = r.isWebGL2,
+                        l = r.maxTextures,
+                        c = r.maxCubemapSize,
+                        h = r.maxTextureSize,
+                        u = r.maxSamples,
+                        d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
+                        p = new WeakMap;
+                    let m, f = !1;
                     try {
-                        C = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
+                        f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                     } catch (t) {}
 
-                    function P(t, e) {
-                        return C ? new OffscreenCanvas(t, e) : K("canvas")
+                    function g(t, e) {
+                        return f ? new OffscreenCanvas(t, e) : Oe("canvas")
                     }
 
-                    function N(t, e, n, i) {
+                    function v(t, e, n, i) {
                         let r = 1;
                         if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                             if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
-                                const i = e ? q : Math.floor,
+                                const i = e ? Pe : Math.floor,
                                     s = i(r * t.width),
                                     a = i(r * t.height);
-                                void 0 === L && (L = P(s, a));
-                                const o = n ? P(s, a) : L;
+                                void 0 === m && (m = g(s, a));
+                                const o = n ? g(s, a) : m;
                                 return o.width = s, o.height = a, o.getContext("2d").drawImage(t, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."), o
                             }
                             return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                         }
                         return t
                     }
 
-                    function O(t) {
-                        return X(t.width) && X(t.height)
+                    function x(t) {
+                        return Ce(t.width) && Ce(t.height)
                     }
 
-                    function U(t, e) {
-                        return t.generateMipmaps && e && t.minFilter !== h && t.minFilter !== u
+                    function y(t, e) {
+                        return t.generateMipmaps && e && t.minFilter !== ot && t.minFilter !== ht
                     }
 
-                    function B(e) {
+                    function _(e) {
                         t.generateMipmap(e)
                     }
 
-                    function z(n, i, r, s, a = !1) {
-                        if (!1 === b) return i;
+                    function M(n, i, r, s, a = !1) {
+                        if (!1 === o) return i;
                         if (null !== n) {
                             if (void 0 !== t[n]) return t[n];
                             console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                         }
-                        let o = i;
-                        return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 33319 === i && (5126 === r && (o = 33328), 5131 === r && (o = 33327), 5121 === r && (o = 33323)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = s === I && !1 === a ? 35907 : 32856), 32819 === r && (o = 32854), 32820 === r && (o = 32855)), 33325 !== o && 33326 !== o && 33327 !== o && 33328 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o
+                        let l = i;
+                        return 6403 === i && (5126 === r && (l = 33326), 5131 === r && (l = 33325), 5121 === r && (l = 33321)), 33319 === i && (5126 === r && (l = 33328), 5131 === r && (l = 33327), 5121 === r && (l = 33323)), 6408 === i && (5126 === r && (l = 34836), 5131 === r && (l = 34842), 5121 === r && (l = s === me && !1 === a ? 35907 : 32856), 32819 === r && (l = 32854), 32820 === r && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || e.get("EXT_color_buffer_float"), l
                     }
 
-                    function H(t, e, n) {
-                        return !0 === U(t, n) || t.isFramebufferTexture && t.minFilter !== h && t.minFilter !== u ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
+                    function b(t, e, n) {
+                        return !0 === y(t, n) || t.isFramebufferTexture && t.minFilter !== ot && t.minFilter !== ht ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
                     }
 
-                    function G(t) {
-                        return t === h || 1004 === t || 1005 === t ? 9728 : 9729
+                    function w(t) {
+                        return t === ot || t === lt || t === ct ? 9728 : 9729
                     }
 
-                    function V(e) {
+                    function S(e) {
                         const n = e.target;
-                        n.removeEventListener("dispose", V),
+                        n.removeEventListener("dispose", S),
                             function(e) {
                                 const n = i.get(e);
                                 void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e))
-                            }(n), n.isVideoTexture && R.delete(n), a.memory.textures--
+                            }(n), n.isVideoTexture && p.delete(n), a.memory.textures--
                     }
 
-                    function k(e) {
+                    function E(e) {
                         const n = e.target;
-                        n.removeEventListener("dispose", k),
+                        n.removeEventListener("dispose", E),
                             function(e) {
                                 const n = e.texture,
                                     r = i.get(e),
                                     s = i.get(n);
                                 if (e) {
                                     if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), a.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                         for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
@@ -24469,408 +24937,407 @@
                                             const r = i.get(n[e]);
                                             r.__webglTexture && (t.deleteTexture(r.__webglTexture), a.memory.textures--), i.remove(n[e])
                                         }
                                     i.remove(n), i.remove(e)
                                 }
                             }(n)
                     }
-                    let W = 0;
+                    let T = 0;
 
-                    function j(t, e) {
+                    function A(t, e) {
                         const r = i.get(t);
                         if (t.isVideoTexture && function(t) {
                                 const e = a.render.frame;
-                                R.get(t) !== e && (R.set(t, e), t.update())
+                                p.get(t) !== e && (p.set(t, e), t.update())
                             }(t), t.version > 0 && r.__version !== t.version) {
                             const n = t.image;
                             if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                             else {
-                                if (!1 !== n.complete) return void tt(r, t, e);
+                                if (!1 !== n.complete) return void I(r, t, e);
                                 console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                             }
                         }
                         n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
                     }
 
-                    function Y(e, r) {
+                    function R(e, r) {
                         const a = i.get(e);
                         e.version > 0 && a.__version !== e.version ? function(e, i, r) {
                             if (6 !== i.image.length) return;
-                            $(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
+                            D(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                             const a = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
-                                o = i.image[0] && i.image[0].isDataTexture,
-                                l = [];
-                            for (let t = 0; t < 6; t++) l[t] = a || o ? o ? i.image[t].image : i.image[t] : N(i.image[t], !1, !0, S), l[t] = st(i, l[t]);
-                            const c = l[0],
-                                h = O(c) || b,
-                                u = s.convert(i.format, i.encoding),
-                                d = s.convert(i.type),
-                                p = z(i.internalFormat, u, d, i.encoding),
-                                m = b && !0 !== i.isVideoTexture,
-                                f = void 0 === e.__version;
-                            let g, v = H(i, c, h);
-                            if (Q(34067, i, h), a) {
-                                m && f && n.texStorage2D(34067, v, p, c.width, c.height);
+                                l = i.image[0] && i.image[0].isDataTexture,
+                                h = [];
+                            for (let t = 0; t < 6; t++) h[t] = a || l ? l ? i.image[t].image : i.image[t] : v(i.image[t], !1, !0, c), h[t] = F(i, h[t]);
+                            const u = h[0],
+                                d = x(u) || o,
+                                p = s.convert(i.format, i.encoding),
+                                m = s.convert(i.type),
+                                f = M(i.internalFormat, p, m, i.encoding),
+                                g = o && !0 !== i.isVideoTexture,
+                                w = void 0 === e.__version;
+                            let S, E = b(i, u, d);
+                            if (P(34067, i, d), a) {
+                                g && w && n.texStorage2D(34067, E, f, u.width, u.height);
                                 for (let t = 0; t < 6; t++) {
-                                    g = l[t].mipmaps;
-                                    for (let e = 0; e < g.length; e++) {
-                                        const r = g[e];
-                                        i.format !== y ? null !== u ? m ? n.compressedTexSubImage2D(34069 + t, e, 0, 0, r.width, r.height, u, r.data) : n.compressedTexImage2D(34069 + t, e, p, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : m ? n.texSubImage2D(34069 + t, e, 0, 0, r.width, r.height, u, d, r.data) : n.texImage2D(34069 + t, e, p, r.width, r.height, 0, u, d, r.data)
+                                    S = h[t].mipmaps;
+                                    for (let e = 0; e < S.length; e++) {
+                                        const r = S[e];
+                                        i.format !== Et ? null !== p ? g ? n.compressedTexSubImage2D(34069 + t, e, 0, 0, r.width, r.height, p, r.data) : n.compressedTexImage2D(34069 + t, e, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(34069 + t, e, 0, 0, r.width, r.height, p, m, r.data) : n.texImage2D(34069 + t, e, f, r.width, r.height, 0, p, m, r.data)
                                     }
                                 }
                             } else {
-                                g = i.mipmaps, m && f && (g.length > 0 && v++, n.texStorage2D(34067, v, p, l[0].width, l[0].height));
+                                S = i.mipmaps, g && w && (S.length > 0 && E++, n.texStorage2D(34067, E, f, h[0].width, h[0].height));
                                 for (let t = 0; t < 6; t++)
-                                    if (o) {
-                                        m ? n.texSubImage2D(34069 + t, 0, 0, 0, l[t].width, l[t].height, u, d, l[t].data) : n.texImage2D(34069 + t, 0, p, l[t].width, l[t].height, 0, u, d, l[t].data);
-                                        for (let e = 0; e < g.length; e++) {
-                                            const i = g[e].image[t].image;
-                                            m ? n.texSubImage2D(34069 + t, e + 1, 0, 0, i.width, i.height, u, d, i.data) : n.texImage2D(34069 + t, e + 1, p, i.width, i.height, 0, u, d, i.data)
+                                    if (l) {
+                                        g ? n.texSubImage2D(34069 + t, 0, 0, 0, h[t].width, h[t].height, p, m, h[t].data) : n.texImage2D(34069 + t, 0, f, h[t].width, h[t].height, 0, p, m, h[t].data);
+                                        for (let e = 0; e < S.length; e++) {
+                                            const i = S[e].image[t].image;
+                                            g ? n.texSubImage2D(34069 + t, e + 1, 0, 0, i.width, i.height, p, m, i.data) : n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, p, m, i.data)
                                         }
                                     } else {
-                                        m ? n.texSubImage2D(34069 + t, 0, 0, 0, u, d, l[t]) : n.texImage2D(34069 + t, 0, p, u, d, l[t]);
-                                        for (let e = 0; e < g.length; e++) {
-                                            const i = g[e];
-                                            m ? n.texSubImage2D(34069 + t, e + 1, 0, 0, u, d, i.image[t]) : n.texImage2D(34069 + t, e + 1, p, u, d, i.image[t])
+                                        g ? n.texSubImage2D(34069 + t, 0, 0, 0, p, m, h[t]) : n.texImage2D(34069 + t, 0, f, p, m, h[t]);
+                                        for (let e = 0; e < S.length; e++) {
+                                            const i = S[e];
+                                            g ? n.texSubImage2D(34069 + t, e + 1, 0, 0, p, m, i.image[t]) : n.texImage2D(34069 + t, e + 1, f, p, m, i.image[t])
                                         }
                                     }
                             }
-                            U(i, h) && B(34067), e.__version = i.version, i.onUpdate && i.onUpdate(i)
+                            y(i, d) && _(34067), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                         }(a, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture))
                     }
-                    const Z = {
-                            [o]: 10497,
-                            [l]: 33071,
-                            [c]: 33648
-                        },
-                        J = {
-                            [h]: 9728,
-                            1004: 9984,
-                            1005: 9986,
-                            [u]: 9729,
-                            1007: 9985,
-                            [d]: 9987
+                    const L = {
+                            [rt]: 10497,
+                            [st]: 33071,
+                            [at]: 33648
+                        },
+                        C = {
+                            [ot]: 9728,
+                            [lt]: 9984,
+                            [ct]: 9986,
+                            [ht]: 9729,
+                            [ut]: 9985,
+                            [dt]: 9987
                         };
 
-                    function Q(n, s, a) {
-                        if (a ? (t.texParameteri(n, 10242, Z[s.wrapS]), t.texParameteri(n, 10243, Z[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, Z[s.wrapR]), t.texParameteri(n, 10240, J[s.magFilter]), t.texParameteri(n, 10241, J[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === l && s.wrapT === l || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, G(s.magFilter)), t.texParameteri(n, 10241, G(s.minFilter)), s.minFilter !== h && s.minFilter !== u && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
+                    function P(n, s, a) {
+                        if (a ? (t.texParameteri(n, 10242, L[s.wrapS]), t.texParameteri(n, 10243, L[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, L[s.wrapR]), t.texParameteri(n, 10240, C[s.magFilter]), t.texParameteri(n, 10241, C[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === st && s.wrapT === st || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, w(s.magFilter)), t.texParameteri(n, 10241, w(s.minFilter)), s.minFilter !== ot && s.minFilter !== ht && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                             const a = e.get("EXT_texture_filter_anisotropic");
-                            if (s.type === g && !1 === e.has("OES_texture_float_linear")) return;
-                            if (!1 === b && s.type === v && !1 === e.has("OES_texture_half_float_linear")) return;
+                            if (s.type === yt && !1 === e.has("OES_texture_float_linear")) return;
+                            if (!1 === o && s.type === _t && !1 === e.has("OES_texture_half_float_linear")) return;
                             (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                         }
                     }
 
-                    function $(e, n) {
-                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", V), e.__webglTexture = t.createTexture(), a.memory.textures++)
+                    function D(e, n) {
+                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", S), e.__webglTexture = t.createTexture(), a.memory.textures++)
                     }
 
-                    function tt(e, i, r) {
+                    function I(e, i, r) {
                         let a = 3553;
-                        i.isDataTexture2DArray && (a = 35866), i.isDataTexture3D && (a = 32879), $(e, i), n.activeTexture(33984 + r), n.bindTexture(a, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
-                        const o = function(t) {
-                            return !b && (t.wrapS !== l || t.wrapT !== l || t.minFilter !== h && t.minFilter !== u)
-                        }(i) && !1 === O(i.image);
-                        let c = N(i.image, o, !1, E);
-                        c = st(i, c);
-                        const d = O(c) || b,
-                            p = s.convert(i.format, i.encoding);
-                        let v, w = s.convert(i.type),
-                            S = z(i.internalFormat, p, w, i.encoding, i.isVideoTexture);
-                        Q(a, i, d);
-                        const T = i.mipmaps,
-                            A = b && !0 !== i.isVideoTexture,
-                            R = void 0 === e.__version,
-                            L = H(i, c, d);
-                        if (i.isDepthTexture) S = 6402, b ? S = i.type === g ? 36012 : i.type === f ? 33190 : i.type === x ? 35056 : 33189 : i.type === g && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === _ && 6402 === S && i.type !== m && i.type !== f && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = m, w = s.convert(i.type)), i.format === M && 6402 === S && (S = 34041, i.type !== x && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = x, w = s.convert(i.type))), A && R ? n.texStorage2D(3553, 1, S, c.width, c.height) : n.texImage2D(3553, 0, S, c.width, c.height, 0, p, w, null);
+                        i.isDataTexture2DArray && (a = 35866), i.isDataTexture3D && (a = 32879), D(e, i), n.activeTexture(33984 + r), n.bindTexture(a, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
+                        const l = function(t) {
+                            return !o && (t.wrapS !== st || t.wrapT !== st || t.minFilter !== ot && t.minFilter !== ht)
+                        }(i) && !1 === x(i.image);
+                        let c = v(i.image, l, !1, h);
+                        c = F(i, c);
+                        const u = x(c) || o,
+                            d = s.convert(i.format, i.encoding);
+                        let p, m = s.convert(i.type),
+                            f = M(i.internalFormat, d, m, i.encoding, i.isVideoTexture);
+                        P(a, i, u);
+                        const g = i.mipmaps,
+                            w = o && !0 !== i.isVideoTexture,
+                            S = void 0 === e.__version,
+                            E = b(i, c, u);
+                        if (i.isDepthTexture) f = 6402, o ? f = i.type === yt ? 36012 : i.type === xt ? 33190 : i.type === wt ? 35056 : 33189 : i.type === yt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Rt && 6402 === f && i.type !== gt && i.type !== xt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = gt, m = s.convert(i.type)), i.format === Lt && 6402 === f && (f = 34041, i.type !== wt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = wt, m = s.convert(i.type))), w && S ? n.texStorage2D(3553, 1, f, c.width, c.height) : n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null);
                         else if (i.isDataTexture)
-                            if (T.length > 0 && d) {
-                                A && R && n.texStorage2D(3553, L, S, T[0].width, T[0].height);
-                                for (let t = 0, e = T.length; t < e; t++) v = T[t], A ? n.texSubImage2D(3553, 0, 0, 0, v.width, v.height, p, w, v.data) : n.texImage2D(3553, t, S, v.width, v.height, 0, p, w, v.data);
+                            if (g.length > 0 && u) {
+                                w && S && n.texStorage2D(3553, E, f, g[0].width, g[0].height);
+                                for (let t = 0, e = g.length; t < e; t++) p = g[t], w ? n.texSubImage2D(3553, 0, 0, 0, p.width, p.height, d, m, p.data) : n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                                 i.generateMipmaps = !1
-                            } else A ? (R && n.texStorage2D(3553, L, S, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, c.width, c.height, p, w, c.data)) : n.texImage2D(3553, 0, S, c.width, c.height, 0, p, w, c.data);
+                            } else w ? (S && n.texStorage2D(3553, E, f, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, c.width, c.height, d, m, c.data)) : n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, c.data);
                         else if (i.isCompressedTexture) {
-                            A && R && n.texStorage2D(3553, L, S, T[0].width, T[0].height);
-                            for (let t = 0, e = T.length; t < e; t++) v = T[t], i.format !== y ? null !== p ? A ? n.compressedTexSubImage2D(3553, t, 0, 0, v.width, v.height, p, v.data) : n.compressedTexImage2D(3553, t, S, v.width, v.height, 0, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : A ? n.texSubImage2D(3553, t, 0, 0, v.width, v.height, p, w, v.data) : n.texImage2D(3553, t, S, v.width, v.height, 0, p, w, v.data)
-                        } else if (i.isDataTexture2DArray) A ? (R && n.texStorage3D(35866, L, S, c.width, c.height, c.depth), n.texSubImage3D(35866, 0, 0, 0, 0, c.width, c.height, c.depth, p, w, c.data)) : n.texImage3D(35866, 0, S, c.width, c.height, c.depth, 0, p, w, c.data);
-                        else if (i.isDataTexture3D) A ? (R && n.texStorage3D(32879, L, S, c.width, c.height, c.depth), n.texSubImage3D(32879, 0, 0, 0, 0, c.width, c.height, c.depth, p, w, c.data)) : n.texImage3D(32879, 0, S, c.width, c.height, c.depth, 0, p, w, c.data);
-                        else if (i.isFramebufferTexture) A && R ? n.texStorage2D(3553, L, S, c.width, c.height) : n.texImage2D(3553, 0, S, c.width, c.height, 0, p, w, null);
-                        else if (T.length > 0 && d) {
-                            A && R && n.texStorage2D(3553, L, S, T[0].width, T[0].height);
-                            for (let t = 0, e = T.length; t < e; t++) v = T[t], A ? n.texSubImage2D(3553, t, 0, 0, p, w, v) : n.texImage2D(3553, t, S, p, w, v);
+                            w && S && n.texStorage2D(3553, E, f, g[0].width, g[0].height);
+                            for (let t = 0, e = g.length; t < e; t++) p = g[t], i.format !== Et ? null !== d ? w ? n.compressedTexSubImage2D(3553, t, 0, 0, p.width, p.height, d, p.data) : n.compressedTexImage2D(3553, t, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : w ? n.texSubImage2D(3553, t, 0, 0, p.width, p.height, d, m, p.data) : n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data)
+                        } else if (i.isDataTexture2DArray) w ? (S && n.texStorage3D(35866, E, f, c.width, c.height, c.depth), n.texSubImage3D(35866, 0, 0, 0, 0, c.width, c.height, c.depth, d, m, c.data)) : n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, d, m, c.data);
+                        else if (i.isDataTexture3D) w ? (S && n.texStorage3D(32879, E, f, c.width, c.height, c.depth), n.texSubImage3D(32879, 0, 0, 0, 0, c.width, c.height, c.depth, d, m, c.data)) : n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, d, m, c.data);
+                        else if (i.isFramebufferTexture) w && S ? n.texStorage2D(3553, E, f, c.width, c.height) : n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null);
+                        else if (g.length > 0 && u) {
+                            w && S && n.texStorage2D(3553, E, f, g[0].width, g[0].height);
+                            for (let t = 0, e = g.length; t < e; t++) p = g[t], w ? n.texSubImage2D(3553, t, 0, 0, d, m, p) : n.texImage2D(3553, t, f, d, m, p);
                             i.generateMipmaps = !1
-                        } else A ? (R && n.texStorage2D(3553, L, S, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, p, w, c)) : n.texImage2D(3553, 0, S, p, w, c);
-                        U(i, d) && B(a), e.__version = i.version, i.onUpdate && i.onUpdate(i)
+                        } else w ? (S && n.texStorage2D(3553, E, f, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, d, m, c)) : n.texImage2D(3553, 0, f, d, m, c);
+                        y(i, u) && _(a), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                     }
 
-                    function et(e, r, a, o, l) {
+                    function N(e, r, a, o, l) {
                         const c = s.convert(a.format, a.encoding),
                             h = s.convert(a.type),
-                            u = z(a.internalFormat, c, h, a.encoding);
-                        i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(36160, e), r.useRenderToTexture ? A.framebufferTexture2DMultisampleEXT(36160, o, l, i.get(a).__webglTexture, 0, rt(r)) : t.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(36160, null)
+                            u = M(a.internalFormat, c, h, a.encoding);
+                        i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(36160, e), r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, o, l, i.get(a).__webglTexture, 0, B(r)) : t.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(36160, null)
                     }
 
-                    function nt(e, n, i) {
+                    function O(e, n, i) {
                         if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                             let r = 33189;
                             if (i || n.useRenderToTexture) {
                                 const e = n.depthTexture;
-                                e && e.isDepthTexture && (e.type === g ? r = 36012 : e.type === f && (r = 33190));
-                                const i = rt(n);
-                                n.useRenderToTexture ? A.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
+                                e && e.isDepthTexture && (e.type === yt ? r = 36012 : e.type === xt && (r = 33190));
+                                const i = B(n);
+                                n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                             } else t.renderbufferStorage(36161, r, n.width, n.height);
                             t.framebufferRenderbuffer(36160, 36096, 36161, e)
                         } else if (n.depthBuffer && n.stencilBuffer) {
-                            const r = rt(n);
-                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : n.useRenderToTexture ? A.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)
+                            const r = B(n);
+                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)
                         } else {
                             const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                                 r = s.convert(e.format, e.encoding),
                                 a = s.convert(e.type),
-                                o = z(e.internalFormat, r, a, e.encoding),
-                                l = rt(n);
-                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, l, o, n.width, n.height) : n.useRenderToTexture ? A.renderbufferStorageMultisampleEXT(36161, l, o, n.width, n.height) : t.renderbufferStorage(36161, o, n.width, n.height)
+                                o = M(e.internalFormat, r, a, e.encoding),
+                                l = B(n);
+                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, l, o, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, l, o, n.width, n.height) : t.renderbufferStorage(36161, o, n.width, n.height)
                         }
                         t.bindRenderbuffer(36161, null)
                     }
 
-                    function it(e) {
+                    function U(e) {
                         const r = i.get(e),
                             s = !0 === e.isWebGLCubeRenderTarget;
                         if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                             if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                             ! function(e, r) {
                                 if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                 if (n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
-                                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), j(r.depthTexture, 0);
+                                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), A(r.depthTexture, 0);
                                 const s = i.get(r.depthTexture).__webglTexture,
-                                    a = rt(r);
-                                if (r.depthTexture.format === _) r.useRenderToTexture ? A.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : t.framebufferTexture2D(36160, 36096, 3553, s, 0);
+                                    a = B(r);
+                                if (r.depthTexture.format === Rt) r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                                 else {
-                                    if (r.depthTexture.format !== M) throw new Error("Unknown depthTexture format");
-                                    r.useRenderToTexture ? A.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : t.framebufferTexture2D(36160, 33306, 3553, s, 0)
+                                    if (r.depthTexture.format !== Lt) throw new Error("Unknown depthTexture format");
+                                    r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                                 }
                             }(r.__webglFramebuffer, e)
                         } else if (s) {
                             r.__webglDepthbuffer = [];
-                            for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), nt(r.__webglDepthbuffer[i], e, !1)
-                        } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), nt(r.__webglDepthbuffer, e, !1);
+                            for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), O(r.__webglDepthbuffer[i], e, !1)
+                        } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), O(r.__webglDepthbuffer, e, !1);
                         n.bindFramebuffer(36160, null)
                     }
 
-                    function rt(t) {
-                        return b && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(T, t.samples) : 0
+                    function B(t) {
+                        return o && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(u, t.samples) : 0
                     }
 
-                    function st(t, n) {
+                    function F(t, n) {
                         const i = t.encoding,
                             r = t.format,
                             s = t.type;
-                        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === F || i !== D && (i === I ? !1 === b ? !0 === e.has("EXT_sRGB") && r === y ? (t.format = F, t.minFilter = u, t.generateMipmaps = !1) : n = at.sRGBToLinear(n) : r === y && s === p || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n
+                        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === be || i !== pe && (i === me ? !1 === o ? !0 === e.has("EXT_sRGB") && r === Et ? (t.format = be, t.minFilter = ht, t.generateMipmaps = !1) : n = We.sRGBToLinear(n) : r === Et && s === pt || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n
                     }
-                    let ot = !1,
-                        lt = !1;
+                    let z = !1,
+                        H = !1;
                     this.allocateTextureUnit = function() {
-                        const t = W;
-                        return t >= w && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + w), W += 1, t
+                        const t = T;
+                        return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), T += 1, t
                     }, this.resetTextureUnits = function() {
-                        W = 0
-                    }, this.setTexture2D = j, this.setTexture2DArray = function(t, e) {
+                        T = 0
+                    }, this.setTexture2D = A, this.setTexture2DArray = function(t, e) {
                         const r = i.get(t);
-                        t.version > 0 && r.__version !== t.version ? tt(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
+                        t.version > 0 && r.__version !== t.version ? I(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
                     }, this.setTexture3D = function(t, e) {
                         const r = i.get(t);
-                        t.version > 0 && r.__version !== t.version ? tt(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
-                    }, this.setTextureCube = Y, this.rebindTextures = function(t, e, n) {
+                        t.version > 0 && r.__version !== t.version ? I(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
+                    }, this.setTextureCube = R, this.rebindTextures = function(t, e, n) {
                         const r = i.get(t);
-                        void 0 !== e && et(r.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && it(t)
+                        void 0 !== e && N(r.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && U(t)
                     }, this.setupRenderTarget = function(e) {
-                        const o = e.texture,
-                            l = i.get(e),
-                            c = i.get(o);
-                        e.addEventListener("dispose", k), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = t.createTexture()), c.__version = o.version, a.memory.textures++);
-                        const h = !0 === e.isWebGLCubeRenderTarget,
-                            u = !0 === e.isWebGLMultipleRenderTargets,
-                            d = o.isDataTexture3D || o.isDataTexture2DArray,
-                            p = O(e) || b;
-                        if (h) {
-                            l.__webglFramebuffer = [];
-                            for (let e = 0; e < 6; e++) l.__webglFramebuffer[e] = t.createFramebuffer()
-                        } else if (l.__webglFramebuffer = t.createFramebuffer(), u)
+                        const l = e.texture,
+                            c = i.get(e),
+                            h = i.get(l);
+                        e.addEventListener("dispose", E), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()), h.__version = l.version, a.memory.textures++);
+                        const u = !0 === e.isWebGLCubeRenderTarget,
+                            d = !0 === e.isWebGLMultipleRenderTargets,
+                            p = l.isDataTexture3D || l.isDataTexture2DArray,
+                            m = x(e) || o;
+                        if (u) {
+                            c.__webglFramebuffer = [];
+                            for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
+                        } else if (c.__webglFramebuffer = t.createFramebuffer(), d)
                             if (r.drawBuffers) {
                                 const n = e.texture;
                                 for (let e = 0, r = n.length; e < r; e++) {
                                     const r = i.get(n[e]);
                                     void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), a.memory.textures++)
                                 }
                             } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                         else if (e.useRenderbuffer)
-                            if (b) {
-                                l.__webglMultisampledFramebuffer = t.createFramebuffer(), l.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
-                                const i = s.convert(o.format, o.encoding),
-                                    r = s.convert(o.type),
-                                    a = z(o.internalFormat, i, r, o.encoding),
-                                    c = rt(e);
-                                t.renderbufferStorageMultisample(36161, c, a, e.width, e.height), n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (l.__webglDepthRenderbuffer = t.createRenderbuffer(), nt(l.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
+                            if (o) {
+                                c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
+                                const i = s.convert(l.format, l.encoding),
+                                    r = s.convert(l.type),
+                                    a = M(l.internalFormat, i, r, l.encoding),
+                                    o = B(e);
+                                t.renderbufferStorageMultisample(36161, o, a, e.width, e.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), O(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                             } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
-                        if (h) {
-                            n.bindTexture(34067, c.__webglTexture), Q(34067, o, p);
-                            for (let t = 0; t < 6; t++) et(l.__webglFramebuffer[t], e, o, 36064, 34069 + t);
-                            U(o, p) && B(34067), n.unbindTexture()
-                        } else if (u) {
+                        if (u) {
+                            n.bindTexture(34067, h.__webglTexture), P(34067, l, m);
+                            for (let t = 0; t < 6; t++) N(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
+                            y(l, m) && _(34067), n.unbindTexture()
+                        } else if (d) {
                             const t = e.texture;
                             for (let r = 0, s = t.length; r < s; r++) {
                                 const s = t[r],
                                     a = i.get(s);
-                                n.bindTexture(3553, a.__webglTexture), Q(3553, s, p), et(l.__webglFramebuffer, e, s, 36064 + r, 3553), U(s, p) && B(3553)
+                                n.bindTexture(3553, a.__webglTexture), P(3553, s, m), N(c.__webglFramebuffer, e, s, 36064 + r, 3553), y(s, m) && _(3553)
                             }
                             n.unbindTexture()
                         } else {
                             let t = 3553;
-                            d && (b ? t = o.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(t, c.__webglTexture), Q(t, o, p), et(l.__webglFramebuffer, e, o, 36064, t), U(o, p) && B(t), n.unbindTexture()
+                            p && (o ? t = l.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(t, h.__webglTexture), P(t, l, m), N(c.__webglFramebuffer, e, l, 36064, t), y(l, m) && _(t), n.unbindTexture()
                         }
-                        e.depthBuffer && it(e)
+                        e.depthBuffer && U(e)
                     }, this.updateRenderTargetMipmap = function(t) {
-                        const e = O(t) || b,
+                        const e = x(t) || o,
                             r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                         for (let s = 0, a = r.length; s < a; s++) {
                             const a = r[s];
-                            if (U(a, e)) {
+                            if (y(a, e)) {
                                 const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                     r = i.get(a).__webglTexture;
-                                n.bindTexture(e, r), B(e), n.unbindTexture()
+                                n.bindTexture(e, r), _(e), n.unbindTexture()
                             }
                         }
                     }, this.updateMultisampleRenderTarget = function(e) {
                         if (e.useRenderbuffer)
-                            if (b) {
+                            if (o) {
                                 const r = e.width,
                                     s = e.height;
                                 let a = 16384;
                                 const o = [36064],
                                     l = e.stencilBuffer ? 33306 : 36096;
                                 e.depthBuffer && o.push(l), e.ignoreDepthForMultisampleCopy || (e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024));
                                 const c = i.get(e);
                                 n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, c.__webglFramebuffer), e.ignoreDepthForMultisampleCopy && (t.invalidateFramebuffer(36008, [l]), t.invalidateFramebuffer(36009, [l])), t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728), t.invalidateFramebuffer(36008, o), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
                             } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
-                    }, this.setupDepthRenderbuffer = it, this.setupFrameBufferTexture = et, this.safeSetTexture2D = function(t, e) {
-                        t && t.isWebGLRenderTarget && (!1 === ot && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), ot = !0), t = t.texture), j(t, e)
+                    }, this.setupDepthRenderbuffer = U, this.setupFrameBufferTexture = N, this.safeSetTexture2D = function(t, e) {
+                        t && t.isWebGLRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), z = !0), t = t.texture), A(t, e)
                     }, this.safeSetTextureCube = function(t, e) {
-                        t && t.isWebGLCubeRenderTarget && (!1 === lt && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), lt = !0), t = t.texture), Y(t, e)
+                        t && t.isWebGLCubeRenderTarget && (!1 === H && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), H = !0), t = t.texture), R(t, e)
                     }
                 }
 
-                function os(t, e, n) {
+                function Za(t, e, n) {
                     const i = n.isWebGL2;
                     return {
                         convert: function(t, n = null) {
                             let r;
-                            if (t === p) return 5121;
-                            if (1017 === t) return 32819;
-                            if (1018 === t) return 32820;
-                            if (1010 === t) return 5120;
-                            if (1011 === t) return 5122;
-                            if (t === m) return 5123;
-                            if (1013 === t) return 5124;
-                            if (t === f) return 5125;
-                            if (t === g) return 5126;
-                            if (t === v) return i ? 5131 : (r = e.get("OES_texture_half_float"), null !== r ? r.HALF_FLOAT_OES : null);
-                            if (1021 === t) return 6406;
-                            if (t === y) return 6408;
-                            if (1024 === t) return 6409;
-                            if (1025 === t) return 6410;
-                            if (t === _) return 6402;
-                            if (t === M) return 34041;
-                            if (1028 === t) return 6403;
-                            if (t === F) return r = e.get("EXT_sRGB"), null !== r ? r.SRGB_ALPHA_EXT : null;
-                            if (1029 === t) return 36244;
-                            if (1030 === t) return 33319;
-                            if (1031 === t) return 33320;
-                            if (1033 === t) return 36249;
-                            if (t === b || t === w || t === S || t === E)
-                                if (n === I) {
+                            if (t === pt) return 5121;
+                            if (t === Mt) return 32819;
+                            if (t === bt) return 32820;
+                            if (t === mt) return 5120;
+                            if (t === ft) return 5122;
+                            if (t === gt) return 5123;
+                            if (t === vt) return 5124;
+                            if (t === xt) return 5125;
+                            if (t === yt) return 5126;
+                            if (t === _t) return i ? 5131 : (r = e.get("OES_texture_half_float"), null !== r ? r.HALF_FLOAT_OES : null);
+                            if (t === St) return 6406;
+                            if (t === Et) return 6408;
+                            if (t === Tt) return 6409;
+                            if (t === At) return 6410;
+                            if (t === Rt) return 6402;
+                            if (t === Lt) return 34041;
+                            if (t === Ct) return 6403;
+                            if (t === be) return r = e.get("EXT_sRGB"), null !== r ? r.SRGB_ALPHA_EXT : null;
+                            if (t === Pt) return 36244;
+                            if (t === Dt) return 33319;
+                            if (t === It) return 33320;
+                            if (t === Nt) return 36249;
+                            if (t === Ot || t === Ut || t === Bt || t === Ft)
+                                if (n === me) {
                                     if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === r) return null;
-                                    if (t === b) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
-                                    if (t === w) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
-                                    if (t === S) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
-                                    if (t === E) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
+                                    if (t === Ot) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
+                                    if (t === Ut) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
+                                    if (t === Bt) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
+                                    if (t === Ft) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                 } else {
                                     if (r = e.get("WEBGL_compressed_texture_s3tc"), null === r) return null;
-                                    if (t === b) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
-                                    if (t === w) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
-                                    if (t === S) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
-                                    if (t === E) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
-                                } if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
+                                    if (t === Ot) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
+                                    if (t === Ut) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
+                                    if (t === Bt) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
+                                    if (t === Ft) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
+                                } if (t === zt || t === Ht || t === Gt || t === Vt) {
                                 if (r = e.get("WEBGL_compressed_texture_pvrtc"), null === r) return null;
-                                if (35840 === t) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
-                                if (35841 === t) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
-                                if (35842 === t) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
-                                if (35843 === t) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
+                                if (t === zt) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
+                                if (t === Ht) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
+                                if (t === Gt) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
+                                if (t === Vt) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                             }
-                            if (36196 === t) return r = e.get("WEBGL_compressed_texture_etc1"), null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
-                            if (37492 === t || 37496 === t) {
+                            if (t === kt) return r = e.get("WEBGL_compressed_texture_etc1"), null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
+                            if (t === Wt || t === jt) {
                                 if (r = e.get("WEBGL_compressed_texture_etc"), null === r) return null;
-                                if (37492 === t) return n === I ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
-                                if (37496 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
+                                if (t === Wt) return n === me ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
+                                if (t === jt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                             }
-                            if (37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) {
+                            if (t === Xt || t === qt || t === Yt || t === Zt || t === Jt || t === Kt || t === Qt || t === $t || t === te || t === ee || t === ne || t === ie || t === re || t === se) {
                                 if (r = e.get("WEBGL_compressed_texture_astc"), null === r) return null;
-                                if (37808 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
-                                if (37809 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
-                                if (37810 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
-                                if (37811 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
-                                if (37812 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
-                                if (37813 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
-                                if (37814 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
-                                if (37815 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
-                                if (37816 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
-                                if (37817 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
-                                if (37818 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
-                                if (37819 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
-                                if (37820 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
-                                if (37821 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
+                                if (t === Xt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
+                                if (t === qt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
+                                if (t === Yt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
+                                if (t === Zt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
+                                if (t === Jt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
+                                if (t === Kt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
+                                if (t === Qt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
+                                if (t === $t) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
+                                if (t === te) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
+                                if (t === ee) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
+                                if (t === ne) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
+                                if (t === ie) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
+                                if (t === re) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
+                                if (t === se) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                             }
-                            if (36492 === t) {
+                            if (t === ae) {
                                 if (r = e.get("EXT_texture_compression_bptc"), null === r) return null;
-                                if (36492 === t) return n === I ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT
+                                if (t === ae) return n === me ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT
                             }
-                            return t === x ? i ? 34042 : (r = e.get("WEBGL_depth_texture"), null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0
+                            return t === wt ? i ? 34042 : (r = e.get("WEBGL_depth_texture"), null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                         }
                     }
                 }
-                is.prototype.isMeshDistanceMaterial = !0;
-                class ls extends vn {
+                class Ja extends er {
                     constructor(t = []) {
                         super(), this.cameras = t
                     }
                 }
-                ls.prototype.isArrayCamera = !0;
-                class cs extends ge {
+                Ja.prototype.isArrayCamera = !0;
+                class Ka extends ei {
                     constructor() {
                         super(), this.type = "Group"
                     }
                 }
-                cs.prototype.isGroup = !0;
-                const hs = {
+                Ka.prototype.isGroup = !0;
+                const Qa = {
                     type: "move"
                 };
-                class us {
+                class $a {
                     constructor() {
                         this._targetRay = null, this._grip = null, this._hand = null
                     }
                     getHandSpace() {
-                        return null === this._hand && (this._hand = new cs, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
+                        return null === this._hand && (this._hand = new Ka, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                             pinching: !1
                         }), this._hand
                     }
                     getTargetRaySpace() {
-                        return null === this._targetRay && (this._targetRay = new cs, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new mt, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new mt), this._targetRay
+                        return null === this._targetRay && (this._targetRay = new Ka, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Qe, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Qe), this._targetRay
                     }
                     getGripSpace() {
-                        return null === this._grip && (this._grip = new cs, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new mt, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new mt), this._grip
+                        return null === this._grip && (this._grip = new Ka, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Qe, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Qe), this._grip
                     }
                     dispatchEvent(t) {
                         return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                     }
                     disconnect(t) {
                         return this.dispatchEvent({
                             type: "disconnected",
@@ -24881,20 +25348,20 @@
                         let i = null,
                             r = null,
                             s = null;
                         const a = this._targetRay,
                             o = this._grip,
                             l = this._hand;
                         if (t && "visible-blurred" !== e.session.visibilityState)
-                            if (null !== a && (i = e.getPose(t.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(hs))), l && t.hand) {
+                            if (null !== a && (i = e.getPose(t.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Qa))), l && t.hand) {
                                 s = !0;
                                 for (const i of t.hand.values()) {
                                     const t = e.getJointPose(i, n);
                                     if (void 0 === l.joints[i.jointName]) {
-                                        const t = new cs;
+                                        const t = new Ka;
                                         t.matrixAutoUpdate = !1, t.visible = !1, l.joints[i.jointName] = t, l.add(t)
                                     }
                                     const r = l.joints[i.jointName];
                                     null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
                                 }
                                 const i = l.joints["index-finger-tip"],
                                     r = l.joints["thumb-tip"],
@@ -24910,187 +25377,187 @@
                                     handedness: t.handedness,
                                     target: this
                                 }))
                             } else null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                         return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
                     }
                 }
-                class ds extends lt {
+                class to extends Xe {
                     constructor(t, e, n, i, r, s, a, o, l, c) {
-                        if ((c = void 0 !== c ? c : _) !== _ && c !== M) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
-                        void 0 === n && c === _ && (n = m), void 0 === n && c === M && (n = x), super(null, i, r, s, a, o, c, n, l), this.image = {
+                        if ((c = void 0 !== c ? c : Rt) !== Rt && c !== Lt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
+                        void 0 === n && c === Rt && (n = gt), void 0 === n && c === Lt && (n = wt), super(null, i, r, s, a, o, c, n, l), this.image = {
                             width: t,
                             height: e
-                        }, this.magFilter = void 0 !== a ? a : h, this.minFilter = void 0 !== o ? o : h, this.flipY = !1, this.generateMipmaps = !1
+                        }, this.magFilter = void 0 !== a ? a : ot, this.minFilter = void 0 !== o ? o : ot, this.flipY = !1, this.generateMipmaps = !1
                     }
                 }
-                ds.prototype.isDepthTexture = !0;
-                class ps extends z {
+                to.prototype.isDepthTexture = !0;
+                class eo extends we {
                     constructor(t, e) {
                         super();
                         const n = this;
                         let i = null,
                             r = 1,
                             s = null,
                             a = "local-floor";
                         const o = t.extensions.has("WEBGL_multisampled_render_to_texture");
                         let l = null,
                             c = null,
                             h = null,
                             u = null,
                             d = !1,
-                            f = null;
-                        const g = e.getContextAttributes();
-                        let v = null,
-                            b = null;
-                        const w = [],
-                            S = new Map,
-                            E = new vn;
-                        E.layers.enable(1), E.viewport = new ht;
-                        const T = new vn;
-                        T.layers.enable(2), T.viewport = new ht;
-                        const A = [E, T],
-                            R = new ls;
-                        R.layers.enable(1), R.layers.enable(2);
-                        let L = null,
-                            C = null;
+                            p = null;
+                        const m = e.getContextAttributes();
+                        let f = null,
+                            g = null;
+                        const v = [],
+                            x = new Map,
+                            y = new er;
+                        y.layers.enable(1), y.viewport = new Ye;
+                        const _ = new er;
+                        _.layers.enable(2), _.viewport = new Ye;
+                        const M = [y, _],
+                            b = new Ja;
+                        b.layers.enable(1), b.layers.enable(2);
+                        let w = null,
+                            S = null;
 
-                        function P(t) {
-                            const e = S.get(t.inputSource);
+                        function E(t) {
+                            const e = x.get(t.inputSource);
                             e && e.dispatchEvent({
                                 type: t.type,
                                 data: t.inputSource
                             })
                         }
 
-                        function D() {
-                            S.forEach((function(t, e) {
+                        function T() {
+                            x.forEach((function(t, e) {
                                 t.disconnect(e)
-                            })), S.clear(), L = null, C = null, t.setRenderTarget(v), u = null, h = null, c = null, i = null, b = null, z.stop(), n.isPresenting = !1, n.dispatchEvent({
+                            })), x.clear(), w = null, S = null, t.setRenderTarget(f), u = null, h = null, c = null, i = null, g = null, D.stop(), n.isPresenting = !1, n.dispatchEvent({
                                 type: "sessionend"
                             })
                         }
 
-                        function N(t) {
+                        function A(t) {
                             const e = i.inputSources;
-                            for (let t = 0; t < w.length; t++) S.set(e[t], w[t]);
+                            for (let t = 0; t < v.length; t++) x.set(e[t], v[t]);
                             for (let e = 0; e < t.removed.length; e++) {
                                 const n = t.removed[e],
-                                    i = S.get(n);
+                                    i = x.get(n);
                                 i && (i.dispatchEvent({
                                     type: "disconnected",
                                     data: n
-                                }), S.delete(n))
+                                }), x.delete(n))
                             }
                             for (let e = 0; e < t.added.length; e++) {
                                 const n = t.added[e],
-                                    i = S.get(n);
+                                    i = x.get(n);
                                 i && i.dispatchEvent({
                                     type: "connected",
                                     data: n
                                 })
                             }
                         }
                         this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
-                            let e = w[t];
-                            return void 0 === e && (e = new us, w[t] = e), e.getTargetRaySpace()
+                            let e = v[t];
+                            return void 0 === e && (e = new $a, v[t] = e), e.getTargetRaySpace()
                         }, this.getControllerGrip = function(t) {
-                            let e = w[t];
-                            return void 0 === e && (e = new us, w[t] = e), e.getGripSpace()
+                            let e = v[t];
+                            return void 0 === e && (e = new $a, v[t] = e), e.getGripSpace()
                         }, this.getHand = function(t) {
-                            let e = w[t];
-                            return void 0 === e && (e = new us, w[t] = e), e.getHandSpace()
+                            let e = v[t];
+                            return void 0 === e && (e = new $a, v[t] = e), e.getHandSpace()
                         }, this.setFramebufferScaleFactor = function(t) {
                             r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                         }, this.setReferenceSpaceType = function(t) {
                             a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                         }, this.getReferenceSpace = function() {
                             return s
                         }, this.getBaseLayer = function() {
                             return null !== h ? h : u
                         }, this.getBinding = function() {
                             return c
                         }, this.getFrame = function() {
-                            return f
+                            return p
                         }, this.getSession = function() {
                             return i
                         }, this.setSession = async function(l) {
                             if (i = l, null !== i) {
-                                if (v = t.getRenderTarget(), i.addEventListener("select", P), i.addEventListener("selectstart", P), i.addEventListener("selectend", P), i.addEventListener("squeeze", P), i.addEventListener("squeezestart", P), i.addEventListener("squeezeend", P), i.addEventListener("end", D), i.addEventListener("inputsourceschange", N), !0 !== g.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
+                                if (f = t.getRenderTarget(), i.addEventListener("select", E), i.addEventListener("selectstart", E), i.addEventListener("selectend", E), i.addEventListener("squeeze", E), i.addEventListener("squeezestart", E), i.addEventListener("squeezeend", E), i.addEventListener("end", T), i.addEventListener("inputsourceschange", A), !0 !== m.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                                     const n = {
-                                        antialias: void 0 !== i.renderState.layers || g.antialias,
-                                        alpha: g.alpha,
-                                        depth: g.depth,
-                                        stencil: g.stencil,
+                                        antialias: void 0 !== i.renderState.layers || m.antialias,
+                                        alpha: m.alpha,
+                                        depth: m.depth,
+                                        stencil: m.stencil,
                                         framebufferScaleFactor: r
                                     };
                                     u = new XRWebGLLayer(i, e, n), i.updateRenderState({
                                         baseLayer: u
-                                    }), b = new ut(u.framebufferWidth, u.framebufferHeight, {
-                                        format: y,
-                                        type: p,
+                                    }), g = new Ze(u.framebufferWidth, u.framebufferHeight, {
+                                        format: Et,
+                                        type: pt,
                                         encoding: t.outputEncoding
                                     })
                                 } else {
-                                    d = g.antialias;
+                                    d = m.antialias;
                                     let n = null,
                                         s = null,
                                         a = null;
-                                    g.depth && (a = g.stencil ? 35056 : 33190, n = g.stencil ? M : _, s = g.stencil ? x : m);
+                                    m.depth && (a = m.stencil ? 35056 : 33190, n = m.stencil ? Lt : Rt, s = m.stencil ? wt : gt);
                                     const l = {
-                                        colorFormat: t.outputEncoding === I ? 35907 : 32856,
+                                        colorFormat: t.outputEncoding === me ? 35907 : 32856,
                                         depthFormat: a,
                                         scaleFactor: r
                                     };
                                     c = new XRWebGLBinding(i, e), h = c.createProjectionLayer(l), i.updateRenderState({
                                         layers: [h]
-                                    }), b = d ? new dt(h.textureWidth, h.textureHeight, {
-                                        format: y,
-                                        type: p,
-                                        depthTexture: new ds(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
-                                        stencilBuffer: g.stencil,
+                                    }), g = d ? new Je(h.textureWidth, h.textureHeight, {
+                                        format: Et,
+                                        type: pt,
+                                        depthTexture: new to(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
+                                        stencilBuffer: m.stencil,
                                         ignoreDepth: h.ignoreDepthValues,
                                         useRenderToTexture: o,
                                         encoding: t.outputEncoding
-                                    }) : new ut(h.textureWidth, h.textureHeight, {
-                                        format: y,
-                                        type: p,
-                                        depthTexture: new ds(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
-                                        stencilBuffer: g.stencil,
+                                    }) : new Ze(h.textureWidth, h.textureHeight, {
+                                        format: Et,
+                                        type: pt,
+                                        depthTexture: new to(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
+                                        stencilBuffer: m.stencil,
                                         ignoreDepth: h.ignoreDepthValues,
                                         encoding: t.outputEncoding
                                     })
                                 }
-                                b.isXRRenderTarget = !0, this.setFoveation(1), s = await i.requestReferenceSpace(a), z.setContext(i), z.start(), n.isPresenting = !0, n.dispatchEvent({
+                                g.isXRRenderTarget = !0, this.setFoveation(1), s = await i.requestReferenceSpace(a), D.setContext(i), D.start(), n.isPresenting = !0, n.dispatchEvent({
                                     type: "sessionstart"
                                 })
                             }
                         };
-                        const O = new mt,
-                            U = new mt;
+                        const R = new Qe,
+                            L = new Qe;
 
-                        function B(t, e) {
+                        function C(t, e) {
                             null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                         }
                         this.updateCamera = function(t) {
                             if (null === i) return;
-                            R.near = T.near = E.near = t.near, R.far = T.far = E.far = t.far, L === R.near && C === R.far || (i.updateRenderState({
-                                depthNear: R.near,
-                                depthFar: R.far
-                            }), L = R.near, C = R.far);
+                            b.near = _.near = y.near = t.near, b.far = _.far = y.far = t.far, w === b.near && S === b.far || (i.updateRenderState({
+                                depthNear: b.near,
+                                depthFar: b.far
+                            }), w = b.near, S = b.far);
                             const e = t.parent,
-                                n = R.cameras;
-                            B(R, e);
-                            for (let t = 0; t < n.length; t++) B(n[t], e);
-                            R.matrixWorld.decompose(R.position, R.quaternion, R.scale), t.position.copy(R.position), t.quaternion.copy(R.quaternion), t.scale.copy(R.scale), t.matrix.copy(R.matrix), t.matrixWorld.copy(R.matrixWorld);
+                                n = b.cameras;
+                            C(b, e);
+                            for (let t = 0; t < n.length; t++) C(n[t], e);
+                            b.matrixWorld.decompose(b.position, b.quaternion, b.scale), t.position.copy(b.position), t.quaternion.copy(b.quaternion), t.scale.copy(b.scale), t.matrix.copy(b.matrix), t.matrixWorld.copy(b.matrixWorld);
                             const r = t.children;
                             for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
                             2 === n.length ? function(t, e, n) {
-                                O.setFromMatrixPosition(e.matrixWorld), U.setFromMatrixPosition(n.matrixWorld);
-                                const i = O.distanceTo(U),
+                                R.setFromMatrixPosition(e.matrixWorld), L.setFromMatrixPosition(n.matrixWorld);
+                                const i = R.distanceTo(L),
                                     r = e.projectionMatrix.elements,
                                     s = n.projectionMatrix.elements,
                                     a = r[14] / (r[10] - 1),
                                     o = r[14] / (r[10] + 1),
                                     l = (r[9] + 1) / r[5],
                                     c = (r[9] - 1) / r[5],
                                     h = (r[8] - 1) / r[0],
@@ -25103,87 +25570,87 @@
                                 const g = a + m,
                                     v = o + m,
                                     x = d - f,
                                     y = p + (i - f),
                                     _ = l * o / v * g,
                                     M = c * o / v * g;
                                 t.projectionMatrix.makePerspective(x, y, _, M, g, v)
-                            }(R, E, T) : R.projectionMatrix.copy(E.projectionMatrix)
+                            }(b, y, _) : b.projectionMatrix.copy(y.projectionMatrix)
                         }, this.getCamera = function() {
-                            return R
+                            return b
                         }, this.getFoveation = function() {
                             return null !== h ? h.fixedFoveation : null !== u ? u.fixedFoveation : void 0
                         }, this.setFoveation = function(t) {
                             null !== h && (h.fixedFoveation = t), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = t)
                         };
-                        let F = null;
-                        const z = new Ln;
-                        z.setAnimationLoop((function(e, n) {
-                            if (l = n.getViewerPose(s), f = n, null !== l) {
+                        let P = null;
+                        const D = new pr;
+                        D.setAnimationLoop((function(e, n) {
+                            if (l = n.getViewerPose(s), p = n, null !== l) {
                                 const e = l.views;
-                                null !== u && (t.setRenderTargetFramebuffer(b, u.framebuffer), t.setRenderTarget(b));
+                                null !== u && (t.setRenderTargetFramebuffer(g, u.framebuffer), t.setRenderTarget(g));
                                 let n = !1;
-                                e.length !== R.cameras.length && (R.cameras.length = 0, n = !0);
+                                e.length !== b.cameras.length && (b.cameras.length = 0, n = !0);
                                 for (let i = 0; i < e.length; i++) {
                                     const r = e[i];
                                     let s = null;
                                     if (null !== u) s = u.getViewport(r);
                                     else {
                                         const e = c.getViewSubImage(h, r);
-                                        s = e.viewport, 0 === i && (t.setRenderTargetTextures(b, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(b))
+                                        s = e.viewport, 0 === i && (t.setRenderTargetTextures(g, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(g))
                                     }
-                                    const a = A[i];
-                                    a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && R.matrix.copy(a.matrix), !0 === n && R.cameras.push(a)
+                                    const a = M[i];
+                                    a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && b.matrix.copy(a.matrix), !0 === n && b.cameras.push(a)
                                 }
                             }
                             const r = i.inputSources;
-                            for (let t = 0; t < w.length; t++) {
-                                const e = w[t],
+                            for (let t = 0; t < v.length; t++) {
+                                const e = v[t],
                                     i = r[t];
                                 e.update(i, n, s)
                             }
-                            F && F(e, n), f = null
+                            P && P(e, n), p = null
                         })), this.setAnimationLoop = function(t) {
-                            F = t
+                            P = t
                         }, this.dispose = function() {}
                     }
                 }
 
-                function ms(t) {
+                function no(t) {
                     function e(e, n) {
                         e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
                         const i = t.get(n).envMap;
                         let r, s;
                         i && (e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.ior.value = n.ior, e.refractionRatio.value = n.refractionRatio), n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
                     }
 
                     function n(e, n) {
-                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
+                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === u && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === u && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
                     }
                     return {
                         refreshFogUniforms: function(t, e) {
                             t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                         },
                         refreshMaterialUniforms: function(t, i, r, s, a) {
                             i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) {
                                 e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                             }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) {
-                                e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === u && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === u && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) {
-                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === u && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === u && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function(t, e, i) {
-                                n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
+                                n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === u && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                             }(t, i, a) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) {
-                                e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === u && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === u && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) {
                                 e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) {
                                 e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                             }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) {
-                                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === u && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === u && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                             }(t, i), i.isLineDashedMaterial && function(t, e) {
                                 t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                             }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                                 let r;
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
@@ -25191,559 +25658,559 @@
                                 let n;
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                             }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                         }
                     }
                 }
 
-                function fs(t = {}) {
+                function io(t = {}) {
                     const e = void 0 !== t.canvas ? t.canvas : function() {
-                            const t = K("canvas");
+                            const t = Oe("canvas");
                             return t.style.display = "block", t
                         }(),
                         n = void 0 !== t.context ? t.context : null,
-                        i = void 0 !== t.alpha && t.alpha,
-                        r = void 0 === t.depth || t.depth,
-                        s = void 0 === t.stencil || t.stencil,
-                        a = void 0 !== t.antialias && t.antialias,
-                        o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
+                        r = void 0 !== t.alpha && t.alpha,
+                        s = void 0 === t.depth || t.depth,
+                        a = void 0 === t.stencil || t.stencil,
+                        o = void 0 !== t.antialias && t.antialias,
+                        l = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                         c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
-                        u = void 0 !== t.powerPreference ? t.powerPreference : "default",
+                        p = void 0 !== t.powerPreference ? t.powerPreference : "default",
                         m = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                     let f = null,
-                        x = null;
-                    const _ = [],
-                        M = [];
+                        g = null;
+                    const v = [],
+                        x = [];
                     this.domElement = e, this.debug = {
                         checkShaderErrors: !0
-                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = D, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
-                    const b = this;
-                    let w = !1,
-                        S = 0,
-                        E = 0,
-                        T = null,
-                        A = -1,
-                        R = null;
-                    const L = new ht,
-                        C = new ht;
-                    let P = null,
-                        I = e.width,
-                        N = e.height,
-                        O = 1,
-                        U = null,
-                        B = null;
-                    const F = new ht(0, 0, I, N),
-                        z = new ht(0, 0, I, N);
-                    let H = !1;
-                    const G = new Rn;
-                    let V = !1,
-                        k = !1,
-                        W = null;
-                    const j = new jt,
-                        X = new mt,
-                        q = {
+                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = pe, this.physicallyCorrectLights = !1, this.toneMapping = X, this.toneMappingExposure = 1;
+                    const y = this;
+                    let _ = !1,
+                        M = 0,
+                        b = 0,
+                        w = null,
+                        S = -1,
+                        E = null;
+                    const T = new Ye,
+                        A = new Ye;
+                    let R = null,
+                        L = e.width,
+                        C = e.height,
+                        P = 1,
+                        D = null,
+                        I = null;
+                    const N = new Ye(0, 0, L, C),
+                        O = new Ye(0, 0, L, C);
+                    let U = !1;
+                    const B = new dr;
+                    let F = !1,
+                        z = !1,
+                        H = null;
+                    const G = new Cn,
+                        V = new Qe,
+                        k = {
                             background: null,
                             fog: null,
                             environment: null,
                             overrideMaterial: null,
                             isScene: !0
                         };
 
-                    function Y() {
-                        return null === T ? O : 1
+                    function W() {
+                        return null === w ? P : 1
                     }
-                    let Z, J, Q, $, tt, et, nt, it, rt, st, at, ot, lt, ct, pt, ft, gt, vt, xt, yt, _t, Mt, bt, wt = n;
+                    let j, q, Y, Z, J, K, Q, $, tt, et, nt, it, rt, at, lt, ct, ht, ut, mt, ft, gt, vt, xt, Mt = n;
 
-                    function St(t, n) {
+                    function bt(t, n) {
                         for (let i = 0; i < t.length; i++) {
                             const r = t[i],
                                 s = e.getContext(r, n);
                             if (null !== s) return s
                         }
                         return null
                     }
                     try {
                         const t = {
                             alpha: !0,
-                            depth: r,
-                            stencil: s,
-                            antialias: a,
-                            premultipliedAlpha: o,
+                            depth: s,
+                            stencil: a,
+                            antialias: o,
+                            premultipliedAlpha: l,
                             preserveDrawingBuffer: c,
-                            powerPreference: u,
+                            powerPreference: p,
                             failIfMajorPerformanceCaveat: m
                         };
-                        if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r137"), e.addEventListener("webglcontextlost", At, !1), e.addEventListener("webglcontextrestored", Rt, !1), null === wt) {
+                        if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${i}`), e.addEventListener("webglcontextlost", Tt, !1), e.addEventListener("webglcontextrestored", At, !1), null === Mt) {
                             const e = ["webgl2", "webgl", "experimental-webgl"];
-                            if (!0 === b.isWebGL1Renderer && e.shift(), wt = St(e, t), null === wt) throw St(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
+                            if (!0 === y.isWebGL1Renderer && e.shift(), Mt = bt(e, t), null === Mt) throw bt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                         }
-                        void 0 === wt.getShaderPrecisionFormat && (wt.getShaderPrecisionFormat = function() {
+                        void 0 === Mt.getShaderPrecisionFormat && (Mt.getShaderPrecisionFormat = function() {
                             return {
                                 rangeMin: 1,
                                 rangeMax: 1,
                                 precision: 1
                             }
                         })
                     } catch (t) {
                         throw console.error("THREE.WebGLRenderer: " + t.message), t
                     }
 
-                    function Et() {
-                        Z = new li(wt), J = new Fn(wt, Z, t), Z.init(J), Mt = new os(wt, Z, J), Q = new ss(wt, Z, J), $ = new ui(wt), tt = new jr, et = new as(wt, Z, Q, tt, J, Mt, $), nt = new Hn(b), it = new oi(b), rt = new Cn(wt, J), bt = new Un(wt, Z, rt, J), st = new ci(wt, rt, $, bt), at = new vi(wt, st, rt, $), xt = new gi(wt, J, et), ft = new zn(tt), ot = new Wr(b, nt, it, Z, J, bt, ft), lt = new ms(tt), ct = new Zr, pt = new es(Z, J), vt = new On(b, nt, Q, at, i, o), gt = new rs(b, at, J), yt = new Bn(wt, Z, $, J), _t = new hi(wt, Z, $, J), $.programs = ot.programs, b.capabilities = J, b.extensions = Z, b.properties = tt, b.renderLists = ct, b.shadowMap = gt, b.state = Q, b.info = $
+                    function wt() {
+                        j = new Yr(Mt), q = new br(Mt, j, t), j.init(q), vt = new Za(Mt, j, q), Y = new qa(Mt, j, q), Z = new Kr(Mt), J = new Pa, K = new Ya(Mt, j, Y, J, q, vt, Z), Q = new Sr(y), $ = new qr(y), tt = new mr(Mt, q), xt = new _r(Mt, j, tt, q), et = new Zr(Mt, tt, Z, xt), nt = new is(Mt, et, tt, Z), mt = new ns(Mt, q, K), ct = new wr(J), it = new Ca(y, Q, $, j, q, xt, ct), rt = new no(J), at = new Oa, lt = new Ga(j, q), ut = new yr(y, Q, Y, nt, r, l), ht = new Xa(y, nt, q), ft = new Mr(Mt, j, Z, q), gt = new Jr(Mt, j, Z, q), Z.programs = it.programs, y.capabilities = q, y.extensions = j, y.properties = J, y.renderLists = at, y.shadowMap = ht, y.state = Y, y.info = Z
                     }
-                    Et();
-                    const Tt = new ps(b, wt);
+                    wt();
+                    const St = new eo(y, Mt);
 
-                    function At(t) {
-                        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), w = !0
+                    function Tt(t) {
+                        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0
                     }
 
-                    function Rt() {
-                        console.log("THREE.WebGLRenderer: Context Restored."), w = !1;
-                        const t = $.autoReset,
-                            e = gt.enabled,
-                            n = gt.autoUpdate,
-                            i = gt.needsUpdate,
-                            r = gt.type;
-                        Et(), $.autoReset = t, gt.enabled = e, gt.autoUpdate = n, gt.needsUpdate = i, gt.type = r
+                    function At() {
+                        console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
+                        const t = Z.autoReset,
+                            e = ht.enabled,
+                            n = ht.autoUpdate,
+                            i = ht.needsUpdate,
+                            r = ht.type;
+                        wt(), Z.autoReset = t, ht.enabled = e, ht.autoUpdate = n, ht.needsUpdate = i, ht.type = r
                     }
 
-                    function Lt(t) {
+                    function Rt(t) {
                         const e = t.target;
-                        e.removeEventListener("dispose", Lt),
+                        e.removeEventListener("dispose", Rt),
                             function(t) {
                                 (function(t) {
-                                    const e = tt.get(t).programs;
+                                    const e = J.get(t).programs;
                                     void 0 !== e && (e.forEach((function(t) {
-                                        ot.releaseProgram(t)
-                                    })), t.isShaderMaterial && ot.releaseShaderCache(t))
-                                })(t), tt.remove(t)
+                                        it.releaseProgram(t)
+                                    })), t.isShaderMaterial && it.releaseShaderCache(t))
+                                })(t), J.remove(t)
                             }(e)
                     }
-                    this.xr = Tt, this.getContext = function() {
-                        return wt
+                    this.xr = St, this.getContext = function() {
+                        return Mt
                     }, this.getContextAttributes = function() {
-                        return wt.getContextAttributes()
+                        return Mt.getContextAttributes()
                     }, this.forceContextLoss = function() {
-                        const t = Z.get("WEBGL_lose_context");
+                        const t = j.get("WEBGL_lose_context");
                         t && t.loseContext()
                     }, this.forceContextRestore = function() {
-                        const t = Z.get("WEBGL_lose_context");
+                        const t = j.get("WEBGL_lose_context");
                         t && t.restoreContext()
                     }, this.getPixelRatio = function() {
-                        return O
+                        return P
                     }, this.setPixelRatio = function(t) {
-                        void 0 !== t && (O = t, this.setSize(I, N, !1))
+                        void 0 !== t && (P = t, this.setSize(L, C, !1))
                     }, this.getSize = function(t) {
-                        return t.set(I, N)
+                        return t.set(L, C)
                     }, this.setSize = function(t, n, i) {
-                        Tt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I = t, N = n, e.width = Math.floor(t * O), e.height = Math.floor(n * O), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
+                        St.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (L = t, C = n, e.width = Math.floor(t * P), e.height = Math.floor(n * P), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                     }, this.getDrawingBufferSize = function(t) {
-                        return t.set(I * O, N * O).floor()
+                        return t.set(L * P, C * P).floor()
                     }, this.setDrawingBufferSize = function(t, n, i) {
-                        I = t, N = n, O = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
+                        L = t, C = n, P = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
                     }, this.getCurrentViewport = function(t) {
-                        return t.copy(L)
+                        return t.copy(T)
                     }, this.getViewport = function(t) {
-                        return t.copy(F)
+                        return t.copy(N)
                     }, this.setViewport = function(t, e, n, i) {
-                        t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i), Q.viewport(L.copy(F).multiplyScalar(O).floor())
+                        t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i), Y.viewport(T.copy(N).multiplyScalar(P).floor())
                     }, this.getScissor = function(t) {
-                        return t.copy(z)
+                        return t.copy(O)
                     }, this.setScissor = function(t, e, n, i) {
-                        t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, n, i), Q.scissor(C.copy(z).multiplyScalar(O).floor())
+                        t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i), Y.scissor(A.copy(O).multiplyScalar(P).floor())
                     }, this.getScissorTest = function() {
-                        return H
+                        return U
                     }, this.setScissorTest = function(t) {
-                        Q.setScissorTest(H = t)
+                        Y.setScissorTest(U = t)
                     }, this.setOpaqueSort = function(t) {
-                        U = t
+                        D = t
                     }, this.setTransparentSort = function(t) {
-                        B = t
+                        I = t
                     }, this.getClearColor = function(t) {
-                        return t.copy(vt.getClearColor())
+                        return t.copy(ut.getClearColor())
                     }, this.setClearColor = function() {
-                        vt.setClearColor.apply(vt, arguments)
+                        ut.setClearColor.apply(ut, arguments)
                     }, this.getClearAlpha = function() {
-                        return vt.getClearAlpha()
+                        return ut.getClearAlpha()
                     }, this.setClearAlpha = function() {
-                        vt.setClearAlpha.apply(vt, arguments)
+                        ut.setClearAlpha.apply(ut, arguments)
                     }, this.clear = function(t, e, n) {
                         let i = 0;
-                        (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), wt.clear(i)
+                        (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), Mt.clear(i)
                     }, this.clearColor = function() {
                         this.clear(!0, !1, !1)
                     }, this.clearDepth = function() {
                         this.clear(!1, !0, !1)
                     }, this.clearStencil = function() {
                         this.clear(!1, !1, !0)
                     }, this.dispose = function() {
-                        e.removeEventListener("webglcontextlost", At, !1), e.removeEventListener("webglcontextrestored", Rt, !1), ct.dispose(), pt.dispose(), tt.dispose(), nt.dispose(), it.dispose(), at.dispose(), bt.dispose(), ot.dispose(), Tt.dispose(), Tt.removeEventListener("sessionstart", Pt), Tt.removeEventListener("sessionend", Dt), W && (W.dispose(), W = null), It.stop()
+                        e.removeEventListener("webglcontextlost", Tt, !1), e.removeEventListener("webglcontextrestored", At, !1), at.dispose(), lt.dispose(), J.dispose(), Q.dispose(), $.dispose(), nt.dispose(), xt.dispose(), it.dispose(), St.dispose(), St.removeEventListener("sessionstart", Ct), St.removeEventListener("sessionend", Pt), H && (H.dispose(), H = null), Dt.stop()
                     }, this.renderBufferDirect = function(t, e, n, i, r, s) {
-                        null === e && (e = q);
+                        null === e && (e = k);
                         const a = r.isMesh && r.matrixWorld.determinant() < 0,
                             o = function(t, e, n, i, r) {
-                                !0 !== e.isScene && (e = q), et.resetTextureUnits();
+                                !0 !== e.isScene && (e = k), K.resetTextureUnits();
                                 const s = e.fog,
                                     a = i.isMeshStandardMaterial ? e.environment : null,
-                                    o = null === T ? b.outputEncoding : !0 === T.isXRRenderTarget ? T.texture.encoding : D,
-                                    l = (i.isMeshStandardMaterial ? it : nt).get(i.envMap || a),
+                                    o = null === w ? y.outputEncoding : !0 === w.isXRRenderTarget ? w.texture.encoding : pe,
+                                    l = (i.isMeshStandardMaterial ? $ : Q).get(i.envMap || a),
                                     c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                     h = !!i.normalMap && !!n.attributes.tangent,
                                     u = !!n.morphAttributes.position,
                                     d = !!n.morphAttributes.normal,
                                     p = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
-                                    m = i.toneMapped ? b.toneMapping : 0,
-                                    f = tt.get(i),
-                                    g = x.state.lights;
-                                if (!0 === V && (!0 === k || t !== R)) {
-                                    const e = t === R && i.id === A;
-                                    ft.setState(i, t, e)
-                                }
-                                let v = !1;
-                                i.version === f.__version ? f.needsLights && f.lightsStateVersion !== g.state.version || f.outputEncoding !== o || r.isInstancedMesh && !1 === f.instancing ? v = !0 : r.isInstancedMesh || !0 !== f.instancing ? r.isSkinnedMesh && !1 === f.skinning ? v = !0 : r.isSkinnedMesh || !0 !== f.skinning ? f.envMap !== l || i.fog && f.fog !== s ? v = !0 : void 0 === f.numClippingPlanes || f.numClippingPlanes === ft.numPlanes && f.numIntersection === ft.numIntersection ? (f.vertexAlphas !== c || f.vertexTangents !== h || f.morphTargets !== u || f.morphNormals !== d || f.toneMapping !== m || !0 === J.isWebGL2 && f.morphTargetsCount !== p) && (v = !0) : v = !0 : v = !0 : v = !0 : (v = !0, f.__version = i.version);
-                                let y = f.currentProgram;
-                                !0 === v && (y = Ft(i, e, r));
-                                let _ = !1,
-                                    M = !1,
-                                    w = !1;
-                                const S = y.getUniforms(),
-                                    E = f.uniforms;
-                                if (Q.useProgram(y.program) && (_ = !0, M = !0, w = !0), i.id !== A && (A = i.id, M = !0), _ || R !== t) {
-                                    if (S.setValue(wt, "projectionMatrix", t.projectionMatrix), J.logarithmicDepthBuffer && S.setValue(wt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), R !== t && (R = t, M = !0, w = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
-                                        const e = S.map.cameraPosition;
-                                        void 0 !== e && e.setValue(wt, X.setFromMatrixPosition(t.matrixWorld))
-                                    }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && S.setValue(wt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && S.setValue(wt, "viewMatrix", t.matrixWorldInverse)
+                                    m = i.toneMapped ? y.toneMapping : X,
+                                    f = J.get(i),
+                                    v = g.state.lights;
+                                if (!0 === F && (!0 === z || t !== E)) {
+                                    const e = t === E && i.id === S;
+                                    ct.setState(i, t, e)
+                                }
+                                let x = !1;
+                                i.version === f.__version ? f.needsLights && f.lightsStateVersion !== v.state.version || f.outputEncoding !== o || r.isInstancedMesh && !1 === f.instancing ? x = !0 : r.isInstancedMesh || !0 !== f.instancing ? r.isSkinnedMesh && !1 === f.skinning ? x = !0 : r.isSkinnedMesh || !0 !== f.skinning ? f.envMap !== l || i.fog && f.fog !== s ? x = !0 : void 0 === f.numClippingPlanes || f.numClippingPlanes === ct.numPlanes && f.numIntersection === ct.numIntersection ? (f.vertexAlphas !== c || f.vertexTangents !== h || f.morphTargets !== u || f.morphNormals !== d || f.toneMapping !== m || !0 === q.isWebGL2 && f.morphTargetsCount !== p) && (x = !0) : x = !0 : x = !0 : x = !0 : (x = !0, f.__version = i.version);
+                                let _ = f.currentProgram;
+                                !0 === x && (_ = Bt(i, e, r));
+                                let M = !1,
+                                    b = !1,
+                                    T = !1;
+                                const A = _.getUniforms(),
+                                    R = f.uniforms;
+                                if (Y.useProgram(_.program) && (M = !0, b = !0, T = !0), i.id !== S && (S = i.id, b = !0), M || E !== t) {
+                                    if (A.setValue(Mt, "projectionMatrix", t.projectionMatrix), q.logarithmicDepthBuffer && A.setValue(Mt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), E !== t && (E = t, b = !0, T = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
+                                        const e = A.map.cameraPosition;
+                                        void 0 !== e && e.setValue(Mt, V.setFromMatrixPosition(t.matrixWorld))
+                                    }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && A.setValue(Mt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && A.setValue(Mt, "viewMatrix", t.matrixWorldInverse)
                                 }
                                 if (r.isSkinnedMesh) {
-                                    S.setOptional(wt, r, "bindMatrix"), S.setOptional(wt, r, "bindMatrixInverse");
+                                    A.setOptional(Mt, r, "bindMatrix"), A.setOptional(Mt, r, "bindMatrixInverse");
                                     const t = r.skeleton;
-                                    t && (J.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), S.setValue(wt, "boneTexture", t.boneTexture, et), S.setValue(wt, "boneTextureSize", t.boneTextureSize)) : S.setOptional(wt, t, "boneMatrices"))
+                                    t && (q.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), A.setValue(Mt, "boneTexture", t.boneTexture, K), A.setValue(Mt, "boneTextureSize", t.boneTextureSize)) : A.setOptional(Mt, t, "boneMatrices"))
                                 }
-                                var L, C;
-                                return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || xt.update(r, n, i, y), (M || f.receiveShadow !== r.receiveShadow) && (f.receiveShadow = r.receiveShadow, S.setValue(wt, "receiveShadow", r.receiveShadow)), M && (S.setValue(wt, "toneMappingExposure", b.toneMappingExposure), f.needsLights && (C = w, (L = E).ambientLightColor.needsUpdate = C, L.lightProbe.needsUpdate = C, L.directionalLights.needsUpdate = C, L.directionalLightShadows.needsUpdate = C, L.pointLights.needsUpdate = C, L.pointLightShadows.needsUpdate = C, L.spotLights.needsUpdate = C, L.spotLightShadows.needsUpdate = C, L.rectAreaLights.needsUpdate = C, L.hemisphereLights.needsUpdate = C), s && i.fog && lt.refreshFogUniforms(E, s), lt.refreshMaterialUniforms(E, i, O, N, W), br.upload(wt, f.uniformsList, E, et)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (br.upload(wt, f.uniformsList, E, et), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && S.setValue(wt, "center", r.center), S.setValue(wt, "modelViewMatrix", r.modelViewMatrix), S.setValue(wt, "normalMatrix", r.normalMatrix), S.setValue(wt, "modelMatrix", r.matrixWorld), y
+                                var L, D;
+                                return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || mt.update(r, n, i, _), (b || f.receiveShadow !== r.receiveShadow) && (f.receiveShadow = r.receiveShadow, A.setValue(Mt, "receiveShadow", r.receiveShadow)), b && (A.setValue(Mt, "toneMappingExposure", y.toneMappingExposure), f.needsLights && (D = T, (L = R).ambientLightColor.needsUpdate = D, L.lightProbe.needsUpdate = D, L.directionalLights.needsUpdate = D, L.directionalLightShadows.needsUpdate = D, L.pointLights.needsUpdate = D, L.pointLightShadows.needsUpdate = D, L.spotLights.needsUpdate = D, L.spotLightShadows.needsUpdate = D, L.rectAreaLights.needsUpdate = D, L.hemisphereLights.needsUpdate = D), s && i.fog && rt.refreshFogUniforms(R, s), rt.refreshMaterialUniforms(R, i, P, C, H), la.upload(Mt, f.uniformsList, R, K)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (la.upload(Mt, f.uniformsList, R, K), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && A.setValue(Mt, "center", r.center), A.setValue(Mt, "modelViewMatrix", r.modelViewMatrix), A.setValue(Mt, "normalMatrix", r.normalMatrix), A.setValue(Mt, "modelMatrix", r.matrixWorld), _
                             }(t, e, n, i, r);
-                        Q.setMaterial(i, a);
+                        Y.setMaterial(i, a);
                         let l = n.index;
                         const c = n.attributes.position;
                         if (null === l) {
                             if (void 0 === c || 0 === c.count) return
                         } else if (0 === l.count) return;
                         let h, u = 1;
-                        !0 === i.wireframe && (l = st.getWireframeAttribute(n), u = 2), bt.setup(r, i, o, n, l);
-                        let d = yt;
-                        null !== l && (h = rt.get(l), d = _t, d.setIndex(h));
+                        !0 === i.wireframe && (l = et.getWireframeAttribute(n), u = 2), xt.setup(r, i, o, n, l);
+                        let d = ft;
+                        null !== l && (h = tt.get(l), d = gt, d.setIndex(h));
                         const p = null !== l ? l.count : c.count,
                             m = n.drawRange.start * u,
                             f = n.drawRange.count * u,
-                            g = null !== s ? s.start * u : 0,
-                            v = null !== s ? s.count * u : 1 / 0,
-                            y = Math.max(m, g),
-                            _ = Math.min(p, m + f, g + v) - 1,
-                            M = Math.max(0, _ - y + 1);
-                        if (0 !== M) {
-                            if (r.isMesh) !0 === i.wireframe ? (Q.setLineWidth(i.wireframeLinewidth * Y()), d.setMode(1)) : d.setMode(4);
+                            v = null !== s ? s.start * u : 0,
+                            x = null !== s ? s.count * u : 1 / 0,
+                            _ = Math.max(m, v),
+                            M = Math.min(p, m + f, v + x) - 1,
+                            b = Math.max(0, M - _ + 1);
+                        if (0 !== b) {
+                            if (r.isMesh) !0 === i.wireframe ? (Y.setLineWidth(i.wireframeLinewidth * W()), d.setMode(1)) : d.setMode(4);
                             else if (r.isLine) {
                                 let t = i.linewidth;
-                                void 0 === t && (t = 1), Q.setLineWidth(t * Y()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
+                                void 0 === t && (t = 1), Y.setLineWidth(t * W()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                             } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
-                            if (r.isInstancedMesh) d.renderInstances(y, M, r.count);
+                            if (r.isInstancedMesh) d.renderInstances(_, b, r.count);
                             else if (n.isInstancedBufferGeometry) {
                                 const t = Math.min(n.instanceCount, n._maxInstanceCount);
-                                d.renderInstances(y, M, t)
-                            } else d.render(y, M)
+                                d.renderInstances(_, b, t)
+                            } else d.render(_, b)
                         }
                     }, this.compile = function(t, e) {
-                        x = pt.get(t), x.init(), M.push(x), t.traverseVisible((function(t) {
-                            t.isLight && t.layers.test(e.layers) && (x.pushLight(t), t.castShadow && x.pushShadow(t))
-                        })), x.setupLights(b.physicallyCorrectLights), t.traverse((function(e) {
+                        g = lt.get(t), g.init(), x.push(g), t.traverseVisible((function(t) {
+                            t.isLight && t.layers.test(e.layers) && (g.pushLight(t), t.castShadow && g.pushShadow(t))
+                        })), g.setupLights(y.physicallyCorrectLights), t.traverse((function(e) {
                             const n = e.material;
                             if (n)
                                 if (Array.isArray(n))
-                                    for (let i = 0; i < n.length; i++) Ft(n[i], t, e);
-                                else Ft(n, t, e)
-                        })), M.pop(), x = null
+                                    for (let i = 0; i < n.length; i++) Bt(n[i], t, e);
+                                else Bt(n, t, e)
+                        })), x.pop(), g = null
                     };
-                    let Ct = null;
+                    let Lt = null;
 
-                    function Pt() {
-                        It.stop()
+                    function Ct() {
+                        Dt.stop()
                     }
 
-                    function Dt() {
-                        It.start()
+                    function Pt() {
+                        Dt.start()
                     }
-                    const It = new Ln;
+                    const Dt = new pr;
 
-                    function Nt(t, e, n, i) {
+                    function It(t, e, n, i) {
                         if (!1 === t.visible) return;
                         if (t.layers.test(e.layers))
                             if (t.isGroup) n = t.renderOrder;
                             else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
-                        else if (t.isLight) x.pushLight(t), t.castShadow && x.pushShadow(t);
+                        else if (t.isLight) g.pushLight(t), t.castShadow && g.pushShadow(t);
                         else if (t.isSprite) {
-                            if (!t.frustumCulled || G.intersectsSprite(t)) {
-                                i && X.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
-                                const e = at.update(t),
+                            if (!t.frustumCulled || B.intersectsSprite(t)) {
+                                i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
+                                const e = nt.update(t),
                                     r = t.material;
-                                r.visible && f.push(t, e, r, n, X.z, null)
+                                r.visible && f.push(t, e, r, n, V.z, null)
                             }
-                        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== $.render.frame && (t.skeleton.update(), t.skeleton.frame = $.render.frame), !t.frustumCulled || G.intersectsObject(t))) {
-                            i && X.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
-                            const e = at.update(t),
+                        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Z.render.frame && (t.skeleton.update(), t.skeleton.frame = Z.render.frame), !t.frustumCulled || B.intersectsObject(t))) {
+                            i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
+                            const e = nt.update(t),
                                 r = t.material;
                             if (Array.isArray(r)) {
                                 const i = e.groups;
                                 for (let s = 0, a = i.length; s < a; s++) {
                                     const a = i[s],
                                         o = r[a.materialIndex];
-                                    o && o.visible && f.push(t, e, o, n, X.z, a)
+                                    o && o.visible && f.push(t, e, o, n, V.z, a)
                                 }
-                            } else r.visible && f.push(t, e, r, n, X.z, null)
+                            } else r.visible && f.push(t, e, r, n, V.z, null)
                         }
                         const r = t.children;
-                        for (let t = 0, s = r.length; t < s; t++) Nt(r[t], e, n, i)
+                        for (let t = 0, s = r.length; t < s; t++) It(r[t], e, n, i)
                     }
 
-                    function Ot(t, e, n, i) {
+                    function Nt(t, e, n, i) {
                         const r = t.opaque,
                             s = t.transmissive,
-                            o = t.transparent;
-                        x.setupLightsView(n), s.length > 0 && function(t, e, n) {
-                            if (null === W) {
-                                const t = !0 === a && !0 === J.isWebGL2;
-                                W = new(t ? dt : ut)(1024, 1024, {
+                            a = t.transparent;
+                        g.setupLightsView(n), s.length > 0 && function(t, e, n) {
+                            if (null === H) {
+                                const t = !0 === o && !0 === q.isWebGL2;
+                                H = new(t ? Je : Ze)(1024, 1024, {
                                     generateMipmaps: !0,
-                                    type: null !== Mt.convert(v) ? v : p,
-                                    minFilter: d,
-                                    magFilter: h,
-                                    wrapS: l,
-                                    wrapT: l,
-                                    useRenderToTexture: Z.has("WEBGL_multisampled_render_to_texture")
+                                    type: null !== vt.convert(_t) ? _t : pt,
+                                    minFilter: dt,
+                                    magFilter: ot,
+                                    wrapS: st,
+                                    wrapT: st,
+                                    useRenderToTexture: j.has("WEBGL_multisampled_render_to_texture")
                                 })
                             }
-                            const i = b.getRenderTarget();
-                            b.setRenderTarget(W), b.clear();
-                            const r = b.toneMapping;
-                            b.toneMapping = 0, Ut(t, e, n), b.toneMapping = r, et.updateMultisampleRenderTarget(W), et.updateRenderTargetMipmap(W), b.setRenderTarget(i)
-                        }(r, e, n), i && Q.viewport(L.copy(i)), r.length > 0 && Ut(r, e, n), s.length > 0 && Ut(s, e, n), o.length > 0 && Ut(o, e, n)
+                            const i = y.getRenderTarget();
+                            y.setRenderTarget(H), y.clear();
+                            const r = y.toneMapping;
+                            y.toneMapping = X, Ot(t, e, n), y.toneMapping = r, K.updateMultisampleRenderTarget(H), K.updateRenderTargetMipmap(H), y.setRenderTarget(i)
+                        }(r, e, n), i && Y.viewport(T.copy(i)), r.length > 0 && Ot(r, e, n), s.length > 0 && Ot(s, e, n), a.length > 0 && Ot(a, e, n)
                     }
 
-                    function Ut(t, e, n) {
+                    function Ot(t, e, n) {
                         const i = !0 === e.isScene ? e.overrideMaterial : null;
                         for (let r = 0, s = t.length; r < s; r++) {
                             const s = t[r],
                                 a = s.object,
                                 o = s.geometry,
                                 l = null === i ? s.material : i,
                                 c = s.group;
-                            a.layers.test(n.layers) && Bt(a, e, n, o, l, c)
+                            a.layers.test(n.layers) && Ut(a, e, n, o, l, c)
                         }
                     }
 
-                    function Bt(t, e, n, i, r, s) {
-                        t.onBeforeRender(b, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(b, e, n, i, t, s), !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, b.renderBufferDirect(n, e, i, r, t, s), r.side = 0, r.needsUpdate = !0, b.renderBufferDirect(n, e, i, r, t, s), r.side = 2) : b.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(b, e, n, i, r, s)
+                    function Ut(t, e, n, i, r, s) {
+                        t.onBeforeRender(y, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(y, e, n, i, t, s), !0 === r.transparent && r.side === d ? (r.side = u, r.needsUpdate = !0, y.renderBufferDirect(n, e, i, r, t, s), r.side = h, r.needsUpdate = !0, y.renderBufferDirect(n, e, i, r, t, s), r.side = d) : y.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(y, e, n, i, r, s)
                     }
 
-                    function Ft(t, e, n) {
-                        !0 !== e.isScene && (e = q);
-                        const i = tt.get(t),
-                            r = x.state.lights,
-                            s = x.state.shadowsArray,
+                    function Bt(t, e, n) {
+                        !0 !== e.isScene && (e = k);
+                        const i = J.get(t),
+                            r = g.state.lights,
+                            s = g.state.shadowsArray,
                             a = r.state.version,
-                            o = ot.getParameters(t, r.state, s, e, n),
-                            l = ot.getProgramCacheKey(o);
+                            o = it.getParameters(t, r.state, s, e, n),
+                            l = it.getProgramCacheKey(o);
                         let c = i.programs;
-                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? it : nt).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", Lt), c = new Map, i.programs = c);
+                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? $ : Q).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", Rt), c = new Map, i.programs = c);
                         let h = c.get(l);
                         if (void 0 !== h) {
-                            if (i.currentProgram === h && i.lightsStateVersion === a) return zt(t, o), h
-                        } else o.uniforms = ot.getUniforms(t), t.onBuild(n, o, b), t.onBeforeCompile(o, b), h = ot.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
+                            if (i.currentProgram === h && i.lightsStateVersion === a) return Ft(t, o), h
+                        } else o.uniforms = it.getUniforms(t), t.onBuild(n, o, y), t.onBeforeCompile(o, y), h = it.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
                         const u = i.uniforms;
-                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = ft.uniform), zt(t, o), i.needsLights = function(t) {
+                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = ct.uniform), Ft(t, o), i.needsLights = function(t) {
                             return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                         }(t), i.lightsStateVersion = a, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                         const d = h.getUniforms(),
-                            p = br.seqWithValue(d.seq, u);
+                            p = la.seqWithValue(d.seq, u);
                         return i.currentProgram = h, i.uniformsList = p, h
                     }
 
-                    function zt(t, e) {
-                        const n = tt.get(t);
+                    function Ft(t, e) {
+                        const n = J.get(t);
                         n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
                     }
-                    It.setAnimationLoop((function(t) {
-                        Ct && Ct(t)
-                    })), "undefined" != typeof window && It.setContext(window), this.setAnimationLoop = function(t) {
-                        Ct = t, Tt.setAnimationLoop(t), null === t ? It.stop() : It.start()
-                    }, Tt.addEventListener("sessionstart", Pt), Tt.addEventListener("sessionend", Dt), this.render = function(t, e) {
+                    Dt.setAnimationLoop((function(t) {
+                        Lt && Lt(t)
+                    })), "undefined" != typeof window && Dt.setContext(window), this.setAnimationLoop = function(t) {
+                        Lt = t, St.setAnimationLoop(t), null === t ? Dt.stop() : Dt.start()
+                    }, St.addEventListener("sessionstart", Ct), St.addEventListener("sessionend", Pt), this.render = function(t, e) {
                         if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
-                        if (!0 === w) return;
-                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === Tt.enabled && !0 === Tt.isPresenting && (!0 === Tt.cameraAutoUpdate && Tt.updateCamera(e), e = Tt.getCamera()), !0 === t.isScene && t.onBeforeRender(b, t, e, T), x = pt.get(t, M.length), x.init(), M.push(x), j.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), G.setFromProjectionMatrix(j), k = this.localClippingEnabled, V = ft.init(this.clippingPlanes, k, e), f = ct.get(t, _.length), f.init(), _.push(f), Nt(t, e, 0, b.sortObjects), f.finish(), !0 === b.sortObjects && f.sort(U, B), !0 === V && ft.beginShadows();
-                        const n = x.state.shadowsArray;
-                        if (gt.render(n, t, e), !0 === V && ft.endShadows(), !0 === this.info.autoReset && this.info.reset(), vt.render(f, t), x.setupLights(b.physicallyCorrectLights), e.isArrayCamera) {
+                        if (!0 === _) return;
+                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === St.enabled && !0 === St.isPresenting && (!0 === St.cameraAutoUpdate && St.updateCamera(e), e = St.getCamera()), !0 === t.isScene && t.onBeforeRender(y, t, e, w), g = lt.get(t, x.length), g.init(), x.push(g), G.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), B.setFromProjectionMatrix(G), z = this.localClippingEnabled, F = ct.init(this.clippingPlanes, z, e), f = at.get(t, v.length), f.init(), v.push(f), It(t, e, 0, y.sortObjects), f.finish(), !0 === y.sortObjects && f.sort(D, I), !0 === F && ct.beginShadows();
+                        const n = g.state.shadowsArray;
+                        if (ht.render(n, t, e), !0 === F && ct.endShadows(), !0 === this.info.autoReset && this.info.reset(), ut.render(f, t), g.setupLights(y.physicallyCorrectLights), e.isArrayCamera) {
                             const n = e.cameras;
                             for (let e = 0, i = n.length; e < i; e++) {
                                 const i = n[e];
-                                Ot(f, t, i, i.viewport)
+                                Nt(f, t, i, i.viewport)
                             }
-                        } else Ot(f, t, e);
-                        null !== T && (et.updateMultisampleRenderTarget(T), et.updateRenderTargetMipmap(T)), !0 === t.isScene && t.onAfterRender(b, t, e), Q.buffers.depth.setTest(!0), Q.buffers.depth.setMask(!0), Q.buffers.color.setMask(!0), Q.setPolygonOffset(!1), bt.resetDefaultState(), A = -1, R = null, M.pop(), x = M.length > 0 ? M[M.length - 1] : null, _.pop(), f = _.length > 0 ? _[_.length - 1] : null
+                        } else Nt(f, t, e);
+                        null !== w && (K.updateMultisampleRenderTarget(w), K.updateRenderTargetMipmap(w)), !0 === t.isScene && t.onAfterRender(y, t, e), Y.buffers.depth.setTest(!0), Y.buffers.depth.setMask(!0), Y.buffers.color.setMask(!0), Y.setPolygonOffset(!1), xt.resetDefaultState(), S = -1, E = null, x.pop(), g = x.length > 0 ? x[x.length - 1] : null, v.pop(), f = v.length > 0 ? v[v.length - 1] : null
                     }, this.getActiveCubeFace = function() {
-                        return S
+                        return M
                     }, this.getActiveMipmapLevel = function() {
-                        return E
+                        return b
                     }, this.getRenderTarget = function() {
-                        return T
+                        return w
                     }, this.setRenderTargetTextures = function(t, e, n) {
-                        tt.get(t.texture).__webglTexture = e, tt.get(t.depthTexture).__webglTexture = n;
-                        const i = tt.get(t);
+                        J.get(t.texture).__webglTexture = e, J.get(t.depthTexture).__webglTexture = n;
+                        const i = J.get(t);
                         i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || t.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), t.useRenderToTexture = !1, t.useRenderbuffer = !0))
                     }, this.setRenderTargetFramebuffer = function(t, e) {
-                        const n = tt.get(t);
+                        const n = J.get(t);
                         n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
                     }, this.setRenderTarget = function(t, e = 0, n = 0) {
-                        T = t, S = e, E = n;
+                        w = t, M = e, b = n;
                         let i = !0;
                         if (t) {
-                            const e = tt.get(t);
-                            void 0 !== e.__useDefaultFramebuffer ? (Q.bindFramebuffer(36160, null), i = !1) : void 0 === e.__webglFramebuffer ? et.setupRenderTarget(t) : e.__hasExternalTextures && et.rebindTextures(t, tt.get(t.texture).__webglTexture, tt.get(t.depthTexture).__webglTexture)
+                            const e = J.get(t);
+                            void 0 !== e.__useDefaultFramebuffer ? (Y.bindFramebuffer(36160, null), i = !1) : void 0 === e.__webglFramebuffer ? K.setupRenderTarget(t) : e.__hasExternalTextures && K.rebindTextures(t, J.get(t.texture).__webglTexture, J.get(t.depthTexture).__webglTexture)
                         }
                         let r = null,
                             s = !1,
                             a = !1;
                         if (t) {
                             const n = t.texture;
                             (n.isDataTexture3D || n.isDataTexture2DArray) && (a = !0);
-                            const i = tt.get(t).__webglFramebuffer;
-                            t.isWebGLCubeRenderTarget ? (r = i[e], s = !0) : r = t.useRenderbuffer ? tt.get(t).__webglMultisampledFramebuffer : i, L.copy(t.viewport), C.copy(t.scissor), P = t.scissorTest
-                        } else L.copy(F).multiplyScalar(O).floor(), C.copy(z).multiplyScalar(O).floor(), P = H;
-                        if (Q.bindFramebuffer(36160, r) && J.drawBuffers && i && Q.drawBuffers(t, r), Q.viewport(L), Q.scissor(C), Q.setScissorTest(P), s) {
-                            const i = tt.get(t.texture);
-                            wt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
+                            const i = J.get(t).__webglFramebuffer;
+                            t.isWebGLCubeRenderTarget ? (r = i[e], s = !0) : r = t.useRenderbuffer ? J.get(t).__webglMultisampledFramebuffer : i, T.copy(t.viewport), A.copy(t.scissor), R = t.scissorTest
+                        } else T.copy(N).multiplyScalar(P).floor(), A.copy(O).multiplyScalar(P).floor(), R = U;
+                        if (Y.bindFramebuffer(36160, r) && q.drawBuffers && i && Y.drawBuffers(t, r), Y.viewport(T), Y.scissor(A), Y.setScissorTest(R), s) {
+                            const i = J.get(t.texture);
+                            Mt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                         } else if (a) {
-                            const i = tt.get(t.texture),
+                            const i = J.get(t.texture),
                                 r = e || 0;
-                            wt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
+                            Mt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                         }
-                        A = -1
+                        S = -1
                     }, this.readRenderTargetPixels = function(t, e, n, i, r, s, a) {
                         if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
-                        let o = tt.get(t).__webglFramebuffer;
+                        let o = J.get(t).__webglFramebuffer;
                         if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
-                            Q.bindFramebuffer(36160, o);
+                            Y.bindFramebuffer(36160, o);
                             try {
                                 const a = t.texture,
                                     o = a.format,
                                     l = a.type;
-                                if (o !== y && Mt.convert(o) !== wt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
-                                const c = l === v && (Z.has("EXT_color_buffer_half_float") || J.isWebGL2 && Z.has("EXT_color_buffer_float"));
-                                if (!(l === p || Mt.convert(l) === wt.getParameter(35738) || l === g && (J.isWebGL2 || Z.has("OES_texture_float") || Z.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
-                                36053 === wt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && wt.readPixels(e, n, i, r, Mt.convert(o), Mt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
+                                if (o !== Et && vt.convert(o) !== Mt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
+                                const c = l === _t && (j.has("EXT_color_buffer_half_float") || q.isWebGL2 && j.has("EXT_color_buffer_float"));
+                                if (!(l === pt || vt.convert(l) === Mt.getParameter(35738) || l === yt && (q.isWebGL2 || j.has("OES_texture_float") || j.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
+                                36053 === Mt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && Mt.readPixels(e, n, i, r, vt.convert(o), vt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                             } finally {
-                                const t = null !== T ? tt.get(T).__webglFramebuffer : null;
-                                Q.bindFramebuffer(36160, t)
+                                const t = null !== w ? J.get(w).__webglFramebuffer : null;
+                                Y.bindFramebuffer(36160, t)
                             }
                         }
                     }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                         if (!0 !== e.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
                         const i = Math.pow(2, -n),
                             r = Math.floor(e.image.width * i),
                             s = Math.floor(e.image.height * i);
-                        et.setTexture2D(e, 0), wt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, r, s), Q.unbindTexture()
+                        K.setTexture2D(e, 0), Mt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, r, s), Y.unbindTexture()
                     }, this.copyTextureToTexture = function(t, e, n, i = 0) {
                         const r = e.image.width,
                             s = e.image.height,
-                            a = Mt.convert(n.format),
-                            o = Mt.convert(n.type);
-                        et.setTexture2D(n, 0), wt.pixelStorei(37440, n.flipY), wt.pixelStorei(37441, n.premultiplyAlpha), wt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? wt.texSubImage2D(3553, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? wt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : wt.texSubImage2D(3553, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && wt.generateMipmap(3553), Q.unbindTexture()
+                            a = vt.convert(n.format),
+                            o = vt.convert(n.type);
+                        K.setTexture2D(n, 0), Mt.pixelStorei(37440, n.flipY), Mt.pixelStorei(37441, n.premultiplyAlpha), Mt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? Mt.texSubImage2D(3553, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? Mt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : Mt.texSubImage2D(3553, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && Mt.generateMipmap(3553), Y.unbindTexture()
                     }, this.copyTextureToTexture3D = function(t, e, n, i, r = 0) {
-                        if (b.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
+                        if (y.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                         const s = t.max.x - t.min.x + 1,
                             a = t.max.y - t.min.y + 1,
                             o = t.max.z - t.min.z + 1,
-                            l = Mt.convert(i.format),
-                            c = Mt.convert(i.type);
+                            l = vt.convert(i.format),
+                            c = vt.convert(i.type);
                         let h;
-                        if (i.isDataTexture3D) et.setTexture3D(i, 0), h = 32879;
+                        if (i.isDataTexture3D) K.setTexture3D(i, 0), h = 32879;
                         else {
                             if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
-                            et.setTexture2DArray(i, 0), h = 35866
+                            K.setTexture2DArray(i, 0), h = 35866
                         }
-                        wt.pixelStorei(37440, i.flipY), wt.pixelStorei(37441, i.premultiplyAlpha), wt.pixelStorei(3317, i.unpackAlignment);
-                        const u = wt.getParameter(3314),
-                            d = wt.getParameter(32878),
-                            p = wt.getParameter(3316),
-                            m = wt.getParameter(3315),
-                            f = wt.getParameter(32877),
+                        Mt.pixelStorei(37440, i.flipY), Mt.pixelStorei(37441, i.premultiplyAlpha), Mt.pixelStorei(3317, i.unpackAlignment);
+                        const u = Mt.getParameter(3314),
+                            d = Mt.getParameter(32878),
+                            p = Mt.getParameter(3316),
+                            m = Mt.getParameter(3315),
+                            f = Mt.getParameter(32877),
                             g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
-                        wt.pixelStorei(3314, g.width), wt.pixelStorei(32878, g.height), wt.pixelStorei(3316, t.min.x), wt.pixelStorei(3315, t.min.y), wt.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? wt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), wt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data)) : wt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g), wt.pixelStorei(3314, u), wt.pixelStorei(32878, d), wt.pixelStorei(3316, p), wt.pixelStorei(3315, m), wt.pixelStorei(32877, f), 0 === r && i.generateMipmaps && wt.generateMipmap(h), Q.unbindTexture()
+                        Mt.pixelStorei(3314, g.width), Mt.pixelStorei(32878, g.height), Mt.pixelStorei(3316, t.min.x), Mt.pixelStorei(3315, t.min.y), Mt.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Mt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data)) : Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g), Mt.pixelStorei(3314, u), Mt.pixelStorei(32878, d), Mt.pixelStorei(3316, p), Mt.pixelStorei(3315, m), Mt.pixelStorei(32877, f), 0 === r && i.generateMipmaps && Mt.generateMipmap(h), Y.unbindTexture()
                     }, this.initTexture = function(t) {
-                        et.setTexture2D(t, 0), Q.unbindTexture()
+                        K.setTexture2D(t, 0), Y.unbindTexture()
                     }, this.resetState = function() {
-                        S = 0, E = 0, T = null, Q.reset(), bt.reset()
+                        M = 0, b = 0, w = null, Y.reset(), xt.reset()
                     }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                         detail: this
                     }))
                 }
-                fs.prototype.isWebGLRenderer = !0, class extends fs {}.prototype.isWebGL1Renderer = !0;
-                class gs {
+                io.prototype.isWebGLRenderer = !0, class extends io {}.prototype.isWebGL1Renderer = !0;
+                class ro {
                     constructor(t, e = 25e-5) {
-                        this.name = "", this.color = new rt(t), this.density = e
+                        this.name = "", this.color = new Ve(t), this.density = e
                     }
                     clone() {
-                        return new gs(this.color, this.density)
+                        return new ro(this.color, this.density)
                     }
                     toJSON() {
                         return {
                             type: "FogExp2",
                             color: this.color.getHex(),
                             density: this.density
                         }
                     }
                 }
-                gs.prototype.isFogExp2 = !0;
-                class vs {
+                ro.prototype.isFogExp2 = !0;
+                class so {
                     constructor(t, e = 1, n = 1e3) {
-                        this.name = "", this.color = new rt(t), this.near = e, this.far = n
+                        this.name = "", this.color = new Ve(t), this.near = e, this.far = n
                     }
                     clone() {
-                        return new vs(this.color, this.near, this.far)
+                        return new so(this.color, this.near, this.far)
                     }
                     toJSON() {
                         return {
                             type: "Fog",
                             color: this.color.getHex(),
                             near: this.near,
                             far: this.far
                         }
                     }
                 }
-                vs.prototype.isFog = !0;
-                class xs extends ge {
+                so.prototype.isFog = !0;
+                class ao extends ei {
                     constructor() {
                         super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                             detail: this
                         }))
                     }
                     copy(t, e) {
                         return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                     }
                 }
-                xs.prototype.isScene = !0;
-                class ys {
+                ao.prototype.isScene = !0;
+                class oo {
                     constructor(t, e) {
-                        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = O, this.updateRange = {
+                        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = ye, this.updateRange = {
                             offset: 0,
                             count: -1
-                        }, this.version = 0, this.uuid = k()
+                        }, this.version = 0, this.uuid = Ae()
                     }
                     onUploadCallback() {}
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                     setUsage(t) {
                         return this.usage = t, this
@@ -25756,56 +26223,56 @@
                         for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                         return this
                     }
                     set(t, e = 0) {
                         return this.array.set(t, e), this
                     }
                     clone(t) {
-                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = k()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
+                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ae()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                         const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                             n = new this.constructor(e, this.stride);
                         return n.setUsage(this.usage), n
                     }
                     onUpload(t) {
                         return this.onUploadCallback = t, this
                     }
                     toJSON(t) {
-                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = k()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
+                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ae()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                             uuid: this.uuid,
                             buffer: this.array.buffer._uuid,
                             type: this.array.constructor.name,
                             stride: this.stride
                         }
                     }
                 }
-                ys.prototype.isInterleavedBuffer = !0;
-                const _s = new mt;
-                class Ms {
+                oo.prototype.isInterleavedBuffer = !0;
+                const lo = new Qe;
+                class co {
                     constructor(t, e, n, i = !1) {
                         this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
                     }
                     get count() {
                         return this.data.count
                     }
                     get array() {
                         return this.data.array
                     }
                     set needsUpdate(t) {
                         this.data.needsUpdate = t
                     }
                     applyMatrix4(t) {
-                        for (let e = 0, n = this.data.count; e < n; e++) _s.x = this.getX(e), _s.y = this.getY(e), _s.z = this.getZ(e), _s.applyMatrix4(t), this.setXYZ(e, _s.x, _s.y, _s.z);
+                        for (let e = 0, n = this.data.count; e < n; e++) lo.x = this.getX(e), lo.y = this.getY(e), lo.z = this.getZ(e), lo.applyMatrix4(t), this.setXYZ(e, lo.x, lo.y, lo.z);
                         return this
                     }
                     applyNormalMatrix(t) {
-                        for (let e = 0, n = this.count; e < n; e++) _s.x = this.getX(e), _s.y = this.getY(e), _s.z = this.getZ(e), _s.applyNormalMatrix(t), this.setXYZ(e, _s.x, _s.y, _s.z);
+                        for (let e = 0, n = this.count; e < n; e++) lo.x = this.getX(e), lo.y = this.getY(e), lo.z = this.getZ(e), lo.applyNormalMatrix(t), this.setXYZ(e, lo.x, lo.y, lo.z);
                         return this
                     }
                     transformDirection(t) {
-                        for (let e = 0, n = this.count; e < n; e++) _s.x = this.getX(e), _s.y = this.getY(e), _s.z = this.getZ(e), _s.transformDirection(t), this.setXYZ(e, _s.x, _s.y, _s.z);
+                        for (let e = 0, n = this.count; e < n; e++) lo.x = this.getX(e), lo.y = this.getY(e), lo.z = this.getZ(e), lo.transformDirection(t), this.setXYZ(e, lo.x, lo.y, lo.z);
                         return this
                     }
                     setX(t, e) {
                         return this.data.array[t * this.data.stride + this.offset] = e, this
                     }
                     setY(t, e) {
                         return this.data.array[t * this.data.stride + this.offset + 1] = e, this
@@ -25841,17 +26308,17 @@
                         if (void 0 === t) {
                             console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                             const t = [];
                             for (let e = 0; e < this.count; e++) {
                                 const n = e * this.data.stride + this.offset;
                                 for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                             }
-                            return new Ie(new this.array.constructor(t), this.itemSize, this.normalized)
+                            return new xi(new this.array.constructor(t), this.itemSize, this.normalized)
                         }
-                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Ms(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
+                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new co(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                     }
                     toJSON(t) {
                         if (void 0 === t) {
                             console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                             const t = [];
                             for (let e = 0; e < this.count; e++) {
                                 const n = e * this.data.stride + this.offset;
@@ -25869,255 +26336,255 @@
                             itemSize: this.itemSize,
                             data: this.data.uuid,
                             offset: this.offset,
                             normalized: this.normalized
                         }
                     }
                 }
-                Ms.prototype.isInterleavedBufferAttribute = !0;
-                class bs extends Le {
+                co.prototype.isInterleavedBufferAttribute = !0;
+                class ho extends mi {
                     constructor(t) {
-                        super(), this.type = "SpriteMaterial", this.color = new rt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
+                        super(), this.type = "SpriteMaterial", this.color = new Ve(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
                     }
                 }
-                let ws;
-                bs.prototype.isSpriteMaterial = !0;
-                const Ss = new mt,
-                    Es = new mt,
-                    Ts = new mt,
-                    As = new Y,
-                    Rs = new Y,
-                    Ls = new jt,
-                    Cs = new mt,
-                    Ps = new mt,
-                    Ds = new mt,
-                    Is = new Y,
-                    Ns = new Y,
-                    Os = new Y;
-
-                function Us(t, e, n, i, r, s) {
-                    As.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (Rs.x = s * As.x - r * As.y, Rs.y = r * As.x + s * As.y) : Rs.copy(As), t.copy(e), t.x += Rs.x, t.y += Rs.y, t.applyMatrix4(Ls)
-                }(class extends ge {
+                let uo;
+                ho.prototype.isSpriteMaterial = !0;
+                const po = new Qe,
+                    mo = new Qe,
+                    fo = new Qe,
+                    go = new De,
+                    vo = new De,
+                    xo = new Cn,
+                    yo = new Qe,
+                    _o = new Qe,
+                    Mo = new Qe,
+                    bo = new De,
+                    wo = new De,
+                    So = new De;
+
+                function Eo(t, e, n, i, r, s) {
+                    go.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (vo.x = s * go.x - r * go.y, vo.y = r * go.x + s * go.y) : vo.copy(go), t.copy(e), t.x += vo.x, t.y += vo.y, t.applyMatrix4(xo)
+                }(class extends ei {
                     constructor(t) {
-                        if (super(), this.type = "Sprite", void 0 === ws) {
-                            ws = new We;
+                        if (super(), this.type = "Sprite", void 0 === uo) {
+                            uo = new Li;
                             const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
-                                e = new ys(t, 5);
-                            ws.setIndex([0, 1, 2, 0, 2, 3]), ws.setAttribute("position", new Ms(e, 3, 0, !1)), ws.setAttribute("uv", new Ms(e, 2, 3, !1))
+                                e = new oo(t, 5);
+                            uo.setIndex([0, 1, 2, 0, 2, 3]), uo.setAttribute("position", new co(e, 3, 0, !1)), uo.setAttribute("uv", new co(e, 2, 3, !1))
                         }
-                        this.geometry = ws, this.material = void 0 !== t ? t : new bs, this.center = new Y(.5, .5)
+                        this.geometry = uo, this.material = void 0 !== t ? t : new ho, this.center = new De(.5, .5)
                     }
                     raycast(t, e) {
-                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Es.setFromMatrixScale(this.matrixWorld), Ls.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Ts.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Es.multiplyScalar(-Ts.z);
+                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), mo.setFromMatrixScale(this.matrixWorld), xo.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), fo.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && mo.multiplyScalar(-fo.z);
                         const n = this.material.rotation;
                         let i, r;
                         0 !== n && (r = Math.cos(n), i = Math.sin(n));
                         const s = this.center;
-                        Us(Cs.set(-.5, -.5, 0), Ts, s, Es, i, r), Us(Ps.set(.5, -.5, 0), Ts, s, Es, i, r), Us(Ds.set(.5, .5, 0), Ts, s, Es, i, r), Is.set(0, 0), Ns.set(1, 0), Os.set(1, 1);
-                        let a = t.ray.intersectTriangle(Cs, Ps, Ds, !1, Ss);
-                        if (null === a && (Us(Ps.set(-.5, .5, 0), Ts, s, Es, i, r), Ns.set(0, 1), a = t.ray.intersectTriangle(Cs, Ds, Ps, !1, Ss), null === a)) return;
-                        const o = t.ray.origin.distanceTo(Ss);
+                        Eo(yo.set(-.5, -.5, 0), fo, s, mo, i, r), Eo(_o.set(.5, -.5, 0), fo, s, mo, i, r), Eo(Mo.set(.5, .5, 0), fo, s, mo, i, r), bo.set(0, 0), wo.set(1, 0), So.set(1, 1);
+                        let a = t.ray.intersectTriangle(yo, _o, Mo, !1, po);
+                        if (null === a && (Eo(_o.set(-.5, .5, 0), fo, s, mo, i, r), wo.set(0, 1), a = t.ray.intersectTriangle(yo, Mo, _o, !1, po), null === a)) return;
+                        const o = t.ray.origin.distanceTo(po);
                         o < t.near || o > t.far || e.push({
                             distance: o,
-                            point: Ss.clone(),
-                            uv: Ae.getUV(Ss, Cs, Ps, Ds, Is, Ns, Os, new Y),
+                            point: po.clone(),
+                            uv: di.getUV(po, yo, _o, Mo, bo, wo, So, new De),
                             face: null,
                             object: this
                         })
                     }
                     copy(t) {
                         return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                     }
                 }).prototype.isSprite = !0;
-                const Bs = new mt,
-                    Fs = new ht,
-                    zs = new ht,
-                    Hs = new mt,
-                    Gs = new jt;
-                class Vs extends cn {
+                const To = new Qe,
+                    Ao = new Ye,
+                    Ro = new Ye,
+                    Lo = new Qe,
+                    Co = new Cn;
+                class Po extends qi {
                     constructor(t, e) {
-                        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new jt, this.bindMatrixInverse = new jt
+                        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Cn, this.bindMatrixInverse = new Cn
                     }
                     copy(t) {
                         return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                     }
                     bind(t, e) {
                         this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                     }
                     pose() {
                         this.skeleton.pose()
                     }
                     normalizeSkinWeights() {
-                        const t = new ht,
+                        const t = new Ye,
                             e = this.geometry.attributes.skinWeight;
                         for (let n = 0, i = e.count; n < i; n++) {
                             t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                             const i = 1 / t.manhattanLength();
                             i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                         }
                     }
                     updateMatrixWorld(t) {
                         super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                     }
                     boneTransform(t, e) {
                         const n = this.skeleton,
                             i = this.geometry;
-                        Fs.fromBufferAttribute(i.attributes.skinIndex, t), zs.fromBufferAttribute(i.attributes.skinWeight, t), Bs.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
+                        Ao.fromBufferAttribute(i.attributes.skinIndex, t), Ro.fromBufferAttribute(i.attributes.skinWeight, t), To.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                         for (let t = 0; t < 4; t++) {
-                            const i = zs.getComponent(t);
+                            const i = Ro.getComponent(t);
                             if (0 !== i) {
-                                const r = Fs.getComponent(t);
-                                Gs.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Hs.copy(Bs).applyMatrix4(Gs), i)
+                                const r = Ao.getComponent(t);
+                                Co.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Lo.copy(To).applyMatrix4(Co), i)
                             }
                         }
                         return e.applyMatrix4(this.bindMatrixInverse)
                     }
                 }
-                Vs.prototype.isSkinnedMesh = !0;
-                (class extends ge {
+                Po.prototype.isSkinnedMesh = !0;
+                (class extends ei {
                     constructor() {
                         super(), this.type = "Bone"
                     }
                 }).prototype.isBone = !0;
-                (class extends lt {
-                    constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, h, u) {
+                (class extends Xe {
+                    constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = ot, c = ot, h, u) {
                         super(null, s, a, o, l, c, i, r, h, u), this.image = {
                             data: t,
                             width: e,
                             height: n
                         }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }).prototype.isDataTexture = !0;
-                class ks extends Ie {
+                class Do extends xi {
                     constructor(t, e, n, i = 1) {
                         "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = i
                     }
                     copy(t) {
                         return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                     }
                 }
-                ks.prototype.isInstancedBufferAttribute = !0;
-                const Ws = new jt,
-                    js = new jt,
-                    Xs = [],
-                    qs = new cn;
-                (class extends cn {
+                Do.prototype.isInstancedBufferAttribute = !0;
+                const Io = new Cn,
+                    No = new Cn,
+                    Oo = [],
+                    Uo = new qi;
+                (class extends qi {
                     constructor(t, e, n) {
-                        super(t, e), this.instanceMatrix = new ks(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
+                        super(t, e), this.instanceMatrix = new Do(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
                     }
                     copy(t) {
                         return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
                     }
                     getColorAt(t, e) {
                         e.fromArray(this.instanceColor.array, 3 * t)
                     }
                     getMatrixAt(t, e) {
                         e.fromArray(this.instanceMatrix.array, 16 * t)
                     }
                     raycast(t, e) {
                         const n = this.matrixWorld,
                             i = this.count;
-                        if (qs.geometry = this.geometry, qs.material = this.material, void 0 !== qs.material)
+                        if (Uo.geometry = this.geometry, Uo.material = this.material, void 0 !== Uo.material)
                             for (let r = 0; r < i; r++) {
-                                this.getMatrixAt(r, Ws), js.multiplyMatrices(n, Ws), qs.matrixWorld = js, qs.raycast(t, Xs);
-                                for (let t = 0, n = Xs.length; t < n; t++) {
-                                    const n = Xs[t];
+                                this.getMatrixAt(r, Io), No.multiplyMatrices(n, Io), Uo.matrixWorld = No, Uo.raycast(t, Oo);
+                                for (let t = 0, n = Oo.length; t < n; t++) {
+                                    const n = Oo[t];
                                     n.instanceId = r, n.object = this, e.push(n)
                                 }
-                                Xs.length = 0
+                                Oo.length = 0
                             }
                     }
                     setColorAt(t, e) {
-                        null === this.instanceColor && (this.instanceColor = new ks(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
+                        null === this.instanceColor && (this.instanceColor = new Do(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                     }
                     setMatrixAt(t, e) {
                         e.toArray(this.instanceMatrix.array, 16 * t)
                     }
                     updateMorphTargets() {}
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }).prototype.isInstancedMesh = !0;
-                class Ys extends Le {
+                class Bo extends mi {
                     constructor(t) {
-                        super(), this.type = "LineBasicMaterial", this.color = new rt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
+                        super(), this.type = "LineBasicMaterial", this.color = new Ve(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
                     }
                 }
-                Ys.prototype.isLineBasicMaterial = !0;
-                const Zs = new mt,
-                    Js = new mt,
-                    Ks = new jt,
-                    Qs = new Wt,
-                    $s = new Ut;
-                class ta extends ge {
-                    constructor(t = new We, e = new Ys) {
+                Bo.prototype.isLineBasicMaterial = !0;
+                const Fo = new Qe,
+                    zo = new Qe,
+                    Ho = new Cn,
+                    Go = new Ln,
+                    Vo = new Mn;
+                class ko extends ei {
+                    constructor(t = new Li, e = new Bo) {
                         super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                     }
                     computeLineDistances() {
                         const t = this.geometry;
                         if (t.isBufferGeometry)
                             if (null === t.index) {
                                 const e = t.attributes.position,
                                     n = [0];
-                                for (let t = 1, i = e.count; t < i; t++) Zs.fromBufferAttribute(e, t - 1), Js.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Zs.distanceTo(Js);
-                                t.setAttribute("lineDistance", new Ue(n, 1))
+                                for (let t = 1, i = e.count; t < i; t++) Fo.fromBufferAttribute(e, t - 1), zo.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Fo.distanceTo(zo);
+                                t.setAttribute("lineDistance", new Mi(n, 1))
                             } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                         else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                         return this
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.matrixWorld,
                             r = t.params.Line.threshold,
                             s = n.drawRange;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), $s.copy(n.boundingSphere), $s.applyMatrix4(i), $s.radius += r, !1 === t.ray.intersectsSphere($s)) return;
-                        Ks.copy(i).invert(), Qs.copy(t.ray).applyMatrix4(Ks);
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), Vo.copy(n.boundingSphere), Vo.applyMatrix4(i), Vo.radius += r, !1 === t.ray.intersectsSphere(Vo)) return;
+                        Ho.copy(i).invert(), Go.copy(t.ray).applyMatrix4(Ho);
                         const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                             o = a * a,
-                            l = new mt,
-                            c = new mt,
-                            h = new mt,
-                            u = new mt,
+                            l = new Qe,
+                            c = new Qe,
+                            h = new Qe,
+                            u = new Qe,
                             d = this.isLineSegments ? 2 : 1;
                         if (n.isBufferGeometry) {
                             const i = n.index,
                                 r = n.attributes.position;
                             if (null !== i)
                                 for (let n = Math.max(0, s.start), a = Math.min(i.count, s.start + s.count) - 1; n < a; n += d) {
                                     const s = i.getX(n),
                                         a = i.getX(n + 1);
-                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a), Qs.distanceSqToSegment(l, c, u, h) > o) continue;
+                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a), Go.distanceSqToSegment(l, c, u, h) > o) continue;
                                     u.applyMatrix4(this.matrixWorld);
                                     const d = t.ray.origin.distanceTo(u);
                                     d < t.near || d > t.far || e.push({
                                         distance: d,
                                         point: h.clone().applyMatrix4(this.matrixWorld),
                                         index: n,
                                         face: null,
                                         faceIndex: null,
                                         object: this
                                     })
                                 } else
                                     for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
-                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), Qs.distanceSqToSegment(l, c, u, h) > o) continue;
+                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), Go.distanceSqToSegment(l, c, u, h) > o) continue;
                                         u.applyMatrix4(this.matrixWorld);
                                         const i = t.ray.origin.distanceTo(u);
                                         i < t.near || i > t.far || e.push({
                                             distance: i,
                                             point: h.clone().applyMatrix4(this.matrixWorld),
                                             index: n,
                                             face: null,
@@ -26144,95 +26611,95 @@
                             }
                         } else {
                             const e = t.morphTargets;
                             void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                         }
                     }
                 }
-                ta.prototype.isLine = !0;
-                const ea = new mt,
-                    na = new mt;
-                class ia extends ta {
+                ko.prototype.isLine = !0;
+                const Wo = new Qe,
+                    jo = new Qe;
+                class Xo extends ko {
                     constructor(t, e) {
                         super(t, e), this.type = "LineSegments"
                     }
                     computeLineDistances() {
                         const t = this.geometry;
                         if (t.isBufferGeometry)
                             if (null === t.index) {
                                 const e = t.attributes.position,
                                     n = [];
-                                for (let t = 0, i = e.count; t < i; t += 2) ea.fromBufferAttribute(e, t), na.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + ea.distanceTo(na);
-                                t.setAttribute("lineDistance", new Ue(n, 1))
+                                for (let t = 0, i = e.count; t < i; t += 2) Wo.fromBufferAttribute(e, t), jo.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Wo.distanceTo(jo);
+                                t.setAttribute("lineDistance", new Mi(n, 1))
                             } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                         else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                         return this
                     }
                 }
-                ia.prototype.isLineSegments = !0;
-                (class extends ta {
+                Xo.prototype.isLineSegments = !0;
+                (class extends ko {
                     constructor(t, e) {
                         super(t, e), this.type = "LineLoop"
                     }
                 }).prototype.isLineLoop = !0;
-                class ra extends Le {
+                class qo extends mi {
                     constructor(t) {
-                        super(), this.type = "PointsMaterial", this.color = new rt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
+                        super(), this.type = "PointsMaterial", this.color = new Ve(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
                     }
                 }
-                ra.prototype.isPointsMaterial = !0;
-                const sa = new jt,
-                    aa = new Wt,
-                    oa = new Ut,
-                    la = new mt;
+                qo.prototype.isPointsMaterial = !0;
+                const Yo = new Cn,
+                    Zo = new Ln,
+                    Jo = new Mn,
+                    Ko = new Qe;
 
-                function ca(t, e, n, i, r, s, a) {
-                    const o = aa.distanceSqToPoint(t);
+                function Qo(t, e, n, i, r, s, a) {
+                    const o = Zo.distanceSqToPoint(t);
                     if (o < n) {
-                        const n = new mt;
-                        aa.closestPointToPoint(t, n), n.applyMatrix4(i);
+                        const n = new Qe;
+                        Zo.closestPointToPoint(t, n), n.applyMatrix4(i);
                         const l = r.ray.origin.distanceTo(n);
                         if (l < r.near || l > r.far) return;
                         s.push({
                             distance: l,
                             distanceToRay: Math.sqrt(o),
                             point: n,
                             index: e,
                             face: null,
                             object: a
                         })
                     }
-                }(class extends ge {
-                    constructor(t = new We, e = new ra) {
+                }(class extends ei {
+                    constructor(t = new Li, e = new qo) {
                         super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.matrixWorld,
                             r = t.params.Points.threshold,
                             s = n.drawRange;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), oa.copy(n.boundingSphere), oa.applyMatrix4(i), oa.radius += r, !1 === t.ray.intersectsSphere(oa)) return;
-                        sa.copy(i).invert(), aa.copy(t.ray).applyMatrix4(sa);
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), Jo.copy(n.boundingSphere), Jo.applyMatrix4(i), Jo.radius += r, !1 === t.ray.intersectsSphere(Jo)) return;
+                        Yo.copy(i).invert(), Zo.copy(t.ray).applyMatrix4(Yo);
                         const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                             o = a * a;
                         if (n.isBufferGeometry) {
                             const r = n.index,
                                 a = n.attributes.position;
                             if (null !== r)
                                 for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                                     const s = r.getX(n);
-                                    la.fromBufferAttribute(a, s), ca(la, s, o, i, t, e, this)
+                                    Ko.fromBufferAttribute(a, s), Qo(Ko, s, o, i, t, e, this)
                                 } else
-                                    for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++) la.fromBufferAttribute(a, n), ca(la, n, o, i, t, e, this)
+                                    for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++) Ko.fromBufferAttribute(a, n), Qo(Ko, n, o, i, t, e, this)
                         } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                     }
                     updateMorphTargets() {
                         const t = this.geometry;
                         if (t.isBufferGeometry) {
                             const e = t.morphAttributes,
                                 n = Object.keys(e);
@@ -26247,50 +26714,50 @@
                                 }
                             }
                         } else {
                             const e = t.morphTargets;
                             void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                         }
                     }
-                }).prototype.isPoints = !0, class extends lt {
+                }).prototype.isPoints = !0, class extends Xe {
                     constructor(t, e, n, i, r, s, a, o, l) {
-                        super(t, e, n, i, r, s, a, o, l), this.minFilter = void 0 !== s ? s : u, this.magFilter = void 0 !== r ? r : u, this.generateMipmaps = !1;
+                        super(t, e, n, i, r, s, a, o, l), this.minFilter = void 0 !== s ? s : ht, this.magFilter = void 0 !== r ? r : ht, this.generateMipmaps = !1;
                         const c = this;
                         "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                             c.needsUpdate = !0, t.requestVideoFrameCallback(e)
                         }))
                     }
                     clone() {
                         return new this.constructor(this.image).copy(this)
                     }
                     update() {
                         const t = this.image;
                         !1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                     }
-                }.prototype.isVideoTexture = !0, class extends lt {
+                }.prototype.isVideoTexture = !0, class extends Xe {
                     constructor(t, e, n) {
                         super({
                             width: t,
                             height: e
-                        }), this.format = n, this.magFilter = h, this.minFilter = h, this.generateMipmaps = !1, this.needsUpdate = !0
+                        }), this.format = n, this.magFilter = ot, this.minFilter = ot, this.generateMipmaps = !1, this.needsUpdate = !0
                     }
                 }.prototype.isFramebufferTexture = !0;
-                (class extends lt {
+                (class extends Xe {
                     constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
                         super(null, s, a, o, l, c, i, r, h, u), this.image = {
                             width: e,
                             height: n
                         }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                     }
-                }).prototype.isCompressedTexture = !0, class extends lt {
+                }).prototype.isCompressedTexture = !0, class extends Xe {
                     constructor(t, e, n, i, r, s, a, o, l) {
                         super(t, e, n, i, r, s, a, o, l), this.needsUpdate = !0
                     }
-                }.prototype.isCanvasTexture = !0, new mt, new mt, new mt, new Ae;
-                class ha {
+                }.prototype.isCanvasTexture = !0, new Qe, new Qe, new Qe, new di;
+                class $o {
                     constructor() {
                         this.type = "Curve", this.arcLengthDivisions = 200
                     }
                     getPoint() {
                         return console.warn("THREE.Curve: .getPoint() not implemented."), null
                     }
                     getPointAt(t, e) {
@@ -26347,48 +26814,48 @@
                     getTangent(t, e) {
                         const n = 1e-4;
                         let i = t - n,
                             r = t + n;
                         i < 0 && (i = 0), r > 1 && (r = 1);
                         const s = this.getPoint(i),
                             a = this.getPoint(r),
-                            o = e || (s.isVector2 ? new Y : new mt);
+                            o = e || (s.isVector2 ? new De : new Qe);
                         return o.copy(a).sub(s).normalize(), o
                     }
                     getTangentAt(t, e) {
                         const n = this.getUtoTmapping(t);
                         return this.getTangent(n, e)
                     }
                     computeFrenetFrames(t, e) {
-                        const n = new mt,
+                        const n = new Qe,
                             i = [],
                             r = [],
                             s = [],
-                            a = new mt,
-                            o = new jt;
+                            a = new Qe,
+                            o = new Cn;
                         for (let e = 0; e <= t; e++) {
                             const n = e / t;
-                            i[e] = this.getTangentAt(n, new mt)
+                            i[e] = this.getTangentAt(n, new Qe)
                         }
-                        r[0] = new mt, s[0] = new mt;
+                        r[0] = new Qe, s[0] = new Qe;
                         let l = Number.MAX_VALUE;
                         const c = Math.abs(i[0].x),
                             h = Math.abs(i[0].y),
                             u = Math.abs(i[0].z);
                         c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), s[0].crossVectors(i[0], r[0]);
                         for (let e = 1; e <= t; e++) {
                             if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), a.crossVectors(i[e - 1], i[e]), a.length() > Number.EPSILON) {
                                 a.normalize();
-                                const t = Math.acos(W(i[e - 1].dot(i[e]), -1, 1));
+                                const t = Math.acos(Re(i[e - 1].dot(i[e]), -1, 1));
                                 r[e].applyMatrix4(o.makeRotationAxis(a, t))
                             }
                             s[e].crossVectors(i[e], r[e])
                         }
                         if (!0 === e) {
-                            let e = Math.acos(W(r[0].dot(r[t]), -1, 1));
+                            let e = Math.acos(Re(r[0].dot(r[t]), -1, 1));
                             e /= t, i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                             for (let n = 1; n <= t; n++) r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
                         }
                         return {
                             tangents: i,
                             normals: r,
                             binormals: s
@@ -26410,20 +26877,20 @@
                         };
                         return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                     }
                     fromJSON(t) {
                         return this.arcLengthDivisions = t.arcLengthDivisions, this
                     }
                 }
-                class ua extends ha {
+                class tl extends $o {
                     constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
                         super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
                     }
                     getPoint(t, e) {
-                        const n = e || new Y,
+                        const n = e || new De,
                             i = 2 * Math.PI;
                         let r = this.aEndAngle - this.aStartAngle;
                         const s = Math.abs(r) < Number.EPSILON;
                         for (; r < 0;) r += i;
                         for (; r > i;) r -= i;
                         r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                         const a = this.aStartAngle + t * r;
@@ -26445,22 +26912,22 @@
                         const t = super.toJSON();
                         return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                     }
                 }
-                ua.prototype.isEllipseCurve = !0;
-                class da extends ua {
+                tl.prototype.isEllipseCurve = !0;
+                class el extends tl {
                     constructor(t, e, n, i, r, s) {
                         super(t, e, n, n, i, r, s), this.type = "ArcCurve"
                     }
                 }
 
-                function pa() {
+                function nl() {
                     let t = 0,
                         e = 0,
                         n = 0,
                         i = 0;
 
                     function r(r, s, a, o) {
                         t = r, e = a, n = -3 * r + 3 * s - 2 * a - o, i = 2 * r - 2 * s + a + o
@@ -26476,41 +26943,41 @@
                         },
                         calc: function(r) {
                             const s = r * r;
                             return t + e * r + n * s + i * (s * r)
                         }
                     }
                 }
-                da.prototype.isArcCurve = !0;
-                const ma = new mt,
-                    fa = new pa,
-                    ga = new pa,
-                    va = new pa;
-                class xa extends ha {
+                el.prototype.isArcCurve = !0;
+                const il = new Qe,
+                    rl = new nl,
+                    sl = new nl,
+                    al = new nl;
+                class ol extends $o {
                     constructor(t = [], e = !1, n = "centripetal", i = .5) {
                         super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i
                     }
-                    getPoint(t, e = new mt) {
+                    getPoint(t, e = new Qe) {
                         const n = e,
                             i = this.points,
                             r = i.length,
                             s = (r - (this.closed ? 0 : 1)) * t;
                         let a, o, l = Math.floor(s),
                             c = s - l;
-                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (ma.subVectors(i[0], i[1]).add(i[0]), a = ma);
+                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (il.subVectors(i[0], i[1]).add(i[0]), a = il);
                         const h = i[l % r],
                             u = i[(l + 1) % r];
-                        if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (ma.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = ma), "centripetal" === this.curveType || "chordal" === this.curveType) {
+                        if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (il.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = il), "centripetal" === this.curveType || "chordal" === this.curveType) {
                             const t = "chordal" === this.curveType ? .5 : .25;
                             let e = Math.pow(a.distanceToSquared(h), t),
                                 n = Math.pow(h.distanceToSquared(u), t),
                                 i = Math.pow(u.distanceToSquared(o), t);
-                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), fa.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i), ga.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i), va.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i)
-                        } else "catmullrom" === this.curveType && (fa.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), ga.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), va.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
-                        return n.set(fa.calc(c), ga.calc(c), va.calc(c)), n
+                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), rl.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i), sl.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i), al.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i)
+                        } else "catmullrom" === this.curveType && (rl.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), sl.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), al.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
+                        return n.set(rl.calc(c), sl.calc(c), al.calc(c)), n
                     }
                     copy(t) {
                         super.copy(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
                             this.points.push(n.clone())
                         }
@@ -26525,188 +26992,188 @@
                         }
                         return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
-                            this.points.push((new mt).fromArray(n))
+                            this.points.push((new Qe).fromArray(n))
                         }
                         return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                     }
                 }
 
-                function ya(t, e, n, i, r) {
+                function ll(t, e, n, i, r) {
                     const s = .5 * (i - e),
                         a = .5 * (r - n),
                         o = t * t;
                     return (2 * n - 2 * i + s + a) * (t * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * t + n
                 }
 
-                function _a(t, e, n, i) {
+                function cl(t, e, n, i) {
                     return function(t, e) {
                         const n = 1 - t;
                         return n * n * e
                     }(t, e) + function(t, e) {
                         return 2 * (1 - t) * t * e
                     }(t, n) + function(t, e) {
                         return t * t * e
                     }(t, i)
                 }
 
-                function Ma(t, e, n, i, r) {
+                function hl(t, e, n, i, r) {
                     return function(t, e) {
                         const n = 1 - t;
                         return n * n * n * e
                     }(t, e) + function(t, e) {
                         const n = 1 - t;
                         return 3 * n * n * t * e
                     }(t, n) + function(t, e) {
                         return 3 * (1 - t) * t * t * e
                     }(t, i) + function(t, e) {
                         return t * t * t * e
                     }(t, r)
                 }
-                xa.prototype.isCatmullRomCurve3 = !0;
-                class ba extends ha {
-                    constructor(t = new Y, e = new Y, n = new Y, i = new Y) {
+                ol.prototype.isCatmullRomCurve3 = !0;
+                class ul extends $o {
+                    constructor(t = new De, e = new De, n = new De, i = new De) {
                         super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                     }
-                    getPoint(t, e = new Y) {
+                    getPoint(t, e = new De) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2,
                             a = this.v3;
-                        return n.set(Ma(t, i.x, r.x, s.x, a.x), Ma(t, i.y, r.y, s.y, a.y)), n
+                        return n.set(hl(t, i.x, r.x, s.x, a.x), hl(t, i.y, r.y, s.y, a.y)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                     }
                 }
-                ba.prototype.isCubicBezierCurve = !0;
-                class wa extends ha {
-                    constructor(t = new mt, e = new mt, n = new mt, i = new mt) {
+                ul.prototype.isCubicBezierCurve = !0;
+                class dl extends $o {
+                    constructor(t = new Qe, e = new Qe, n = new Qe, i = new Qe) {
                         super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                     }
-                    getPoint(t, e = new mt) {
+                    getPoint(t, e = new Qe) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2,
                             a = this.v3;
-                        return n.set(Ma(t, i.x, r.x, s.x, a.x), Ma(t, i.y, r.y, s.y, a.y), Ma(t, i.z, r.z, s.z, a.z)), n
+                        return n.set(hl(t, i.x, r.x, s.x, a.x), hl(t, i.y, r.y, s.y, a.y), hl(t, i.z, r.z, s.z, a.z)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                     }
                 }
-                wa.prototype.isCubicBezierCurve3 = !0;
-                class Sa extends ha {
-                    constructor(t = new Y, e = new Y) {
+                dl.prototype.isCubicBezierCurve3 = !0;
+                class pl extends $o {
+                    constructor(t = new De, e = new De) {
                         super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
                     }
-                    getPoint(t, e = new Y) {
+                    getPoint(t, e = new De) {
                         const n = e;
                         return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                     }
                     getPointAt(t, e) {
                         return this.getPoint(t, e)
                     }
                     getTangent(t, e) {
-                        const n = e || new Y;
+                        const n = e || new De;
                         return n.copy(this.v2).sub(this.v1).normalize(), n
                     }
                     copy(t) {
                         return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                Sa.prototype.isLineCurve = !0;
-                class Ea extends ha {
-                    constructor(t = new Y, e = new Y, n = new Y) {
+                pl.prototype.isLineCurve = !0;
+                class ml extends $o {
+                    constructor(t = new De, e = new De, n = new De) {
                         super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
                     }
-                    getPoint(t, e = new Y) {
+                    getPoint(t, e = new De) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2;
-                        return n.set(_a(t, i.x, r.x, s.x), _a(t, i.y, r.y, s.y)), n
+                        return n.set(cl(t, i.x, r.x, s.x), cl(t, i.y, r.y, s.y)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                Ea.prototype.isQuadraticBezierCurve = !0;
-                class Ta extends ha {
-                    constructor(t = new mt, e = new mt, n = new mt) {
+                ml.prototype.isQuadraticBezierCurve = !0;
+                class fl extends $o {
+                    constructor(t = new Qe, e = new Qe, n = new Qe) {
                         super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
                     }
-                    getPoint(t, e = new mt) {
+                    getPoint(t, e = new Qe) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2;
-                        return n.set(_a(t, i.x, r.x, s.x), _a(t, i.y, r.y, s.y), _a(t, i.z, r.z, s.z)), n
+                        return n.set(cl(t, i.x, r.x, s.x), cl(t, i.y, r.y, s.y), cl(t, i.z, r.z, s.z)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                Ta.prototype.isQuadraticBezierCurve3 = !0;
-                class Aa extends ha {
+                fl.prototype.isQuadraticBezierCurve3 = !0;
+                class gl extends $o {
                     constructor(t = []) {
                         super(), this.type = "SplineCurve", this.points = t
                     }
-                    getPoint(t, e = new Y) {
+                    getPoint(t, e = new De) {
                         const n = e,
                             i = this.points,
                             r = (i.length - 1) * t,
                             s = Math.floor(r),
                             a = r - s,
                             o = i[0 === s ? s : s - 1],
                             l = i[s],
                             c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                             h = i[s > i.length - 3 ? i.length - 1 : s + 2];
-                        return n.set(ya(a, o.x, l.x, c.x, h.x), ya(a, o.y, l.y, c.y, h.y)), n
+                        return n.set(ll(a, o.x, l.x, c.x, h.x), ll(a, o.y, l.y, c.y, h.y)), n
                     }
                     copy(t) {
                         super.copy(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
                             this.points.push(n.clone())
                         }
@@ -26721,33 +27188,33 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
-                            this.points.push((new Y).fromArray(n))
+                            this.points.push((new De).fromArray(n))
                         }
                         return this
                     }
                 }
-                Aa.prototype.isSplineCurve = !0;
-                var Ra = Object.freeze({
+                gl.prototype.isSplineCurve = !0;
+                var vl = Object.freeze({
                     __proto__: null,
-                    ArcCurve: da,
-                    CatmullRomCurve3: xa,
-                    CubicBezierCurve: ba,
-                    CubicBezierCurve3: wa,
-                    EllipseCurve: ua,
-                    LineCurve: Sa,
-                    LineCurve3: class extends ha {
-                        constructor(t = new mt, e = new mt) {
+                    ArcCurve: el,
+                    CatmullRomCurve3: ol,
+                    CubicBezierCurve: ul,
+                    CubicBezierCurve3: dl,
+                    EllipseCurve: tl,
+                    LineCurve: pl,
+                    LineCurve3: class extends $o {
+                        constructor(t = new Qe, e = new Qe) {
                             super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                         }
-                        getPoint(t, e = new mt) {
+                        getPoint(t, e = new Qe) {
                             const n = e;
                             return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                         }
                         getPointAt(t, e) {
                             return this.getPoint(t, e)
                         }
                         copy(t) {
@@ -26757,29 +27224,29 @@
                             const t = super.toJSON();
                             return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                         }
                         fromJSON(t) {
                             return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                         }
                     },
-                    QuadraticBezierCurve: Ea,
-                    QuadraticBezierCurve3: Ta,
-                    SplineCurve: Aa
+                    QuadraticBezierCurve: ml,
+                    QuadraticBezierCurve3: fl,
+                    SplineCurve: gl
                 });
-                class La extends ha {
+                class xl extends $o {
                     constructor() {
                         super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                     }
                     add(t) {
                         this.curves.push(t)
                     }
                     closePath() {
                         const t = this.curves[0].getPoint(0),
                             e = this.curves[this.curves.length - 1].getPoint(1);
-                        t.equals(e) || this.curves.push(new Sa(e, t))
+                        t.equals(e) || this.curves.push(new pl(e, t))
                     }
                     getPoint(t, e) {
                         const n = t * this.getLength(),
                             i = this.getCurveLengths();
                         let r = 0;
                         for (; r < i.length;) {
                             if (i[r] >= n) {
@@ -26843,46 +27310,46 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                         for (let e = 0, n = t.curves.length; e < n; e++) {
                             const n = t.curves[e];
-                            this.curves.push((new Ra[n.type]).fromJSON(n))
+                            this.curves.push((new vl[n.type]).fromJSON(n))
                         }
                         return this
                     }
                 }
-                class Ca extends La {
+                class yl extends xl {
                     constructor(t) {
-                        super(), this.type = "Path", this.currentPoint = new Y, t && this.setFromPoints(t)
+                        super(), this.type = "Path", this.currentPoint = new De, t && this.setFromPoints(t)
                     }
                     setFromPoints(t) {
                         this.moveTo(t[0].x, t[0].y);
                         for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                         return this
                     }
                     moveTo(t, e) {
                         return this.currentPoint.set(t, e), this
                     }
                     lineTo(t, e) {
-                        const n = new Sa(this.currentPoint.clone(), new Y(t, e));
+                        const n = new pl(this.currentPoint.clone(), new De(t, e));
                         return this.curves.push(n), this.currentPoint.set(t, e), this
                     }
                     quadraticCurveTo(t, e, n, i) {
-                        const r = new Ea(this.currentPoint.clone(), new Y(t, e), new Y(n, i));
+                        const r = new ml(this.currentPoint.clone(), new De(t, e), new De(n, i));
                         return this.curves.push(r), this.currentPoint.set(n, i), this
                     }
                     bezierCurveTo(t, e, n, i, r, s) {
-                        const a = new ba(this.currentPoint.clone(), new Y(t, e), new Y(n, i), new Y(r, s));
+                        const a = new ul(this.currentPoint.clone(), new De(t, e), new De(n, i), new De(r, s));
                         return this.curves.push(a), this.currentPoint.set(r, s), this
                     }
                     splineThru(t) {
                         const e = [this.currentPoint.clone()].concat(t),
-                            n = new Aa(e);
+                            n = new gl(e);
                         return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                     }
                     arc(t, e, n, i, r, s) {
                         const a = this.currentPoint.x,
                             o = this.currentPoint.y;
                         return this.absarc(t + a, e + o, n, i, r, s), this
                     }
@@ -26891,15 +27358,15 @@
                     }
                     ellipse(t, e, n, i, r, s, a, o) {
                         const l = this.currentPoint.x,
                             c = this.currentPoint.y;
                         return this.absellipse(t + l, e + c, n, i, r, s, a, o), this
                     }
                     absellipse(t, e, n, i, r, s, a, o) {
-                        const l = new ua(t, e, n, i, r, s, a, o);
+                        const l = new tl(t, e, n, i, r, s, a, o);
                         if (this.curves.length > 0) {
                             const t = l.getPoint(0);
                             t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                         }
                         this.curves.push(l);
                         const c = l.getPoint(1);
                         return this.currentPoint.copy(c), this
@@ -26911,17 +27378,17 @@
                         const t = super.toJSON();
                         return t.currentPoint = this.currentPoint.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                     }
                 }
-                class Pa extends Ca {
+                class _l extends yl {
                     constructor(t) {
-                        super(t), this.uuid = k(), this.type = "Shape", this.holes = []
+                        super(t), this.uuid = Ae(), this.type = "Shape", this.holes = []
                     }
                     getPointsHoles(t) {
                         const e = [];
                         for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                         return e
                     }
                     extractPoints(t) {
@@ -26947,53 +27414,53 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                         for (let e = 0, n = t.holes.length; e < n; e++) {
                             const n = t.holes[e];
-                            this.holes.push((new Ca).fromJSON(n))
+                            this.holes.push((new yl).fromJSON(n))
                         }
                         return this
                     }
                 }
 
-                function Da(t, e, n, i, r) {
+                function Ml(t, e, n, i, r) {
                     let s, a;
                     if (r === function(t, e, n, i) {
                             let r = 0;
                             for (let s = e, a = n - i; s < n; s += i) r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;
                             return r
                         }(t, e, n, i) > 0)
-                        for (s = e; s < n; s += i) a = $a(s, t[s], t[s + 1], a);
+                        for (s = e; s < n; s += i) a = Vl(s, t[s], t[s + 1], a);
                     else
-                        for (s = n - i; s >= e; s -= i) a = $a(s, t[s], t[s + 1], a);
-                    return a && qa(a, a.next) && (to(a), a = a.next), a
+                        for (s = n - i; s >= e; s -= i) a = Vl(s, t[s], t[s + 1], a);
+                    return a && Ul(a, a.next) && (kl(a), a = a.next), a
                 }
 
-                function Ia(t, e) {
+                function bl(t, e) {
                     if (!t) return t;
                     e || (e = t);
                     let n, i = t;
                     do {
-                        if (n = !1, i.steiner || !qa(i, i.next) && 0 !== Xa(i.prev, i, i.next)) i = i.next;
+                        if (n = !1, i.steiner || !Ul(i, i.next) && 0 !== Ol(i.prev, i, i.next)) i = i.next;
                         else {
-                            if (to(i), i = e = i.prev, i === i.next) break;
+                            if (kl(i), i = e = i.prev, i === i.next) break;
                             n = !0
                         }
                     } while (n || i !== e);
                     return e
                 }
 
-                function Na(t, e, n, i, r, s, a) {
+                function wl(t, e, n, i, r, s, a) {
                     if (!t) return;
                     !a && s && function(t, e, n, i) {
                         let r = t;
                         do {
-                            null === r.z && (r.z = Va(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
+                            null === r.z && (r.z = Pl(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                         } while (r !== t);
                         r.prevZ.nextZ = null, r.prevZ = null,
                             function(t) {
                                 let e, n, i, r, s, a, o, l, c = 1;
                                 do {
                                     for (n = t, t = null, s = null, a = 0; n;) {
                                         for (a++, i = n, o = 0, e = 0; e < c && (o++, i = i.nextZ, i); e++);
@@ -27002,93 +27469,93 @@
                                     }
                                     s.nextZ = null, c *= 2
                                 } while (a > 1)
                             }(r)
                     }(t, i, r, s);
                     let o, l, c = t;
                     for (; t.prev !== t.next;)
-                        if (o = t.prev, l = t.next, s ? Ua(t, i, r, s) : Oa(t)) e.push(o.i / n), e.push(t.i / n), e.push(l.i / n), to(t), t = l.next, c = l.next;
+                        if (o = t.prev, l = t.next, s ? El(t, i, r, s) : Sl(t)) e.push(o.i / n), e.push(t.i / n), e.push(l.i / n), kl(t), t = l.next, c = l.next;
                         else if ((t = l) === c) {
-                        a ? 1 === a ? Na(t = Ba(Ia(t), e, n), e, n, i, r, s, 2) : 2 === a && Fa(t, e, n, i, r, s) : Na(Ia(t), e, n, i, r, s, 1);
+                        a ? 1 === a ? wl(t = Tl(bl(t), e, n), e, n, i, r, s, 2) : 2 === a && Al(t, e, n, i, r, s) : wl(bl(t), e, n, i, r, s, 1);
                         break
                     }
                 }
 
-                function Oa(t) {
+                function Sl(t) {
                     const e = t.prev,
                         n = t,
                         i = t.next;
-                    if (Xa(e, n, i) >= 0) return !1;
+                    if (Ol(e, n, i) >= 0) return !1;
                     let r = t.next.next;
                     for (; r !== t.prev;) {
-                        if (Wa(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Xa(r.prev, r, r.next) >= 0) return !1;
+                        if (Il(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Ol(r.prev, r, r.next) >= 0) return !1;
                         r = r.next
                     }
                     return !0
                 }
 
-                function Ua(t, e, n, i) {
+                function El(t, e, n, i) {
                     const r = t.prev,
                         s = t,
                         a = t.next;
-                    if (Xa(r, s, a) >= 0) return !1;
+                    if (Ol(r, s, a) >= 0) return !1;
                     const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x,
                         l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y,
                         c = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x,
                         h = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y,
-                        u = Va(o, l, e, n, i),
-                        d = Va(c, h, e, n, i);
+                        u = Pl(o, l, e, n, i),
+                        d = Pl(c, h, e, n, i);
                     let p = t.prevZ,
                         m = t.nextZ;
                     for (; p && p.z >= u && m && m.z <= d;) {
-                        if (p !== t.prev && p !== t.next && Wa(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Xa(p.prev, p, p.next) >= 0) return !1;
-                        if (p = p.prevZ, m !== t.prev && m !== t.next && Wa(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Xa(m.prev, m, m.next) >= 0) return !1;
+                        if (p !== t.prev && p !== t.next && Il(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Ol(p.prev, p, p.next) >= 0) return !1;
+                        if (p = p.prevZ, m !== t.prev && m !== t.next && Il(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Ol(m.prev, m, m.next) >= 0) return !1;
                         m = m.nextZ
                     }
                     for (; p && p.z >= u;) {
-                        if (p !== t.prev && p !== t.next && Wa(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Xa(p.prev, p, p.next) >= 0) return !1;
+                        if (p !== t.prev && p !== t.next && Il(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Ol(p.prev, p, p.next) >= 0) return !1;
                         p = p.prevZ
                     }
                     for (; m && m.z <= d;) {
-                        if (m !== t.prev && m !== t.next && Wa(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Xa(m.prev, m, m.next) >= 0) return !1;
+                        if (m !== t.prev && m !== t.next && Il(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Ol(m.prev, m, m.next) >= 0) return !1;
                         m = m.nextZ
                     }
                     return !0
                 }
 
-                function Ba(t, e, n) {
+                function Tl(t, e, n) {
                     let i = t;
                     do {
                         const r = i.prev,
                             s = i.next.next;
-                        !qa(r, s) && Ya(r, i, i.next, s) && Ka(r, s) && Ka(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), to(i), to(i.next), i = t = s), i = i.next
+                        !Ul(r, s) && Bl(r, i, i.next, s) && Hl(r, s) && Hl(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), kl(i), kl(i.next), i = t = s), i = i.next
                     } while (i !== t);
-                    return Ia(i)
+                    return bl(i)
                 }
 
-                function Fa(t, e, n, i, r, s) {
+                function Al(t, e, n, i, r, s) {
                     let a = t;
                     do {
                         let t = a.next.next;
                         for (; t !== a.prev;) {
-                            if (a.i !== t.i && ja(a, t)) {
-                                let o = Qa(a, t);
-                                return a = Ia(a, a.next), o = Ia(o, o.next), Na(a, e, n, i, r, s), void Na(o, e, n, i, r, s)
+                            if (a.i !== t.i && Nl(a, t)) {
+                                let o = Gl(a, t);
+                                return a = bl(a, a.next), o = bl(o, o.next), wl(a, e, n, i, r, s), void wl(o, e, n, i, r, s)
                             }
                             t = t.next
                         }
                         a = a.next
                     } while (a !== t)
                 }
 
-                function za(t, e) {
+                function Rl(t, e) {
                     return t.x - e.x
                 }
 
-                function Ha(t, e) {
+                function Ll(t, e) {
                     if (e = function(t, e) {
                             let n = e;
                             const i = t.x,
                                 r = t.y;
                             let s, a = -1 / 0;
                             do {
                                 if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
@@ -27107,165 +27574,165 @@
                             if (i === a) return s;
                             const o = s,
                                 l = s.x,
                                 c = s.y;
                             let h, u = 1 / 0;
                             n = s;
                             do {
-                                i >= n.x && n.x >= l && i !== n.x && Wa(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), Ka(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && Ga(s, n))) && (s = n, u = h)), n = n.next
+                                i >= n.x && n.x >= l && i !== n.x && Il(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), Hl(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && Cl(s, n))) && (s = n, u = h)), n = n.next
                             } while (n !== o);
                             return s
                         }(t, e), e) {
-                        const n = Qa(e, t);
-                        Ia(e, e.next), Ia(n, n.next)
+                        const n = Gl(e, t);
+                        bl(e, e.next), bl(n, n.next)
                     }
                 }
 
-                function Ga(t, e) {
-                    return Xa(t.prev, t, e.prev) < 0 && Xa(e.next, t, t.next) < 0
+                function Cl(t, e) {
+                    return Ol(t.prev, t, e.prev) < 0 && Ol(e.next, t, t.next) < 0
                 }
 
-                function Va(t, e, n, i, r) {
+                function Pl(t, e, n, i, r) {
                     return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                 }
 
-                function ka(t) {
+                function Dl(t) {
                     let e = t,
                         n = t;
                     do {
                         (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                     } while (e !== t);
                     return n
                 }
 
-                function Wa(t, e, n, i, r, s, a, o) {
+                function Il(t, e, n, i, r, s, a, o) {
                     return (r - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (i - o) - (n - a) * (e - o) >= 0 && (n - a) * (s - o) - (r - a) * (i - o) >= 0
                 }
 
-                function ja(t, e) {
+                function Nl(t, e) {
                     return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                         let n = t;
                         do {
-                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Ya(n, n.next, t, e)) return !0;
+                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Bl(n, n.next, t, e)) return !0;
                             n = n.next
                         } while (n !== t);
                         return !1
-                    }(t, e) && (Ka(t, e) && Ka(e, t) && function(t, e) {
+                    }(t, e) && (Hl(t, e) && Hl(e, t) && function(t, e) {
                         let n = t,
                             i = !1;
                         const r = (t.x + e.x) / 2,
                             s = (t.y + e.y) / 2;
                         do {
                             n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                         } while (n !== t);
                         return i
-                    }(t, e) && (Xa(t.prev, t, e.prev) || Xa(t, e.prev, e)) || qa(t, e) && Xa(t.prev, t, t.next) > 0 && Xa(e.prev, e, e.next) > 0)
+                    }(t, e) && (Ol(t.prev, t, e.prev) || Ol(t, e.prev, e)) || Ul(t, e) && Ol(t.prev, t, t.next) > 0 && Ol(e.prev, e, e.next) > 0)
                 }
 
-                function Xa(t, e, n) {
+                function Ol(t, e, n) {
                     return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
                 }
 
-                function qa(t, e) {
+                function Ul(t, e) {
                     return t.x === e.x && t.y === e.y
                 }
 
-                function Ya(t, e, n, i) {
-                    const r = Ja(Xa(t, e, n)),
-                        s = Ja(Xa(t, e, i)),
-                        a = Ja(Xa(n, i, t)),
-                        o = Ja(Xa(n, i, e));
-                    return r !== s && a !== o || !(0 !== r || !Za(t, n, e)) || !(0 !== s || !Za(t, i, e)) || !(0 !== a || !Za(n, t, i)) || !(0 !== o || !Za(n, e, i))
+                function Bl(t, e, n, i) {
+                    const r = zl(Ol(t, e, n)),
+                        s = zl(Ol(t, e, i)),
+                        a = zl(Ol(n, i, t)),
+                        o = zl(Ol(n, i, e));
+                    return r !== s && a !== o || !(0 !== r || !Fl(t, n, e)) || !(0 !== s || !Fl(t, i, e)) || !(0 !== a || !Fl(n, t, i)) || !(0 !== o || !Fl(n, e, i))
                 }
 
-                function Za(t, e, n) {
+                function Fl(t, e, n) {
                     return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
                 }
 
-                function Ja(t) {
+                function zl(t) {
                     return t > 0 ? 1 : t < 0 ? -1 : 0
                 }
 
-                function Ka(t, e) {
-                    return Xa(t.prev, t, t.next) < 0 ? Xa(t, e, t.next) >= 0 && Xa(t, t.prev, e) >= 0 : Xa(t, e, t.prev) < 0 || Xa(t, t.next, e) < 0
+                function Hl(t, e) {
+                    return Ol(t.prev, t, t.next) < 0 ? Ol(t, e, t.next) >= 0 && Ol(t, t.prev, e) >= 0 : Ol(t, e, t.prev) < 0 || Ol(t, t.next, e) < 0
                 }
 
-                function Qa(t, e) {
-                    const n = new eo(t.i, t.x, t.y),
-                        i = new eo(e.i, e.x, e.y),
+                function Gl(t, e) {
+                    const n = new Wl(t.i, t.x, t.y),
+                        i = new Wl(e.i, e.x, e.y),
                         r = t.next,
                         s = e.prev;
                     return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
                 }
 
-                function $a(t, e, n, i) {
-                    const r = new eo(t, e, n);
+                function Vl(t, e, n, i) {
+                    const r = new Wl(t, e, n);
                     return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
                 }
 
-                function to(t) {
+                function kl(t) {
                     t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                 }
 
-                function eo(t, e, n) {
+                function Wl(t, e, n) {
                     this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
                 }
-                class no {
+                class jl {
                     static area(t) {
                         const e = t.length;
                         let n = 0;
                         for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                         return .5 * n
                     }
                     static isClockWise(t) {
-                        return no.area(t) < 0
+                        return jl.area(t) < 0
                     }
                     static triangulateShape(t, e) {
                         const n = [],
                             i = [],
                             r = [];
-                        io(t), ro(n, t);
+                        Xl(t), ql(n, t);
                         let s = t.length;
-                        e.forEach(io);
-                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, ro(n, e[t]);
+                        e.forEach(Xl);
+                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, ql(n, e[t]);
                         const a = function(t, e, n = 2) {
                             const i = e && e.length,
                                 r = i ? e[0] * n : t.length;
-                            let s = Da(t, 0, r, n, !0);
+                            let s = Ml(t, 0, r, n, !0);
                             const a = [];
                             if (!s || s.next === s.prev) return a;
                             let o, l, c, h, u, d, p;
                             if (i && (s = function(t, e, n, i) {
                                     const r = [];
                                     let s, a, o, l, c;
-                                    for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : t.length, c = Da(t, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(ka(c));
-                                    for (r.sort(za), s = 0; s < r.length; s++) Ha(r[s], n), n = Ia(n, n.next);
+                                    for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : t.length, c = Ml(t, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(Dl(c));
+                                    for (r.sort(Rl), s = 0; s < r.length; s++) Ll(r[s], n), n = bl(n, n.next);
                                     return n
                                 }(t, e, s, n)), t.length > 80 * n) {
                                 o = c = t[0], l = h = t[1];
                                 for (let e = n; e < r; e += n) u = t[e], d = t[e + 1], u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
                                 p = Math.max(c - o, h - l), p = 0 !== p ? 1 / p : 0
                             }
-                            return Na(s, a, n, o, l, p), a
+                            return wl(s, a, n, o, l, p), a
                         }(n, i);
                         for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
                         return r
                     }
                 }
 
-                function io(t) {
+                function Xl(t) {
                     const e = t.length;
                     e > 2 && t[e - 1].equals(t[0]) && t.pop()
                 }
 
-                function ro(t, e) {
+                function ql(t, e) {
                     for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
                 }
-                class so extends We {
-                    constructor(t = new Pa([new Y(.5, .5), new Y(-.5, .5), new Y(-.5, -.5), new Y(.5, -.5)]), e = {}) {
+                class Yl extends Li {
+                    constructor(t = new _l([new De(.5, .5), new De(-.5, .5), new De(-.5, -.5), new De(.5, -.5)]), e = {}) {
                         super(), this.type = "ExtrudeGeometry", this.parameters = {
                             shapes: t,
                             options: e
                         }, t = Array.isArray(t) ? t : [t];
                         const n = this,
                             i = [],
                             r = [];
@@ -27278,29 +27745,29 @@
                             let l = void 0 !== e.depth ? e.depth : 1,
                                 c = void 0 === e.bevelEnabled || e.bevelEnabled,
                                 h = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                                 u = void 0 !== e.bevelSize ? e.bevelSize : h - .1,
                                 d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                 p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                             const m = e.extrudePath,
-                                f = void 0 !== e.UVGenerator ? e.UVGenerator : ao;
+                                f = void 0 !== e.UVGenerator ? e.UVGenerator : Zl;
                             void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                             let g, v, x, y, _, M = !1;
-                            m && (g = m.getSpacedPoints(o), M = !0, c = !1, v = m.computeFrenetFrames(o, !1), x = new mt, y = new mt, _ = new mt), c || (p = 0, h = 0, u = 0, d = 0);
+                            m && (g = m.getSpacedPoints(o), M = !0, c = !1, v = m.computeFrenetFrames(o, !1), x = new Qe, y = new Qe, _ = new Qe), c || (p = 0, h = 0, u = 0, d = 0);
                             const b = t.extractPoints(a);
                             let w = b.shape;
                             const S = b.holes;
-                            if (!no.isClockWise(w)) {
+                            if (!jl.isClockWise(w)) {
                                 w = w.reverse();
                                 for (let t = 0, e = S.length; t < e; t++) {
                                     const e = S[t];
-                                    no.isClockWise(e) && (S[t] = e.reverse())
+                                    jl.isClockWise(e) && (S[t] = e.reverse())
                                 }
                             }
-                            const E = no.triangulateShape(w, S),
+                            const E = jl.triangulateShape(w, S),
                                 T = w;
                             for (let t = 0, e = S.length; t < e; t++) {
                                 const e = S[t];
                                 w = w.concat(e)
                             }
 
                             function A(t, e, n) {
@@ -27321,21 +27788,21 @@
                                     const u = Math.sqrt(h),
                                         d = Math.sqrt(l * l + c * c),
                                         p = e.x - o / u,
                                         m = e.y + a / u,
                                         f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (a * c - o * l);
                                     i = p + a * f - t.x, r = m + o * f - t.y;
                                     const g = i * i + r * r;
-                                    if (g <= 2) return new Y(i, r);
+                                    if (g <= 2) return new De(i, r);
                                     s = Math.sqrt(g / 2)
                                 } else {
                                     let t = !1;
                                     a > Number.EPSILON ? l > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(c) && (t = !0), t ? (i = -o, r = a, s = Math.sqrt(h)) : (i = a, r = o, s = Math.sqrt(h / 2))
                                 }
-                                return new Y(i / s, r / s)
+                                return new De(i / s, r / s)
                             }
                             const P = [];
                             for (let t = 0, e = T.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), P[t] = C(T[t], T[n], T[i]);
                             const D = [];
                             let I, N = P.concat();
                             for (let t = 0, e = S.length; t < e; t++) {
                                 const e = S[t];
@@ -27459,15 +27926,15 @@
                                 for (let t = 0, n = S.length; t < n; t++) {
                                     const n = S[t];
                                     U(n, e), e += n.length
                                 }
                                 n.addGroup(t, i.length / 3 - t, 1)
                             }()
                         }
-                        this.setAttribute("position", new Ue(i, 3)), this.setAttribute("uv", new Ue(r, 2)), this.computeVertexNormals()
+                        this.setAttribute("position", new Mi(i, 3)), this.setAttribute("uv", new Mi(r, 2)), this.computeVertexNormals()
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return function(t, e, n) {
                             if (n.shapes = [], Array.isArray(t))
                                 for (let e = 0, i = t.length; e < i; e++) {
                                     const i = t[e];
@@ -27479,45 +27946,45 @@
                     static fromJSON(t, e) {
                         const n = [];
                         for (let i = 0, r = t.shapes.length; i < r; i++) {
                             const r = e[t.shapes[i]];
                             n.push(r)
                         }
                         const i = t.options.extrudePath;
-                        return void 0 !== i && (t.options.extrudePath = (new Ra[i.type]).fromJSON(i)), new so(n, t.options)
+                        return void 0 !== i && (t.options.extrudePath = (new vl[i.type]).fromJSON(i)), new Yl(n, t.options)
                     }
                 }
-                const ao = {
+                const Zl = {
                     generateTopUV: function(t, e, n, i, r) {
                         const s = e[3 * n],
                             a = e[3 * n + 1],
                             o = e[3 * i],
                             l = e[3 * i + 1],
                             c = e[3 * r],
                             h = e[3 * r + 1];
-                        return [new Y(s, a), new Y(o, l), new Y(c, h)]
+                        return [new De(s, a), new De(o, l), new De(c, h)]
                     },
                     generateSideWallUV: function(t, e, n, i, r, s) {
                         const a = e[3 * n],
                             o = e[3 * n + 1],
                             l = e[3 * n + 2],
                             c = e[3 * i],
                             h = e[3 * i + 1],
                             u = e[3 * i + 2],
                             d = e[3 * r],
                             p = e[3 * r + 1],
                             m = e[3 * r + 2],
                             f = e[3 * s],
                             g = e[3 * s + 1],
                             v = e[3 * s + 2];
-                        return Math.abs(o - h) < Math.abs(a - c) ? [new Y(a, 1 - l), new Y(c, 1 - u), new Y(d, 1 - m), new Y(f, 1 - v)] : [new Y(o, 1 - l), new Y(h, 1 - u), new Y(p, 1 - m), new Y(g, 1 - v)]
+                        return Math.abs(o - h) < Math.abs(a - c) ? [new De(a, 1 - l), new De(c, 1 - u), new De(d, 1 - m), new De(f, 1 - v)] : [new De(o, 1 - l), new De(h, 1 - u), new De(p, 1 - m), new De(g, 1 - v)]
                     }
                 };
-                class oo extends We {
-                    constructor(t = new Pa([new Y(0, .5), new Y(-.5, -.5), new Y(.5, -.5)]), e = 12) {
+                class Jl extends Li {
+                    constructor(t = new _l([new De(0, .5), new De(-.5, -.5), new De(.5, -.5)]), e = 12) {
                         super(), this.type = "ShapeGeometry", this.parameters = {
                             shapes: t,
                             curveSegments: e
                         };
                         const n = [],
                             i = [],
                             r = [],
@@ -27529,20 +27996,20 @@
                             for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(a, o, e), a += o, o = 0;
 
                         function l(t) {
                             const a = i.length / 3,
                                 l = t.extractPoints(e);
                             let c = l.shape;
                             const h = l.holes;
-                            !1 === no.isClockWise(c) && (c = c.reverse());
+                            !1 === jl.isClockWise(c) && (c = c.reverse());
                             for (let t = 0, e = h.length; t < e; t++) {
                                 const e = h[t];
-                                !0 === no.isClockWise(e) && (h[t] = e.reverse())
+                                !0 === jl.isClockWise(e) && (h[t] = e.reverse())
                             }
-                            const u = no.triangulateShape(c, h);
+                            const u = jl.triangulateShape(c, h);
                             for (let t = 0, e = h.length; t < e; t++) {
                                 const e = h[t];
                                 c = c.concat(e)
                             }
                             for (let t = 0, e = c.length; t < e; t++) {
                                 const e = c[t];
                                 i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
@@ -27551,15 +28018,15 @@
                                 const e = u[t],
                                     i = e[0] + a,
                                     r = e[1] + a,
                                     s = e[2] + a;
                                 n.push(i, r, s), o += 3
                             }
                         }
-                        this.setIndex(n), this.setAttribute("position", new Ue(i, 3)), this.setAttribute("normal", new Ue(r, 3)), this.setAttribute("uv", new Ue(s, 2))
+                        this.setIndex(n), this.setAttribute("position", new Mi(i, 3)), this.setAttribute("normal", new Mi(r, 3)), this.setAttribute("uv", new Mi(s, 2))
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return function(t, e) {
                             if (e.shapes = [], Array.isArray(t))
                                 for (let n = 0, i = t.length; n < i; n++) {
                                     const i = t[n];
@@ -27570,50 +28037,50 @@
                     }
                     static fromJSON(t, e) {
                         const n = [];
                         for (let i = 0, r = t.shapes.length; i < r; i++) {
                             const r = e[t.shapes[i]];
                             n.push(r)
                         }
-                        return new oo(n, t.curveSegments)
+                        return new Jl(n, t.curveSegments)
                     }
-                }(class extends Le {
+                }(class extends mi {
                     constructor(t) {
-                        super(), this.type = "ShadowMaterial", this.color = new rt(0), this.transparent = !0, this.setValues(t)
+                        super(), this.type = "ShadowMaterial", this.color = new Ve(0), this.transparent = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this
                     }
                 }).prototype.isShadowMaterial = !0;
-                class lo extends Le {
+                class Kl extends mi {
                     constructor(t) {
                         super(), this.defines = {
                             STANDARD: ""
-                        }, this.type = "MeshStandardMaterial", this.color = new rt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
+                        }, this.type = "MeshStandardMaterial", this.color = new Ve(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ge, this.normalScale = new De(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.defines = {
                             STANDARD: ""
                         }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                     }
                 }
-                lo.prototype.isMeshStandardMaterial = !0;
-                (class extends lo {
+                Kl.prototype.isMeshStandardMaterial = !0;
+                (class extends Kl {
                     constructor(t) {
                         super(), this.defines = {
                             STANDARD: "",
                             PHYSICAL: ""
-                        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Y(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
+                        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new De(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                             get: function() {
-                                return W(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
+                                return Re(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                             },
                             set: function(t) {
                                 this.ior = (1 + .4 * t) / (1 - .4 * t)
                             }
-                        }), this.sheenColor = new rt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new rt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new rt(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
+                        }), this.sheenColor = new Ve(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Ve(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ve(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
                     }
                     get sheen() {
                         return this._sheen
                     }
                     set sheen(t) {
                         this._sheen > 0 != t > 0 && this.version++, this._sheen = t
                     }
@@ -27632,71 +28099,71 @@
                     copy(t) {
                         return super.copy(t), this.defines = {
                             STANDARD: "",
                             PHYSICAL: ""
                         }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
                     }
                 }).prototype.isMeshPhysicalMaterial = !0;
-                (class extends Le {
+                (class extends mi {
                     constructor(t) {
-                        super(), this.type = "MeshPhongMaterial", this.color = new rt(16777215), this.specular = new rt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
+                        super(), this.type = "MeshPhongMaterial", this.color = new Ve(16777215), this.specular = new Ve(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ge, this.normalScale = new De(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = k, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                     }
                 }).prototype.isMeshPhongMaterial = !0;
-                (class extends Le {
+                (class extends mi {
                     constructor(t) {
                         super(), this.defines = {
                             TOON: ""
-                        }, this.type = "MeshToonMaterial", this.color = new rt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        }, this.type = "MeshToonMaterial", this.color = new Ve(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ge, this.normalScale = new De(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }).prototype.isMeshToonMaterial = !0;
-                (class extends Le {
+                (class extends mi {
                     constructor(t) {
-                        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
+                        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ge, this.normalScale = new De(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
                     }
                 }).prototype.isMeshNormalMaterial = !0;
-                (class extends Le {
+                (class extends mi {
                     constructor(t) {
-                        super(), this.type = "MeshLambertMaterial", this.color = new rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        super(), this.type = "MeshLambertMaterial", this.color = new Ve(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = k, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }).prototype.isMeshLambertMaterial = !0;
-                (class extends Le {
+                (class extends mi {
                     constructor(t) {
                         super(), this.defines = {
                             MATCAP: ""
-                        }, this.type = "MeshMatcapMaterial", this.color = new rt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
+                        }, this.type = "MeshMatcapMaterial", this.color = new Ve(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ge, this.normalScale = new De(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.defines = {
                             MATCAP: ""
                         }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this
                     }
                 }).prototype.isMeshMatcapMaterial = !0;
-                (class extends Ys {
+                (class extends Bo {
                     constructor(t) {
                         super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
                     }
                 }).prototype.isLineDashedMaterial = !0;
-                const co = {
+                const Ql = {
                     arraySlice: function(t, e, n) {
-                        return co.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
+                        return Ql.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                     },
                     convertArray: function(t, e, n) {
                         return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                     },
                     isTypedArray: function(t) {
                         return ArrayBuffer.isView(t) && !(t instanceof DataView)
                     },
@@ -27749,15 +28216,15 @@
                             for (let t = 0; t < e.times.length; ++t) {
                                 const s = e.times[t] * r;
                                 if (!(s < n || s >= i)) {
                                     l.push(e.times[t]);
                                     for (let n = 0; n < o; ++n) c.push(e.values[t * o + n])
                                 }
                             }
-                            0 !== l.length && (e.times = co.convertArray(l, e.times.constructor), e.values = co.convertArray(c, e.values.constructor), a.push(e))
+                            0 !== l.length && (e.times = Ql.convertArray(l, e.times.constructor), e.values = Ql.convertArray(c, e.values.constructor), a.push(e))
                         }
                         s.tracks = a;
                         let o = 1 / 0;
                         for (let t = 0; t < s.tracks.length; ++t) o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
                         for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);
                         return s.resetDuration(), s
                     },
@@ -27780,40 +28247,40 @@
                             const h = a.getValueSize();
                             a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                             const u = i.times.length - 1;
                             let d;
                             if (s <= i.times[0]) {
                                 const t = o,
                                     e = l - o;
-                                d = co.arraySlice(i.values, t, e)
+                                d = Ql.arraySlice(i.values, t, e)
                             } else if (s >= i.times[u]) {
                                 const t = u * l + o,
                                     e = t + l - o;
-                                d = co.arraySlice(i.values, t, e)
+                                d = Ql.arraySlice(i.values, t, e)
                             } else {
                                 const t = i.createInterpolant(),
                                     e = o,
                                     n = l - o;
-                                t.evaluate(s), d = co.arraySlice(t.resultBuffer, e, n)
+                                t.evaluate(s), d = Ql.arraySlice(t.resultBuffer, e, n)
                             }
-                            "quaternion" === r && (new pt).fromArray(d).normalize().conjugate().toArray(d);
+                            "quaternion" === r && (new Ke).fromArray(d).normalize().conjugate().toArray(d);
                             const p = a.times.length;
                             for (let t = 0; t < p; ++t) {
                                 const e = t * h + c;
-                                if ("quaternion" === r) pt.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
+                                if ("quaternion" === r) Ke.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                                 else {
                                     const t = h - 2 * c;
                                     for (let n = 0; n < t; ++n) a.values[e + n] -= d[n]
                                 }
                             }
                         }
                         return t.blendMode = 2501, t
                     }
                 };
-                class ho {
+                class $l {
                     constructor(t, e, n, i) {
                         this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                     }
                     evaluate(t) {
                         const e = this.parameterPositions;
                         let n = this._cachedIndex,
                             i = e[n],
@@ -27870,43 +28337,43 @@
                         return e
                     }
                     interpolate_() {
                         throw new Error("call to abstract method")
                     }
                     intervalChanged_() {}
                 }
-                ho.prototype.beforeStart_ = ho.prototype.copySampleValue_, ho.prototype.afterEnd_ = ho.prototype.copySampleValue_;
-                class uo extends ho {
+                $l.prototype.beforeStart_ = $l.prototype.copySampleValue_, $l.prototype.afterEnd_ = $l.prototype.copySampleValue_;
+                class tc extends $l {
                     constructor(t, e, n, i) {
                         super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
-                            endingStart: L,
-                            endingEnd: L
+                            endingStart: he,
+                            endingEnd: he
                         }
                     }
                     intervalChanged_(t, e, n) {
                         const i = this.parameterPositions;
                         let r = t - 2,
                             s = t + 1,
                             a = i[r],
                             o = i[s];
                         if (void 0 === a) switch (this.getSettings_().endingStart) {
-                            case C:
+                            case ue:
                                 r = t, a = 2 * e - n;
                                 break;
-                            case P:
+                            case de:
                                 r = i.length - 2, a = e + i[r] - i[r + 1];
                                 break;
                             default:
                                 r = t, a = n
                         }
                         if (void 0 === o) switch (this.getSettings_().endingEnd) {
-                            case C:
+                            case ue:
                                 s = t, o = 2 * n - e;
                                 break;
-                            case P:
+                            case de:
                                 s = 1, o = n + i[1] - i[0];
                                 break;
                             default:
                                 s = t - 1, o = e
                         }
                         const l = .5 * (n - e),
                             c = this.valueSize;
@@ -27929,15 +28396,15 @@
                             v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                             x = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                             y = d * f - d * m;
                         for (let t = 0; t !== a; ++t) r[t] = g * s[c + t] + v * s[l + t] + x * s[o + t] + y * s[h + t];
                         return r
                     }
                 }
-                class po extends ho {
+                class ec extends $l {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t, e, n, i) {
                         const r = this.resultBuffer,
                             s = this.sampleValues,
                             a = this.valueSize,
@@ -27945,62 +28412,62 @@
                             l = o - a,
                             c = (n - e) / (i - e),
                             h = 1 - c;
                         for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;
                         return r
                     }
                 }
-                class mo extends ho {
+                class nc extends $l {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t) {
                         return this.copySampleValue_(t - 1)
                     }
                 }
-                class fo {
+                class ic {
                     constructor(t, e, n, i) {
                         if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                         if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
-                        this.name = t, this.times = co.convertArray(e, this.TimeBufferType), this.values = co.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
+                        this.name = t, this.times = Ql.convertArray(e, this.TimeBufferType), this.values = Ql.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                     }
                     static toJSON(t) {
                         const e = t.constructor;
                         let n;
                         if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                         else {
                             n = {
                                 name: t.name,
-                                times: co.convertArray(t.times, Array),
-                                values: co.convertArray(t.values, Array)
+                                times: Ql.convertArray(t.times, Array),
+                                values: Ql.convertArray(t.values, Array)
                             };
                             const e = t.getInterpolation();
                             e !== t.DefaultInterpolation && (n.interpolation = e)
                         }
                         return n.type = t.ValueTypeName, n
                     }
                     InterpolantFactoryMethodDiscrete(t) {
-                        return new mo(this.times, this.values, this.getValueSize(), t)
+                        return new nc(this.times, this.values, this.getValueSize(), t)
                     }
                     InterpolantFactoryMethodLinear(t) {
-                        return new po(this.times, this.values, this.getValueSize(), t)
+                        return new ec(this.times, this.values, this.getValueSize(), t)
                     }
                     InterpolantFactoryMethodSmooth(t) {
-                        return new uo(this.times, this.values, this.getValueSize(), t)
+                        return new tc(this.times, this.values, this.getValueSize(), t)
                     }
                     setInterpolation(t) {
                         let e;
                         switch (t) {
-                            case T:
+                            case oe:
                                 e = this.InterpolantFactoryMethodDiscrete;
                                 break;
-                            case A:
+                            case le:
                                 e = this.InterpolantFactoryMethodLinear;
                                 break;
-                            case R:
+                            case ce:
                                 e = this.InterpolantFactoryMethodSmooth
                         }
                         if (void 0 === e) {
                             const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                             if (void 0 === this.createInterpolant) {
                                 if (t === this.DefaultInterpolation) throw new Error(e);
                                 this.setInterpolation(this.DefaultInterpolation)
@@ -28008,19 +28475,19 @@
                             return console.warn("THREE.KeyframeTrack:", e), this
                         }
                         return this.createInterpolant = e, this
                     }
                     getInterpolation() {
                         switch (this.createInterpolant) {
                             case this.InterpolantFactoryMethodDiscrete:
-                                return T;
+                                return oe;
                             case this.InterpolantFactoryMethodLinear:
-                                return A;
+                                return le;
                             case this.InterpolantFactoryMethodSmooth:
-                                return R
+                                return ce
                         }
                     }
                     getValueSize() {
                         return this.values.length / this.times.length
                     }
                     shift(t) {
                         if (0 !== t) {
@@ -28042,15 +28509,15 @@
                         let r = 0,
                             s = i - 1;
                         for (; r !== i && n[r] < t;) ++r;
                         for (; - 1 !== s && n[s] > e;) --s;
                         if (++s, 0 !== r || s !== i) {
                             r >= s && (s = Math.max(s, 1), r = s - 1);
                             const t = this.getValueSize();
-                            this.times = co.arraySlice(n, r, s), this.values = co.arraySlice(this.values, r * t, s * t)
+                            this.times = Ql.arraySlice(n, r, s), this.values = Ql.arraySlice(this.values, r * t, s * t)
                         }
                         return this
                     }
                     validate() {
                         let t = !0;
                         const e = this.getValueSize();
                         e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
@@ -28067,29 +28534,29 @@
                             }
                             if (null !== s && s > i) {
                                 console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1;
                                 break
                             }
                             s = i
                         }
-                        if (void 0 !== i && co.isTypedArray(i))
+                        if (void 0 !== i && Ql.isTypedArray(i))
                             for (let e = 0, n = i.length; e !== n; ++e) {
                                 const n = i[e];
                                 if (isNaN(n)) {
                                     console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                                     break
                                 }
                             }
                         return t
                     }
                     optimize() {
-                        const t = co.arraySlice(this.times),
-                            e = co.arraySlice(this.values),
+                        const t = Ql.arraySlice(this.times),
+                            e = Ql.arraySlice(this.values),
                             n = this.getValueSize(),
-                            i = this.getInterpolation() === R,
+                            i = this.getInterpolation() === ce,
                             r = t.length - 1;
                         let s = 1;
                         for (let a = 1; a < r; ++a) {
                             let r = !1;
                             const o = t[a];
                             if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                                 if (i) r = !0;
@@ -28114,88 +28581,88 @@
                             }
                         }
                         if (r > 0) {
                             t[s] = t[r];
                             for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
                             ++s
                         }
-                        return s !== t.length ? (this.times = co.arraySlice(t, 0, s), this.values = co.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
+                        return s !== t.length ? (this.times = Ql.arraySlice(t, 0, s), this.values = Ql.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
                     }
                     clone() {
-                        const t = co.arraySlice(this.times, 0),
-                            e = co.arraySlice(this.values, 0),
+                        const t = Ql.arraySlice(this.times, 0),
+                            e = Ql.arraySlice(this.values, 0),
                             n = new(0, this.constructor)(this.name, t, e);
                         return n.createInterpolant = this.createInterpolant, n
                     }
                 }
-                fo.prototype.TimeBufferType = Float32Array, fo.prototype.ValueBufferType = Float32Array, fo.prototype.DefaultInterpolation = A;
-                class go extends fo {}
-                go.prototype.ValueTypeName = "bool", go.prototype.ValueBufferType = Array, go.prototype.DefaultInterpolation = T, go.prototype.InterpolantFactoryMethodLinear = void 0, go.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class vo extends fo {}
-                vo.prototype.ValueTypeName = "color";
-                class xo extends fo {}
-                xo.prototype.ValueTypeName = "number";
-                class yo extends ho {
+                ic.prototype.TimeBufferType = Float32Array, ic.prototype.ValueBufferType = Float32Array, ic.prototype.DefaultInterpolation = le;
+                class rc extends ic {}
+                rc.prototype.ValueTypeName = "bool", rc.prototype.ValueBufferType = Array, rc.prototype.DefaultInterpolation = oe, rc.prototype.InterpolantFactoryMethodLinear = void 0, rc.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class sc extends ic {}
+                sc.prototype.ValueTypeName = "color";
+                class ac extends ic {}
+                ac.prototype.ValueTypeName = "number";
+                class oc extends $l {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t, e, n, i) {
                         const r = this.resultBuffer,
                             s = this.sampleValues,
                             a = this.valueSize,
                             o = (n - e) / (i - e);
                         let l = t * a;
-                        for (let t = l + a; l !== t; l += 4) pt.slerpFlat(r, 0, s, l - a, s, l, o);
+                        for (let t = l + a; l !== t; l += 4) Ke.slerpFlat(r, 0, s, l - a, s, l, o);
                         return r
                     }
                 }
-                class _o extends fo {
+                class lc extends ic {
                     InterpolantFactoryMethodLinear(t) {
-                        return new yo(this.times, this.values, this.getValueSize(), t)
+                        return new oc(this.times, this.values, this.getValueSize(), t)
                     }
                 }
-                _o.prototype.ValueTypeName = "quaternion", _o.prototype.DefaultInterpolation = A, _o.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class Mo extends fo {}
-                Mo.prototype.ValueTypeName = "string", Mo.prototype.ValueBufferType = Array, Mo.prototype.DefaultInterpolation = T, Mo.prototype.InterpolantFactoryMethodLinear = void 0, Mo.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class bo extends fo {}
-                bo.prototype.ValueTypeName = "vector";
-                class wo {
+                lc.prototype.ValueTypeName = "quaternion", lc.prototype.DefaultInterpolation = le, lc.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class cc extends ic {}
+                cc.prototype.ValueTypeName = "string", cc.prototype.ValueBufferType = Array, cc.prototype.DefaultInterpolation = oe, cc.prototype.InterpolantFactoryMethodLinear = void 0, cc.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class hc extends ic {}
+                hc.prototype.ValueTypeName = "vector";
+                class uc {
                     constructor(t, e = -1, n, i = 2500) {
-                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = k(), this.duration < 0 && this.resetDuration()
+                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Ae(), this.duration < 0 && this.resetDuration()
                     }
                     static parse(t) {
                         const e = [],
                             n = t.tracks,
                             i = 1 / (t.fps || 1);
-                        for (let t = 0, r = n.length; t !== r; ++t) e.push(So(n[t]).scale(i));
+                        for (let t = 0, r = n.length; t !== r; ++t) e.push(dc(n[t]).scale(i));
                         const r = new this(t.name, t.duration, e, t.blendMode);
                         return r.uuid = t.uuid, r
                     }
                     static toJSON(t) {
                         const e = [],
                             n = t.tracks,
                             i = {
                                 name: t.name,
                                 duration: t.duration,
                                 tracks: e,
                                 uuid: t.uuid,
                                 blendMode: t.blendMode
                             };
-                        for (let t = 0, i = n.length; t !== i; ++t) e.push(fo.toJSON(n[t]));
+                        for (let t = 0, i = n.length; t !== i; ++t) e.push(ic.toJSON(n[t]));
                         return i
                     }
                     static CreateFromMorphTargetSequence(t, e, n, i) {
                         const r = e.length,
                             s = [];
                         for (let t = 0; t < r; t++) {
                             let a = [],
                                 o = [];
                             a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
-                            const l = co.getKeyframeOrder(a);
-                            a = co.sortedArray(a, 1, l), o = co.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new xo(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / n))
+                            const l = Ql.getKeyframeOrder(a);
+                            a = Ql.sortedArray(a, 1, l), o = Ql.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new ac(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / n))
                         }
                         return new this(t, -1, s)
                     }
                     static findByName(t, e) {
                         let n = t;
                         if (!Array.isArray(t)) {
                             const e = t;
@@ -28223,15 +28690,15 @@
                     }
                     static parseAnimation(t, e) {
                         if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                         const n = function(t, e, n, i, r) {
                                 if (0 !== n.length) {
                                     const s = [],
                                         a = [];
-                                    co.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a))
+                                    Ql.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a))
                                 }
                             },
                             i = [],
                             r = t.name || "default",
                             s = t.fps || 30,
                             a = t.blendMode;
                         let o = t.length || -1;
@@ -28248,20 +28715,20 @@
                                     for (const n in t) {
                                         const t = [],
                                             s = [];
                                         for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                             const i = r[e];
                                             t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                         }
-                                        i.push(new xo(".morphTargetInfluence[" + n + "]", t, s))
+                                        i.push(new ac(".morphTargetInfluence[" + n + "]", t, s))
                                     }
                                     o = t.length * (s || 1)
                                 } else {
                                     const s = ".bones[" + e[t].name + "]";
-                                    n(bo, s + ".position", r, "pos", i), n(_o, s + ".quaternion", r, "rot", i), n(bo, s + ".scale", r, "scl", i)
+                                    n(hc, s + ".position", r, "pos", i), n(lc, s + ".quaternion", r, "rot", i), n(hc, s + ".scale", r, "scl", i)
                                 }
                         }
                         return 0 === i.length ? null : new this(r, o, i, a)
                     }
                     resetDuration() {
                         let t = 0;
                         for (let e = 0, n = this.tracks.length; e !== n; ++e) {
@@ -28289,49 +28756,49 @@
                         return new this.constructor(this.name, this.duration, t, this.blendMode)
                     }
                     toJSON() {
                         return this.constructor.toJSON(this)
                     }
                 }
 
-                function So(t) {
+                function dc(t) {
                     if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                     const e = function(t) {
                         switch (t.toLowerCase()) {
                             case "scalar":
                             case "double":
                             case "float":
                             case "number":
                             case "integer":
-                                return xo;
+                                return ac;
                             case "vector":
                             case "vector2":
                             case "vector3":
                             case "vector4":
-                                return bo;
+                                return hc;
                             case "color":
-                                return vo;
+                                return sc;
                             case "quaternion":
-                                return _o;
+                                return lc;
                             case "bool":
                             case "boolean":
-                                return go;
+                                return rc;
                             case "string":
-                                return Mo
+                                return cc
                         }
                         throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                     }(t.type);
                     if (void 0 === t.times) {
                         const e = [],
                             n = [];
-                        co.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
+                        Ql.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                     }
                     return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                 }
-                const Eo = {
+                const pc = {
                     enabled: !1,
                     files: {},
                     add: function(t, e) {
                         !1 !== this.enabled && (this.files[t] = e)
                     },
                     get: function(t) {
                         if (!1 !== this.enabled) return this.files[t]
@@ -28339,15 +28806,15 @@
                     remove: function(t) {
                         delete this.files[t]
                     },
                     clear: function() {
                         this.files = {}
                     }
                 };
-                const To = new class {
+                const mc = new class {
                     constructor(t, e, n) {
                         const i = this;
                         let r, s = !1,
                             a = 0,
                             o = 0;
                         const l = [];
                         this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
@@ -28371,17 +28838,17 @@
                                     i = l[e + 1];
                                 if (n.global && (n.lastIndex = 0), n.test(t)) return i
                             }
                             return null
                         }
                     }
                 };
-                class Ao {
+                class fc {
                     constructor(t) {
-                        this.manager = void 0 !== t ? t : To, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
+                        this.manager = void 0 !== t ? t : mc, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                     }
                     load() {}
                     loadAsync(t, e) {
                         const n = this;
                         return new Promise((function(i, r) {
                             n.load(t, i, e, r)
                         }))
@@ -28399,45 +28866,45 @@
                     setResourcePath(t) {
                         return this.resourcePath = t, this
                     }
                     setRequestHeader(t) {
                         return this.requestHeader = t, this
                     }
                 }
-                const Ro = {};
-                class Lo extends Ao {
+                const gc = {};
+                class vc extends fc {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
-                        const r = Eo.get(t);
+                        const r = pc.get(t);
                         if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => {
                             e && e(r), this.manager.itemEnd(t)
                         }), 0), r;
-                        if (void 0 !== Ro[t]) return void Ro[t].push({
+                        if (void 0 !== gc[t]) return void gc[t].push({
                             onLoad: e,
                             onProgress: n,
                             onError: i
                         });
-                        Ro[t] = [], Ro[t].push({
+                        gc[t] = [], gc[t].push({
                             onLoad: e,
                             onProgress: n,
                             onError: i
                         });
                         const s = new Request(t, {
                                 headers: new Headers(this.requestHeader),
                                 credentials: this.withCredentials ? "include" : "same-origin"
                             }),
                             a = this.mimeType,
                             o = this.responseType;
                         fetch(s).then((e => {
                             if (200 === e.status || 0 === e.status) {
                                 if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body.getReader) return e;
-                                const n = Ro[t],
+                                const n = gc[t],
                                     i = e.body.getReader(),
                                     r = e.headers.get("Content-Length"),
                                     s = r ? parseInt(r) : 0,
                                     a = 0 !== s;
                                 let o = 0;
                                 const l = new ReadableStream({
                                     start(t) {
@@ -28482,25 +28949,25 @@
                                         const e = /charset="?([^;"\s]*)"?/i.exec(a),
                                             n = e && e[1] ? e[1].toLowerCase() : void 0,
                                             i = new TextDecoder(n);
                                         return t.arrayBuffer().then((t => i.decode(t)))
                                     }
                             }
                         })).then((e => {
-                            Eo.add(t, e);
-                            const n = Ro[t];
-                            delete Ro[t];
+                            pc.add(t, e);
+                            const n = gc[t];
+                            delete gc[t];
                             for (let t = 0, i = n.length; t < i; t++) {
                                 const i = n[t];
                                 i.onLoad && i.onLoad(e)
                             }
                         })).catch((e => {
-                            const n = Ro[t];
+                            const n = gc[t];
                             if (void 0 === n) throw this.manager.itemError(t), e;
-                            delete Ro[t];
+                            delete gc[t];
                             for (let t = 0, i = n.length; t < i; t++) {
                                 const i = n[t];
                                 i.onError && i.onError(e)
                             }
                             this.manager.itemError(t)
                         })).finally((() => {
                             this.manager.itemEnd(t)
@@ -28509,111 +28976,111 @@
                     setResponseType(t) {
                         return this.responseType = t, this
                     }
                     setMimeType(t) {
                         return this.mimeType = t, this
                     }
                 }
-                class Co extends Ao {
+                class xc extends fc {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                         const r = this,
-                            s = Eo.get(t);
+                            s = pc.get(t);
                         if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                             e && e(s), r.manager.itemEnd(t)
                         }), 0), s;
-                        const a = K("img");
+                        const a = Oe("img");
 
                         function o() {
-                            c(), Eo.add(t, this), e && e(this), r.manager.itemEnd(t)
+                            c(), pc.add(t, this), e && e(this), r.manager.itemEnd(t)
                         }
 
                         function l(e) {
                             c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                         }
 
                         function c() {
                             a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
                         }
                         return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                     }
                 }
-                class Po extends Ao {
+                class yc extends fc {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
-                        const r = new _n,
-                            s = new Co(this.manager);
+                        const r = new rr,
+                            s = new xc(this.manager);
                         s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                         let a = 0;
 
                         function o(n) {
                             s.load(t[n], (function(t) {
                                 r.images[n] = t, a++, 6 === a && (r.needsUpdate = !0, e && e(r))
                             }), void 0, i)
                         }
                         for (let e = 0; e < t.length; ++e) o(e);
                         return r
                     }
                 }
-                class Do extends Ao {
+                class _c extends fc {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
-                        const r = new lt,
-                            s = new Co(this.manager);
+                        const r = new Xe,
+                            s = new xc(this.manager);
                         return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(t) {
                             r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                         }), n, i), r
                     }
                 }
-                class Io extends ge {
+                class Mc extends ei {
                     constructor(t, e = 1) {
-                        super(), this.type = "Light", this.color = new rt(t), this.intensity = e
+                        super(), this.type = "Light", this.color = new Ve(t), this.intensity = e
                     }
                     dispose() {}
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                     }
                 }
-                Io.prototype.isLight = !0;
-                (class extends Io {
+                Mc.prototype.isLight = !0;
+                (class extends Mc {
                     constructor(t, e, n) {
-                        super(t, n), this.type = "HemisphereLight", this.position.copy(ge.DefaultUp), this.updateMatrix(), this.groundColor = new rt(e)
+                        super(t, n), this.type = "HemisphereLight", this.position.copy(ei.DefaultUp), this.updateMatrix(), this.groundColor = new Ve(e)
                     }
                     copy(t) {
-                        return Io.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
+                        return Mc.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                     }
                 }).prototype.isHemisphereLight = !0;
-                const No = new jt,
-                    Oo = new mt,
-                    Uo = new mt;
-                class Bo {
+                const bc = new Cn,
+                    wc = new Qe,
+                    Sc = new Qe;
+                class Ec {
                     constructor(t) {
-                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Y(512, 512), this.map = null, this.mapPass = null, this.matrix = new jt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Rn, this._frameExtents = new Y(1, 1), this._viewportCount = 1, this._viewports = [new ht(0, 0, 1, 1)]
+                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new De(512, 512), this.map = null, this.mapPass = null, this.matrix = new Cn, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new dr, this._frameExtents = new De(1, 1), this._viewportCount = 1, this._viewports = [new Ye(0, 0, 1, 1)]
                     }
                     getViewportCount() {
                         return this._viewportCount
                     }
                     getFrustum() {
                         return this._frustum
                     }
                     updateMatrices(t) {
                         const e = this.camera,
                             n = this.matrix;
-                        Oo.setFromMatrixPosition(t.matrixWorld), e.position.copy(Oo), Uo.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Uo), e.updateMatrixWorld(), No.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(No), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
+                        wc.setFromMatrixPosition(t.matrixWorld), e.position.copy(wc), Sc.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Sc), e.updateMatrixWorld(), bc.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(bc), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                     }
                     getViewport(t) {
                         return this._viewports[t]
                     }
                     getFrameExtents() {
                         return this._frameExtents
                     }
@@ -28627,102 +29094,102 @@
                         return (new this.constructor).copy(this)
                     }
                     toJSON() {
                         const t = {};
                         return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                     }
                 }
-                class Fo extends Bo {
+                class Tc extends Ec {
                     constructor() {
-                        super(new vn(50, 1, .5, 500)), this.focus = 1
+                        super(new er(50, 1, .5, 500)), this.focus = 1
                     }
                     updateMatrices(t) {
                         const e = this.camera,
-                            n = 2 * V * t.angle * this.focus,
+                            n = 2 * Te * t.angle * this.focus,
                             i = this.mapSize.width / this.mapSize.height,
                             r = t.distance || e.far;
                         n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                     }
                     copy(t) {
                         return super.copy(t), this.focus = t.focus, this
                     }
                 }
-                Fo.prototype.isSpotLightShadow = !0;
-                (class extends Io {
+                Tc.prototype.isSpotLightShadow = !0;
+                (class extends Mc {
                     constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
-                        super(t, e), this.type = "SpotLight", this.position.copy(ge.DefaultUp), this.updateMatrix(), this.target = new ge, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new Fo
+                        super(t, e), this.type = "SpotLight", this.position.copy(ei.DefaultUp), this.updateMatrix(), this.target = new ei, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new Tc
                     }
                     get power() {
                         return this.intensity * Math.PI
                     }
                     set power(t) {
                         this.intensity = t / Math.PI
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                     }
                 }).prototype.isSpotLight = !0;
-                const zo = new jt,
-                    Ho = new mt,
-                    Go = new mt;
-                class Vo extends Bo {
+                const Ac = new Cn,
+                    Rc = new Qe,
+                    Lc = new Qe;
+                class Cc extends Ec {
                     constructor() {
-                        super(new vn(90, 1, .5, 500)), this._frameExtents = new Y(4, 2), this._viewportCount = 6, this._viewports = [new ht(2, 1, 1, 1), new ht(0, 1, 1, 1), new ht(3, 1, 1, 1), new ht(1, 1, 1, 1), new ht(3, 0, 1, 1), new ht(1, 0, 1, 1)], this._cubeDirections = [new mt(1, 0, 0), new mt(-1, 0, 0), new mt(0, 0, 1), new mt(0, 0, -1), new mt(0, 1, 0), new mt(0, -1, 0)], this._cubeUps = [new mt(0, 1, 0), new mt(0, 1, 0), new mt(0, 1, 0), new mt(0, 1, 0), new mt(0, 0, 1), new mt(0, 0, -1)]
+                        super(new er(90, 1, .5, 500)), this._frameExtents = new De(4, 2), this._viewportCount = 6, this._viewports = [new Ye(2, 1, 1, 1), new Ye(0, 1, 1, 1), new Ye(3, 1, 1, 1), new Ye(1, 1, 1, 1), new Ye(3, 0, 1, 1), new Ye(1, 0, 1, 1)], this._cubeDirections = [new Qe(1, 0, 0), new Qe(-1, 0, 0), new Qe(0, 0, 1), new Qe(0, 0, -1), new Qe(0, 1, 0), new Qe(0, -1, 0)], this._cubeUps = [new Qe(0, 1, 0), new Qe(0, 1, 0), new Qe(0, 1, 0), new Qe(0, 1, 0), new Qe(0, 0, 1), new Qe(0, 0, -1)]
                     }
                     updateMatrices(t, e = 0) {
                         const n = this.camera,
                             i = this.matrix,
                             r = t.distance || n.far;
-                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Ho.setFromMatrixPosition(t.matrixWorld), n.position.copy(Ho), Go.copy(n.position), Go.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Go), n.updateMatrixWorld(), i.makeTranslation(-Ho.x, -Ho.y, -Ho.z), zo.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(zo)
+                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Rc.setFromMatrixPosition(t.matrixWorld), n.position.copy(Rc), Lc.copy(n.position), Lc.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Lc), n.updateMatrixWorld(), i.makeTranslation(-Rc.x, -Rc.y, -Rc.z), Ac.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ac)
                     }
                 }
-                Vo.prototype.isPointLightShadow = !0;
-                (class extends Io {
+                Cc.prototype.isPointLightShadow = !0;
+                (class extends Mc {
                     constructor(t, e, n = 0, i = 1) {
-                        super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Vo
+                        super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Cc
                     }
                     get power() {
                         return 4 * this.intensity * Math.PI
                     }
                     set power(t) {
                         this.intensity = t / (4 * Math.PI)
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                     }
                 }).prototype.isPointLight = !0;
-                class ko extends Bo {
+                class Pc extends Ec {
                     constructor() {
-                        super(new Gn(-5, 5, 5, -5, .5, 500))
+                        super(new Er(-5, 5, 5, -5, .5, 500))
                     }
                 }
-                ko.prototype.isDirectionalLightShadow = !0;
-                (class extends Io {
+                Pc.prototype.isDirectionalLightShadow = !0;
+                (class extends Mc {
                     constructor(t, e) {
-                        super(t, e), this.type = "DirectionalLight", this.position.copy(ge.DefaultUp), this.updateMatrix(), this.target = new ge, this.shadow = new ko
+                        super(t, e), this.type = "DirectionalLight", this.position.copy(ei.DefaultUp), this.updateMatrix(), this.target = new ei, this.shadow = new Pc
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                     }
                 }).prototype.isDirectionalLight = !0;
-                (class extends Io {
+                (class extends Mc {
                     constructor(t, e) {
                         super(t, e), this.type = "AmbientLight"
                     }
                 }).prototype.isAmbientLight = !0;
-                (class extends Io {
+                (class extends Mc {
                     constructor(t, e, n = 10, i = 10) {
                         super(t, e), this.type = "RectAreaLight", this.width = n, this.height = i
                     }
                     get power() {
                         return this.intensity * this.width * this.height * Math.PI
                     }
                     set power(t) {
@@ -28732,18 +29199,18 @@
                         return super.copy(t), this.width = t.width, this.height = t.height, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.width = this.width, e.object.height = this.height, e
                     }
                 }).prototype.isRectAreaLight = !0;
-                class Wo {
+                class Dc {
                     constructor() {
                         this.coefficients = [];
-                        for (let t = 0; t < 9; t++) this.coefficients.push(new mt)
+                        for (let t = 0; t < 9; t++) this.coefficients.push(new Qe)
                     }
                     set(t) {
                         for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                         return this
                     }
                     zero() {
                         for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
@@ -28803,32 +29270,32 @@
                     static getBasisAt(t, e) {
                         const n = t.x,
                             i = t.y,
                             r = t.z;
                         e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                     }
                 }
-                Wo.prototype.isSphericalHarmonics3 = !0;
-                class jo extends Io {
-                    constructor(t = new Wo, e = 1) {
+                Dc.prototype.isSphericalHarmonics3 = !0;
+                class Ic extends Mc {
+                    constructor(t = new Dc, e = 1) {
                         super(void 0, e), this.sh = t
                     }
                     copy(t) {
                         return super.copy(t), this.sh.copy(t.sh), this
                     }
                     fromJSON(t) {
                         return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.sh = this.sh.toArray(), e
                     }
                 }
-                jo.prototype.isLightProbe = !0;
-                class Xo {
+                Ic.prototype.isLightProbe = !0;
+                class Nc {
                     static decodeText(t) {
                         if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                         let e = "";
                         for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                         try {
                             return decodeURIComponent(escape(e))
                         } catch (t) {
@@ -28839,96 +29306,96 @@
                         const e = t.lastIndexOf("/");
                         return -1 === e ? "./" : t.substr(0, e + 1)
                     }
                     static resolveURL(t, e) {
                         return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                     }
                 }
-                let qo;
-                (class extends We {
+                let Oc;
+                (class extends Li {
                     constructor() {
                         super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                     }
                     copy(t) {
                         return super.copy(t), this.instanceCount = t.instanceCount, this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     toJSON() {
                         const t = super.toJSON(this);
                         return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                     }
-                }).prototype.isInstancedBufferGeometry = !0, class extends Ao {
+                }).prototype.isInstancedBufferGeometry = !0, class extends fc {
                     constructor(t) {
                         super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                             premultiplyAlpha: "none"
                         }
                     }
                     setOptions(t) {
                         return this.options = t, this
                     }
                     load(t, e, n, i) {
                         void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                         const r = this,
-                            s = Eo.get(t);
+                            s = pc.get(t);
                         if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                             e && e(s), r.manager.itemEnd(t)
                         }), 0), s;
                         const a = {};
                         a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(t, a).then((function(t) {
                             return t.blob()
                         })).then((function(t) {
                             return createImageBitmap(t, Object.assign(r.options, {
                                 colorSpaceConversion: "none"
                             }))
                         })).then((function(n) {
-                            Eo.add(t, n), e && e(n), r.manager.itemEnd(t)
+                            pc.add(t, n), e && e(n), r.manager.itemEnd(t)
                         })).catch((function(e) {
                             i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                         })), r.manager.itemStart(t)
                     }
                 }.prototype.isImageBitmapLoader = !0;
-                class Yo extends Ao {
+                class Uc extends fc {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new Lo(this.manager);
+                            s = new vc(this.manager);
                         s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                             try {
                                 const t = n.slice(0);
-                                (void 0 === qo && (qo = new(window.AudioContext || window.webkitAudioContext)), qo).decodeAudioData(t, (function(t) {
+                                (void 0 === Oc && (Oc = new(window.AudioContext || window.webkitAudioContext)), Oc).decodeAudioData(t, (function(t) {
                                     e(t)
                                 }))
                             } catch (e) {
                                 i ? i(e) : console.error(e), r.manager.itemError(t)
                             }
                         }), n, i)
                     }
-                }(class extends jo {
+                }(class extends Ic {
                     constructor(t, e, n = 1) {
                         super(void 0, n);
-                        const i = (new rt).set(t),
-                            r = (new rt).set(e),
-                            s = new mt(i.r, i.g, i.b),
-                            a = new mt(r.r, r.g, r.b),
+                        const i = (new Ve).set(t),
+                            r = (new Ve).set(e),
+                            s = new Qe(i.r, i.g, i.b),
+                            a = new Qe(r.r, r.g, r.b),
                             o = Math.sqrt(Math.PI),
                             l = o * Math.sqrt(.75);
                         this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
                     }
-                }).prototype.isHemisphereLightProbe = !0, class extends jo {
+                }).prototype.isHemisphereLightProbe = !0, class extends Ic {
                     constructor(t, e = 1) {
                         super(void 0, e);
-                        const n = (new rt).set(t);
+                        const n = (new Ve).set(t);
                         this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                     }
                 }.prototype.isAmbientLightProbe = !0;
-                class Zo {
+                class Bc {
                     constructor(t, e, n) {
                         let i, r, s;
                         switch (this.binding = t, this.valueSize = n, e) {
                             case "quaternion":
                                 i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                                 break;
                             case "string":
@@ -29006,19 +29473,19 @@
                         for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                     }
                     _select(t, e, n, i, r) {
                         if (i >= .5)
                             for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
                     }
                     _slerp(t, e, n, i) {
-                        pt.slerpFlat(t, e, t, e, t, n, i)
+                        Ke.slerpFlat(t, e, t, e, t, n, i)
                     }
                     _slerpAdditive(t, e, n, i, r) {
                         const s = this._workIndex * r;
-                        pt.multiplyQuaternionsFlat(t, s, t, e, t, n), pt.slerpFlat(t, e, t, e, t, s, i)
+                        Ke.multiplyQuaternionsFlat(t, s, t, e, t, n), Ke.slerpFlat(t, e, t, e, t, s, i)
                     }
                     _lerp(t, e, n, i, r) {
                         const s = 1 - i;
                         for (let a = 0; a !== r; ++a) {
                             const r = e + a;
                             t[r] = t[r] * s + t[n + a] * i
                         }
@@ -29026,46 +29493,47 @@
                     _lerpAdditive(t, e, n, i, r) {
                         for (let s = 0; s !== r; ++s) {
                             const r = e + s;
                             t[r] = t[r] + t[n + s] * i
                         }
                     }
                 }
-                const Jo = new RegExp("[\\[\\]\\.:\\/]", "g"),
-                    Ko = "[^\\[\\]\\.:\\/]",
-                    Qo = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
-                    $o = /((?:WC+[\/:])*)/.source.replace("WC", Ko),
-                    tl = /(WCOD+)?/.source.replace("WCOD", Qo),
-                    el = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ko),
-                    nl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ko),
-                    il = new RegExp("^" + $o + tl + el + nl + "$"),
-                    rl = ["material", "materials", "bones"];
-                class sl {
+                const Fc = "\\[\\]\\.:\\/",
+                    zc = new RegExp("[" + Fc + "]", "g"),
+                    Hc = "[^" + Fc + "]",
+                    Gc = "[^" + Fc.replace("\\.", "") + "]",
+                    Vc = /((?:WC+[\/:])*)/.source.replace("WC", Hc),
+                    kc = /(WCOD+)?/.source.replace("WCOD", Gc),
+                    Wc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Hc),
+                    jc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Hc),
+                    Xc = new RegExp("^" + Vc + kc + Wc + jc + "$"),
+                    qc = ["material", "materials", "bones"];
+                class Yc {
                     constructor(t, e, n) {
-                        this.path = e, this.parsedPath = n || sl.parseTrackName(e), this.node = sl.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
+                        this.path = e, this.parsedPath = n || Yc.parseTrackName(e), this.node = Yc.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                     }
                     static create(t, e, n) {
-                        return t && t.isAnimationObjectGroup ? new sl.Composite(t, e, n) : new sl(t, e, n)
+                        return t && t.isAnimationObjectGroup ? new Yc.Composite(t, e, n) : new Yc(t, e, n)
                     }
                     static sanitizeNodeName(t) {
-                        return t.replace(/\s/g, "_").replace(Jo, "")
+                        return t.replace(/\s/g, "_").replace(zc, "")
                     }
                     static parseTrackName(t) {
-                        const e = il.exec(t);
+                        const e = Xc.exec(t);
                         if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                         const n = {
                                 nodeName: e[2],
                                 objectName: e[3],
                                 objectIndex: e[4],
                                 propertyName: e[5],
                                 propertyIndex: e[6]
                             },
                             i = n.nodeName && n.nodeName.lastIndexOf(".");
                         if (void 0 !== i && -1 !== i) {
-                            const t = n.nodeName.substring(i + 1); - 1 !== rl.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
+                            const t = n.nodeName.substring(i + 1); - 1 !== qc.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                         }
                         if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                         return n
                     }
                     static findNode(t, e) {
                         if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                         if (t.skeleton) {
@@ -29151,15 +29619,15 @@
                     }
                     bind() {
                         let t = this.node;
                         const e = this.parsedPath,
                             n = e.objectName,
                             i = e.propertyName;
                         let r = e.propertyIndex;
-                        if (t || (t = sl.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
+                        if (t || (t = Yc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                         if (n) {
                             let i = e.objectIndex;
                             switch (n) {
                                 case "materials":
                                     if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                     if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                     t = t.material.materials;
@@ -29200,17 +29668,17 @@
                         } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                         this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
                     }
                     unbind() {
                         this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                     }
                 }
-                sl.Composite = class {
+                Yc.Composite = class {
                     constructor(t, e, n) {
-                        const i = n || sl.parseTrackName(e);
+                        const i = n || Yc.parseTrackName(e);
                         this._targetGroup = t, this._bindings = t.subscribe_(e, i)
                     }
                     getValue(t, e) {
                         this.bind();
                         const n = this._targetGroup.nCachedObjects_,
                             i = this._bindings[n];
                         void 0 !== i && i.getValue(t, e)
@@ -29223,38 +29691,38 @@
                         const t = this._bindings;
                         for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                     }
                     unbind() {
                         const t = this._bindings;
                         for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                     }
-                }, sl.prototype.BindingType = {
+                }, Yc.prototype.BindingType = {
                     Direct: 0,
                     EntireArray: 1,
                     ArrayElement: 2,
                     HasFromToArray: 3
-                }, sl.prototype.Versioning = {
+                }, Yc.prototype.Versioning = {
                     None: 0,
                     NeedsUpdate: 1,
                     MatrixWorldNeedsUpdate: 2
-                }, sl.prototype.GetterByBindingType = [sl.prototype._getValue_direct, sl.prototype._getValue_array, sl.prototype._getValue_arrayElement, sl.prototype._getValue_toArray], sl.prototype.SetterByBindingTypeAndVersioning = [
-                    [sl.prototype._setValue_direct, sl.prototype._setValue_direct_setNeedsUpdate, sl.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
-                    [sl.prototype._setValue_array, sl.prototype._setValue_array_setNeedsUpdate, sl.prototype._setValue_array_setMatrixWorldNeedsUpdate],
-                    [sl.prototype._setValue_arrayElement, sl.prototype._setValue_arrayElement_setNeedsUpdate, sl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
-                    [sl.prototype._setValue_fromArray, sl.prototype._setValue_fromArray_setNeedsUpdate, sl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
+                }, Yc.prototype.GetterByBindingType = [Yc.prototype._getValue_direct, Yc.prototype._getValue_array, Yc.prototype._getValue_arrayElement, Yc.prototype._getValue_toArray], Yc.prototype.SetterByBindingTypeAndVersioning = [
+                    [Yc.prototype._setValue_direct, Yc.prototype._setValue_direct_setNeedsUpdate, Yc.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
+                    [Yc.prototype._setValue_array, Yc.prototype._setValue_array_setNeedsUpdate, Yc.prototype._setValue_array_setMatrixWorldNeedsUpdate],
+                    [Yc.prototype._setValue_arrayElement, Yc.prototype._setValue_arrayElement_setNeedsUpdate, Yc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
+                    [Yc.prototype._setValue_fromArray, Yc.prototype._setValue_fromArray_setNeedsUpdate, Yc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                 ];
-                class al {
+                class Zc {
                     constructor(t, e, n = null, i = e.blendMode) {
                         this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                         const r = e.tracks,
                             s = r.length,
                             a = new Array(s),
                             o = {
-                                endingStart: L,
-                                endingEnd: L
+                                endingStart: he,
+                                endingEnd: he
                             };
                         for (let t = 0; t !== s; ++t) {
                             const e = r[t].createInterpolant(null);
                             a[t] = e, e.settings = o
                         }
                         this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                     }
@@ -29437,26 +29905,26 @@
                             } else this.time = i;
                             if (s && 1 == (1 & r)) return e - i
                         }
                         return i
                     }
                     _setEndings(t, e, n) {
                         const i = this._interpolantSettings;
-                        n ? (i.endingStart = C, i.endingEnd = C) : (i.endingStart = t ? this.zeroSlopeAtStart ? C : L : P, i.endingEnd = e ? this.zeroSlopeAtEnd ? C : L : P)
+                        n ? (i.endingStart = ue, i.endingEnd = ue) : (i.endingStart = t ? this.zeroSlopeAtStart ? ue : he : de, i.endingEnd = e ? this.zeroSlopeAtEnd ? ue : he : de)
                     }
                     _scheduleFading(t, e, n) {
                         const i = this._mixer,
                             r = i.time;
                         let s = this._weightInterpolant;
                         null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                         const a = s.parameterPositions,
                             o = s.sampleValues;
                         return a[0] = r, o[0] = e, a[1] = r + t, o[1] = n, this
                     }
-                }(class extends z {
+                }(class extends we {
                     constructor(t) {
                         super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                     }
                     _bindAction(t, e) {
                         const n = t._localRoot || this._root,
                             i = t._clip.tracks,
                             r = i.length,
@@ -29473,15 +29941,15 @@
                             if (void 0 !== h) ++h.referenceCount, s[t] = h;
                             else {
                                 if (h = s[t], void 0 !== h) {
                                     null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l));
                                     continue
                                 }
                                 const i = e && e._propertyBindings[t].binding.parsedPath;
-                                h = new Zo(sl.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), s[t] = h
+                                h = new Bc(Yc.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), s[t] = h
                             }
                             a[t].resultBuffer = h.buffer
                         }
                     }
                     _activateAction(t) {
                         if (!this._isActiveAction(t)) {
                             if (null === t._cacheIndex) {
@@ -29621,43 +30089,43 @@
                             r = e[i];
                         t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                     }
                     _lendControlInterpolant() {
                         const t = this._controlInterpolants,
                             e = this._nActiveControlInterpolants++;
                         let n = t[e];
-                        return void 0 === n && (n = new po(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
+                        return void 0 === n && (n = new ec(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                     }
                     _takeBackControlInterpolant(t) {
                         const e = this._controlInterpolants,
                             n = t.__cacheIndex,
                             i = --this._nActiveControlInterpolants,
                             r = e[i];
                         t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                     }
                     clipAction(t, e, n) {
                         const i = e || this._root,
                             r = i.uuid;
-                        let s = "string" == typeof t ? wo.findByName(i, t) : t;
+                        let s = "string" == typeof t ? uc.findByName(i, t) : t;
                         const a = null !== s ? s.uuid : t,
                             o = this._actionsByClip[a];
                         let l = null;
                         if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o) {
                             const t = o.actionByRoot[r];
                             if (void 0 !== t && t.blendMode === n) return t;
                             l = o.knownActions[0], null === s && (s = l._clip)
                         }
                         if (null === s) return null;
-                        const c = new al(this, s, e, n);
+                        const c = new Zc(this, s, e, n);
                         return this._bindAction(c, l), this._addInactiveAction(c, a, r), c
                     }
                     existingAction(t, e) {
                         const n = e || this._root,
                             i = n.uuid,
-                            r = "string" == typeof t ? wo.findByName(n, t) : t,
+                            r = "string" == typeof t ? uc.findByName(n, t) : t,
                             s = r ? r.uuid : t,
                             a = this._actionsByClip[s];
                         return void 0 !== a && a.actionByRoot[i] || null
                     }
                     stopAllAction() {
                         const t = this._actions;
                         for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
@@ -29716,22 +30184,22 @@
                             }
                     }
                     uncacheAction(t, e) {
                         const n = this.existingAction(t, e);
                         null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                     }
                 }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
-                class ol {
+                class Jc {
                     constructor(t) {
                         "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                     }
                     clone() {
-                        return new ol(void 0 === this.value.clone ? this.value : this.value.clone())
+                        return new Jc(void 0 === this.value.clone ? this.value : this.value.clone())
                     }
-                }(class extends ys {
+                }(class extends oo {
                     constructor(t, e, n = 1) {
                         super(t, e), this.meshPerAttribute = n
                     }
                     copy(t) {
                         return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                     }
                     clone(t) {
@@ -29739,15 +30207,15 @@
                         return e.meshPerAttribute = this.meshPerAttribute, e
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                     }
                 }).prototype.isInstancedInterleavedBuffer = !0;
-                class ll {
+                class Kc {
                     constructor(t = 1, e = 0, n = 0) {
                         return this.radius = t, this.phi = e, this.theta = n, this
                     }
                     set(t, e, n) {
                         return this.radius = t, this.phi = e, this.theta = n, this
                     }
                     copy(t) {
@@ -29757,35 +30225,35 @@
                         const t = 1e-6;
                         return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
                     }
                     setFromVector3(t) {
                         return this.setFromCartesianCoords(t.x, t.y, t.z)
                     }
                     setFromCartesianCoords(t, e, n) {
-                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(W(e / this.radius, -1, 1))), this
+                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Re(e / this.radius, -1, 1))), this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                const cl = new Y;
-                class hl {
-                    constructor(t = new Y(1 / 0, 1 / 0), e = new Y(-1 / 0, -1 / 0)) {
+                const Qc = new De;
+                class $c {
+                    constructor(t = new De(1 / 0, 1 / 0), e = new De(-1 / 0, -1 / 0)) {
                         this.min = t, this.max = e
                     }
                     set(t, e) {
                         return this.min.copy(t), this.max.copy(e), this
                     }
                     setFromPoints(t) {
                         this.makeEmpty();
                         for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                         return this
                     }
                     setFromCenterAndSize(t, e) {
-                        const n = cl.copy(e).multiplyScalar(.5);
+                        const n = Qc.copy(e).multiplyScalar(.5);
                         return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     copy(t) {
                         return this.min.copy(t.min), this.max.copy(t.max), this
@@ -29823,251 +30291,251 @@
                     intersectsBox(t) {
                         return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                     }
                     clampPoint(t, e) {
                         return e.copy(t).clamp(this.min, this.max)
                     }
                     distanceToPoint(t) {
-                        return cl.copy(t).clamp(this.min, this.max).sub(t).length()
+                        return Qc.copy(t).clamp(this.min, this.max).sub(t).length()
                     }
                     intersect(t) {
                         return this.min.max(t.min), this.max.min(t.max), this
                     }
                     union(t) {
                         return this.min.min(t.min), this.max.max(t.max), this
                     }
                     translate(t) {
                         return this.min.add(t), this.max.add(t), this
                     }
                     equals(t) {
                         return t.min.equals(this.min) && t.max.equals(this.max)
                     }
                 }
-                hl.prototype.isBox2 = !0;
-                const ul = new mt,
-                    dl = new jt,
-                    pl = new jt;
+                $c.prototype.isBox2 = !0;
+                const th = new Qe,
+                    eh = new Cn,
+                    nh = new Cn;
 
-                function ml(t) {
+                function ih(t) {
                     const e = [];
                     t && t.isBone && e.push(t);
-                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, ml(t.children[n]));
+                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, ih(t.children[n]));
                     return e
                 }
-                const fl = new Float32Array(1);
-                new Int32Array(fl.buffer), ha.create = function(t, e) {
-                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(ha.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
-                }, Ca.prototype.fromPoints = function(t) {
+                const rh = new Float32Array(1);
+                new Int32Array(rh.buffer), $o.create = function(t, e) {
+                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create($o.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
+                }, yl.prototype.fromPoints = function(t) {
                     return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
-                }, class extends ia {
+                }, class extends Xo {
                     constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
-                        n = new rt(n), i = new rt(i);
+                        n = new Ve(n), i = new Ve(i);
                         const r = e / 2,
                             s = t / e,
                             a = t / 2,
                             o = [],
                             l = [];
                         for (let t = 0, c = 0, h = -a; t <= e; t++, h += s) {
                             o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
                             const e = t === r ? n : i;
                             e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3
                         }
-                        const c = new We;
-                        c.setAttribute("position", new Ue(o, 3)), c.setAttribute("color", new Ue(l, 3)), super(c, new Ys({
+                        const c = new Li;
+                        c.setAttribute("position", new Mi(o, 3)), c.setAttribute("color", new Mi(l, 3)), super(c, new Bo({
                             vertexColors: !0,
                             toneMapped: !1
                         })), this.type = "GridHelper"
                     }
                 }.prototype.setColors = function() {
                     console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
-                }, class extends ia {
+                }, class extends Xo {
                     constructor(t) {
-                        const e = ml(t),
-                            n = new We,
+                        const e = ih(t),
+                            n = new Li,
                             i = [],
                             r = [],
-                            s = new rt(0, 0, 1),
-                            a = new rt(0, 1, 0);
+                            s = new Ve(0, 0, 1),
+                            a = new Ve(0, 1, 0);
                         for (let t = 0; t < e.length; t++) {
                             const n = e[t];
                             n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
                         }
-                        n.setAttribute("position", new Ue(i, 3)), n.setAttribute("color", new Ue(r, 3)), super(n, new Ys({
+                        n.setAttribute("position", new Mi(i, 3)), n.setAttribute("color", new Mi(r, 3)), super(n, new Bo({
                             vertexColors: !0,
                             depthTest: !1,
                             depthWrite: !1,
                             toneMapped: !1,
                             transparent: !0
                         })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                     }
                     updateMatrixWorld(t) {
                         const e = this.bones,
                             n = this.geometry,
                             i = n.getAttribute("position");
-                        pl.copy(this.root.matrixWorld).invert();
+                        nh.copy(this.root.matrixWorld).invert();
                         for (let t = 0, n = 0; t < e.length; t++) {
                             const r = e[t];
-                            r.parent && r.parent.isBone && (dl.multiplyMatrices(pl, r.matrixWorld), ul.setFromMatrixPosition(dl), i.setXYZ(n, ul.x, ul.y, ul.z), dl.multiplyMatrices(pl, r.parent.matrixWorld), ul.setFromMatrixPosition(dl), i.setXYZ(n + 1, ul.x, ul.y, ul.z), n += 2)
+                            r.parent && r.parent.isBone && (eh.multiplyMatrices(nh, r.matrixWorld), th.setFromMatrixPosition(eh), i.setXYZ(n, th.x, th.y, th.z), eh.multiplyMatrices(nh, r.parent.matrixWorld), th.setFromMatrixPosition(eh), i.setXYZ(n + 1, th.x, th.y, th.z), n += 2)
                         }
                         n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                     }
                 }.prototype.update = function() {
                     console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
-                }, Ao.prototype.extractUrlBase = function(t) {
-                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Xo.extractUrlBase(t)
-                }, Ao.Handlers = {
+                }, fc.prototype.extractUrlBase = function(t) {
+                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Nc.extractUrlBase(t)
+                }, fc.Handlers = {
                     add: function() {
                         console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                     },
                     get: function() {
                         console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                     }
-                }, hl.prototype.center = function(t) {
+                }, $c.prototype.center = function(t) {
                     return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
-                }, hl.prototype.empty = function() {
+                }, $c.prototype.empty = function() {
                     return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, hl.prototype.isIntersectionBox = function(t) {
+                }, $c.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, hl.prototype.size = function(t) {
+                }, $c.prototype.size = function(t) {
                     return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
-                }, vt.prototype.center = function(t) {
+                }, en.prototype.center = function(t) {
                     return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
-                }, vt.prototype.empty = function() {
+                }, en.prototype.empty = function() {
                     return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, vt.prototype.isIntersectionBox = function(t) {
+                }, en.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, vt.prototype.isIntersectionSphere = function(t) {
+                }, en.prototype.isIntersectionSphere = function(t) {
                     return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
-                }, vt.prototype.size = function(t) {
+                }, en.prototype.size = function(t) {
                     return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
-                }, Ut.prototype.empty = function() {
+                }, Mn.prototype.empty = function() {
                     return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, Rn.prototype.setFromMatrix = function(t) {
+                }, dr.prototype.setFromMatrix = function(t) {
                     return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
-                }, Z.prototype.flattenToArrayOffset = function(t, e) {
+                }, Ie.prototype.flattenToArrayOffset = function(t, e) {
                     return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
-                }, Z.prototype.multiplyVector3 = function(t) {
+                }, Ie.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
-                }, Z.prototype.multiplyVector3Array = function() {
+                }, Ie.prototype.multiplyVector3Array = function() {
                     console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
-                }, Z.prototype.applyToBufferAttribute = function(t) {
+                }, Ie.prototype.applyToBufferAttribute = function(t) {
                     return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
-                }, Z.prototype.applyToVector3Array = function() {
+                }, Ie.prototype.applyToVector3Array = function() {
                     console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
-                }, Z.prototype.getInverse = function(t) {
+                }, Ie.prototype.getInverse = function(t) {
                     return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
-                }, jt.prototype.extractPosition = function(t) {
+                }, Cn.prototype.extractPosition = function(t) {
                     return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
-                }, jt.prototype.flattenToArrayOffset = function(t, e) {
+                }, Cn.prototype.flattenToArrayOffset = function(t, e) {
                     return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
-                }, jt.prototype.getPosition = function() {
-                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new mt).setFromMatrixColumn(this, 3)
-                }, jt.prototype.setRotationFromQuaternion = function(t) {
+                }, Cn.prototype.getPosition = function() {
+                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Qe).setFromMatrixColumn(this, 3)
+                }, Cn.prototype.setRotationFromQuaternion = function(t) {
                     return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
-                }, jt.prototype.multiplyToArray = function() {
+                }, Cn.prototype.multiplyToArray = function() {
                     console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
-                }, jt.prototype.multiplyVector3 = function(t) {
+                }, Cn.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, jt.prototype.multiplyVector4 = function(t) {
+                }, Cn.prototype.multiplyVector4 = function(t) {
                     return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, jt.prototype.multiplyVector3Array = function() {
+                }, Cn.prototype.multiplyVector3Array = function() {
                     console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
-                }, jt.prototype.rotateAxis = function(t) {
+                }, Cn.prototype.rotateAxis = function(t) {
                     console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
-                }, jt.prototype.crossVector = function(t) {
+                }, Cn.prototype.crossVector = function(t) {
                     return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, jt.prototype.translate = function() {
+                }, Cn.prototype.translate = function() {
                     console.error("THREE.Matrix4: .translate() has been removed.")
-                }, jt.prototype.rotateX = function() {
+                }, Cn.prototype.rotateX = function() {
                     console.error("THREE.Matrix4: .rotateX() has been removed.")
-                }, jt.prototype.rotateY = function() {
+                }, Cn.prototype.rotateY = function() {
                     console.error("THREE.Matrix4: .rotateY() has been removed.")
-                }, jt.prototype.rotateZ = function() {
+                }, Cn.prototype.rotateZ = function() {
                     console.error("THREE.Matrix4: .rotateZ() has been removed.")
-                }, jt.prototype.rotateByAxis = function() {
+                }, Cn.prototype.rotateByAxis = function() {
                     console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
-                }, jt.prototype.applyToBufferAttribute = function(t) {
+                }, Cn.prototype.applyToBufferAttribute = function(t) {
                     return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, jt.prototype.applyToVector3Array = function() {
+                }, Cn.prototype.applyToVector3Array = function() {
                     console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
-                }, jt.prototype.makeFrustum = function(t, e, n, i, r, s) {
+                }, Cn.prototype.makeFrustum = function(t, e, n, i, r, s) {
                     return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, s)
-                }, jt.prototype.getInverse = function(t) {
+                }, Cn.prototype.getInverse = function(t) {
                     return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
-                }, En.prototype.isIntersectionLine = function(t) {
+                }, cr.prototype.isIntersectionLine = function(t) {
                     return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
-                }, pt.prototype.multiplyVector3 = function(t) {
+                }, Ke.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
-                }, pt.prototype.inverse = function() {
+                }, Ke.prototype.inverse = function() {
                     return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
-                }, Wt.prototype.isIntersectionBox = function(t) {
+                }, Ln.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, Wt.prototype.isIntersectionPlane = function(t) {
+                }, Ln.prototype.isIntersectionPlane = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
-                }, Wt.prototype.isIntersectionSphere = function(t) {
+                }, Ln.prototype.isIntersectionSphere = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
-                }, Ae.prototype.area = function() {
+                }, di.prototype.area = function() {
                     return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
-                }, Ae.prototype.barycoordFromPoint = function(t, e) {
+                }, di.prototype.barycoordFromPoint = function(t, e) {
                     return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
-                }, Ae.prototype.midpoint = function(t) {
+                }, di.prototype.midpoint = function(t) {
                     return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
-                }, Ae.prototypenormal = function(t) {
+                }, di.prototypenormal = function(t) {
                     return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
-                }, Ae.prototype.plane = function(t) {
+                }, di.prototype.plane = function(t) {
                     return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
-                }, Ae.barycoordFromPoint = function(t, e, n, i, r) {
-                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Ae.getBarycoord(t, e, n, i, r)
-                }, Ae.normal = function(t, e, n, i) {
-                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Ae.getNormal(t, e, n, i)
-                }, Pa.prototype.extractAllPoints = function(t) {
+                }, di.barycoordFromPoint = function(t, e, n, i, r) {
+                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), di.getBarycoord(t, e, n, i, r)
+                }, di.normal = function(t, e, n, i) {
+                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), di.getNormal(t, e, n, i)
+                }, _l.prototype.extractAllPoints = function(t) {
                     return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
-                }, Pa.prototype.extrude = function(t) {
-                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new so(this, t)
-                }, Pa.prototype.makeGeometry = function(t) {
-                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new oo(this, t)
-                }, Y.prototype.fromAttribute = function(t, e, n) {
+                }, _l.prototype.extrude = function(t) {
+                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Yl(this, t)
+                }, _l.prototype.makeGeometry = function(t) {
+                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Jl(this, t)
+                }, De.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, Y.prototype.distanceToManhattan = function(t) {
+                }, De.prototype.distanceToManhattan = function(t) {
                     return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
-                }, Y.prototype.lengthManhattan = function() {
+                }, De.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, mt.prototype.setEulerFromRotationMatrix = function() {
+                }, Qe.prototype.setEulerFromRotationMatrix = function() {
                     console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
-                }, mt.prototype.setEulerFromQuaternion = function() {
+                }, Qe.prototype.setEulerFromQuaternion = function() {
                     console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
-                }, mt.prototype.getPositionFromMatrix = function(t) {
+                }, Qe.prototype.getPositionFromMatrix = function(t) {
                     return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
-                }, mt.prototype.getScaleFromMatrix = function(t) {
+                }, Qe.prototype.getScaleFromMatrix = function(t) {
                     return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
-                }, mt.prototype.getColumnFromMatrix = function(t, e) {
+                }, Qe.prototype.getColumnFromMatrix = function(t, e) {
                     return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
-                }, mt.prototype.applyProjection = function(t) {
+                }, Qe.prototype.applyProjection = function(t) {
                     return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
-                }, mt.prototype.fromAttribute = function(t, e, n) {
+                }, Qe.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, mt.prototype.distanceToManhattan = function(t) {
+                }, Qe.prototype.distanceToManhattan = function(t) {
                     return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
-                }, mt.prototype.lengthManhattan = function() {
+                }, Qe.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, ht.prototype.fromAttribute = function(t, e, n) {
+                }, Ye.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, ht.prototype.lengthManhattan = function() {
+                }, Ye.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, ge.prototype.getChildByName = function(t) {
+                }, ei.prototype.getChildByName = function(t) {
                     return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
-                }, ge.prototype.renderDepth = function() {
+                }, ei.prototype.renderDepth = function() {
                     console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
-                }, ge.prototype.translate = function(t, e) {
+                }, ei.prototype.translate = function(t, e) {
                     return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
-                }, ge.prototype.getWorldRotation = function() {
+                }, ei.prototype.getWorldRotation = function() {
                     console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
-                }, ge.prototype.applyMatrix = function(t) {
+                }, ei.prototype.applyMatrix = function(t) {
                     return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
-                }, Object.defineProperties(ge.prototype, {
+                }, Object.defineProperties(ei.prototype, {
                     eulerOrder: {
                         get: function() {
                             return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                         },
                         set: function(t) {
                             console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                         }
@@ -30076,30 +30544,30 @@
                         get: function() {
                             console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                         },
                         set: function() {
                             console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                         }
                     }
-                }), cn.prototype.setDrawMode = function() {
+                }), qi.prototype.setDrawMode = function() {
                     console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
-                }, Object.defineProperties(cn.prototype, {
+                }, Object.defineProperties(qi.prototype, {
                     drawMode: {
                         get: function() {
                             return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                         },
                         set: function() {
                             console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                         }
                     }
-                }), Vs.prototype.initBones = function() {
+                }), Po.prototype.initBones = function() {
                     console.error("THREE.SkinnedMesh: initBones() has been removed.")
-                }, vn.prototype.setLens = function(t, e) {
+                }, er.prototype.setLens = function(t, e) {
                     console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
-                }, Object.defineProperties(Io.prototype, {
+                }, Object.defineProperties(Mc.prototype, {
                     onlyShadow: {
                         set: function() {
                             console.warn("THREE.Light: .onlyShadow has been removed.")
                         }
                     },
                     shadowCameraFov: {
                         set: function(t) {
@@ -30157,74 +30625,74 @@
                         }
                     },
                     shadowMapHeight: {
                         set: function(t) {
                             console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                         }
                     }
-                }), Object.defineProperties(Ie.prototype, {
+                }), Object.defineProperties(xi.prototype, {
                     length: {
                         get: function() {
                             return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                         }
                     },
                     dynamic: {
                         get: function() {
-                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === U
+                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === _e
                         },
                         set: function() {
-                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(U)
+                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(_e)
                         }
                     }
-                }), Ie.prototype.setDynamic = function(t) {
-                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? U : O), this
-                }, Ie.prototype.copyIndicesArray = function() {
+                }), xi.prototype.setDynamic = function(t) {
+                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? _e : ye), this
+                }, xi.prototype.copyIndicesArray = function() {
                     console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
-                }, Ie.prototype.setArray = function() {
+                }, xi.prototype.setArray = function() {
                     console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
-                }, We.prototype.addIndex = function(t) {
+                }, Li.prototype.addIndex = function(t) {
                     console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
-                }, We.prototype.addAttribute = function(t, e) {
-                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Ie(arguments[1], arguments[2])))
-                }, We.prototype.addDrawCall = function(t, e, n) {
+                }, Li.prototype.addAttribute = function(t, e) {
+                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new xi(arguments[1], arguments[2])))
+                }, Li.prototype.addDrawCall = function(t, e, n) {
                     void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
-                }, We.prototype.clearDrawCalls = function() {
+                }, Li.prototype.clearDrawCalls = function() {
                     console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
-                }, We.prototype.computeOffsets = function() {
+                }, Li.prototype.computeOffsets = function() {
                     console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
-                }, We.prototype.removeAttribute = function(t) {
+                }, Li.prototype.removeAttribute = function(t) {
                     return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
-                }, We.prototype.applyMatrix = function(t) {
+                }, Li.prototype.applyMatrix = function(t) {
                     return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
-                }, Object.defineProperties(We.prototype, {
+                }, Object.defineProperties(Li.prototype, {
                     drawcalls: {
                         get: function() {
                             return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                         }
                     },
                     offsets: {
                         get: function() {
                             return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                         }
                     }
-                }), ys.prototype.setDynamic = function(t) {
-                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? U : O), this
-                }, ys.prototype.setArray = function() {
+                }), oo.prototype.setDynamic = function(t) {
+                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? _e : ye), this
+                }, oo.prototype.setArray = function() {
                     console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
-                }, so.prototype.getArrays = function() {
+                }, Yl.prototype.getArrays = function() {
                     console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
-                }, so.prototype.addShapeList = function() {
+                }, Yl.prototype.addShapeList = function() {
                     console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
-                }, so.prototype.addShape = function() {
+                }, Yl.prototype.addShape = function() {
                     console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
-                }, xs.prototype.dispose = function() {
+                }, ao.prototype.dispose = function() {
                     console.error("THREE.Scene: .dispose() has been removed.")
-                }, ol.prototype.onUpdate = function() {
+                }, Jc.prototype.onUpdate = function() {
                     return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
-                }, Object.defineProperties(Le.prototype, {
+                }, Object.defineProperties(mi.prototype, {
                     wrapAround: {
                         get: function() {
                             console.warn("THREE.Material: .wrapAround has been removed.")
                         },
                         set: function() {
                             console.warn("THREE.Material: .wrapAround has been removed.")
                         }
@@ -30235,15 +30703,15 @@
                         },
                         set: function() {
                             console.warn("THREE.Material: .overdraw has been removed.")
                         }
                     },
                     wrapRGB: {
                         get: function() {
-                            return console.warn("THREE.Material: .wrapRGB has been removed."), new rt
+                            return console.warn("THREE.Material: .wrapRGB has been removed."), new Ve
                         }
                     },
                     shading: {
                         get: function() {
                             console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                         },
                         set: function(t) {
@@ -30262,74 +30730,74 @@
                         get: function() {
                             console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                         },
                         set: function() {
                             console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                         }
                     }
-                }), Object.defineProperties(fn.prototype, {
+                }), Object.defineProperties($i.prototype, {
                     derivatives: {
                         get: function() {
                             return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                         },
                         set: function(t) {
                             console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                         }
                     }
-                }), fs.prototype.clearTarget = function(t, e, n, i) {
+                }), io.prototype.clearTarget = function(t, e, n, i) {
                     console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
-                }, fs.prototype.animate = function(t) {
+                }, io.prototype.animate = function(t) {
                     console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
-                }, fs.prototype.getCurrentRenderTarget = function() {
+                }, io.prototype.getCurrentRenderTarget = function() {
                     return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
-                }, fs.prototype.getMaxAnisotropy = function() {
+                }, io.prototype.getMaxAnisotropy = function() {
                     return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
-                }, fs.prototype.getPrecision = function() {
+                }, io.prototype.getPrecision = function() {
                     return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
-                }, fs.prototype.resetGLState = function() {
+                }, io.prototype.resetGLState = function() {
                     return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
-                }, fs.prototype.supportsFloatTextures = function() {
+                }, io.prototype.supportsFloatTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
-                }, fs.prototype.supportsHalfFloatTextures = function() {
+                }, io.prototype.supportsHalfFloatTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
-                }, fs.prototype.supportsStandardDerivatives = function() {
+                }, io.prototype.supportsStandardDerivatives = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
-                }, fs.prototype.supportsCompressedTextureS3TC = function() {
+                }, io.prototype.supportsCompressedTextureS3TC = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
-                }, fs.prototype.supportsCompressedTexturePVRTC = function() {
+                }, io.prototype.supportsCompressedTexturePVRTC = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
-                }, fs.prototype.supportsBlendMinMax = function() {
+                }, io.prototype.supportsBlendMinMax = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
-                }, fs.prototype.supportsVertexTextures = function() {
+                }, io.prototype.supportsVertexTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
-                }, fs.prototype.supportsInstancedArrays = function() {
+                }, io.prototype.supportsInstancedArrays = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
-                }, fs.prototype.enableScissorTest = function(t) {
+                }, io.prototype.enableScissorTest = function(t) {
                     console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
-                }, fs.prototype.initMaterial = function() {
+                }, io.prototype.initMaterial = function() {
                     console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
-                }, fs.prototype.addPrePlugin = function() {
+                }, io.prototype.addPrePlugin = function() {
                     console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
-                }, fs.prototype.addPostPlugin = function() {
+                }, io.prototype.addPostPlugin = function() {
                     console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
-                }, fs.prototype.updateShadowMap = function() {
+                }, io.prototype.updateShadowMap = function() {
                     console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
-                }, fs.prototype.setFaceCulling = function() {
+                }, io.prototype.setFaceCulling = function() {
                     console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
-                }, fs.prototype.allocTextureUnit = function() {
+                }, io.prototype.allocTextureUnit = function() {
                     console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
-                }, fs.prototype.setTexture = function() {
+                }, io.prototype.setTexture = function() {
                     console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
-                }, fs.prototype.setTexture2D = function() {
+                }, io.prototype.setTexture2D = function() {
                     console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
-                }, fs.prototype.setTextureCube = function() {
+                }, io.prototype.setTextureCube = function() {
                     console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
-                }, fs.prototype.getActiveMipMapLevel = function() {
+                }, io.prototype.getActiveMipMapLevel = function() {
                     return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
-                }, Object.defineProperties(fs.prototype, {
+                }, Object.defineProperties(io.prototype, {
                     shadowMapEnabled: {
                         get: function() {
                             return this.shadowMap.enabled
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                         }
@@ -30369,15 +30837,15 @@
                         }
                     },
                     gammaOutput: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                         },
                         set: function(t) {
-                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? I : D
+                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? me : pe
                         }
                     },
                     toneMappingWhitePoint: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                         },
                         set: function() {
@@ -30388,15 +30856,15 @@
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                         }
                     }
-                }), Object.defineProperties(rs.prototype, {
+                }), Object.defineProperties(Xa.prototype, {
                     cullFace: {
                         get: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                         }
@@ -30413,15 +30881,15 @@
                         get: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                         }
                     }
-                }), Object.defineProperties(ut.prototype, {
+                }), Object.defineProperties(Ze.prototype, {
                     wrapS: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                         }
@@ -30494,15 +30962,15 @@
                         get: function() {
                             return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                         }
                     }
-                }), class extends ge {
+                }), class extends ei {
                     constructor(t) {
                         super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                     }
                     getOutput() {
                         return this.gain
                     }
                     setNodeSource(t) {
@@ -30594,54 +31062,54 @@
                     }
                     setVolume(t) {
                         return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                     }
                 }.prototype.load = function(t) {
                     console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                     const e = this;
-                    return (new Yo).load(t, (function(t) {
+                    return (new Uc).load(t, (function(t) {
                         e.setBuffer(t)
                     })), this
-                }, yn.prototype.updateCubeMap = function(t, e) {
+                }, ir.prototype.updateCubeMap = function(t, e) {
                     return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
-                }, yn.prototype.clear = function(t, e, n, i) {
+                }, ir.prototype.clear = function(t, e, n, i) {
                     return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i)
-                }, at.crossOrigin = void 0, at.loadTexture = function(t, e, n, i) {
+                }, We.crossOrigin = void 0, We.loadTexture = function(t, e, n, i) {
                     console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
-                    const r = new Do;
+                    const r = new _c;
                     r.setCrossOrigin(this.crossOrigin);
                     const s = r.load(t, n, void 0, i);
                     return e && (s.mapping = e), s
-                }, at.loadTextureCube = function(t, e, n, i) {
+                }, We.loadTextureCube = function(t, e, n, i) {
                     console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
-                    const r = new Po;
+                    const r = new yc;
                     r.setCrossOrigin(this.crossOrigin);
                     const s = r.load(t, n, void 0, i);
                     return e && (s.mapping = e), s
-                }, at.loadCompressedTexture = function() {
+                }, We.loadCompressedTexture = function() {
                     console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
-                }, at.loadCompressedTextureCube = function() {
+                }, We.loadCompressedTextureCube = function() {
                     console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                 }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                     detail: {
-                        revision: "137"
+                        revision: i
                     }
-                })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "137");
-                const gl = {
+                })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i);
+                const sh = {
                         type: "change"
                     },
-                    vl = {
+                    ah = {
                         type: "start"
                     },
-                    xl = {
+                    oh = {
                         type: "end"
                     };
-                class yl extends z {
+                class lh extends we {
                     constructor(t, e) {
-                        super(), void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new mt, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
+                        super(), void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new Qe, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
                             LEFT: "ArrowLeft",
                             UP: "ArrowUp",
                             RIGHT: "ArrowRight",
                             BOTTOM: "ArrowDown"
                         }, this.mouseButtons = {
                             LEFT: 0,
                             MIDDLE: 1,
@@ -30656,28 +31124,28 @@
                         }, this.getDistance = function() {
                             return this.object.position.distanceTo(this.target)
                         }, this.listenToKeyEvents = function(t) {
                             t.addEventListener("keydown", k), this._domElementKeyEvents = t
                         }, this.saveState = function() {
                             n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
                         }, this.reset = function() {
-                            n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(gl), n.update(), r = i.NONE
+                            n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(sh), n.update(), r = i.NONE
                         }, this.update = function() {
-                            const e = new mt,
-                                u = (new pt).setFromUnitVectors(t.up, new mt(0, 1, 0)),
+                            const e = new Qe,
+                                u = (new Ke).setFromUnitVectors(t.up, new Qe(0, 1, 0)),
                                 d = u.clone().invert(),
-                                p = new mt,
-                                m = new pt,
+                                p = new Qe,
+                                m = new Ke,
                                 f = 2 * Math.PI;
                             return function() {
                                 const t = n.object.position;
                                 e.copy(t).sub(n.target), e.applyQuaternion(u), a.setFromVector3(e), n.autoRotate && r === i.NONE && w(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (a.theta += o.theta * n.dampingFactor, a.phi += o.phi * n.dampingFactor) : (a.theta += o.theta, a.phi += o.phi);
                                 let g = n.minAzimuthAngle,
                                     v = n.maxAzimuthAngle;
-                                return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += f : g > Math.PI && (g -= f), v < -Math.PI ? v += f : v > Math.PI && (v -= f), a.theta = g <= v ? Math.max(g, Math.min(v, a.theta)) : a.theta > (g + v) / 2 ? Math.max(g, a.theta) : Math.min(v, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), a.radius *= l, a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)), !0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c), e.setFromSpherical(a), e.applyQuaternion(d), t.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (o.theta *= 1 - n.dampingFactor, o.phi *= 1 - n.dampingFactor, c.multiplyScalar(1 - n.dampingFactor)) : (o.set(0, 0, 0), c.set(0, 0, 0)), l = 1, !!(h || p.distanceToSquared(n.object.position) > s || 8 * (1 - m.dot(n.object.quaternion)) > s) && (n.dispatchEvent(gl), p.copy(n.object.position), m.copy(n.object.quaternion), h = !1, !0)
+                                return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += f : g > Math.PI && (g -= f), v < -Math.PI ? v += f : v > Math.PI && (v -= f), a.theta = g <= v ? Math.max(g, Math.min(v, a.theta)) : a.theta > (g + v) / 2 ? Math.max(g, a.theta) : Math.min(v, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), a.radius *= l, a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)), !0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c), e.setFromSpherical(a), e.applyQuaternion(d), t.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (o.theta *= 1 - n.dampingFactor, o.phi *= 1 - n.dampingFactor, c.multiplyScalar(1 - n.dampingFactor)) : (o.set(0, 0, 0), c.set(0, 0, 0)), l = 1, !!(h || p.distanceToSquared(n.object.position) > s || 8 * (1 - m.dot(n.object.quaternion)) > s) && (n.dispatchEvent(sh), p.copy(n.object.position), m.copy(n.object.quaternion), h = !1, !0)
                             }
                         }(), this.dispose = function() {
                             n.domElement.removeEventListener("contextmenu", W), n.domElement.removeEventListener("pointerdown", F), n.domElement.removeEventListener("pointercancel", G), n.domElement.removeEventListener("wheel", V), n.domElement.removeEventListener("pointermove", z), n.domElement.removeEventListener("pointerup", H), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", k)
                         };
                         const n = this,
                             i = {
                                 NONE: -1,
@@ -30687,28 +31155,28 @@
                                 TOUCH_ROTATE: 3,
                                 TOUCH_PAN: 4,
                                 TOUCH_DOLLY_PAN: 5,
                                 TOUCH_DOLLY_ROTATE: 6
                             };
                         let r = i.NONE;
                         const s = 1e-6,
-                            a = new ll,
-                            o = new ll;
+                            a = new Kc,
+                            o = new Kc;
                         let l = 1;
-                        const c = new mt;
+                        const c = new Qe;
                         let h = !1;
-                        const u = new Y,
-                            d = new Y,
-                            p = new Y,
-                            m = new Y,
-                            f = new Y,
-                            g = new Y,
-                            v = new Y,
-                            x = new Y,
-                            y = new Y,
+                        const u = new De,
+                            d = new De,
+                            p = new De,
+                            m = new De,
+                            f = new De,
+                            g = new De,
+                            v = new De,
+                            x = new De,
+                            y = new De,
                             _ = [],
                             M = {};
 
                         function b() {
                             return Math.pow(.95, n.zoomSpeed)
                         }
 
@@ -30716,27 +31184,27 @@
                             o.theta -= t
                         }
 
                         function S(t) {
                             o.phi -= t
                         }
                         const E = function() {
-                                const t = new mt;
+                                const t = new Qe;
                                 return function(e, n) {
                                     t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), c.add(t)
                                 }
                             }(),
                             T = function() {
-                                const t = new mt;
+                                const t = new Qe;
                                 return function(e, i) {
                                     !0 === n.screenSpacePanning ? t.setFromMatrixColumn(i, 1) : (t.setFromMatrixColumn(i, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), c.add(t)
                                 }
                             }(),
                             A = function() {
-                                const t = new mt;
+                                const t = new Qe;
                                 return function(e, i) {
                                     const r = n.domElement;
                                     if (n.object.isPerspectiveCamera) {
                                         const s = n.object.position;
                                         t.copy(s).sub(n.target);
                                         let a = t.length();
                                         a *= Math.tan(n.object.fov / 2 * Math.PI / 180), E(2 * e * a / r.clientHeight, n.object.matrix), T(2 * i * a / r.clientHeight, n.object.matrix)
@@ -30849,15 +31317,15 @@
                                             default:
                                                 r = i.NONE
                                         }
                                         break;
                                     default:
                                         r = i.NONE
                                 }
-                                r !== i.NONE && n.dispatchEvent(vl)
+                                r !== i.NONE && n.dispatchEvent(ah)
                             }(t) : function(t) {
                                 let e;
                                 switch (t.button) {
                                     case 0:
                                         e = n.mouseButtons.LEFT;
                                         break;
                                     case 1:
@@ -30893,15 +31361,15 @@
                                             if (!1 === n.enablePan) return;
                                             P(t), r = i.PAN
                                         }
                                         break;
                                     default:
                                         r = i.NONE
                                 }
-                                r !== i.NONE && n.dispatchEvent(vl)
+                                r !== i.NONE && n.dispatchEvent(ah)
                             }(t))
                         }
 
                         function z(t) {
                             !1 !== n.enabled && ("touch" === t.pointerType ? function(t) {
                                 switch (X(t), r) {
                                     case i.TOUCH_ROTATE:
@@ -30949,25 +31417,25 @@
                                             f.set(t.clientX, t.clientY), g.subVectors(f, m).multiplyScalar(n.panSpeed), A(g.x, g.y), m.copy(f), n.update()
                                         }(t)
                                 }
                             }(t))
                         }
 
                         function H(t) {
-                            j(t), 0 === _.length && (n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", z), n.domElement.removeEventListener("pointerup", H)), n.dispatchEvent(xl), r = i.NONE
+                            j(t), 0 === _.length && (n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", z), n.domElement.removeEventListener("pointerup", H)), n.dispatchEvent(oh), r = i.NONE
                         }
 
                         function G(t) {
                             j(t)
                         }
 
                         function V(t) {
-                            !1 !== n.enabled && !1 !== n.enableZoom && r === i.NONE && (t.preventDefault(), n.dispatchEvent(vl), function(t) {
+                            !1 !== n.enabled && !1 !== n.enableZoom && r === i.NONE && (t.preventDefault(), n.dispatchEvent(ah), function(t) {
                                 t.deltaY < 0 ? L(b()) : t.deltaY > 0 && R(b()), n.update()
-                            }(t), n.dispatchEvent(xl))
+                            }(t), n.dispatchEvent(oh))
                         }
 
                         function k(t) {
                             !1 !== n.enabled && !1 !== n.enablePan && function(t) {
                                 let e = !1;
                                 switch (t.code) {
                                     case n.keys.UP:
@@ -30994,329 +31462,31 @@
                             delete M[t.pointerId];
                             for (let e = 0; e < _.length; e++)
                                 if (_[e].pointerId == t.pointerId) return void _.splice(e, 1)
                         }
 
                         function X(t) {
                             let e = M[t.pointerId];
-                            void 0 === e && (e = new Y, M[t.pointerId] = e), e.set(t.pageX, t.pageY)
+                            void 0 === e && (e = new De, M[t.pointerId] = e), e.set(t.pageX, t.pageY)
                         }
 
                         function q(t) {
                             const e = t.pointerId === _[0].pointerId ? _[1] : _[0];
                             return M[e.pointerId]
                         }
                         n.domElement.addEventListener("contextmenu", W), n.domElement.addEventListener("pointerdown", F), n.domElement.addEventListener("pointercancel", G), n.domElement.addEventListener("wheel", V, {
                             passive: !1
                         }), this.update()
                     }
                 }
-                class _l extends yl {
+                class ch extends lh {
                     constructor(t, e) {
                         super(t, e), this.screenSpacePanning = !1, this.mouseButtons.LEFT = 2, this.mouseButtons.RIGHT = 0, this.touches.ONE = 1, this.touches.TWO = 3
                     }
                 }
-            },
-            908: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.BlochSphere = void 0;
-                const i = n(78),
-                    r = n(429),
-                    s = n(510),
-                    a = n(649),
-                    o = n(692),
-                    l = n(69),
-                    c = n(691);
-                class h extends c.Group {
-                    constructor(t = 5, e = 7, n = 4) {
-                        return super(), this.radius = t, this.hMeridians = e, this.vMeridians = n, this.addSphere(), this.addHorizontalMeridians(), this.addVerticalMeridians(), this.addAxes(), this.addLabels(), this
-                    }
-                    addVector(t, e, n) {
-                        const i = new l.StateVector(t, e, n, this.radius);
-                        this.add(i)
-                    }
-                    addSphere() {
-                        const t = new r.Sphere(this.radius);
-                        this.add(t)
-                    }
-                    addAxes() {
-                        const t = new s.Axes(this.radius);
-                        this.add(t)
-                    }
-                    addHorizontalMeridians() {
-                        const t = new a.Meridians(this.radius, this.hMeridians, i.Orientation.HORIZONTAL);
-                        this.add(t)
-                    }
-                    addVerticalMeridians() {
-                        const t = new a.Meridians(this.radius, this.vMeridians, i.Orientation.VERTICAL);
-                        this.add(t)
-                    }
-                    addLabels() {
-                        const t = .5,
-                            e = {
-                                "|+⟩": new c.Vector3(this.radius + t, 0, 0),
-                                "|-⟩": new c.Vector3(-this.radius - t, 0, 0),
-                                "|i⟩": new c.Vector3(0, 0, -this.radius - t),
-                                "|-i⟩": new c.Vector3(0, 0, this.radius + t),
-                                "|0⟩": new c.Vector3(0, this.radius + t, 0),
-                                "|1⟩": new c.Vector3(0, -this.radius - t, 0)
-                            },
-                            n = new o.Labels(e);
-                        this.add(n)
-                    }
-                }
-                e.BlochSphere = h
-            },
-            510: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.Axes = void 0;
-                const i = n(691);
-                class r extends i.Group {
-                    constructor(t) {
-                        return super(), this.xAxisColor = "#1f51ff", this.yAxisColor = "#ff3131", this.zAxisColor = "#39ff14", this.halfLength = t, this.generateAxes(), this
-                    }
-                    generateAxes() {
-                        const t = [new i.Vector3(-this.halfLength, 0, 0), new i.Vector3(this.halfLength, 0, 0)],
-                            e = [new i.Vector3(0, 0, -this.halfLength), new i.Vector3(0, 0, this.halfLength)],
-                            n = [new i.Vector3(0, -this.halfLength, 0), new i.Vector3(0, this.halfLength, 0)],
-                            r = {
-                                x: this.asLine({
-                                    points: t,
-                                    hexColor: this.xAxisColor,
-                                    lineWidth: 1.5
-                                }),
-                                y: this.asLine({
-                                    points: e,
-                                    hexColor: this.yAxisColor,
-                                    lineWidth: 1.5
-                                }),
-                                z: this.asLine({
-                                    points: n,
-                                    hexColor: this.zAxisColor,
-                                    lineWidth: 1.5
-                                })
-                            };
-                        this.add(r.x), this.add(r.y), this.add(r.z)
-                    }
-                    asLine(t) {
-                        return new i.Line((new i.BufferGeometry).setFromPoints(t.points), new i.LineDashedMaterial({
-                            color: t.hexColor,
-                            linewidth: t.lineWidth,
-                            scale: 1,
-                            dashSize: .1,
-                            gapSize: .1
-                        })).computeLineDistances()
-                    }
-                }
-                e.Axes = r
-            },
-            78: (t, e) => {
-                var n;
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.Orientation = void 0, (n = e.Orientation || (e.Orientation = {}))[n.HORIZONTAL = 0] = "HORIZONTAL", n[n.VERTICAL = 1] = "VERTICAL"
-            },
-            649: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.Meridians = void 0;
-                const i = n(691),
-                    r = n(78);
-                class s extends i.Group {
-                    constructor(t, e, n) {
-                        switch (super(), this.color = "gray", this.radius = t, this.orientation = n, n) {
-                            case r.Orientation.HORIZONTAL:
-                                return this.numCircles = this.sanitizeCircleInput(e), this.createHorizontalChordMeridians(this.radius, this.numCircles), this;
-                            case r.Orientation.VERTICAL:
-                                return this.numCircles = this.sanitizeCircleInput(e), this.createVerticalMeridians(this.radius, this.numCircles), this;
-                            default:
-                                throw new Error("Invalid orientation input in Meridians constructor")
-                        }
-                    }
-                    createHorizontalChordMeridians(t, e) {
-                        if (0 === e) return;
-                        let n;
-                        n = e % 2 != 0 ? e - 1 : e;
-                        const i = n / 2;
-                        let s;
-                        s = 1 === e ? 0 : t - .5 * t / 5;
-                        const a = [0];
-                        for (let t = s; t > 0; t -= s / i) a.push(t), a.push(-t);
-                        for (const e of a) {
-                            const n = Math.pow(t, 2),
-                                i = Math.pow(e, 2),
-                                s = Math.sqrt(n - i),
-                                a = this.curveDataWithRadius(s),
-                                o = this.createMeridianCurve(a),
-                                l = this.createMeridianLine(o, Math.PI / 2, r.Orientation.HORIZONTAL, e);
-                            this.add(l)
-                        }
-                    }
-                    createVerticalMeridians(t, e) {
-                        if (0 === e) return;
-                        const n = {
-                            anchorX: 0,
-                            anchorY: 0,
-                            radius: t,
-                            startAngle: 0,
-                            endAngle: 2 * Math.PI,
-                            isClockwise: !1,
-                            rotation: 0
-                        };
-                        for (let t = 0; t < Math.PI; t += Math.PI / e) {
-                            const e = this.createMeridianCurve(n),
-                                i = this.createMeridianLine(e, t, r.Orientation.VERTICAL);
-                            this.add(i)
-                        }
-                    }
-                    createMeridianLine(t, e, n, s) {
-                        const a = t.getSpacedPoints(128),
-                            o = (new i.BufferGeometry).setFromPoints(a);
-                        switch (n) {
-                            case r.Orientation.HORIZONTAL:
-                                o.rotateX(e);
-                                break;
-                            case r.Orientation.VERTICAL:
-                                o.rotateY(e)
-                        }
-                        const l = new i.Line(o, new i.LineBasicMaterial({
-                            color: "gray"
-                        }));
-                        return s && (l.position.y = s), l
-                    }
-                    createMeridianCurve(t) {
-                        return new i.EllipseCurve(t.anchorX, t.anchorY, t.radius, t.radius, t.startAngle, t.endAngle, t.isClockwise, t.rotation)
-                    }
-                    curveDataWithRadius(t) {
-                        return {
-                            anchorX: 0,
-                            anchorY: 0,
-                            radius: t,
-                            startAngle: 0,
-                            endAngle: 2 * Math.PI,
-                            isClockwise: !1,
-                            rotation: 0
-                        }
-                    }
-                    sanitizeCircleInput(t) {
-                        if (t < 0) throw new Error("A negative number of meridians are not supported");
-                        if (t > 300) throw new Error("Over 300 meridians are not supported");
-                        return Math.floor(t)
-                    }
-                }
-                e.Meridians = s
-            },
-            643: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.BlochSphereScene = void 0;
-                const i = n(691),
-                    r = n(296);
-                class s extends i.Scene {
-                    constructor(t = 75, e = s.VIZ_HEIGHT / s.VIZ_WIDTH, n = .1, a = 1e3) {
-                        return super(), this.camera = new i.PerspectiveCamera(t, e, n, a), this.renderer = new i.WebGLRenderer({
-                            alpha: !0
-                        }), this.renderer.setSize(s.VIZ_WIDTH, s.VIZ_HEIGHT), this.controls = new r.OrbitControls(this.camera, this.renderer.domElement), this.init(), this
-                    }
-                    addSceneToHTMLContainer(t) {
-                        document.getElementById(t).appendChild(this.renderer.domElement)
-                    }
-                    init() {
-                        this.camera.position.x = 6, this.camera.position.y = 2, this.camera.position.z = 2, this.setUpControls(), this.setRenderSize(s.VIZ_WIDTH, s.VIZ_HEIGHT), this.animate()
-                    }
-                    setUpControls() {
-                        this.controls.enableDamping = !0, this.controls.dampingFactor = .05, this.controls.screenSpacePanning = !1, this.controls.minDistance = 10, this.controls.maxDistance = 50, this.controls.maxPolarAngle = Math.PI
-                    }
-                    setRenderSize(t, e) {
-                        this.renderer.setSize(t, e)
-                    }
-                    animate() {
-                        requestAnimationFrame(this.animate.bind(this)), this.controls.update(), this.renderer.render(this, this.camera)
-                    }
-                }
-                e.BlochSphereScene = s, s.VIZ_WIDTH = 500, s.VIZ_HEIGHT = 500
-            },
-            429: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.Sphere = void 0;
-                const i = n(691);
-                class r extends i.Group {
-                    constructor(t) {
-                        if (super(), t < 1) throw new Error("The radius of a Sphere must be greater than or equal to 1");
-                        return this.radius = t, this.createSphere(this.radius), this
-                    }
-                    createSphere(t) {
-                        const e = new i.SphereGeometry(t, 32, 32),
-                            n = new i.MeshNormalMaterial({
-                                opacity: .6,
-                                transparent: !0
-                            }),
-                            r = new i.Mesh(e, n);
-                        r.geometry.computeVertexNormals(), this.add(r)
-                    }
-                }
-                e.Sphere = r
-            },
-            69: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.StateVector = void 0;
-                const i = n(691);
-                class r extends i.Group {
-                    constructor(t, e, n, i) {
-                        return super(), this.x = t, this.y = e, this.z = n, this.blochSphereRadius = i, this.generateVector(this.x, this.y, this.z, this.blochSphereRadius), this
-                    }
-                    generateVector(t, e, n, r) {
-                        const s = new i.Vector3(t, e, n),
-                            a = new i.Vector3(1, 0, 0),
-                            o = -Math.PI / 2;
-                        s.applyAxisAngle(a, o);
-                        const l = new i.Vector3(0, 0, 0),
-                            c = l.distanceTo(s) * r,
-                            h = new i.ArrowHelper(s, l, c, "#800080", void 0, 1);
-                        h.line.material.linewidth = 20, this.add(h)
-                    }
-                }
-                e.StateVector = r
-            },
-            692: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.Label = e.Labels = void 0;
-                const i = n(691);
-                class r extends i.Group {
-                    constructor(t) {
-                        return super(), this.labels = t, this.generateLabels(this.labels), this
-                    }
-                    generateLabels(t) {
-                        for (const [e, n] of Object.entries(t)) this.add(new s(e, n))
-                    }
-                }
-                e.Labels = r;
-                class s extends i.Sprite {
-                    constructor(t, e) {
-                        const n = function(t) {
-                            const e = 256,
-                                n = document.createElement("canvas");
-                            n.width = e, n.height = e, n.textContent = t;
-                            const r = n.getContext("2d");
-                            r.fillStyle = "#000000", r.textAlign = "center", r.font = "120px Arial", r.fillText(t, 128, 128);
-                            const s = new i.Texture(n);
-                            return s.needsUpdate = !0, new i.SpriteMaterial({
-                                map: s,
-                                transparent: !0
-                            })
-                        }(t);
-                        return super(n), this.text = t, this.position.copy(e), this
-                    }
-                }
-                e.Label = s
             }
         },
         e = {};
 
     function n(i) {
         var r = e[i];
         if (void 0 !== r) return r.exports;
```

## cirq_ts/dist/circuit.bundle.js

### js-beautify {}

```diff
@@ -1,82 +1,367 @@
 /*! For license information please see circuit.bundle.js.LICENSE.txt */
 (() => {
     "use strict";
     var t = {
-            691: (t, e) => {
+            421: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.GridQubit = void 0;
+                const i = n(232),
+                    r = n(99);
+                class s extends i.Group {
+                    constructor(t, e, n, i = 1) {
+                        super(), this.row = t, this.col = e, this.add(this.createLine(n, i)), this.add(this.addLocationLabel(i))
+                    }
+                    addSymbol(t) {
+                        this.add(t)
+                    }
+                    createLine(t, e) {
+                        const n = [new i.Vector3(this.row * e, 0, this.col * e), new i.Vector3(this.row * e, t * e, this.col * e)];
+                        return new r.QubitLine(n[0], n[1])
+                    }
+                    addLocationLabel(t) {
+                        const e = new r.QubitLabel(`(${this.row}, ${this.col})`);
+                        return e.position.copy(new i.Vector3(this.row * t, -.6 * t, this.col * t)), e
+                    }
+                }
+                e.GridQubit = s
+            },
+            99: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.BoxGate3DSymbol = e.Swap3DSymbol = e.X3DSymbol = e.Control3DSymbol = e.QubitLine = e.QubitLabel = e.ConnectionLine = void 0;
+                const i = n(232);
+                class r extends i.Line {
+                    constructor(t, e) {
+                        const n = new i.LineBasicMaterial({
+                                color: "black"
+                            }),
+                            r = [t, e];
+                        return super((new i.BufferGeometry).setFromPoints(r), n), this
+                    }
+                }
+                e.ConnectionLine = r;
+                class s extends i.Sprite {
+                    constructor(t) {
+                        const e = document.createElement("canvas");
+                        e.width = 128, e.height = 128, e.textContent = t;
+                        const n = e.getContext("2d");
+                        n.fillStyle = "#000000", n.textAlign = "center", n.font = "20px Arial", n.fillText(t, 64, 64);
+                        const r = new i.Texture(e);
+                        return r.needsUpdate = !0, super(new i.SpriteMaterial({
+                            map: r,
+                            transparent: !0
+                        })), this.text = t, this
+                    }
+                }
+                e.QubitLabel = s;
+                class a extends i.Line {
+                    constructor(t, e) {
+                        const n = new i.LineBasicMaterial({
+                                color: "gray"
+                            }),
+                            r = [t, e];
+                        return super((new i.BufferGeometry).setFromPoints(r), n), this
+                    }
+                }
+                e.QubitLine = a;
+                class o extends i.Mesh {
+                    constructor() {
+                        const t = new i.MeshBasicMaterial({
+                            color: "black"
+                        });
+                        return super(new i.SphereGeometry(.1, 32, 32), t), this
+                    }
+                }
+                e.Control3DSymbol = o;
+                class l extends i.Group {
+                    constructor(t) {
+                        super();
+                        const e = new i.MeshBasicMaterial({
+                                color: t,
+                                side: i.DoubleSide
+                            }),
+                            n = new i.CylinderGeometry(.3, .3, .1, 32, 1, !0, 0, 2 * Math.PI),
+                            r = new i.Mesh(n, e);
+                        this.add(r);
+                        const s = Math.PI / 2,
+                            a = new i.MeshBasicMaterial({
+                                color: t
+                            }),
+                            o = new i.CylinderGeometry(.01, .01, .6),
+                            l = new i.Mesh(o, a);
+                        l.rotation.x = s;
+                        const c = new i.MeshBasicMaterial({
+                                color: t
+                            }),
+                            h = new i.CylinderGeometry(.01, .01, .6),
+                            u = new i.Mesh(h, c);
+                        return u.rotation.z = s, this.add(l), this.add(u), this
+                    }
+                }
+                e.X3DSymbol = l;
+                class c extends i.Group {
+                    constructor() {
+                        super();
+                        const t = new i.MeshBasicMaterial({
+                                color: "black"
+                            }),
+                            e = new i.CylinderGeometry(.01, .01, .3),
+                            n = new i.Mesh(e, t);
+                        n.rotation.x = Math.PI / 2, n.rotation.z = 3 * Math.PI / 4;
+                        const r = new i.MeshBasicMaterial({
+                                color: "black"
+                            }),
+                            s = new i.CylinderGeometry(.01, .01, .3),
+                            a = new i.Mesh(s, r);
+                        return a.rotation.x = Math.PI / 2, a.rotation.z = Math.PI / 4, this.add(n), this.add(a), this
+                    }
+                }
+                e.Swap3DSymbol = c;
+                class h extends i.Mesh {
+                    constructor(t, e) {
+                        const n = document.createElement("canvas"),
+                            r = n.getContext("2d");
+                        n.width = n.height = 128, r.fillStyle = e, r.fillRect(0, 0, n.width, n.height);
+                        let s, a = 60;
+                        do {
+                            a /= 1.2, r.font = `${a}pt arial bold`, s = r.measureText(t).width
+                        } while (s > n.width);
+                        const o = new i.Color(e).getHSL({
+                            h: 0,
+                            s: 0,
+                            l: 0
+                        });
+                        r.fillStyle = o.l < .5 ? "white" : "black", r.fillText(t, n.width / 2 - s / 2, n.height / 2 + a / 2);
+                        const l = new i.Texture(n);
+                        return l.needsUpdate = !0, super(new i.BoxGeometry(.5, .5, .5), new i.MeshBasicMaterial({
+                            map: l,
+                            color: "white"
+                        })), this
+                    }
+                }
+                e.BoxGate3DSymbol = h
+            },
+            883: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.Symbol3D = void 0;
+                const i = n(232),
+                    r = n(99);
+                class s extends i.Group {
+                    constructor(t, e = 1) {
+                        super(), this.padding_factor = e, this.moment = t.moment, this.buildAndAddMeshesToGroup(t), this.addConnectionLines(t)
+                    }
+                    buildAndAddMeshesToGroup(t) {
+                        const e = t.location_info;
+                        t.wire_symbols.forEach(((n, i) => {
+                            let s;
+                            switch (n) {
+                                case "X":
+                                    s = new r.X3DSymbol(t.color_info[i]);
+                                    break;
+                                case "@":
+                                    s = new r.Control3DSymbol;
+                                    break;
+                                case "×":
+                                    s = new r.Swap3DSymbol;
+                                    break;
+                                default:
+                                    s = new r.BoxGate3DSymbol(n, t.color_info[i])
+                            }
+                            s.position.set(e[i].row * this.padding_factor, t.moment * this.padding_factor, e[i].col * this.padding_factor), this.add(s)
+                        }))
+                    }
+                    addConnectionLines(t) {
+                        const e = t.location_info;
+                        if (e.length > 1) {
+                            let n = 0;
+                            for (; n < e.length - 1;) {
+                                const s = [new i.Vector3(e[n].row * this.padding_factor, t.moment * this.padding_factor, e[n].col * this.padding_factor), new i.Vector3(e[n + 1].row * this.padding_factor, t.moment * this.padding_factor, e[n + 1].col * this.padding_factor)];
+                                this.add(new r.ConnectionLine(s[0], s[1])), n++
+                            }
+                        }
+                    }
+                }
+                e.Symbol3D = s
+            },
+            25: (t, e, n) => {
+                Object.defineProperty(e, "__esModule", {
+                    value: !0
+                }), e.GridCircuit = void 0;
+                const i = n(232),
+                    r = n(421),
+                    s = n(883);
+                class a extends i.Group {
+                    constructor(t, e, n = 1) {
+                        super(), this.padding_factor = n, this.qubit_map = new Map;
+                        for (const n of e) {
+                            for (const e of n.location_info) this.hasQubit(e.row, e.col) || this.addQubit(e.row, e.col, t);
+                            this.addSymbol(n, t)
+                        }
+                    }
+                    addSymbol(t, e) {
+                        const n = new s.Symbol3D(t, this.padding_factor);
+                        if (t.moment < 0 || t.moment > e) throw new Error(`The SymbolInformation object ${t} has an invalid moment ${t.moment}`);
+                        this.getQubit(t.location_info[0].row, t.location_info[0].col).addSymbol(n)
+                    }
+                    addQubit(t, e, n) {
+                        const i = new r.GridQubit(t, e, n, this.padding_factor);
+                        this.setQubit(t, e, i), this.add(i)
+                    }
+                    getQubit(t, e) {
+                        return this.qubit_map.get(t).get(e)
+                    }
+                    setQubit(t, e, n) {
+                        const i = this.qubit_map.get(t);
+                        i ? i.set(e, n) : this.qubit_map.set(t, (new Map).set(e, n))
+                    }
+                    hasQubit(t, e) {
+                        const n = this.qubit_map.get(t);
+                        return !!n && n.has(e)
+                    }
+                }
+                e.GridCircuit = a
+            },
+            232: (t, e) => {
                 Object.defineProperty(e, "__esModule", {
                     value: !0
                 });
                 const n = "137",
-                    i = 100,
-                    r = 300,
-                    s = 301,
-                    a = 302,
-                    o = 303,
-                    l = 304,
-                    c = 306,
-                    h = 307,
-                    u = 1e3,
-                    d = 1001,
-                    p = 1002,
-                    m = 1003,
-                    f = 1004,
-                    g = 1005,
-                    v = 1006,
-                    x = 1007,
-                    y = 1008,
-                    _ = 1009,
-                    M = 1012,
-                    b = 1014,
-                    w = 1015,
-                    S = 1016,
-                    E = 1020,
-                    T = 1023,
-                    A = 1026,
-                    R = 1027,
-                    L = 33776,
-                    C = 33777,
-                    P = 33778,
-                    D = 33779,
-                    I = 35840,
-                    N = 35841,
-                    O = 35842,
-                    U = 35843,
-                    B = 37492,
-                    F = 37496,
-                    z = 37808,
-                    H = 37809,
-                    G = 37810,
-                    V = 37811,
-                    k = 37812,
-                    W = 37813,
-                    j = 37814,
-                    X = 37815,
-                    q = 37816,
-                    Y = 37817,
-                    J = 37818,
-                    Z = 37819,
-                    K = 37820,
-                    Q = 37821,
-                    $ = 36492,
-                    tt = 2300,
-                    et = 2301,
-                    nt = 2302,
-                    it = 2400,
-                    rt = 2401,
-                    st = 2402,
-                    at = 2501,
-                    ot = 3e3,
-                    lt = 3001,
-                    ct = 7680,
-                    ht = 35044,
-                    ut = 35048,
-                    dt = "300 es",
-                    pt = 1035;
-                class mt {
+                    i = 0,
+                    r = 1,
+                    s = 2,
+                    a = 1,
+                    o = 2,
+                    l = 3,
+                    c = 0,
+                    h = 1,
+                    u = 2,
+                    d = 0,
+                    p = 1,
+                    m = 2,
+                    f = 3,
+                    g = 4,
+                    v = 5,
+                    x = 100,
+                    y = 101,
+                    _ = 102,
+                    M = 103,
+                    b = 104,
+                    w = 200,
+                    S = 201,
+                    E = 202,
+                    T = 203,
+                    A = 204,
+                    R = 205,
+                    L = 206,
+                    C = 207,
+                    P = 208,
+                    D = 209,
+                    I = 210,
+                    N = 0,
+                    O = 1,
+                    U = 2,
+                    B = 3,
+                    F = 4,
+                    z = 5,
+                    H = 6,
+                    G = 7,
+                    V = 0,
+                    k = 1,
+                    W = 2,
+                    j = 0,
+                    X = 1,
+                    q = 2,
+                    Y = 3,
+                    J = 4,
+                    Z = 5,
+                    K = 300,
+                    Q = 301,
+                    $ = 302,
+                    tt = 303,
+                    et = 304,
+                    nt = 306,
+                    it = 307,
+                    rt = 1e3,
+                    st = 1001,
+                    at = 1002,
+                    ot = 1003,
+                    lt = 1004,
+                    ct = 1005,
+                    ht = 1006,
+                    ut = 1007,
+                    dt = 1008,
+                    pt = 1009,
+                    mt = 1010,
+                    ft = 1011,
+                    gt = 1012,
+                    vt = 1013,
+                    xt = 1014,
+                    yt = 1015,
+                    _t = 1016,
+                    Mt = 1017,
+                    bt = 1018,
+                    wt = 1020,
+                    St = 1021,
+                    Et = 1023,
+                    Tt = 1024,
+                    At = 1025,
+                    Rt = 1026,
+                    Lt = 1027,
+                    Ct = 1028,
+                    Pt = 1029,
+                    Dt = 1030,
+                    It = 1031,
+                    Nt = 1033,
+                    Ot = 33776,
+                    Ut = 33777,
+                    Bt = 33778,
+                    Ft = 33779,
+                    zt = 35840,
+                    Ht = 35841,
+                    Gt = 35842,
+                    Vt = 35843,
+                    kt = 36196,
+                    Wt = 37492,
+                    jt = 37496,
+                    Xt = 37808,
+                    qt = 37809,
+                    Yt = 37810,
+                    Jt = 37811,
+                    Zt = 37812,
+                    Kt = 37813,
+                    Qt = 37814,
+                    $t = 37815,
+                    te = 37816,
+                    ee = 37817,
+                    ne = 37818,
+                    ie = 37819,
+                    re = 37820,
+                    se = 37821,
+                    ae = 36492,
+                    oe = 2300,
+                    le = 2301,
+                    ce = 2302,
+                    he = 2400,
+                    ue = 2401,
+                    de = 2402,
+                    pe = 2501,
+                    me = 3e3,
+                    fe = 3001,
+                    ge = 3201,
+                    ve = 0,
+                    xe = 1,
+                    ye = 7680,
+                    _e = 35044,
+                    Me = 35048,
+                    be = "300 es",
+                    we = 1035;
+                class Se {
                     addEventListener(t, e) {
                         void 0 === this._listeners && (this._listeners = {});
                         const n = this._listeners;
                         void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                     }
                     hasEventListener(t, e) {
                         if (void 0 === this._listeners) return !1;
@@ -97,70 +382,70 @@
                             t.target = this;
                             const n = e.slice(0);
                             for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                             t.target = null
                         }
                     }
                 }
-                const ft = [];
-                for (let t = 0; t < 256; t++) ft[t] = (t < 16 ? "0" : "") + t.toString(16);
-                let gt = 1234567;
-                const vt = Math.PI / 180,
-                    xt = 180 / Math.PI;
+                const Ee = [];
+                for (let t = 0; t < 256; t++) Ee[t] = (t < 16 ? "0" : "") + t.toString(16);
+                let Te = 1234567;
+                const Ae = Math.PI / 180,
+                    Re = 180 / Math.PI;
 
-                function yt() {
+                function Le() {
                     const t = 4294967295 * Math.random() | 0,
                         e = 4294967295 * Math.random() | 0,
                         n = 4294967295 * Math.random() | 0,
                         i = 4294967295 * Math.random() | 0;
-                    return (ft[255 & t] + ft[t >> 8 & 255] + ft[t >> 16 & 255] + ft[t >> 24 & 255] + "-" + ft[255 & e] + ft[e >> 8 & 255] + "-" + ft[e >> 16 & 15 | 64] + ft[e >> 24 & 255] + "-" + ft[63 & n | 128] + ft[n >> 8 & 255] + "-" + ft[n >> 16 & 255] + ft[n >> 24 & 255] + ft[255 & i] + ft[i >> 8 & 255] + ft[i >> 16 & 255] + ft[i >> 24 & 255]).toUpperCase()
+                    return (Ee[255 & t] + Ee[t >> 8 & 255] + Ee[t >> 16 & 255] + Ee[t >> 24 & 255] + "-" + Ee[255 & e] + Ee[e >> 8 & 255] + "-" + Ee[e >> 16 & 15 | 64] + Ee[e >> 24 & 255] + "-" + Ee[63 & n | 128] + Ee[n >> 8 & 255] + "-" + Ee[n >> 16 & 255] + Ee[n >> 24 & 255] + Ee[255 & i] + Ee[i >> 8 & 255] + Ee[i >> 16 & 255] + Ee[i >> 24 & 255]).toUpperCase()
                 }
 
-                function _t(t, e, n) {
+                function Ce(t, e, n) {
                     return Math.max(e, Math.min(n, t))
                 }
 
-                function Mt(t, e) {
+                function Pe(t, e) {
                     return (t % e + e) % e
                 }
 
-                function bt(t, e, n) {
+                function De(t, e, n) {
                     return (1 - n) * t + n * e
                 }
 
-                function wt(t) {
+                function Ie(t) {
                     return 0 == (t & t - 1) && 0 !== t
                 }
 
-                function St(t) {
+                function Ne(t) {
                     return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                 }
 
-                function Et(t) {
+                function Oe(t) {
                     return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                 }
-                var Tt = Object.freeze({
+                var Ue = Object.freeze({
                     __proto__: null,
-                    DEG2RAD: vt,
-                    RAD2DEG: xt,
-                    generateUUID: yt,
-                    clamp: _t,
-                    euclideanModulo: Mt,
+                    DEG2RAD: Ae,
+                    RAD2DEG: Re,
+                    generateUUID: Le,
+                    clamp: Ce,
+                    euclideanModulo: Pe,
                     mapLinear: function(t, e, n, i, r) {
                         return i + (t - e) * (r - i) / (n - e)
                     },
                     inverseLerp: function(t, e, n) {
                         return t !== e ? (n - t) / (e - t) : 0
                     },
-                    lerp: bt,
+                    lerp: De,
                     damp: function(t, e, n, i) {
-                        return bt(t, e, 1 - Math.exp(-n * i))
+                        return De(t, e, 1 - Math.exp(-n * i))
                     },
                     pingpong: function(t, e = 1) {
-                        return e - Math.abs(Mt(t, 2 * e) - e)
+                        return e - Math.abs(Pe(t, 2 * e) - e)
                     },
                     smoothstep: function(t, e, n) {
                         return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                     },
                     smootherstep: function(t, e, n) {
                         return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                     },
@@ -170,25 +455,25 @@
                     randFloat: function(t, e) {
                         return t + Math.random() * (e - t)
                     },
                     randFloatSpread: function(t) {
                         return t * (.5 - Math.random())
                     },
                     seededRandom: function(t) {
-                        return void 0 !== t && (gt = t % 2147483647), gt = 16807 * gt % 2147483647, (gt - 1) / 2147483646
+                        return void 0 !== t && (Te = t % 2147483647), Te = 16807 * Te % 2147483647, (Te - 1) / 2147483646
                     },
                     degToRad: function(t) {
-                        return t * vt
+                        return t * Ae
                     },
                     radToDeg: function(t) {
-                        return t * xt
+                        return t * Re
                     },
-                    isPowerOfTwo: wt,
-                    ceilPowerOfTwo: St,
-                    floorPowerOfTwo: Et,
+                    isPowerOfTwo: Ie,
+                    ceilPowerOfTwo: Ne,
+                    floorPowerOfTwo: Oe,
                     setQuaternionFromProperEuler: function(t, e, n, i, r) {
                         const s = Math.cos,
                             a = Math.sin,
                             o = s(n / 2),
                             l = a(n / 2),
                             c = s((e + i) / 2),
                             h = a((e + i) / 2),
@@ -216,15 +501,15 @@
                                 t.set(l * m, l * p, o * h, o * c);
                                 break;
                             default:
                                 console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                         }
                     }
                 });
-                class At {
+                class Be {
                     constructor(t = 0, e = 0) {
                         this.x = t, this.y = e
                     }
                     get width() {
                         return this.x
                     }
                     set width(t) {
@@ -409,16 +694,16 @@
                     }
                     random() {
                         return this.x = Math.random(), this.y = Math.random(), this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y
                     }
                 }
-                At.prototype.isVector2 = !0;
-                class Rt {
+                Be.prototype.isVector2 = !0;
+                class Fe {
                     constructor() {
                         this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                     }
                     set(t, e, n, i, r, s, a, o, l) {
                         const c = this.elements;
                         return c[0] = t, c[1] = i, c[2] = a, c[3] = e, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this
                     }
@@ -556,40 +841,40 @@
                         return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                     }
                     clone() {
                         return (new this.constructor).fromArray(this.elements)
                     }
                 }
 
-                function Lt(t) {
+                function ze(t) {
                     for (let e = t.length - 1; e >= 0; --e)
                         if (t[e] > 65535) return !0;
                     return !1
                 }
-                Rt.prototype.isMatrix3 = !0;
-                const Ct = {
+                Fe.prototype.isMatrix3 = !0;
+                const He = {
                     Int8Array,
                     Uint8Array,
                     Uint8ClampedArray,
                     Int16Array,
                     Uint16Array,
                     Int32Array,
                     Uint32Array,
                     Float32Array,
                     Float64Array
                 };
 
-                function Pt(t, e) {
-                    return new Ct[t](e)
+                function Ge(t, e) {
+                    return new He[t](e)
                 }
 
-                function Dt(t) {
+                function Ve(t) {
                     return document.createElementNS("http://www.w3.org/1999/xhtml", t)
                 }
-                const It = {
+                const ke = {
                         aliceblue: 15792383,
                         antiquewhite: 16444375,
                         aqua: 65535,
                         aquamarine: 8388564,
                         azure: 15794175,
                         beige: 16119260,
                         bisque: 16770244,
@@ -731,37 +1016,37 @@
                         violet: 15631086,
                         wheat: 16113331,
                         white: 16777215,
                         whitesmoke: 16119285,
                         yellow: 16776960,
                         yellowgreen: 10145074
                     },
-                    Nt = {
+                    We = {
                         h: 0,
                         s: 0,
                         l: 0
                     },
-                    Ot = {
+                    je = {
                         h: 0,
                         s: 0,
                         l: 0
                     };
 
-                function Ut(t, e, n) {
+                function Xe(t, e, n) {
                     return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                 }
 
-                function Bt(t) {
+                function qe(t) {
                     return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                 }
 
-                function Ft(t) {
+                function Ye(t) {
                     return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                 }
-                class zt {
+                class Je {
                     constructor(t, e, n) {
                         return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
                     }
                     set(t) {
                         return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                     }
                     setScalar(t) {
@@ -770,19 +1055,19 @@
                     setHex(t) {
                         return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                     }
                     setRGB(t, e, n) {
                         return this.r = t, this.g = e, this.b = n, this
                     }
                     setHSL(t, e, n) {
-                        if (t = Mt(t, 1), e = _t(e, 0, 1), n = _t(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
+                        if (t = Pe(t, 1), e = Ce(e, 0, 1), n = Ce(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                         else {
                             const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                                 r = 2 * n - i;
-                            this.r = Ut(r, i, t + 1 / 3), this.g = Ut(r, i, t), this.b = Ut(r, i, t - 1 / 3)
+                            this.r = Xe(r, i, t + 1 / 3), this.g = Xe(r, i, t), this.b = Xe(r, i, t - 1 / 3)
                         }
                         return this
                     }
                     setStyle(t) {
                         function e(e) {
                             void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                         }
@@ -811,28 +1096,28 @@
                                 e = t.length;
                             if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                             if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                         }
                         return t && t.length > 0 ? this.setColorName(t) : this
                     }
                     setColorName(t) {
-                        const e = It[t.toLowerCase()];
+                        const e = ke[t.toLowerCase()];
                         return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
                     }
                     clone() {
                         return new this.constructor(this.r, this.g, this.b)
                     }
                     copy(t) {
                         return this.r = t.r, this.g = t.g, this.b = t.b, this
                     }
                     copySRGBToLinear(t) {
-                        return this.r = Bt(t.r), this.g = Bt(t.g), this.b = Bt(t.b), this
+                        return this.r = qe(t.r), this.g = qe(t.g), this.b = qe(t.b), this
                     }
                     copyLinearToSRGB(t) {
-                        return this.r = Ft(t.r), this.g = Ft(t.g), this.b = Ft(t.b), this
+                        return this.r = Ye(t.r), this.g = Ye(t.g), this.b = Ye(t.b), this
                     }
                     convertSRGBToLinear() {
                         return this.copySRGBToLinear(this), this
                     }
                     convertLinearToSRGB() {
                         return this.copyLinearToSRGB(this), this
                     }
@@ -867,15 +1152,15 @@
                         }
                         return t.h = a, t.s = o, t.l = l, t
                     }
                     getStyle() {
                         return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                     }
                     offsetHSL(t, e, n) {
-                        return this.getHSL(Nt), Nt.h += t, Nt.s += e, Nt.l += n, this.setHSL(Nt.h, Nt.s, Nt.l), this
+                        return this.getHSL(We), We.h += t, We.s += e, We.l += n, this.setHSL(We.h, We.s, We.l), this
                     }
                     add(t) {
                         return this.r += t.r, this.g += t.g, this.b += t.b, this
                     }
                     addColors(t, e) {
                         return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                     }
@@ -894,18 +1179,18 @@
                     lerp(t, e) {
                         return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                     }
                     lerpColors(t, e, n) {
                         return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
                     }
                     lerpHSL(t, e) {
-                        this.getHSL(Nt), t.getHSL(Ot);
-                        const n = bt(Nt.h, Ot.h, e),
-                            i = bt(Nt.s, Ot.s, e),
-                            r = bt(Nt.l, Ot.l, e);
+                        this.getHSL(We), t.getHSL(je);
+                        const n = De(We.h, je.h, e),
+                            i = De(We.s, je.s, e),
+                            r = De(We.l, je.l, e);
                         return this.setHSL(n, i, r), this
                     }
                     equals(t) {
                         return t.r === this.r && t.g === this.g && t.b === this.b
                     }
                     fromArray(t, e = 0) {
                         return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
@@ -916,58 +1201,58 @@
                     fromBufferAttribute(t, e) {
                         return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                     }
                     toJSON() {
                         return this.getHex()
                     }
                 }
-                let Ht;
-                zt.NAMES = It, zt.prototype.isColor = !0, zt.prototype.r = 1, zt.prototype.g = 1, zt.prototype.b = 1;
-                class Gt {
+                let Ze;
+                Je.NAMES = ke, Je.prototype.isColor = !0, Je.prototype.r = 1, Je.prototype.g = 1, Je.prototype.b = 1;
+                class Ke {
                     static getDataURL(t) {
                         if (/^data:/i.test(t.src)) return t.src;
                         if ("undefined" == typeof HTMLCanvasElement) return t.src;
                         let e;
                         if (t instanceof HTMLCanvasElement) e = t;
                         else {
-                            void 0 === Ht && (Ht = Dt("canvas")), Ht.width = t.width, Ht.height = t.height;
-                            const n = Ht.getContext("2d");
-                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Ht
+                            void 0 === Ze && (Ze = Ve("canvas")), Ze.width = t.width, Ze.height = t.height;
+                            const n = Ze.getContext("2d");
+                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Ze
                         }
                         return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                     }
                     static sRGBToLinear(t) {
                         if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
-                            const e = Dt("canvas");
+                            const e = Ve("canvas");
                             e.width = t.width, e.height = t.height;
                             const n = e.getContext("2d");
                             n.drawImage(t, 0, 0, t.width, t.height);
                             const i = n.getImageData(0, 0, t.width, t.height),
                                 r = i.data;
-                            for (let t = 0; t < r.length; t++) r[t] = 255 * Bt(r[t] / 255);
+                            for (let t = 0; t < r.length; t++) r[t] = 255 * qe(r[t] / 255);
                             return n.putImageData(i, 0, 0), e
                         }
                         if (t.data) {
                             const e = t.data.slice(0);
-                            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * Bt(e[t] / 255)) : e[t] = Bt(e[t]);
+                            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * qe(e[t] / 255)) : e[t] = qe(e[t]);
                             return {
                                 data: e,
                                 width: t.width,
                                 height: t.height
                             }
                         }
                         return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
                     }
                 }
-                let Vt = 0;
-                class kt extends mt {
-                    constructor(t = kt.DEFAULT_IMAGE, e = kt.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = 1, c = 3e3) {
+                let Qe = 0;
+                class $e extends Se {
+                    constructor(t = $e.DEFAULT_IMAGE, e = $e.DEFAULT_MAPPING, n = st, i = st, r = ht, s = dt, a = Et, o = pt, l = 1, c = me) {
                         super(), Object.defineProperty(this, "id", {
-                            value: Vt++
-                        }), this.uuid = yt(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new At(0, 0), this.repeat = new At(1, 1), this.center = new At(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Rt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
+                            value: Qe++
+                        }), this.uuid = Le(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new Be(0, 0), this.repeat = new Be(1, 1), this.center = new Be(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Fe, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                     }
                     updateMatrix() {
                         this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
@@ -999,20 +1284,20 @@
                             anisotropy: this.anisotropy,
                             flipY: this.flipY,
                             premultiplyAlpha: this.premultiplyAlpha,
                             unpackAlignment: this.unpackAlignment
                         };
                         if (void 0 !== this.image) {
                             const i = this.image;
-                            if (void 0 === i.uuid && (i.uuid = yt()), !e && void 0 === t.images[i.uuid]) {
+                            if (void 0 === i.uuid && (i.uuid = Le()), !e && void 0 === t.images[i.uuid]) {
                                 let e;
                                 if (Array.isArray(i)) {
                                     e = [];
-                                    for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(Wt(i[t].image)) : e.push(Wt(i[t]))
-                                } else e = Wt(i);
+                                    for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(tn(i[t].image)) : e.push(tn(i[t]))
+                                } else e = tn(i);
                                 t.images[i.uuid] = {
                                     uuid: i.uuid,
                                     url: e
                                 }
                             }
                             n.image = i.uuid
                         }
@@ -1020,52 +1305,52 @@
                     }
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                     transformUv(t) {
-                        if (this.mapping !== r) return t;
+                        if (this.mapping !== K) return t;
                         if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
-                            case u:
+                            case rt:
                                 t.x = t.x - Math.floor(t.x);
                                 break;
-                            case d:
+                            case st:
                                 t.x = t.x < 0 ? 0 : 1;
                                 break;
-                            case p:
+                            case at:
                                 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                         }
                         if (t.y < 0 || t.y > 1) switch (this.wrapT) {
-                            case u:
+                            case rt:
                                 t.y = t.y - Math.floor(t.y);
                                 break;
-                            case d:
+                            case st:
                                 t.y = t.y < 0 ? 0 : 1;
                                 break;
-                            case p:
+                            case at:
                                 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                         }
                         return this.flipY && (t.y = 1 - t.y), t
                     }
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                 }
 
-                function Wt(t) {
-                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Gt.getDataURL(t) : t.data ? {
+                function tn(t) {
+                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Ke.getDataURL(t) : t.data ? {
                         data: Array.prototype.slice.call(t.data),
                         width: t.width,
                         height: t.height,
                         type: t.data.constructor.name
                     } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
                 }
-                kt.DEFAULT_IMAGE = void 0, kt.DEFAULT_MAPPING = r, kt.prototype.isTexture = !0;
-                class jt {
+                $e.DEFAULT_IMAGE = void 0, $e.DEFAULT_MAPPING = K, $e.prototype.isTexture = !0;
+                class en {
                     constructor(t = 0, e = 0, n = 0, i = 1) {
                         this.x = t, this.y = e, this.z = n, this.w = i
                     }
                     get width() {
                         return this.z
                     }
                     set width(t) {
@@ -1274,22 +1559,22 @@
                     }
                     random() {
                         return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y, yield this.z, yield this.w
                     }
                 }
-                jt.prototype.isVector4 = !0;
-                class Xt extends mt {
+                en.prototype.isVector4 = !0;
+                class nn extends Se {
                     constructor(t, e, n = {}) {
-                        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new jt(0, 0, t, e), this.scissorTest = !1, this.viewport = new jt(0, 0, t, e), this.texture = new kt(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
+                        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new en(0, 0, t, e), this.scissorTest = !1, this.viewport = new en(0, 0, t, e), this.texture = new $e(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                             width: t,
                             height: e,
                             depth: 1
-                        }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : v, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
+                        }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ht, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
                     }
                     setTexture(t) {
                         t.image = {
                             width: this.width,
                             height: this.height,
                             depth: this.depth
                         }, this.texture = t
@@ -1305,16 +1590,16 @@
                     }
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }
-                Xt.prototype.isWebGLRenderTarget = !0;
-                class qt extends Xt {
+                nn.prototype.isWebGLRenderTarget = !0;
+                class rn extends nn {
                     constructor(t, e, n) {
                         super(t, e);
                         const i = this.texture;
                         this.texture = [];
                         for (let t = 0; t < n; t++) this.texture[t] = i.clone()
                     }
                     setSize(t, e, n = 1) {
@@ -1327,25 +1612,25 @@
                     }
                     copy(t) {
                         this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
                         for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
                         return this
                     }
                 }
-                qt.prototype.isWebGLMultipleRenderTargets = !0;
-                class Yt extends Xt {
+                rn.prototype.isWebGLMultipleRenderTargets = !0;
+                class sn extends nn {
                     constructor(t, e, n = {}) {
                         super(t, e, n), this.samples = 4, this.ignoreDepthForMultisampleCopy = void 0 === n.ignoreDepth || n.ignoreDepth, this.useRenderToTexture = void 0 !== n.useRenderToTexture && n.useRenderToTexture, this.useRenderbuffer = !1 === this.useRenderToTexture
                     }
                     copy(t) {
                         return super.copy.call(this, t), this.samples = t.samples, this.useRenderToTexture = t.useRenderToTexture, this.useRenderbuffer = t.useRenderbuffer, this
                     }
                 }
-                Yt.prototype.isWebGLMultisampleRenderTarget = !0;
-                class Jt {
+                sn.prototype.isWebGLMultisampleRenderTarget = !0;
+                class an {
                     constructor(t = 0, e = 0, n = 0, i = 1) {
                         this._x = t, this._y = e, this._z = n, this._w = i
                     }
                     static slerp(t, e, n, i) {
                         return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i)
                     }
                     static slerpFlat(t, e, n, i, r, s, a) {
@@ -1492,15 +1777,15 @@
                         return this._onChangeCallback(), this
                     }
                     setFromUnitVectors(t, e) {
                         let n = t.dot(e) + 1;
                         return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                     }
                     angleTo(t) {
-                        return 2 * Math.acos(Math.abs(_t(this.dot(t), -1, 1)))
+                        return 2 * Math.acos(Math.abs(Ce(this.dot(t), -1, 1)))
                     }
                     rotateTowards(t, e) {
                         const n = this.angleTo(t);
                         if (0 === n) return this;
                         const i = Math.min(1, e / n);
                         return this.slerp(t, i), this
                     }
@@ -1587,16 +1872,16 @@
                         return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                     }
                     _onChange(t) {
                         return this._onChangeCallback = t, this
                     }
                     _onChangeCallback() {}
                 }
-                Jt.prototype.isQuaternion = !0;
-                class Zt {
+                an.prototype.isQuaternion = !0;
+                class on {
                     constructor(t = 0, e = 0, n = 0) {
                         this.x = t, this.y = e, this.z = n
                     }
                     set(t, e, n) {
                         return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
                     }
                     setScalar(t) {
@@ -1672,18 +1957,18 @@
                     multiplyScalar(t) {
                         return this.x *= t, this.y *= t, this.z *= t, this
                     }
                     multiplyVectors(t, e) {
                         return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                     }
                     applyEuler(t) {
-                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Qt.setFromEuler(t))
+                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(cn.setFromEuler(t))
                     }
                     applyAxisAngle(t, e) {
-                        return this.applyQuaternion(Qt.setFromAxisAngle(t, e))
+                        return this.applyQuaternion(cn.setFromAxisAngle(t, e))
                     }
                     applyMatrix3(t) {
                         const e = this.x,
                             n = this.y,
                             i = this.z,
                             r = t.elements;
                         return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
@@ -1802,24 +2087,24 @@
                     projectOnVector(t) {
                         const e = t.lengthSq();
                         if (0 === e) return this.set(0, 0, 0);
                         const n = t.dot(this) / e;
                         return this.copy(t).multiplyScalar(n)
                     }
                     projectOnPlane(t) {
-                        return Kt.copy(this).projectOnVector(t), this.sub(Kt)
+                        return ln.copy(this).projectOnVector(t), this.sub(ln)
                     }
                     reflect(t) {
-                        return this.sub(Kt.copy(t).multiplyScalar(2 * this.dot(t)))
+                        return this.sub(ln.copy(t).multiplyScalar(2 * this.dot(t)))
                     }
                     angleTo(t) {
                         const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                         if (0 === e) return Math.PI / 2;
                         const n = this.dot(t) / e;
-                        return Math.acos(_t(n, -1, 1))
+                        return Math.acos(Ce(n, -1, 1))
                     }
                     distanceTo(t) {
                         return Math.sqrt(this.distanceToSquared(t))
                     }
                     distanceToSquared(t) {
                         const e = this.x - t.x,
                             n = this.y - t.y,
@@ -1878,19 +2163,19 @@
                             e = Math.random() * Math.PI * 2,
                             n = Math.sqrt(1 - t ** 2);
                         return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y, yield this.z
                     }
                 }
-                Zt.prototype.isVector3 = !0;
-                const Kt = new Zt,
-                    Qt = new Jt;
-                class $t {
-                    constructor(t = new Zt(1 / 0, 1 / 0, 1 / 0), e = new Zt(-1 / 0, -1 / 0, -1 / 0)) {
+                on.prototype.isVector3 = !0;
+                const ln = new on,
+                    cn = new an;
+                class hn {
+                    constructor(t = new on(1 / 0, 1 / 0, 1 / 0), e = new on(-1 / 0, -1 / 0, -1 / 0)) {
                         this.min = t, this.max = e
                     }
                     set(t, e) {
                         return this.min.copy(t), this.max.copy(e), this
                     }
                     setFromArray(t) {
                         let e = 1 / 0,
@@ -1924,15 +2209,15 @@
                     }
                     setFromPoints(t) {
                         this.makeEmpty();
                         for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                         return this
                     }
                     setFromCenterAndSize(t, e) {
-                        const n = ee.copy(e).multiplyScalar(.5);
+                        const n = dn.copy(e).multiplyScalar(.5);
                         return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                     }
                     setFromObject(t, e = !1) {
                         return this.makeEmpty(), this.expandByObject(t, e)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
@@ -1963,16 +2248,16 @@
                     }
                     expandByObject(t, e = !1) {
                         t.updateWorldMatrix(!1, !1);
                         const n = t.geometry;
                         if (void 0 !== n)
                             if (e && null != n.attributes && void 0 !== n.attributes.position) {
                                 const e = n.attributes.position;
-                                for (let n = 0, i = e.count; n < i; n++) ee.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(ee)
-                            } else null === n.boundingBox && n.computeBoundingBox(), ne.copy(n.boundingBox), ne.applyMatrix4(t.matrixWorld), this.union(ne);
+                                for (let n = 0, i = e.count; n < i; n++) dn.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(dn)
+                            } else null === n.boundingBox && n.computeBoundingBox(), pn.copy(n.boundingBox), pn.applyMatrix4(t.matrixWorld), this.union(pn);
                         const i = t.children;
                         for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
                         return this
                     }
                     containsPoint(t) {
                         return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                     }
@@ -1982,91 +2267,91 @@
                     getParameter(t, e) {
                         return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                     }
                     intersectsBox(t) {
                         return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                     }
                     intersectsSphere(t) {
-                        return this.clampPoint(t.center, ee), ee.distanceToSquared(t.center) <= t.radius * t.radius
+                        return this.clampPoint(t.center, dn), dn.distanceToSquared(t.center) <= t.radius * t.radius
                     }
                     intersectsPlane(t) {
                         let e, n;
                         return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                     }
                     intersectsTriangle(t) {
                         if (this.isEmpty()) return !1;
-                        this.getCenter(ce), he.subVectors(this.max, ce), ie.subVectors(t.a, ce), re.subVectors(t.b, ce), se.subVectors(t.c, ce), ae.subVectors(re, ie), oe.subVectors(se, re), le.subVectors(ie, se);
-                        let e = [0, -ae.z, ae.y, 0, -oe.z, oe.y, 0, -le.z, le.y, ae.z, 0, -ae.x, oe.z, 0, -oe.x, le.z, 0, -le.x, -ae.y, ae.x, 0, -oe.y, oe.x, 0, -le.y, le.x, 0];
-                        return !!pe(e, ie, re, se, he) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!pe(e, ie, re, se, he) && (ue.crossVectors(ae, oe), e = [ue.x, ue.y, ue.z], pe(e, ie, re, se, he)))
+                        this.getCenter(_n), Mn.subVectors(this.max, _n), mn.subVectors(t.a, _n), fn.subVectors(t.b, _n), gn.subVectors(t.c, _n), vn.subVectors(fn, mn), xn.subVectors(gn, fn), yn.subVectors(mn, gn);
+                        let e = [0, -vn.z, vn.y, 0, -xn.z, xn.y, 0, -yn.z, yn.y, vn.z, 0, -vn.x, xn.z, 0, -xn.x, yn.z, 0, -yn.x, -vn.y, vn.x, 0, -xn.y, xn.x, 0, -yn.y, yn.x, 0];
+                        return !!Sn(e, mn, fn, gn, Mn) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Sn(e, mn, fn, gn, Mn) && (bn.crossVectors(vn, xn), e = [bn.x, bn.y, bn.z], Sn(e, mn, fn, gn, Mn)))
                     }
                     clampPoint(t, e) {
                         return e.copy(t).clamp(this.min, this.max)
                     }
                     distanceToPoint(t) {
-                        return ee.copy(t).clamp(this.min, this.max).sub(t).length()
+                        return dn.copy(t).clamp(this.min, this.max).sub(t).length()
                     }
                     getBoundingSphere(t) {
-                        return this.getCenter(t.center), t.radius = .5 * this.getSize(ee).length(), t
+                        return this.getCenter(t.center), t.radius = .5 * this.getSize(dn).length(), t
                     }
                     intersect(t) {
                         return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                     }
                     union(t) {
                         return this.min.min(t.min), this.max.max(t.max), this
                     }
                     applyMatrix4(t) {
-                        return this.isEmpty() || (te[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), te[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), te[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), te[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), te[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), te[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), te[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), te[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(te)), this
+                        return this.isEmpty() || (un[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), un[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), un[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), un[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), un[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), un[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), un[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), un[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(un)), this
                     }
                     translate(t) {
                         return this.min.add(t), this.max.add(t), this
                     }
                     equals(t) {
                         return t.min.equals(this.min) && t.max.equals(this.max)
                     }
                 }
-                $t.prototype.isBox3 = !0;
-                const te = [new Zt, new Zt, new Zt, new Zt, new Zt, new Zt, new Zt, new Zt],
-                    ee = new Zt,
-                    ne = new $t,
-                    ie = new Zt,
-                    re = new Zt,
-                    se = new Zt,
-                    ae = new Zt,
-                    oe = new Zt,
-                    le = new Zt,
-                    ce = new Zt,
-                    he = new Zt,
-                    ue = new Zt,
-                    de = new Zt;
+                hn.prototype.isBox3 = !0;
+                const un = [new on, new on, new on, new on, new on, new on, new on, new on],
+                    dn = new on,
+                    pn = new hn,
+                    mn = new on,
+                    fn = new on,
+                    gn = new on,
+                    vn = new on,
+                    xn = new on,
+                    yn = new on,
+                    _n = new on,
+                    Mn = new on,
+                    bn = new on,
+                    wn = new on;
 
-                function pe(t, e, n, i, r) {
+                function Sn(t, e, n, i, r) {
                     for (let s = 0, a = t.length - 3; s <= a; s += 3) {
-                        de.fromArray(t, s);
-                        const a = r.x * Math.abs(de.x) + r.y * Math.abs(de.y) + r.z * Math.abs(de.z),
-                            o = e.dot(de),
-                            l = n.dot(de),
-                            c = i.dot(de);
+                        wn.fromArray(t, s);
+                        const a = r.x * Math.abs(wn.x) + r.y * Math.abs(wn.y) + r.z * Math.abs(wn.z),
+                            o = e.dot(wn),
+                            l = n.dot(wn),
+                            c = i.dot(wn);
                         if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
                     }
                     return !0
                 }
-                const me = new $t,
-                    fe = new Zt,
-                    ge = new Zt,
-                    ve = new Zt;
-                class xe {
-                    constructor(t = new Zt, e = -1) {
+                const En = new hn,
+                    Tn = new on,
+                    An = new on,
+                    Rn = new on;
+                class Ln {
+                    constructor(t = new on, e = -1) {
                         this.center = t, this.radius = e
                     }
                     set(t, e) {
                         return this.center.copy(t), this.radius = e, this
                     }
                     setFromPoints(t, e) {
                         const n = this.center;
-                        void 0 !== e ? n.copy(e) : me.setFromPoints(t).getCenter(n);
+                        void 0 !== e ? n.copy(e) : En.setFromPoints(t).getCenter(n);
                         let i = 0;
                         for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                         return this.radius = Math.sqrt(i), this
                     }
                     copy(t) {
                         return this.center.copy(t.center), this.radius = t.radius, this
                     }
@@ -2102,42 +2387,42 @@
                     applyMatrix4(t) {
                         return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                     }
                     translate(t) {
                         return this.center.add(t), this
                     }
                     expandByPoint(t) {
-                        ve.subVectors(t, this.center);
-                        const e = ve.lengthSq();
+                        Rn.subVectors(t, this.center);
+                        const e = Rn.lengthSq();
                         if (e > this.radius * this.radius) {
                             const t = Math.sqrt(e),
                                 n = .5 * (t - this.radius);
-                            this.center.add(ve.multiplyScalar(n / t)), this.radius += n
+                            this.center.add(Rn.multiplyScalar(n / t)), this.radius += n
                         }
                         return this
                     }
                     union(t) {
-                        return !0 === this.center.equals(t.center) ? ge.set(0, 0, 1).multiplyScalar(t.radius) : ge.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(fe.copy(t.center).add(ge)), this.expandByPoint(fe.copy(t.center).sub(ge)), this
+                        return !0 === this.center.equals(t.center) ? An.set(0, 0, 1).multiplyScalar(t.radius) : An.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(Tn.copy(t.center).add(An)), this.expandByPoint(Tn.copy(t.center).sub(An)), this
                     }
                     equals(t) {
                         return t.center.equals(this.center) && t.radius === this.radius
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                const ye = new Zt,
-                    _e = new Zt,
-                    Me = new Zt,
-                    be = new Zt,
-                    we = new Zt,
-                    Se = new Zt,
-                    Ee = new Zt;
-                class Te {
-                    constructor(t = new Zt, e = new Zt(0, 0, -1)) {
+                const Cn = new on,
+                    Pn = new on,
+                    Dn = new on,
+                    In = new on,
+                    Nn = new on,
+                    On = new on,
+                    Un = new on;
+                class Bn {
+                    constructor(t = new on, e = new on(0, 0, -1)) {
                         this.origin = t, this.direction = e
                     }
                     set(t, e) {
                         return this.origin.copy(t), this.direction.copy(e), this
                     }
                     copy(t) {
                         return this.origin.copy(t.origin), this.direction.copy(t.direction), this
@@ -2145,53 +2430,53 @@
                     at(t, e) {
                         return e.copy(this.direction).multiplyScalar(t).add(this.origin)
                     }
                     lookAt(t) {
                         return this.direction.copy(t).sub(this.origin).normalize(), this
                     }
                     recast(t) {
-                        return this.origin.copy(this.at(t, ye)), this
+                        return this.origin.copy(this.at(t, Cn)), this
                     }
                     closestPointToPoint(t, e) {
                         e.subVectors(t, this.origin);
                         const n = e.dot(this.direction);
                         return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                     }
                     distanceToPoint(t) {
                         return Math.sqrt(this.distanceSqToPoint(t))
                     }
                     distanceSqToPoint(t) {
-                        const e = ye.subVectors(t, this.origin).dot(this.direction);
-                        return e < 0 ? this.origin.distanceToSquared(t) : (ye.copy(this.direction).multiplyScalar(e).add(this.origin), ye.distanceToSquared(t))
+                        const e = Cn.subVectors(t, this.origin).dot(this.direction);
+                        return e < 0 ? this.origin.distanceToSquared(t) : (Cn.copy(this.direction).multiplyScalar(e).add(this.origin), Cn.distanceToSquared(t))
                     }
                     distanceSqToSegment(t, e, n, i) {
-                        _e.copy(t).add(e).multiplyScalar(.5), Me.copy(e).sub(t).normalize(), be.copy(this.origin).sub(_e);
+                        Pn.copy(t).add(e).multiplyScalar(.5), Dn.copy(e).sub(t).normalize(), In.copy(this.origin).sub(Pn);
                         const r = .5 * t.distanceTo(e),
-                            s = -this.direction.dot(Me),
-                            a = be.dot(this.direction),
-                            o = -be.dot(Me),
-                            l = be.lengthSq(),
+                            s = -this.direction.dot(Dn),
+                            a = In.dot(this.direction),
+                            o = -In.dot(Dn),
+                            l = In.lengthSq(),
                             c = Math.abs(1 - s * s);
                         let h, u, d, p;
                         if (c > 0)
                             if (h = s * o - a, u = s * a - o, p = r * c, h >= 0)
                                 if (u >= -p)
                                     if (u <= p) {
                                         const t = 1 / c;
                                         h *= t, u *= t, d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l
                                     } else u = r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                         else u = -r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                         else u <= -p ? (h = Math.max(0, -(-s * r + a)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
                         else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
-                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Me).multiplyScalar(u).add(_e), d
+                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Dn).multiplyScalar(u).add(Pn), d
                     }
                     intersectSphere(t, e) {
-                        ye.subVectors(t.center, this.origin);
-                        const n = ye.dot(this.direction),
-                            i = ye.dot(ye) - n * n,
+                        Cn.subVectors(t.center, this.origin);
+                        const n = Cn.dot(this.direction),
+                            i = Cn.dot(Cn) - n * n,
                             r = t.radius * t.radius;
                         if (i > r) return null;
                         const s = Math.sqrt(r - i),
                             a = n - s,
                             o = n + s;
                         return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
                     }
@@ -2217,58 +2502,58 @@
                         const l = 1 / this.direction.x,
                             c = 1 / this.direction.y,
                             h = 1 / this.direction.z,
                             u = this.origin;
                         return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (a = (t.min.z - u.z) * h, o = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, o = (t.min.z - u.z) * h), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                     }
                     intersectsBox(t) {
-                        return null !== this.intersectBox(t, ye)
+                        return null !== this.intersectBox(t, Cn)
                     }
                     intersectTriangle(t, e, n, i, r) {
-                        we.subVectors(e, t), Se.subVectors(n, t), Ee.crossVectors(we, Se);
-                        let s, a = this.direction.dot(Ee);
+                        Nn.subVectors(e, t), On.subVectors(n, t), Un.crossVectors(Nn, On);
+                        let s, a = this.direction.dot(Un);
                         if (a > 0) {
                             if (i) return null;
                             s = 1
                         } else {
                             if (!(a < 0)) return null;
                             s = -1, a = -a
                         }
-                        be.subVectors(this.origin, t);
-                        const o = s * this.direction.dot(Se.crossVectors(be, Se));
+                        In.subVectors(this.origin, t);
+                        const o = s * this.direction.dot(On.crossVectors(In, On));
                         if (o < 0) return null;
-                        const l = s * this.direction.dot(we.cross(be));
+                        const l = s * this.direction.dot(Nn.cross(In));
                         if (l < 0) return null;
                         if (o + l > a) return null;
-                        const c = -s * be.dot(Ee);
+                        const c = -s * In.dot(Un);
                         return c < 0 ? null : this.at(c / a, r)
                     }
                     applyMatrix4(t) {
                         return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                     }
                     equals(t) {
                         return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                class Ae {
+                class Fn {
                     constructor() {
                         this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                     }
                     set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
                         const g = this.elements;
                         return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
                     }
                     identity() {
                         return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                     }
                     clone() {
-                        return (new Ae).fromArray(this.elements)
+                        return (new Fn).fromArray(this.elements)
                     }
                     copy(t) {
                         const e = this.elements,
                             n = t.elements;
                         return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                     }
                     copyPosition(t) {
@@ -2285,17 +2570,17 @@
                     }
                     makeBasis(t, e, n) {
                         return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                     }
                     extractRotation(t) {
                         const e = this.elements,
                             n = t.elements,
-                            i = 1 / Re.setFromMatrixColumn(t, 0).length(),
-                            r = 1 / Re.setFromMatrixColumn(t, 1).length(),
-                            s = 1 / Re.setFromMatrixColumn(t, 2).length();
+                            i = 1 / zn.setFromMatrixColumn(t, 0).length(),
+                            r = 1 / zn.setFromMatrixColumn(t, 1).length(),
+                            s = 1 / zn.setFromMatrixColumn(t, 2).length();
                         return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                     }
                     makeRotationFromEuler(t) {
                         t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                         const e = this.elements,
                             n = t.x,
                             i = t.y,
@@ -2342,19 +2627,19 @@
                                 i = a * o,
                                 r = a * l;
                             e[0] = o * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = s * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = a * c, e[10] = r * h + t
                         }
                         return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                     }
                     makeRotationFromQuaternion(t) {
-                        return this.compose(Ce, t, Pe)
+                        return this.compose(Gn, t, Vn)
                     }
                     lookAt(t, e, n) {
                         const i = this.elements;
-                        return Ne.subVectors(t, e), 0 === Ne.lengthSq() && (Ne.z = 1), Ne.normalize(), De.crossVectors(n, Ne), 0 === De.lengthSq() && (1 === Math.abs(n.z) ? Ne.x += 1e-4 : Ne.z += 1e-4, Ne.normalize(), De.crossVectors(n, Ne)), De.normalize(), Ie.crossVectors(Ne, De), i[0] = De.x, i[4] = Ie.x, i[8] = Ne.x, i[1] = De.y, i[5] = Ie.y, i[9] = Ne.y, i[2] = De.z, i[6] = Ie.z, i[10] = Ne.z, this
+                        return jn.subVectors(t, e), 0 === jn.lengthSq() && (jn.z = 1), jn.normalize(), kn.crossVectors(n, jn), 0 === kn.lengthSq() && (1 === Math.abs(n.z) ? jn.x += 1e-4 : jn.z += 1e-4, jn.normalize(), kn.crossVectors(n, jn)), kn.normalize(), Wn.crossVectors(jn, kn), i[0] = kn.x, i[4] = Wn.x, i[8] = jn.x, i[1] = kn.y, i[5] = Wn.y, i[9] = jn.y, i[2] = kn.z, i[6] = Wn.z, i[10] = jn.z, this
                     }
                     multiply(t, e) {
                         return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                     }
                     premultiply(t) {
                         return this.multiplyMatrices(t, this)
                     }
@@ -2522,22 +2807,22 @@
                             _ = n.x,
                             M = n.y,
                             b = n.z;
                         return i[0] = (1 - (m + g)) * _, i[1] = (d + y) * _, i[2] = (p - x) * _, i[3] = 0, i[4] = (d - y) * M, i[5] = (1 - (u + g)) * M, i[6] = (f + v) * M, i[7] = 0, i[8] = (p + x) * b, i[9] = (f - v) * b, i[10] = (1 - (u + m)) * b, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                     }
                     decompose(t, e, n) {
                         const i = this.elements;
-                        let r = Re.set(i[0], i[1], i[2]).length();
-                        const s = Re.set(i[4], i[5], i[6]).length(),
-                            a = Re.set(i[8], i[9], i[10]).length();
-                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Le.copy(this);
+                        let r = zn.set(i[0], i[1], i[2]).length();
+                        const s = zn.set(i[4], i[5], i[6]).length(),
+                            a = zn.set(i[8], i[9], i[10]).length();
+                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Hn.copy(this);
                         const o = 1 / r,
                             l = 1 / s,
                             c = 1 / a;
-                        return Le.elements[0] *= o, Le.elements[1] *= o, Le.elements[2] *= o, Le.elements[4] *= l, Le.elements[5] *= l, Le.elements[6] *= l, Le.elements[8] *= c, Le.elements[9] *= c, Le.elements[10] *= c, e.setFromRotationMatrix(Le), n.x = r, n.y = s, n.z = a, this
+                        return Hn.elements[0] *= o, Hn.elements[1] *= o, Hn.elements[2] *= o, Hn.elements[4] *= l, Hn.elements[5] *= l, Hn.elements[6] *= l, Hn.elements[8] *= c, Hn.elements[9] *= c, Hn.elements[10] *= c, e.setFromRotationMatrix(Hn), n.x = r, n.y = s, n.z = a, this
                     }
                     makePerspective(t, e, n, i, r, s) {
                         void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                         const a = this.elements,
                             o = 2 * r / (e - t),
                             l = 2 * r / (n - i),
                             c = (e + t) / (e - t),
@@ -2568,26 +2853,26 @@
                         return this
                     }
                     toArray(t = [], e = 0) {
                         const n = this.elements;
                         return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                     }
                 }
-                Ae.prototype.isMatrix4 = !0;
-                const Re = new Zt,
-                    Le = new Ae,
-                    Ce = new Zt(0, 0, 0),
-                    Pe = new Zt(1, 1, 1),
-                    De = new Zt,
-                    Ie = new Zt,
-                    Ne = new Zt,
-                    Oe = new Ae,
-                    Ue = new Jt;
-                class Be {
-                    constructor(t = 0, e = 0, n = 0, i = Be.DefaultOrder) {
+                Fn.prototype.isMatrix4 = !0;
+                const zn = new on,
+                    Hn = new Fn,
+                    Gn = new on(0, 0, 0),
+                    Vn = new on(1, 1, 1),
+                    kn = new on,
+                    Wn = new on,
+                    jn = new on,
+                    Xn = new Fn,
+                    qn = new an;
+                class Yn {
+                    constructor(t = 0, e = 0, n = 0, i = Yn.DefaultOrder) {
                         this._x = t, this._y = e, this._z = n, this._order = i
                     }
                     get x() {
                         return this._x
                     }
                     set x(t) {
                         this._x = t, this._onChangeCallback()
@@ -2628,64 +2913,64 @@
                             l = i[5],
                             c = i[9],
                             h = i[2],
                             u = i[6],
                             d = i[10];
                         switch (e) {
                             case "XYZ":
-                                this._y = Math.asin(_t(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
+                                this._y = Math.asin(Ce(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                                 break;
                             case "YXZ":
-                                this._x = Math.asin(-_t(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
+                                this._x = Math.asin(-Ce(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                                 break;
                             case "ZXY":
-                                this._x = Math.asin(_t(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
+                                this._x = Math.asin(Ce(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                                 break;
                             case "ZYX":
-                                this._y = Math.asin(-_t(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
+                                this._y = Math.asin(-Ce(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                                 break;
                             case "YZX":
-                                this._z = Math.asin(_t(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
+                                this._z = Math.asin(Ce(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                                 break;
                             case "XZY":
-                                this._z = Math.asin(-_t(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
+                                this._z = Math.asin(-Ce(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                                 break;
                             default:
                                 console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                         }
                         return this._order = e, !0 === n && this._onChangeCallback(), this
                     }
                     setFromQuaternion(t, e, n) {
-                        return Oe.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Oe, e, n)
+                        return Xn.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Xn, e, n)
                     }
                     setFromVector3(t, e = this._order) {
                         return this.set(t.x, t.y, t.z, e)
                     }
                     reorder(t) {
-                        return Ue.setFromEuler(this), this.setFromQuaternion(Ue, t)
+                        return qn.setFromEuler(this), this.setFromQuaternion(qn, t)
                     }
                     equals(t) {
                         return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                     }
                     fromArray(t) {
                         return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                     }
                     toArray(t = [], e = 0) {
                         return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                     }
                     toVector3(t) {
-                        return t ? t.set(this._x, this._y, this._z) : new Zt(this._x, this._y, this._z)
+                        return t ? t.set(this._x, this._y, this._z) : new on(this._x, this._y, this._z)
                     }
                     _onChange(t) {
                         return this._onChangeCallback = t, this
                     }
                     _onChangeCallback() {}
                 }
-                Be.prototype.isEuler = !0, Be.DefaultOrder = "XYZ", Be.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
-                class Fe {
+                Yn.prototype.isEuler = !0, Yn.DefaultOrder = "XYZ", Yn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
+                class Jn {
                     constructor() {
                         this.mask = 1
                     }
                     set(t) {
                         this.mask = (1 << t | 0) >>> 0
                     }
                     enable(t) {
@@ -2706,40 +2991,40 @@
                     test(t) {
                         return 0 != (this.mask & t.mask)
                     }
                     isEnabled(t) {
                         return 0 != (this.mask & (1 << t | 0))
                     }
                 }
-                let ze = 0;
-                const He = new Zt,
-                    Ge = new Jt,
-                    Ve = new Ae,
-                    ke = new Zt,
-                    We = new Zt,
-                    je = new Zt,
-                    Xe = new Jt,
-                    qe = new Zt(1, 0, 0),
-                    Ye = new Zt(0, 1, 0),
-                    Je = new Zt(0, 0, 1),
-                    Ze = {
+                let Zn = 0;
+                const Kn = new on,
+                    Qn = new an,
+                    $n = new Fn,
+                    ti = new on,
+                    ei = new on,
+                    ni = new on,
+                    ii = new an,
+                    ri = new on(1, 0, 0),
+                    si = new on(0, 1, 0),
+                    ai = new on(0, 0, 1),
+                    oi = {
                         type: "added"
                     },
-                    Ke = {
+                    li = {
                         type: "removed"
                     };
-                class Qe extends mt {
+                class ci extends Se {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: ze++
-                        }), this.uuid = yt(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Qe.DefaultUp.clone();
-                        const t = new Zt,
-                            e = new Be,
-                            n = new Jt,
-                            i = new Zt(1, 1, 1);
+                            value: Zn++
+                        }), this.uuid = Le(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ci.DefaultUp.clone();
+                        const t = new on,
+                            e = new Yn,
+                            n = new an,
+                            i = new on(1, 1, 1);
                         e._onChange((function() {
                             n.setFromEuler(e, !1)
                         })), n._onChange((function() {
                             e.setFromQuaternion(n, void 0, !1)
                         })), Object.defineProperties(this, {
                             position: {
                                 configurable: !0,
@@ -2758,20 +3043,20 @@
                             },
                             scale: {
                                 configurable: !0,
                                 enumerable: !0,
                                 value: i
                             },
                             modelViewMatrix: {
-                                value: new Ae
+                                value: new Fn
                             },
                             normalMatrix: {
-                                value: new Rt
+                                value: new Fe
                             }
-                        }), this.matrix = new Ae, this.matrixWorld = new Ae, this.matrixAutoUpdate = Qe.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Fe, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
+                        }), this.matrix = new Fn, this.matrixWorld = new Fn, this.matrixAutoUpdate = ci.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Jn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                     }
                     onBeforeRender() {}
                     onAfterRender() {}
                     applyMatrix4(t) {
                         this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                     }
                     applyQuaternion(t) {
@@ -2786,79 +3071,79 @@
                     setRotationFromMatrix(t) {
                         this.quaternion.setFromRotationMatrix(t)
                     }
                     setRotationFromQuaternion(t) {
                         this.quaternion.copy(t)
                     }
                     rotateOnAxis(t, e) {
-                        return Ge.setFromAxisAngle(t, e), this.quaternion.multiply(Ge), this
+                        return Qn.setFromAxisAngle(t, e), this.quaternion.multiply(Qn), this
                     }
                     rotateOnWorldAxis(t, e) {
-                        return Ge.setFromAxisAngle(t, e), this.quaternion.premultiply(Ge), this
+                        return Qn.setFromAxisAngle(t, e), this.quaternion.premultiply(Qn), this
                     }
                     rotateX(t) {
-                        return this.rotateOnAxis(qe, t)
+                        return this.rotateOnAxis(ri, t)
                     }
                     rotateY(t) {
-                        return this.rotateOnAxis(Ye, t)
+                        return this.rotateOnAxis(si, t)
                     }
                     rotateZ(t) {
-                        return this.rotateOnAxis(Je, t)
+                        return this.rotateOnAxis(ai, t)
                     }
                     translateOnAxis(t, e) {
-                        return He.copy(t).applyQuaternion(this.quaternion), this.position.add(He.multiplyScalar(e)), this
+                        return Kn.copy(t).applyQuaternion(this.quaternion), this.position.add(Kn.multiplyScalar(e)), this
                     }
                     translateX(t) {
-                        return this.translateOnAxis(qe, t)
+                        return this.translateOnAxis(ri, t)
                     }
                     translateY(t) {
-                        return this.translateOnAxis(Ye, t)
+                        return this.translateOnAxis(si, t)
                     }
                     translateZ(t) {
-                        return this.translateOnAxis(Je, t)
+                        return this.translateOnAxis(ai, t)
                     }
                     localToWorld(t) {
                         return t.applyMatrix4(this.matrixWorld)
                     }
                     worldToLocal(t) {
-                        return t.applyMatrix4(Ve.copy(this.matrixWorld).invert())
+                        return t.applyMatrix4($n.copy(this.matrixWorld).invert())
                     }
                     lookAt(t, e, n) {
-                        t.isVector3 ? ke.copy(t) : ke.set(t, e, n);
+                        t.isVector3 ? ti.copy(t) : ti.set(t, e, n);
                         const i = this.parent;
-                        this.updateWorldMatrix(!0, !1), We.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ve.lookAt(We, ke, this.up) : Ve.lookAt(ke, We, this.up), this.quaternion.setFromRotationMatrix(Ve), i && (Ve.extractRotation(i.matrixWorld), Ge.setFromRotationMatrix(Ve), this.quaternion.premultiply(Ge.invert()))
+                        this.updateWorldMatrix(!0, !1), ei.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? $n.lookAt(ei, ti, this.up) : $n.lookAt(ti, ei, this.up), this.quaternion.setFromRotationMatrix($n), i && ($n.extractRotation(i.matrixWorld), Qn.setFromRotationMatrix($n), this.quaternion.premultiply(Qn.invert()))
                     }
                     add(t) {
                         if (arguments.length > 1) {
                             for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                             return this
                         }
-                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Ze)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
+                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(oi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                     }
                     remove(t) {
                         if (arguments.length > 1) {
                             for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                             return this
                         }
                         const e = this.children.indexOf(t);
-                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Ke)), this
+                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(li)), this
                     }
                     removeFromParent() {
                         const t = this.parent;
                         return null !== t && t.remove(this), this
                     }
                     clear() {
                         for (let t = 0; t < this.children.length; t++) {
                             const e = this.children[t];
-                            e.parent = null, e.dispatchEvent(Ke)
+                            e.parent = null, e.dispatchEvent(li)
                         }
                         return this.children.length = 0, this
                     }
                     attach(t) {
-                        return this.updateWorldMatrix(!0, !1), Ve.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Ve.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ve), this.add(t), t.updateWorldMatrix(!1, !0), this
+                        return this.updateWorldMatrix(!0, !1), $n.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), $n.multiply(t.parent.matrixWorld)), t.applyMatrix4($n), this.add(t), t.updateWorldMatrix(!1, !0), this
                     }
                     getObjectById(t) {
                         return this.getObjectByProperty("id", t)
                     }
                     getObjectByName(t) {
                         return this.getObjectByProperty("name", t)
                     }
@@ -2869,18 +3154,18 @@
                             if (void 0 !== i) return i
                         }
                     }
                     getWorldPosition(t) {
                         return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                     }
                     getWorldQuaternion(t) {
-                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(We, t, je), t
+                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ei, t, ni), t
                     }
                     getWorldScale(t) {
-                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(We, Xe, t), t
+                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ei, ii, t), t
                     }
                     getWorldDirection(t) {
                         this.updateWorldMatrix(!0, !1);
                         const e = this.matrixWorld.elements;
                         return t.set(e[8], e[9], e[10]).normalize()
                     }
                     raycast() {}
@@ -2994,56 +3279,56 @@
                             for (let e = 0; e < t.children.length; e++) {
                                 const n = t.children[e];
                                 this.add(n.clone())
                             }
                         return this
                     }
                 }
-                Qe.DefaultUp = new Zt(0, 1, 0), Qe.DefaultMatrixAutoUpdate = !0, Qe.prototype.isObject3D = !0;
-                const $e = new Zt,
-                    tn = new Zt,
-                    en = new Zt,
-                    nn = new Zt,
-                    rn = new Zt,
-                    sn = new Zt,
-                    an = new Zt,
-                    on = new Zt,
-                    ln = new Zt,
-                    cn = new Zt;
-                class hn {
-                    constructor(t = new Zt, e = new Zt, n = new Zt) {
+                ci.DefaultUp = new on(0, 1, 0), ci.DefaultMatrixAutoUpdate = !0, ci.prototype.isObject3D = !0;
+                const hi = new on,
+                    ui = new on,
+                    di = new on,
+                    pi = new on,
+                    mi = new on,
+                    fi = new on,
+                    gi = new on,
+                    vi = new on,
+                    xi = new on,
+                    yi = new on;
+                class _i {
+                    constructor(t = new on, e = new on, n = new on) {
                         this.a = t, this.b = e, this.c = n
                     }
                     static getNormal(t, e, n, i) {
-                        i.subVectors(n, e), $e.subVectors(t, e), i.cross($e);
+                        i.subVectors(n, e), hi.subVectors(t, e), i.cross(hi);
                         const r = i.lengthSq();
                         return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                     }
                     static getBarycoord(t, e, n, i, r) {
-                        $e.subVectors(i, e), tn.subVectors(n, e), en.subVectors(t, e);
-                        const s = $e.dot($e),
-                            a = $e.dot(tn),
-                            o = $e.dot(en),
-                            l = tn.dot(tn),
-                            c = tn.dot(en),
+                        hi.subVectors(i, e), ui.subVectors(n, e), di.subVectors(t, e);
+                        const s = hi.dot(hi),
+                            a = hi.dot(ui),
+                            o = hi.dot(di),
+                            l = ui.dot(ui),
+                            c = ui.dot(di),
                             h = s * l - a * a;
                         if (0 === h) return r.set(-2, -1, -1);
                         const u = 1 / h,
                             d = (l * o - a * c) * u,
                             p = (s * c - a * o) * u;
                         return r.set(1 - d - p, p, d)
                     }
                     static containsPoint(t, e, n, i) {
-                        return this.getBarycoord(t, e, n, i, nn), nn.x >= 0 && nn.y >= 0 && nn.x + nn.y <= 1
+                        return this.getBarycoord(t, e, n, i, pi), pi.x >= 0 && pi.y >= 0 && pi.x + pi.y <= 1
                     }
                     static getUV(t, e, n, i, r, s, a, o) {
-                        return this.getBarycoord(t, e, n, i, nn), o.set(0, 0), o.addScaledVector(r, nn.x), o.addScaledVector(s, nn.y), o.addScaledVector(a, nn.z), o
+                        return this.getBarycoord(t, e, n, i, pi), o.set(0, 0), o.addScaledVector(r, pi.x), o.addScaledVector(s, pi.y), o.addScaledVector(a, pi.z), o
                     }
                     static isFrontFacing(t, e, n, i) {
-                        return $e.subVectors(n, e), tn.subVectors(t, e), $e.cross(tn).dot(i) < 0
+                        return hi.subVectors(n, e), ui.subVectors(t, e), hi.cross(ui).dot(i) < 0
                     }
                     set(t, e, n) {
                         return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                     }
                     setFromPointsAndIndices(t, e, n, i) {
                         return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                     }
@@ -3053,76 +3338,76 @@
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     copy(t) {
                         return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                     }
                     getArea() {
-                        return $e.subVectors(this.c, this.b), tn.subVectors(this.a, this.b), .5 * $e.cross(tn).length()
+                        return hi.subVectors(this.c, this.b), ui.subVectors(this.a, this.b), .5 * hi.cross(ui).length()
                     }
                     getMidpoint(t) {
                         return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                     }
                     getNormal(t) {
-                        return hn.getNormal(this.a, this.b, this.c, t)
+                        return _i.getNormal(this.a, this.b, this.c, t)
                     }
                     getPlane(t) {
                         return t.setFromCoplanarPoints(this.a, this.b, this.c)
                     }
                     getBarycoord(t, e) {
-                        return hn.getBarycoord(t, this.a, this.b, this.c, e)
+                        return _i.getBarycoord(t, this.a, this.b, this.c, e)
                     }
                     getUV(t, e, n, i, r) {
-                        return hn.getUV(t, this.a, this.b, this.c, e, n, i, r)
+                        return _i.getUV(t, this.a, this.b, this.c, e, n, i, r)
                     }
                     containsPoint(t) {
-                        return hn.containsPoint(t, this.a, this.b, this.c)
+                        return _i.containsPoint(t, this.a, this.b, this.c)
                     }
                     isFrontFacing(t) {
-                        return hn.isFrontFacing(this.a, this.b, this.c, t)
+                        return _i.isFrontFacing(this.a, this.b, this.c, t)
                     }
                     intersectsBox(t) {
                         return t.intersectsTriangle(this)
                     }
                     closestPointToPoint(t, e) {
                         const n = this.a,
                             i = this.b,
                             r = this.c;
                         let s, a;
-                        rn.subVectors(i, n), sn.subVectors(r, n), on.subVectors(t, n);
-                        const o = rn.dot(on),
-                            l = sn.dot(on);
+                        mi.subVectors(i, n), fi.subVectors(r, n), vi.subVectors(t, n);
+                        const o = mi.dot(vi),
+                            l = fi.dot(vi);
                         if (o <= 0 && l <= 0) return e.copy(n);
-                        ln.subVectors(t, i);
-                        const c = rn.dot(ln),
-                            h = sn.dot(ln);
+                        xi.subVectors(t, i);
+                        const c = mi.dot(xi),
+                            h = fi.dot(xi);
                         if (c >= 0 && h <= c) return e.copy(i);
                         const u = o * h - c * l;
-                        if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector(rn, s);
-                        cn.subVectors(t, r);
-                        const d = rn.dot(cn),
-                            p = sn.dot(cn);
+                        if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector(mi, s);
+                        yi.subVectors(t, r);
+                        const d = mi.dot(yi),
+                            p = fi.dot(yi);
                         if (p >= 0 && d <= p) return e.copy(r);
                         const m = d * l - o * p;
-                        if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(sn, a);
+                        if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(fi, a);
                         const f = c * p - d * h;
-                        if (f <= 0 && h - c >= 0 && d - p >= 0) return an.subVectors(r, i), a = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(an, a);
+                        if (f <= 0 && h - c >= 0 && d - p >= 0) return gi.subVectors(r, i), a = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(gi, a);
                         const g = 1 / (f + m + u);
-                        return s = m * g, a = u * g, e.copy(n).addScaledVector(rn, s).addScaledVector(sn, a)
+                        return s = m * g, a = u * g, e.copy(n).addScaledVector(mi, s).addScaledVector(fi, a)
                     }
                     equals(t) {
                         return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                     }
                 }
-                let un = 0;
-                class dn extends mt {
+                let Mi = 0;
+                class bi extends Se {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: un++
-                        }), this.uuid = yt(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = i, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ct, this.stencilZFail = ct, this.stencilZPass = ct, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.alphaWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
+                            value: Mi++
+                        }), this.uuid = Le(), this.name = "", this.type = "Material", this.fog = !0, this.blending = p, this.side = c, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = A, this.blendDst = R, this.blendEquation = x, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = B, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ye, this.stencilZFail = ye, this.stencilZPass = ye, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.alphaWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                     }
                     get alphaTest() {
                         return this._alphaTest
                     }
                     set alphaTest(t) {
                         this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
                     }
@@ -3166,15 +3451,15 @@
                             const e = [];
                             for (const n in t) {
                                 const i = t[n];
                                 delete i.metadata, e.push(i)
                             }
                             return e
                         }
-                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.alphaWrite = this.alphaWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
+                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== p && (n.blending = this.blending), this.side !== c && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.alphaWrite = this.alphaWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                             const e = i(t.textures),
                                 r = i(t.images);
                             e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                         }
                         return n
                     }
                     clone() {
@@ -3196,30 +3481,30 @@
                             type: "dispose"
                         })
                     }
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                 }
-                dn.prototype.isMaterial = !0;
-                class pn extends dn {
+                bi.prototype.isMaterial = !0;
+                class wi extends bi {
                     constructor(t) {
-                        super(), this.type = "MeshBasicMaterial", this.color = new zt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        super(), this.type = "MeshBasicMaterial", this.color = new Je(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }
-                pn.prototype.isMeshBasicMaterial = !0;
-                const mn = new Zt,
-                    fn = new At;
-                class gn {
+                wi.prototype.isMeshBasicMaterial = !0;
+                const Si = new on,
+                    Ei = new Be;
+                class Ti {
                     constructor(t, e, n) {
                         if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
-                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = ht, this.updateRange = {
+                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = _e, this.updateRange = {
                             offset: 0,
                             count: -1
                         }, this.version = 0
                     }
                     onUploadCallback() {}
                     set needsUpdate(t) {
                         !0 === t && this.version++
@@ -3239,62 +3524,62 @@
                         return this.array.set(t), this
                     }
                     copyColorsArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new zt), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Je), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                         }
                         return this
                     }
                     copyVector2sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new At), e[n++] = r.x, e[n++] = r.y
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Be), e[n++] = r.x, e[n++] = r.y
                         }
                         return this
                     }
                     copyVector3sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Zt), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new on), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                         }
                         return this
                     }
                     copyVector4sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new jt), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new en), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                         }
                         return this
                     }
                     applyMatrix3(t) {
                         if (2 === this.itemSize)
-                            for (let e = 0, n = this.count; e < n; e++) fn.fromBufferAttribute(this, e), fn.applyMatrix3(t), this.setXY(e, fn.x, fn.y);
+                            for (let e = 0, n = this.count; e < n; e++) Ei.fromBufferAttribute(this, e), Ei.applyMatrix3(t), this.setXY(e, Ei.x, Ei.y);
                         else if (3 === this.itemSize)
-                            for (let e = 0, n = this.count; e < n; e++) mn.fromBufferAttribute(this, e), mn.applyMatrix3(t), this.setXYZ(e, mn.x, mn.y, mn.z);
+                            for (let e = 0, n = this.count; e < n; e++) Si.fromBufferAttribute(this, e), Si.applyMatrix3(t), this.setXYZ(e, Si.x, Si.y, Si.z);
                         return this
                     }
                     applyMatrix4(t) {
-                        for (let e = 0, n = this.count; e < n; e++) mn.x = this.getX(e), mn.y = this.getY(e), mn.z = this.getZ(e), mn.applyMatrix4(t), this.setXYZ(e, mn.x, mn.y, mn.z);
+                        for (let e = 0, n = this.count; e < n; e++) Si.x = this.getX(e), Si.y = this.getY(e), Si.z = this.getZ(e), Si.applyMatrix4(t), this.setXYZ(e, Si.x, Si.y, Si.z);
                         return this
                     }
                     applyNormalMatrix(t) {
-                        for (let e = 0, n = this.count; e < n; e++) mn.x = this.getX(e), mn.y = this.getY(e), mn.z = this.getZ(e), mn.applyNormalMatrix(t), this.setXYZ(e, mn.x, mn.y, mn.z);
+                        for (let e = 0, n = this.count; e < n; e++) Si.x = this.getX(e), Si.y = this.getY(e), Si.z = this.getZ(e), Si.applyNormalMatrix(t), this.setXYZ(e, Si.x, Si.y, Si.z);
                         return this
                     }
                     transformDirection(t) {
-                        for (let e = 0, n = this.count; e < n; e++) mn.x = this.getX(e), mn.y = this.getY(e), mn.z = this.getZ(e), mn.transformDirection(t), this.setXYZ(e, mn.x, mn.y, mn.z);
+                        for (let e = 0, n = this.count; e < n; e++) Si.x = this.getX(e), Si.y = this.getY(e), Si.z = this.getZ(e), Si.transformDirection(t), this.setXYZ(e, Si.x, Si.y, Si.z);
                         return this
                     }
                     set(t, e = 0) {
                         return this.array.set(t, e), this
                     }
                     getX(t) {
                         return this.array[t * this.itemSize]
@@ -3338,90 +3623,90 @@
                     toJSON() {
                         const t = {
                             itemSize: this.itemSize,
                             type: this.array.constructor.name,
                             array: Array.prototype.slice.call(this.array),
                             normalized: this.normalized
                         };
-                        return "" !== this.name && (t.name = this.name), this.usage !== ht && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
+                        return "" !== this.name && (t.name = this.name), this.usage !== _e && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
                     }
                 }
-                gn.prototype.isBufferAttribute = !0;
-                class vn extends gn {
+                Ti.prototype.isBufferAttribute = !0;
+                class Ai extends Ti {
                     constructor(t, e, n) {
                         super(new Int8Array(t), e, n)
                     }
                 }
-                class xn extends gn {
+                class Ri extends Ti {
                     constructor(t, e, n) {
                         super(new Uint8Array(t), e, n)
                     }
                 }
-                class yn extends gn {
+                class Li extends Ti {
                     constructor(t, e, n) {
                         super(new Uint8ClampedArray(t), e, n)
                     }
                 }
-                class _n extends gn {
+                class Ci extends Ti {
                     constructor(t, e, n) {
                         super(new Int16Array(t), e, n)
                     }
                 }
-                class Mn extends gn {
+                class Pi extends Ti {
                     constructor(t, e, n) {
                         super(new Uint16Array(t), e, n)
                     }
                 }
-                class bn extends gn {
+                class Di extends Ti {
                     constructor(t, e, n) {
                         super(new Int32Array(t), e, n)
                     }
                 }
-                class wn extends gn {
+                class Ii extends Ti {
                     constructor(t, e, n) {
                         super(new Uint32Array(t), e, n)
                     }
                 }
-                class Sn extends gn {
+                class Ni extends Ti {
                     constructor(t, e, n) {
                         super(new Uint16Array(t), e, n)
                     }
                 }
-                Sn.prototype.isFloat16BufferAttribute = !0;
-                class En extends gn {
+                Ni.prototype.isFloat16BufferAttribute = !0;
+                class Oi extends Ti {
                     constructor(t, e, n) {
                         super(new Float32Array(t), e, n)
                     }
                 }
-                class Tn extends gn {
+                class Ui extends Ti {
                     constructor(t, e, n) {
                         super(new Float64Array(t), e, n)
                     }
                 }
-                let An = 0;
-                const Rn = new Ae,
-                    Ln = new Qe,
-                    Cn = new Zt,
-                    Pn = new $t,
-                    Dn = new $t,
-                    In = new Zt;
-                class Nn extends mt {
+                let Bi = 0;
+                const Fi = new Fn,
+                    zi = new ci,
+                    Hi = new on,
+                    Gi = new hn,
+                    Vi = new hn,
+                    ki = new on;
+                class Wi extends Se {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: An++
-                        }), this.uuid = yt(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
+                            value: Bi++
+                        }), this.uuid = Le(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                             start: 0,
                             count: 1 / 0
                         }, this.userData = {}
                     }
                     getIndex() {
                         return this.index
                     }
                     setIndex(t) {
-                        return Array.isArray(t) ? this.index = new(Lt(t) ? wn : Mn)(t, 1) : this.index = t, this
+                        return Array.isArray(t) ? this.index = new(ze(t) ? Ii : Pi)(t, 1) : this.index = t, this
                     }
                     getAttribute(t) {
                         return this.attributes[t]
                     }
                     setAttribute(t, e) {
                         return this.attributes[t] = e, this
                     }
@@ -3445,112 +3730,112 @@
                         this.drawRange.start = t, this.drawRange.count = e
                     }
                     applyMatrix4(t) {
                         const e = this.attributes.position;
                         void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                         const n = this.attributes.normal;
                         if (void 0 !== n) {
-                            const e = (new Rt).getNormalMatrix(t);
+                            const e = (new Fe).getNormalMatrix(t);
                             n.applyNormalMatrix(e), n.needsUpdate = !0
                         }
                         const i = this.attributes.tangent;
                         return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                     }
                     applyQuaternion(t) {
-                        return Rn.makeRotationFromQuaternion(t), this.applyMatrix4(Rn), this
+                        return Fi.makeRotationFromQuaternion(t), this.applyMatrix4(Fi), this
                     }
                     rotateX(t) {
-                        return Rn.makeRotationX(t), this.applyMatrix4(Rn), this
+                        return Fi.makeRotationX(t), this.applyMatrix4(Fi), this
                     }
                     rotateY(t) {
-                        return Rn.makeRotationY(t), this.applyMatrix4(Rn), this
+                        return Fi.makeRotationY(t), this.applyMatrix4(Fi), this
                     }
                     rotateZ(t) {
-                        return Rn.makeRotationZ(t), this.applyMatrix4(Rn), this
+                        return Fi.makeRotationZ(t), this.applyMatrix4(Fi), this
                     }
                     translate(t, e, n) {
-                        return Rn.makeTranslation(t, e, n), this.applyMatrix4(Rn), this
+                        return Fi.makeTranslation(t, e, n), this.applyMatrix4(Fi), this
                     }
                     scale(t, e, n) {
-                        return Rn.makeScale(t, e, n), this.applyMatrix4(Rn), this
+                        return Fi.makeScale(t, e, n), this.applyMatrix4(Fi), this
                     }
                     lookAt(t) {
-                        return Ln.lookAt(t), Ln.updateMatrix(), this.applyMatrix4(Ln.matrix), this
+                        return zi.lookAt(t), zi.updateMatrix(), this.applyMatrix4(zi.matrix), this
                     }
                     center() {
-                        return this.computeBoundingBox(), this.boundingBox.getCenter(Cn).negate(), this.translate(Cn.x, Cn.y, Cn.z), this
+                        return this.computeBoundingBox(), this.boundingBox.getCenter(Hi).negate(), this.translate(Hi.x, Hi.y, Hi.z), this
                     }
                     setFromPoints(t) {
                         const e = [];
                         for (let n = 0, i = t.length; n < i; n++) {
                             const i = t[n];
                             e.push(i.x, i.y, i.z || 0)
                         }
-                        return this.setAttribute("position", new En(e, 3)), this
+                        return this.setAttribute("position", new Oi(e, 3)), this
                     }
                     computeBoundingBox() {
-                        null === this.boundingBox && (this.boundingBox = new $t);
+                        null === this.boundingBox && (this.boundingBox = new hn);
                         const t = this.attributes.position,
                             e = this.morphAttributes.position;
-                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Zt(-1 / 0, -1 / 0, -1 / 0), new Zt(1 / 0, 1 / 0, 1 / 0));
+                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new on(-1 / 0, -1 / 0, -1 / 0), new on(1 / 0, 1 / 0, 1 / 0));
                         if (void 0 !== t) {
                             if (this.boundingBox.setFromBufferAttribute(t), e)
                                 for (let t = 0, n = e.length; t < n; t++) {
                                     const n = e[t];
-                                    Pn.setFromBufferAttribute(n), this.morphTargetsRelative ? (In.addVectors(this.boundingBox.min, Pn.min), this.boundingBox.expandByPoint(In), In.addVectors(this.boundingBox.max, Pn.max), this.boundingBox.expandByPoint(In)) : (this.boundingBox.expandByPoint(Pn.min), this.boundingBox.expandByPoint(Pn.max))
+                                    Gi.setFromBufferAttribute(n), this.morphTargetsRelative ? (ki.addVectors(this.boundingBox.min, Gi.min), this.boundingBox.expandByPoint(ki), ki.addVectors(this.boundingBox.max, Gi.max), this.boundingBox.expandByPoint(ki)) : (this.boundingBox.expandByPoint(Gi.min), this.boundingBox.expandByPoint(Gi.max))
                                 }
                         } else this.boundingBox.makeEmpty();
                         (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                     }
                     computeBoundingSphere() {
-                        null === this.boundingSphere && (this.boundingSphere = new xe);
+                        null === this.boundingSphere && (this.boundingSphere = new Ln);
                         const t = this.attributes.position,
                             e = this.morphAttributes.position;
-                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Zt, 1 / 0);
+                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new on, 1 / 0);
                         if (t) {
                             const n = this.boundingSphere.center;
-                            if (Pn.setFromBufferAttribute(t), e)
+                            if (Gi.setFromBufferAttribute(t), e)
                                 for (let t = 0, n = e.length; t < n; t++) {
                                     const n = e[t];
-                                    Dn.setFromBufferAttribute(n), this.morphTargetsRelative ? (In.addVectors(Pn.min, Dn.min), Pn.expandByPoint(In), In.addVectors(Pn.max, Dn.max), Pn.expandByPoint(In)) : (Pn.expandByPoint(Dn.min), Pn.expandByPoint(Dn.max))
+                                    Vi.setFromBufferAttribute(n), this.morphTargetsRelative ? (ki.addVectors(Gi.min, Vi.min), Gi.expandByPoint(ki), ki.addVectors(Gi.max, Vi.max), Gi.expandByPoint(ki)) : (Gi.expandByPoint(Vi.min), Gi.expandByPoint(Vi.max))
                                 }
-                            Pn.getCenter(n);
+                            Gi.getCenter(n);
                             let i = 0;
-                            for (let e = 0, r = t.count; e < r; e++) In.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(In));
+                            for (let e = 0, r = t.count; e < r; e++) ki.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(ki));
                             if (e)
                                 for (let r = 0, s = e.length; r < s; r++) {
                                     const s = e[r],
                                         a = this.morphTargetsRelative;
-                                    for (let e = 0, r = s.count; e < r; e++) In.fromBufferAttribute(s, e), a && (Cn.fromBufferAttribute(t, e), In.add(Cn)), i = Math.max(i, n.distanceToSquared(In))
+                                    for (let e = 0, r = s.count; e < r; e++) ki.fromBufferAttribute(s, e), a && (Hi.fromBufferAttribute(t, e), ki.add(Hi)), i = Math.max(i, n.distanceToSquared(ki))
                                 }
                             this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                         }
                     }
                     computeTangents() {
                         const t = this.index,
                             e = this.attributes;
                         if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                         const n = t.array,
                             i = e.position.array,
                             r = e.normal.array,
                             s = e.uv.array,
                             a = i.length / 3;
-                        void 0 === e.tangent && this.setAttribute("tangent", new gn(new Float32Array(4 * a), 4));
+                        void 0 === e.tangent && this.setAttribute("tangent", new Ti(new Float32Array(4 * a), 4));
                         const o = e.tangent.array,
                             l = [],
                             c = [];
-                        for (let t = 0; t < a; t++) l[t] = new Zt, c[t] = new Zt;
-                        const h = new Zt,
-                            u = new Zt,
-                            d = new Zt,
-                            p = new At,
-                            m = new At,
-                            f = new At,
-                            g = new Zt,
-                            v = new Zt;
+                        for (let t = 0; t < a; t++) l[t] = new on, c[t] = new on;
+                        const h = new on,
+                            u = new on,
+                            d = new on,
+                            p = new Be,
+                            m = new Be,
+                            f = new Be,
+                            g = new on,
+                            v = new on;
 
                         function x(t, e, n) {
                             h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * n), u.sub(h), d.sub(h), m.sub(p), f.sub(p);
                             const r = 1 / (m.x * f.y - f.x * m.y);
                             isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                         }
                         let y = this.groups;
@@ -3559,18 +3844,18 @@
                             count: n.length
                         }]);
                         for (let t = 0, e = y.length; t < e; ++t) {
                             const e = y[t],
                                 i = e.start;
                             for (let t = i, r = i + e.count; t < r; t += 3) x(n[t + 0], n[t + 1], n[t + 2])
                         }
-                        const _ = new Zt,
-                            M = new Zt,
-                            b = new Zt,
-                            w = new Zt;
+                        const _ = new on,
+                            M = new on,
+                            b = new on,
+                            w = new on;
 
                         function S(t) {
                             b.fromArray(r, 3 * t), w.copy(b);
                             const e = l[t];
                             _.copy(e), _.sub(b.multiplyScalar(b.dot(e))).normalize(), M.crossVectors(w, e);
                             const n = M.dot(c[t]) < 0 ? -1 : 1;
                             o[4 * t] = _.x, o[4 * t + 1] = _.y, o[4 * t + 2] = _.z, o[4 * t + 3] = n
@@ -3582,25 +3867,25 @@
                         }
                     }
                     computeVertexNormals() {
                         const t = this.index,
                             e = this.getAttribute("position");
                         if (void 0 !== e) {
                             let n = this.getAttribute("normal");
-                            if (void 0 === n) n = new gn(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
+                            if (void 0 === n) n = new Ti(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                             else
                                 for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
-                            const i = new Zt,
-                                r = new Zt,
-                                s = new Zt,
-                                a = new Zt,
-                                o = new Zt,
-                                l = new Zt,
-                                c = new Zt,
-                                h = new Zt;
+                            const i = new on,
+                                r = new on,
+                                s = new on,
+                                a = new on,
+                                o = new on,
+                                l = new on,
+                                c = new on,
+                                h = new on;
                             if (t)
                                 for (let u = 0, d = t.count; u < d; u += 3) {
                                     const d = t.getX(u + 0),
                                         p = t.getX(u + 1),
                                         m = t.getX(u + 2);
                                     i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(m, l.x, l.y, l.z)
                                 } else
@@ -3621,32 +3906,32 @@
                                 l = Math.min(a.length, r.length - o);
                             for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t]
                         }
                         return this
                     }
                     normalizeNormals() {
                         const t = this.attributes.normal;
-                        for (let e = 0, n = t.count; e < n; e++) In.fromBufferAttribute(t, e), In.normalize(), t.setXYZ(e, In.x, In.y, In.z)
+                        for (let e = 0, n = t.count; e < n; e++) ki.fromBufferAttribute(t, e), ki.normalize(), t.setXYZ(e, ki.x, ki.y, ki.z)
                     }
                     toNonIndexed() {
                         function t(t, e) {
                             const n = t.array,
                                 i = t.itemSize,
                                 r = t.normalized,
                                 s = new n.constructor(e.length * i);
                             let a = 0,
                                 o = 0;
                             for (let r = 0, l = e.length; r < l; r++) {
                                 a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                                 for (let t = 0; t < i; t++) s[o++] = n[a++]
                             }
-                            return new gn(s, i, r)
+                            return new Ti(s, i, r)
                         }
                         if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
-                        const e = new Nn,
+                        const e = new Wi,
                             n = this.index.array,
                             i = this.attributes;
                         for (const r in i) {
                             const s = t(i[r], n);
                             e.setAttribute(r, s)
                         }
                         const r = this.morphAttributes;
@@ -3747,34 +4032,34 @@
                     }
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }
-                Nn.prototype.isBufferGeometry = !0;
-                const On = new Ae,
-                    Un = new Te,
-                    Bn = new xe,
-                    Fn = new Zt,
-                    zn = new Zt,
-                    Hn = new Zt,
-                    Gn = new Zt,
-                    Vn = new Zt,
-                    kn = new Zt,
-                    Wn = new Zt,
-                    jn = new Zt,
-                    Xn = new Zt,
-                    qn = new At,
-                    Yn = new At,
-                    Jn = new At,
-                    Zn = new Zt,
-                    Kn = new Zt;
-                class Qn extends Qe {
-                    constructor(t = new Nn, e = new pn) {
+                Wi.prototype.isBufferGeometry = !0;
+                const ji = new Fn,
+                    Xi = new Bn,
+                    qi = new Ln,
+                    Yi = new on,
+                    Ji = new on,
+                    Zi = new on,
+                    Ki = new on,
+                    Qi = new on,
+                    $i = new on,
+                    tr = new on,
+                    er = new on,
+                    nr = new on,
+                    ir = new Be,
+                    rr = new Be,
+                    sr = new Be,
+                    ar = new on,
+                    or = new on;
+                class lr extends ci {
+                    constructor(t = new Wi, e = new wi) {
                         super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                     }
                     updateMorphTargets() {
                         const t = this.geometry;
@@ -3797,16 +4082,16 @@
                         }
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.material,
                             r = this.matrixWorld;
                         if (void 0 === i) return;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), Bn.copy(n.boundingSphere), Bn.applyMatrix4(r), !1 === t.ray.intersectsSphere(Bn)) return;
-                        if (On.copy(r).invert(), Un.copy(t.ray).applyMatrix4(On), null !== n.boundingBox && !1 === Un.intersectsBox(n.boundingBox)) return;
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), qi.copy(n.boundingSphere), qi.applyMatrix4(r), !1 === t.ray.intersectsSphere(qi)) return;
+                        if (ji.copy(r).invert(), Xi.copy(t.ray).applyMatrix4(ji), null !== n.boundingBox && !1 === Xi.intersectsBox(n.boundingBox)) return;
                         let s;
                         if (n.isBufferGeometry) {
                             const r = n.index,
                                 a = n.attributes.position,
                                 o = n.morphAttributes.position,
                                 l = n.morphTargetsRelative,
                                 c = n.attributes.uv,
@@ -3818,73 +4103,73 @@
                                     for (let n = 0, p = u.length; n < p; n++) {
                                         const p = u[n],
                                             m = i[p.materialIndex];
                                         for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                                             const i = r.getX(n),
                                                 u = r.getX(n + 1),
                                                 d = r.getX(n + 2);
-                                            s = $n(this, m, t, Un, a, o, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
+                                            s = cr(this, m, t, Xi, a, o, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                         }
                                     } else
                                         for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                                             const u = r.getX(n),
                                                 d = r.getX(n + 1),
                                                 p = r.getX(n + 2);
-                                            s = $n(this, i, t, Un, a, o, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
+                                            s = cr(this, i, t, Xi, a, o, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                         } else if (void 0 !== a)
                                             if (Array.isArray(i))
                                                 for (let n = 0, r = u.length; n < r; n++) {
                                                     const r = u[n],
                                                         p = i[r.materialIndex];
-                                                    for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) s = $n(this, p, t, Un, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
+                                                    for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) s = cr(this, p, t, Xi, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                                 } else
-                                                    for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) s = $n(this, i, t, Un, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
+                                                    for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) s = cr(this, i, t, Xi, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                         } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                     }
                 }
 
-                function $n(t, e, n, i, r, s, a, o, l, c, h, u) {
-                    Fn.fromBufferAttribute(r, c), zn.fromBufferAttribute(r, h), Hn.fromBufferAttribute(r, u);
-                    const d = t.morphTargetInfluences;
-                    if (s && d) {
-                        Wn.set(0, 0, 0), jn.set(0, 0, 0), Xn.set(0, 0, 0);
+                function cr(t, e, n, i, r, s, a, o, l, c, d, p) {
+                    Yi.fromBufferAttribute(r, c), Ji.fromBufferAttribute(r, d), Zi.fromBufferAttribute(r, p);
+                    const m = t.morphTargetInfluences;
+                    if (s && m) {
+                        tr.set(0, 0, 0), er.set(0, 0, 0), nr.set(0, 0, 0);
                         for (let t = 0, e = s.length; t < e; t++) {
-                            const e = d[t],
+                            const e = m[t],
                                 n = s[t];
-                            0 !== e && (Gn.fromBufferAttribute(n, c), Vn.fromBufferAttribute(n, h), kn.fromBufferAttribute(n, u), a ? (Wn.addScaledVector(Gn, e), jn.addScaledVector(Vn, e), Xn.addScaledVector(kn, e)) : (Wn.addScaledVector(Gn.sub(Fn), e), jn.addScaledVector(Vn.sub(zn), e), Xn.addScaledVector(kn.sub(Hn), e)))
+                            0 !== e && (Ki.fromBufferAttribute(n, c), Qi.fromBufferAttribute(n, d), $i.fromBufferAttribute(n, p), a ? (tr.addScaledVector(Ki, e), er.addScaledVector(Qi, e), nr.addScaledVector($i, e)) : (tr.addScaledVector(Ki.sub(Yi), e), er.addScaledVector(Qi.sub(Ji), e), nr.addScaledVector($i.sub(Zi), e)))
                         }
-                        Fn.add(Wn), zn.add(jn), Hn.add(Xn)
+                        Yi.add(tr), Ji.add(er), Zi.add(nr)
                     }
-                    t.isSkinnedMesh && (t.boneTransform(c, Fn), t.boneTransform(h, zn), t.boneTransform(u, Hn));
-                    const p = function(t, e, n, i, r, s, a, o) {
+                    t.isSkinnedMesh && (t.boneTransform(c, Yi), t.boneTransform(d, Ji), t.boneTransform(p, Zi));
+                    const f = function(t, e, n, i, r, s, a, o) {
                         let l;
-                        if (l = 1 === e.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, 2 !== e.side, o), null === l) return null;
-                        Kn.copy(o), Kn.applyMatrix4(t.matrixWorld);
-                        const c = n.ray.origin.distanceTo(Kn);
+                        if (l = e.side === h ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, e.side !== u, o), null === l) return null;
+                        or.copy(o), or.applyMatrix4(t.matrixWorld);
+                        const c = n.ray.origin.distanceTo(or);
                         return c < n.near || c > n.far ? null : {
                             distance: c,
-                            point: Kn.clone(),
+                            point: or.clone(),
                             object: t
                         }
-                    }(t, e, n, i, Fn, zn, Hn, Zn);
-                    if (p) {
-                        o && (qn.fromBufferAttribute(o, c), Yn.fromBufferAttribute(o, h), Jn.fromBufferAttribute(o, u), p.uv = hn.getUV(Zn, Fn, zn, Hn, qn, Yn, Jn, new At)), l && (qn.fromBufferAttribute(l, c), Yn.fromBufferAttribute(l, h), Jn.fromBufferAttribute(l, u), p.uv2 = hn.getUV(Zn, Fn, zn, Hn, qn, Yn, Jn, new At));
+                    }(t, e, n, i, Yi, Ji, Zi, ar);
+                    if (f) {
+                        o && (ir.fromBufferAttribute(o, c), rr.fromBufferAttribute(o, d), sr.fromBufferAttribute(o, p), f.uv = _i.getUV(ar, Yi, Ji, Zi, ir, rr, sr, new Be)), l && (ir.fromBufferAttribute(l, c), rr.fromBufferAttribute(l, d), sr.fromBufferAttribute(l, p), f.uv2 = _i.getUV(ar, Yi, Ji, Zi, ir, rr, sr, new Be));
                         const t = {
                             a: c,
-                            b: h,
-                            c: u,
-                            normal: new Zt,
+                            b: d,
+                            c: p,
+                            normal: new on,
                             materialIndex: 0
                         };
-                        hn.getNormal(Fn, zn, Hn, t.normal), p.face = t
+                        _i.getNormal(Yi, Ji, Zi, t.normal), f.face = t
                     }
-                    return p
+                    return f
                 }
-                Qn.prototype.isMesh = !0;
-                class ti extends Nn {
+                lr.prototype.isMesh = !0;
+                class hr extends Wi {
                     constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                         super(), this.type = "BoxGeometry", this.parameters = {
                             width: t,
                             height: e,
                             depth: n,
                             widthSegments: i,
                             heightSegments: r,
@@ -3905,15 +4190,15 @@
                                 _ = s / 2,
                                 M = p / 2,
                                 b = m / 2,
                                 w = f + 1,
                                 S = g + 1;
                             let E = 0,
                                 T = 0;
-                            const A = new Zt;
+                            const A = new on;
                             for (let s = 0; s < S; s++) {
                                 const a = s * y - M;
                                 for (let o = 0; o < w; o++) {
                                     const u = o * x - _;
                                     A[t] = u * i, A[e] = a * r, A[n] = b, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(o / f), h.push(1 - s / g), E += 1
                                 }
                             }
@@ -3923,60 +4208,60 @@
                                         i = u + e + w * (t + 1),
                                         r = u + (e + 1) + w * (t + 1),
                                         s = u + (e + 1) + w * t;
                                     o.push(n, i, s), o.push(i, r, s), T += 6
                                 }
                             a.addGroup(d, T, v), d += T, u += E
                         }
-                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new En(l, 3)), this.setAttribute("normal", new En(c, 3)), this.setAttribute("uv", new En(h, 2))
+                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Oi(l, 3)), this.setAttribute("normal", new Oi(c, 3)), this.setAttribute("uv", new Oi(h, 2))
                     }
                     static fromJSON(t) {
-                        return new ti(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
+                        return new hr(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
                     }
                 }
 
-                function ei(t) {
+                function ur(t) {
                     const e = {};
                     for (const n in t) {
                         e[n] = {};
                         for (const i in t[n]) {
                             const r = t[n][i];
                             r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                         }
                     }
                     return e
                 }
 
-                function ni(t) {
+                function dr(t) {
                     const e = {};
                     for (let n = 0; n < t.length; n++) {
-                        const i = ei(t[n]);
+                        const i = ur(t[n]);
                         for (const t in i) e[t] = i[t]
                     }
                     return e
                 }
-                const ii = {
-                    clone: ei,
-                    merge: ni
+                const pr = {
+                    clone: ur,
+                    merge: dr
                 };
-                class ri extends dn {
+                class mr extends bi {
                     constructor(t) {
                         super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                             derivatives: !1,
                             fragDepth: !1,
                             drawBuffers: !1,
                             shaderTextureLOD: !1
                         }, this.defaultAttributeValues = {
                             color: [1, 1, 1],
                             uv: [0, 0],
                             uv2: [0, 0]
                         }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
                     }
                     copy(t) {
-                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = ei(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
+                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = ur(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         e.glslVersion = this.glslVersion, e.uniforms = {};
                         for (const n in this.uniforms) {
                             const i = this.uniforms[n].value;
                             i && i.isTexture ? e.uniforms[n] = {
@@ -4006,18 +4291,18 @@
                         }
                         Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                         const n = {};
                         for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                         return Object.keys(n).length > 0 && (e.extensions = n), e
                     }
                 }
-                ri.prototype.isShaderMaterial = !0;
-                class si extends Qe {
+                mr.prototype.isShaderMaterial = !0;
+                class fr extends ci {
                     constructor() {
-                        super(), this.type = "Camera", this.matrixWorldInverse = new Ae, this.projectionMatrix = new Ae, this.projectionMatrixInverse = new Ae
+                        super(), this.type = "Camera", this.matrixWorldInverse = new Fn, this.projectionMatrix = new Fn, this.projectionMatrixInverse = new Fn
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                     }
                     getWorldDirection(t) {
                         this.updateWorldMatrix(!0, !1);
                         const e = this.matrixWorld.elements;
@@ -4029,32 +4314,32 @@
                     updateWorldMatrix(t, e) {
                         super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                si.prototype.isCamera = !0;
-                class ai extends si {
+                fr.prototype.isCamera = !0;
+                class gr extends fr {
                     constructor(t = 50, e = 1, n = .1, i = 2e3) {
                         super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                     }
                     setFocalLength(t) {
                         const e = .5 * this.getFilmHeight() / t;
-                        this.fov = 2 * xt * Math.atan(e), this.updateProjectionMatrix()
+                        this.fov = 2 * Re * Math.atan(e), this.updateProjectionMatrix()
                     }
                     getFocalLength() {
-                        const t = Math.tan(.5 * vt * this.fov);
+                        const t = Math.tan(.5 * Ae * this.fov);
                         return .5 * this.getFilmHeight() / t
                     }
                     getEffectiveFOV() {
-                        return 2 * xt * Math.atan(Math.tan(.5 * vt * this.fov) / this.zoom)
+                        return 2 * Re * Math.atan(Math.tan(.5 * Ae * this.fov) / this.zoom)
                     }
                     getFilmWidth() {
                         return this.filmGauge * Math.min(this.aspect, 1)
                     }
                     getFilmHeight() {
                         return this.filmGauge / Math.max(this.aspect, 1)
                     }
@@ -4070,15 +4355,15 @@
                         }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                     }
                     clearViewOffset() {
                         null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                     }
                     updateProjectionMatrix() {
                         const t = this.near;
-                        let e = t * Math.tan(.5 * vt * this.fov) / this.zoom,
+                        let e = t * Math.tan(.5 * Ae * this.fov) / this.zoom,
                             n = 2 * e,
                             i = this.aspect * n,
                             r = -.5 * i;
                         const s = this.view;
                         if (null !== this.view && this.view.enabled) {
                             const t = s.fullWidth,
                                 a = s.fullHeight;
@@ -4088,108 +4373,108 @@
                         0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                     }
                 }
-                ai.prototype.isPerspectiveCamera = !0;
-                const oi = 90;
-                class li extends Qe {
+                gr.prototype.isPerspectiveCamera = !0;
+                const vr = 90;
+                class xr extends ci {
                     constructor(t, e, n) {
                         if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                         this.renderTarget = n;
-                        const i = new ai(oi, 1, t, e);
-                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Zt(1, 0, 0)), this.add(i);
-                        const r = new ai(oi, 1, t, e);
-                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Zt(-1, 0, 0)), this.add(r);
-                        const s = new ai(oi, 1, t, e);
-                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Zt(0, 1, 0)), this.add(s);
-                        const a = new ai(oi, 1, t, e);
-                        a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new Zt(0, -1, 0)), this.add(a);
-                        const o = new ai(oi, 1, t, e);
-                        o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Zt(0, 0, 1)), this.add(o);
-                        const l = new ai(oi, 1, t, e);
-                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Zt(0, 0, -1)), this.add(l)
+                        const i = new gr(vr, 1, t, e);
+                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new on(1, 0, 0)), this.add(i);
+                        const r = new gr(vr, 1, t, e);
+                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new on(-1, 0, 0)), this.add(r);
+                        const s = new gr(vr, 1, t, e);
+                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new on(0, 1, 0)), this.add(s);
+                        const a = new gr(vr, 1, t, e);
+                        a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new on(0, -1, 0)), this.add(a);
+                        const o = new gr(vr, 1, t, e);
+                        o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new on(0, 0, 1)), this.add(o);
+                        const l = new gr(vr, 1, t, e);
+                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new on(0, 0, -1)), this.add(l)
                     }
                     update(t, e) {
                         null === this.parent && this.updateMatrixWorld();
                         const n = this.renderTarget,
                             [i, r, s, a, o, l] = this.children,
                             c = t.xr.enabled,
                             h = t.getRenderTarget();
                         t.xr.enabled = !1;
                         const u = n.texture.generateMipmaps;
                         n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, a), t.setRenderTarget(n, 4), t.render(e, o), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c, n.texture.needsPMREMUpdate = !0
                     }
                 }
-                class ci extends kt {
-                    constructor(t, e, n, i, r, a, o, l, c, h) {
-                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : s, n, i, r, a, o, l, c, h), this.flipY = !1
+                class yr extends $e {
+                    constructor(t, e, n, i, r, s, a, o, l, c) {
+                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : Q, n, i, r, s, a, o, l, c), this.flipY = !1
                     }
                     get images() {
                         return this.image
                     }
                     set images(t) {
                         this.image = t
                     }
                 }
-                ci.prototype.isCubeTexture = !0;
-                class hi extends Xt {
+                yr.prototype.isCubeTexture = !0;
+                class _r extends nn {
                     constructor(t, e, n) {
-                        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new ci(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : v
+                        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new yr(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : ht
                     }
                     fromEquirectangularTexture(t, e) {
-                        this.texture.type = e.type, this.texture.format = T, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
+                        this.texture.type = e.type, this.texture.format = Et, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                         const n = {
                                 tEquirect: {
                                     value: null
                                 }
                             },
                             i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                             r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
-                            s = new ti(5, 5, 5),
-                            a = new ri({
+                            s = new hr(5, 5, 5),
+                            a = new mr({
                                 name: "CubemapFromEquirect",
-                                uniforms: ei(n),
+                                uniforms: ur(n),
                                 vertexShader: i,
                                 fragmentShader: r,
-                                side: 1,
-                                blending: 0
+                                side: h,
+                                blending: d
                             });
                         a.uniforms.tEquirect.value = e;
-                        const o = new Qn(s, a),
+                        const o = new lr(s, a),
                             l = e.minFilter;
-                        return e.minFilter === y && (e.minFilter = v), new li(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
+                        return e.minFilter === dt && (e.minFilter = ht), new xr(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
                     }
                     clear(t, e, n, i) {
                         const r = t.getRenderTarget();
                         for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                         t.setRenderTarget(r)
                     }
                 }
-                hi.prototype.isWebGLCubeRenderTarget = !0;
-                const ui = new Zt,
-                    di = new Zt,
-                    pi = new Rt;
-                class mi {
-                    constructor(t = new Zt(1, 0, 0), e = 0) {
+                _r.prototype.isWebGLCubeRenderTarget = !0;
+                const Mr = new on,
+                    br = new on,
+                    wr = new Fe;
+                class Sr {
+                    constructor(t = new on(1, 0, 0), e = 0) {
                         this.normal = t, this.constant = e
                     }
                     set(t, e) {
                         return this.normal.copy(t), this.constant = e, this
                     }
                     setComponents(t, e, n, i) {
                         return this.normal.set(t, e, n), this.constant = i, this
                     }
                     setFromNormalAndCoplanarPoint(t, e) {
                         return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                     }
                     setFromCoplanarPoints(t, e, n) {
-                        const i = ui.subVectors(n, e).cross(di.subVectors(t, e)).normalize();
+                        const i = Mr.subVectors(n, e).cross(br.subVectors(t, e)).normalize();
                         return this.setFromNormalAndCoplanarPoint(i, t), this
                     }
                     copy(t) {
                         return this.normal.copy(t.normal), this.constant = t.constant, this
                     }
                     normalize() {
                         const t = 1 / this.normal.length();
@@ -4204,15 +4489,15 @@
                     distanceToSphere(t) {
                         return this.distanceToPoint(t.center) - t.radius
                     }
                     projectPoint(t, e) {
                         return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                     }
                     intersectLine(t, e) {
-                        const n = t.delta(ui),
+                        const n = t.delta(Mr),
                             i = this.normal.dot(n);
                         if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                         const r = -(t.start.dot(this.normal) + this.constant) / i;
                         return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
                     }
                     intersectsLine(t) {
                         const e = this.distanceToPoint(t.start),
@@ -4225,34 +4510,34 @@
                     intersectsSphere(t) {
                         return t.intersectsPlane(this)
                     }
                     coplanarPoint(t) {
                         return t.copy(this.normal).multiplyScalar(-this.constant)
                     }
                     applyMatrix4(t, e) {
-                        const n = e || pi.getNormalMatrix(t),
-                            i = this.coplanarPoint(ui).applyMatrix4(t),
+                        const n = e || wr.getNormalMatrix(t),
+                            i = this.coplanarPoint(Mr).applyMatrix4(t),
                             r = this.normal.applyMatrix3(n).normalize();
                         return this.constant = -i.dot(r), this
                     }
                     translate(t) {
                         return this.constant -= t.dot(this.normal), this
                     }
                     equals(t) {
                         return t.normal.equals(this.normal) && t.constant === this.constant
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                mi.prototype.isPlane = !0;
-                const fi = new xe,
-                    gi = new Zt;
-                class vi {
-                    constructor(t = new mi, e = new mi, n = new mi, i = new mi, r = new mi, s = new mi) {
+                Sr.prototype.isPlane = !0;
+                const Er = new Ln,
+                    Tr = new on;
+                class Ar {
+                    constructor(t = new Sr, e = new Sr, n = new Sr, i = new Sr, r = new Sr, s = new Sr) {
                         this.planes = [t, e, n, i, r, s]
                     }
                     set(t, e, n, i, r, s) {
                         const a = this.planes;
                         return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this
                     }
                     copy(t) {
@@ -4279,47 +4564,47 @@
                             g = n[13],
                             v = n[14],
                             x = n[15];
                         return e[0].setComponents(a - i, h - o, m - u, x - f).normalize(), e[1].setComponents(a + i, h + o, m + u, x + f).normalize(), e[2].setComponents(a + r, h + l, m + d, x + g).normalize(), e[3].setComponents(a - r, h - l, m - d, x - g).normalize(), e[4].setComponents(a - s, h - c, m - p, x - v).normalize(), e[5].setComponents(a + s, h + c, m + p, x + v).normalize(), this
                     }
                     intersectsObject(t) {
                         const e = t.geometry;
-                        return null === e.boundingSphere && e.computeBoundingSphere(), fi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(fi)
+                        return null === e.boundingSphere && e.computeBoundingSphere(), Er.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Er)
                     }
                     intersectsSprite(t) {
-                        return fi.center.set(0, 0, 0), fi.radius = .7071067811865476, fi.applyMatrix4(t.matrixWorld), this.intersectsSphere(fi)
+                        return Er.center.set(0, 0, 0), Er.radius = .7071067811865476, Er.applyMatrix4(t.matrixWorld), this.intersectsSphere(Er)
                     }
                     intersectsSphere(t) {
                         const e = this.planes,
                             n = t.center,
                             i = -t.radius;
                         for (let t = 0; t < 6; t++)
                             if (e[t].distanceToPoint(n) < i) return !1;
                         return !0
                     }
                     intersectsBox(t) {
                         const e = this.planes;
                         for (let n = 0; n < 6; n++) {
                             const i = e[n];
-                            if (gi.x = i.normal.x > 0 ? t.max.x : t.min.x, gi.y = i.normal.y > 0 ? t.max.y : t.min.y, gi.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(gi) < 0) return !1
+                            if (Tr.x = i.normal.x > 0 ? t.max.x : t.min.x, Tr.y = i.normal.y > 0 ? t.max.y : t.min.y, Tr.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Tr) < 0) return !1
                         }
                         return !0
                     }
                     containsPoint(t) {
                         const e = this.planes;
                         for (let n = 0; n < 6; n++)
                             if (e[n].distanceToPoint(t) < 0) return !1;
                         return !0
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
 
-                function xi() {
+                function Rr() {
                     let t = null,
                         e = !1,
                         n = null,
                         i = null;
 
                     function r(e, s) {
                         n(e, s), i = t.requestAnimationFrame(r)
@@ -4336,15 +4621,15 @@
                         },
                         setContext: function(e) {
                             t = e
                         }
                     }
                 }
 
-                function yi(t, e) {
+                function Lr(t, e) {
                     const n = e.isWebGL2,
                         i = new WeakMap;
                     return {
                         get: function(t) {
                             return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                         },
                         remove: function(e) {
@@ -4380,15 +4665,15 @@
                                 const s = i.array,
                                     a = i.updateRange;
                                 t.bindBuffer(r, e), -1 === a.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1)
                             }(s.buffer, e, r), s.version = e.version)
                         }
                     }
                 }
-                class _i extends Nn {
+                class Cr extends Wi {
                     constructor(t = 1, e = 1, n = 1, i = 1) {
                         super(), this.type = "PlaneGeometry", this.parameters = {
                             width: t,
                             height: e,
                             widthSegments: n,
                             heightSegments: i
                         };
@@ -4415,21 +4700,21 @@
                             for (let e = 0; e < a; e++) {
                                 const n = e + l * t,
                                     i = e + l * (t + 1),
                                     r = e + 1 + l * (t + 1),
                                     s = e + 1 + l * t;
                                 d.push(n, i, s), d.push(i, r, s)
                             }
-                        this.setIndex(d), this.setAttribute("position", new En(p, 3)), this.setAttribute("normal", new En(m, 3)), this.setAttribute("uv", new En(f, 2))
+                        this.setIndex(d), this.setAttribute("position", new Oi(p, 3)), this.setAttribute("normal", new Oi(m, 3)), this.setAttribute("uv", new Oi(f, 2))
                     }
                     static fromJSON(t) {
-                        return new _i(t.width, t.height, t.widthSegments, t.heightSegments)
+                        return new Cr(t.width, t.height, t.widthSegments, t.heightSegments)
                     }
                 }
-                const Mi = {
+                const Pr = {
                         alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                         alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                         alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                         alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                         aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                         aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                         begin_vertex: "vec3 transformed = vec3( position );",
@@ -4557,30 +4842,30 @@
                         points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                         points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                         shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                         shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                         sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                         sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
                     },
-                    bi = {
+                    Dr = {
                         common: {
                             diffuse: {
-                                value: new zt(16777215)
+                                value: new Je(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             map: {
                                 value: null
                             },
                             uvTransform: {
-                                value: new Rt
+                                value: new Fe
                             },
                             uv2Transform: {
-                                value: new Rt
+                                value: new Fe
                             },
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             }
@@ -4637,15 +4922,15 @@
                             }
                         },
                         normalmap: {
                             normalMap: {
                                 value: null
                             },
                             normalScale: {
-                                value: new At(1, 1)
+                                value: new Be(1, 1)
                             }
                         },
                         displacementmap: {
                             displacementMap: {
                                 value: null
                             },
                             displacementScale: {
@@ -4677,15 +4962,15 @@
                             fogNear: {
                                 value: 1
                             },
                             fogFar: {
                                 value: 2e3
                             },
                             fogColor: {
-                                value: new zt(16777215)
+                                value: new Je(16777215)
                             }
                         },
                         lights: {
                             ambientLightColor: {
                                 value: []
                             },
                             lightProbe: {
@@ -4788,15 +5073,15 @@
                             },
                             ltc_2: {
                                 value: null
                             }
                         },
                         points: {
                             diffuse: {
-                                value: new zt(16777215)
+                                value: new Je(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             size: {
                                 value: 1
                             },
@@ -4809,271 +5094,271 @@
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             },
                             uvTransform: {
-                                value: new Rt
+                                value: new Fe
                             }
                         },
                         sprite: {
                             diffuse: {
-                                value: new zt(16777215)
+                                value: new Je(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             center: {
-                                value: new At(.5, .5)
+                                value: new Be(.5, .5)
                             },
                             rotation: {
                                 value: 0
                             },
                             map: {
                                 value: null
                             },
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             },
                             uvTransform: {
-                                value: new Rt
+                                value: new Fe
                             }
                         }
                     },
-                    wi = {
+                    Ir = {
                         basic: {
-                            uniforms: ni([bi.common, bi.specularmap, bi.envmap, bi.aomap, bi.lightmap, bi.fog]),
-                            vertexShader: Mi.meshbasic_vert,
-                            fragmentShader: Mi.meshbasic_frag
+                            uniforms: dr([Dr.common, Dr.specularmap, Dr.envmap, Dr.aomap, Dr.lightmap, Dr.fog]),
+                            vertexShader: Pr.meshbasic_vert,
+                            fragmentShader: Pr.meshbasic_frag
                         },
                         lambert: {
-                            uniforms: ni([bi.common, bi.specularmap, bi.envmap, bi.aomap, bi.lightmap, bi.emissivemap, bi.fog, bi.lights, {
+                            uniforms: dr([Dr.common, Dr.specularmap, Dr.envmap, Dr.aomap, Dr.lightmap, Dr.emissivemap, Dr.fog, Dr.lights, {
                                 emissive: {
-                                    value: new zt(0)
+                                    value: new Je(0)
                                 }
                             }]),
-                            vertexShader: Mi.meshlambert_vert,
-                            fragmentShader: Mi.meshlambert_frag
+                            vertexShader: Pr.meshlambert_vert,
+                            fragmentShader: Pr.meshlambert_frag
                         },
                         phong: {
-                            uniforms: ni([bi.common, bi.specularmap, bi.envmap, bi.aomap, bi.lightmap, bi.emissivemap, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.fog, bi.lights, {
+                            uniforms: dr([Dr.common, Dr.specularmap, Dr.envmap, Dr.aomap, Dr.lightmap, Dr.emissivemap, Dr.bumpmap, Dr.normalmap, Dr.displacementmap, Dr.fog, Dr.lights, {
                                 emissive: {
-                                    value: new zt(0)
+                                    value: new Je(0)
                                 },
                                 specular: {
-                                    value: new zt(1118481)
+                                    value: new Je(1118481)
                                 },
                                 shininess: {
                                     value: 30
                                 }
                             }]),
-                            vertexShader: Mi.meshphong_vert,
-                            fragmentShader: Mi.meshphong_frag
+                            vertexShader: Pr.meshphong_vert,
+                            fragmentShader: Pr.meshphong_frag
                         },
                         standard: {
-                            uniforms: ni([bi.common, bi.envmap, bi.aomap, bi.lightmap, bi.emissivemap, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.roughnessmap, bi.metalnessmap, bi.fog, bi.lights, {
+                            uniforms: dr([Dr.common, Dr.envmap, Dr.aomap, Dr.lightmap, Dr.emissivemap, Dr.bumpmap, Dr.normalmap, Dr.displacementmap, Dr.roughnessmap, Dr.metalnessmap, Dr.fog, Dr.lights, {
                                 emissive: {
-                                    value: new zt(0)
+                                    value: new Je(0)
                                 },
                                 roughness: {
                                     value: 1
                                 },
                                 metalness: {
                                     value: 0
                                 },
                                 envMapIntensity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Mi.meshphysical_vert,
-                            fragmentShader: Mi.meshphysical_frag
+                            vertexShader: Pr.meshphysical_vert,
+                            fragmentShader: Pr.meshphysical_frag
                         },
                         toon: {
-                            uniforms: ni([bi.common, bi.aomap, bi.lightmap, bi.emissivemap, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.gradientmap, bi.fog, bi.lights, {
+                            uniforms: dr([Dr.common, Dr.aomap, Dr.lightmap, Dr.emissivemap, Dr.bumpmap, Dr.normalmap, Dr.displacementmap, Dr.gradientmap, Dr.fog, Dr.lights, {
                                 emissive: {
-                                    value: new zt(0)
+                                    value: new Je(0)
                                 }
                             }]),
-                            vertexShader: Mi.meshtoon_vert,
-                            fragmentShader: Mi.meshtoon_frag
+                            vertexShader: Pr.meshtoon_vert,
+                            fragmentShader: Pr.meshtoon_frag
                         },
                         matcap: {
-                            uniforms: ni([bi.common, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.fog, {
+                            uniforms: dr([Dr.common, Dr.bumpmap, Dr.normalmap, Dr.displacementmap, Dr.fog, {
                                 matcap: {
                                     value: null
                                 }
                             }]),
-                            vertexShader: Mi.meshmatcap_vert,
-                            fragmentShader: Mi.meshmatcap_frag
+                            vertexShader: Pr.meshmatcap_vert,
+                            fragmentShader: Pr.meshmatcap_frag
                         },
                         points: {
-                            uniforms: ni([bi.points, bi.fog]),
-                            vertexShader: Mi.points_vert,
-                            fragmentShader: Mi.points_frag
+                            uniforms: dr([Dr.points, Dr.fog]),
+                            vertexShader: Pr.points_vert,
+                            fragmentShader: Pr.points_frag
                         },
                         dashed: {
-                            uniforms: ni([bi.common, bi.fog, {
+                            uniforms: dr([Dr.common, Dr.fog, {
                                 scale: {
                                     value: 1
                                 },
                                 dashSize: {
                                     value: 1
                                 },
                                 totalSize: {
                                     value: 2
                                 }
                             }]),
-                            vertexShader: Mi.linedashed_vert,
-                            fragmentShader: Mi.linedashed_frag
+                            vertexShader: Pr.linedashed_vert,
+                            fragmentShader: Pr.linedashed_frag
                         },
                         depth: {
-                            uniforms: ni([bi.common, bi.displacementmap]),
-                            vertexShader: Mi.depth_vert,
-                            fragmentShader: Mi.depth_frag
+                            uniforms: dr([Dr.common, Dr.displacementmap]),
+                            vertexShader: Pr.depth_vert,
+                            fragmentShader: Pr.depth_frag
                         },
                         normal: {
-                            uniforms: ni([bi.common, bi.bumpmap, bi.normalmap, bi.displacementmap, {
+                            uniforms: dr([Dr.common, Dr.bumpmap, Dr.normalmap, Dr.displacementmap, {
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Mi.meshnormal_vert,
-                            fragmentShader: Mi.meshnormal_frag
+                            vertexShader: Pr.meshnormal_vert,
+                            fragmentShader: Pr.meshnormal_frag
                         },
                         sprite: {
-                            uniforms: ni([bi.sprite, bi.fog]),
-                            vertexShader: Mi.sprite_vert,
-                            fragmentShader: Mi.sprite_frag
+                            uniforms: dr([Dr.sprite, Dr.fog]),
+                            vertexShader: Pr.sprite_vert,
+                            fragmentShader: Pr.sprite_frag
                         },
                         background: {
                             uniforms: {
                                 uvTransform: {
-                                    value: new Rt
+                                    value: new Fe
                                 },
                                 t2D: {
                                     value: null
                                 }
                             },
-                            vertexShader: Mi.background_vert,
-                            fragmentShader: Mi.background_frag
+                            vertexShader: Pr.background_vert,
+                            fragmentShader: Pr.background_frag
                         },
                         cube: {
-                            uniforms: ni([bi.envmap, {
+                            uniforms: dr([Dr.envmap, {
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Mi.cube_vert,
-                            fragmentShader: Mi.cube_frag
+                            vertexShader: Pr.cube_vert,
+                            fragmentShader: Pr.cube_frag
                         },
                         equirect: {
                             uniforms: {
                                 tEquirect: {
                                     value: null
                                 }
                             },
-                            vertexShader: Mi.equirect_vert,
-                            fragmentShader: Mi.equirect_frag
+                            vertexShader: Pr.equirect_vert,
+                            fragmentShader: Pr.equirect_frag
                         },
                         distanceRGBA: {
-                            uniforms: ni([bi.common, bi.displacementmap, {
+                            uniforms: dr([Dr.common, Dr.displacementmap, {
                                 referencePosition: {
-                                    value: new Zt
+                                    value: new on
                                 },
                                 nearDistance: {
                                     value: 1
                                 },
                                 farDistance: {
                                     value: 1e3
                                 }
                             }]),
-                            vertexShader: Mi.distanceRGBA_vert,
-                            fragmentShader: Mi.distanceRGBA_frag
+                            vertexShader: Pr.distanceRGBA_vert,
+                            fragmentShader: Pr.distanceRGBA_frag
                         },
                         shadow: {
-                            uniforms: ni([bi.lights, bi.fog, {
+                            uniforms: dr([Dr.lights, Dr.fog, {
                                 color: {
-                                    value: new zt(0)
+                                    value: new Je(0)
                                 },
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Mi.shadow_vert,
-                            fragmentShader: Mi.shadow_frag
+                            vertexShader: Pr.shadow_vert,
+                            fragmentShader: Pr.shadow_frag
                         }
                     };
 
-                function Si(t, e, n, i, r, s) {
-                    const a = new zt(0);
-                    let o, l, h = !0 === r ? 0 : 1,
-                        u = null,
-                        d = 0,
-                        p = null;
+                function Nr(t, e, n, i, r, s) {
+                    const a = new Je(0);
+                    let o, l, u = !0 === r ? 0 : 1,
+                        d = null,
+                        p = 0,
+                        m = null;
 
-                    function m(t, e) {
+                    function f(t, e) {
                         n.buffers.color.setClear(t.r, t.g, t.b, e, s)
                     }
                     return {
                         getClearColor: function() {
                             return a
                         },
                         setClearColor: function(t, e = 1) {
-                            a.set(t), h = e, m(a, h)
+                            a.set(t), u = e, f(a, u)
                         },
                         getClearAlpha: function() {
-                            return h
+                            return u
                         },
                         setClearAlpha: function(t) {
-                            h = t, m(a, h)
+                            u = t, f(a, u)
                         },
                         render: function(n, r) {
                             let s = !1,
-                                f = !0 === r.isScene ? r.background : null;
-                            f && f.isTexture && (f = e.get(f));
-                            const g = t.xr,
-                                v = g.getSession && g.getSession();
-                            v && "additive" === v.environmentBlendMode && (f = null), null === f ? m(a, h) : f && f.isColor && (m(f, 1), s = !0), (t.autoClear || s) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.mapping === c) ? (void 0 === l && (l = new Qn(new ti(1, 1, 1), new ri({
+                                g = !0 === r.isScene ? r.background : null;
+                            g && g.isTexture && (g = e.get(g));
+                            const v = t.xr,
+                                x = v.getSession && v.getSession();
+                            x && "additive" === x.environmentBlendMode && (g = null), null === g ? f(a, u) : g && g.isColor && (f(g, 1), s = !0), (t.autoClear || s) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.mapping === nt) ? (void 0 === l && (l = new lr(new hr(1, 1, 1), new mr({
                                 name: "BackgroundCubeMaterial",
-                                uniforms: ei(wi.cube.uniforms),
-                                vertexShader: wi.cube.vertexShader,
-                                fragmentShader: wi.cube.fragmentShader,
-                                side: 1,
+                                uniforms: ur(Ir.cube.uniforms),
+                                vertexShader: Ir.cube.vertexShader,
+                                fragmentShader: Ir.cube.fragmentShader,
+                                side: h,
                                 depthTest: !1,
                                 depthWrite: !1,
                                 fog: !1
                             })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(t, e, n) {
                                 this.matrixWorld.copyPosition(n.matrixWorld)
                             }, Object.defineProperty(l.material, "envMap", {
                                 get: function() {
                                     return this.uniforms.envMap.value
                                 }
-                            }), i.update(l)), l.material.uniforms.envMap.value = f, l.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, u === f && d === f.version && p === t.toneMapping || (l.material.needsUpdate = !0, u = f, d = f.version, p = t.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && (o = new Qn(new _i(2, 2), new ri({
+                            }), i.update(l)), l.material.uniforms.envMap.value = g, l.material.uniforms.flipEnvMap.value = g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1, d === g && p === g.version && m === t.toneMapping || (l.material.needsUpdate = !0, d = g, p = g.version, m = t.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null)) : g && g.isTexture && (void 0 === o && (o = new lr(new Cr(2, 2), new mr({
                                 name: "BackgroundMaterial",
-                                uniforms: ei(wi.background.uniforms),
-                                vertexShader: wi.background.vertexShader,
-                                fragmentShader: wi.background.fragmentShader,
-                                side: 0,
+                                uniforms: ur(Ir.background.uniforms),
+                                vertexShader: Ir.background.vertexShader,
+                                fragmentShader: Ir.background.fragmentShader,
+                                side: c,
                                 depthTest: !1,
                                 depthWrite: !1,
                                 fog: !1
                             })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                                 get: function() {
                                     return this.uniforms.t2D.value
                                 }
-                            }), i.update(o)), o.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), o.material.uniforms.uvTransform.value.copy(f.matrix), u === f && d === f.version && p === t.toneMapping || (o.material.needsUpdate = !0, u = f, d = f.version, p = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
+                            }), i.update(o)), o.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), o.material.uniforms.uvTransform.value.copy(g.matrix), d === g && p === g.version && m === t.toneMapping || (o.material.needsUpdate = !0, d = g, p = g.version, m = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                         }
                     }
                 }
 
-                function Ei(t, e, n, i) {
+                function Or(t, e, n, i) {
                     const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                         s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                         a = i.isWebGL2 || null !== s,
                         o = {},
                         l = d(null);
                     let c = l;
 
@@ -5270,15 +5555,15 @@
                         },
                         initAttributes: p,
                         enableAttribute: m,
                         disableUnusedAttributes: g
                     }
                 }
 
-                function Ti(t, e, n, i) {
+                function Ur(t, e, n, i) {
                     const r = i.isWebGL2;
                     let s;
                     this.setMode = function(t) {
                         s = t
                     }, this.render = function(e, i) {
                         t.drawArrays(s, e, i), n.update(i, s, 1)
                     }, this.renderInstances = function(i, a, o) {
@@ -5286,15 +5571,15 @@
                         let l, c;
                         if (r) l = t, c = "drawArraysInstanced";
                         else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                         l[c](s, i, a, o), n.update(a, s, o)
                     }
                 }
 
-                function Ai(t, e, n) {
+                function Br(t, e, n) {
                     let i;
 
                     function r(e) {
                         if ("highp" === e) {
                             if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                             e = "mediump"
                         }
@@ -5341,22 +5626,22 @@
                         vertexTextures: x,
                         floatFragmentTextures: y,
                         floatVertexTextures: x && y,
                         maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0
                     }
                 }
 
-                function Ri(t) {
+                function Fr(t) {
                     const e = this;
                     let n = null,
                         i = 0,
                         r = !1,
                         s = !1;
-                    const a = new mi,
-                        o = new Rt,
+                    const a = new Sr,
+                        o = new Fe,
                         l = {
                             value: null,
                             needsUpdate: !1
                         };
 
                     function c() {
                         l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
@@ -5396,74 +5681,74 @@
                             l.value = r, r = h(u, a, e, o);
                             for (let t = 0; t !== e; ++t) r[t] = n[t];
                             m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                         }
                     }
                 }
 
-                function Li(t) {
+                function zr(t) {
                     let e = new WeakMap;
 
                     function n(t, e) {
-                        return e === o ? t.mapping = s : e === l && (t.mapping = a), t
+                        return e === tt ? t.mapping = Q : e === et && (t.mapping = $), t
                     }
 
                     function i(t) {
                         const n = t.target;
                         n.removeEventListener("dispose", i);
                         const r = e.get(n);
                         void 0 !== r && (e.delete(n), r.dispose())
                     }
                     return {
                         get: function(r) {
                             if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                                 const s = r.mapping;
-                                if (s === o || s === l) {
+                                if (s === tt || s === et) {
                                     if (e.has(r)) return n(e.get(r).texture, r.mapping); {
                                         const s = r.image;
                                         if (s && s.height > 0) {
-                                            const a = new hi(s.height / 2);
+                                            const a = new _r(s.height / 2);
                                             return a.fromEquirectangularTexture(t, r), e.set(r, a), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                         }
                                         return null
                                     }
                                 }
                             }
                             return r
                         },
                         dispose: function() {
                             e = new WeakMap
                         }
                     }
                 }
-                wi.physical = {
-                    uniforms: ni([wi.standard.uniforms, {
+                Ir.physical = {
+                    uniforms: dr([Ir.standard.uniforms, {
                         clearcoat: {
                             value: 0
                         },
                         clearcoatMap: {
                             value: null
                         },
                         clearcoatRoughness: {
                             value: 0
                         },
                         clearcoatRoughnessMap: {
                             value: null
                         },
                         clearcoatNormalScale: {
-                            value: new At(1, 1)
+                            value: new Be(1, 1)
                         },
                         clearcoatNormalMap: {
                             value: null
                         },
                         sheen: {
                             value: 0
                         },
                         sheenColor: {
-                            value: new zt(0)
+                            value: new Je(0)
                         },
                         sheenColorMap: {
                             value: null
                         },
                         sheenRoughness: {
                             value: 1
                         },
@@ -5473,48 +5758,48 @@
                         transmission: {
                             value: 0
                         },
                         transmissionMap: {
                             value: null
                         },
                         transmissionSamplerSize: {
-                            value: new At
+                            value: new Be
                         },
                         transmissionSamplerMap: {
                             value: null
                         },
                         thickness: {
                             value: 0
                         },
                         thicknessMap: {
                             value: null
                         },
                         attenuationDistance: {
                             value: 0
                         },
                         attenuationColor: {
-                            value: new zt(0)
+                            value: new Je(0)
                         },
                         specularIntensity: {
                             value: 1
                         },
                         specularIntensityMap: {
                             value: null
                         },
                         specularColor: {
-                            value: new zt(1, 1, 1)
+                            value: new Je(1, 1, 1)
                         },
                         specularColorMap: {
                             value: null
                         }
                     }]),
-                    vertexShader: Mi.meshphysical_vert,
-                    fragmentShader: Mi.meshphysical_frag
+                    vertexShader: Pr.meshphysical_vert,
+                    fragmentShader: Pr.meshphysical_frag
                 };
-                class Ci extends si {
+                class Hr extends fr {
                     constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) {
                         super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                     }
                     setViewOffset(t, e, n, i, r, s) {
@@ -5548,41 +5833,43 @@
                         this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                     }
                 }
-                Ci.prototype.isOrthographicCamera = !0;
-                class Pi extends ri {
+                Hr.prototype.isOrthographicCamera = !0;
+                class Gr extends mr {
                     constructor(t) {
                         super(t), this.type = "RawShaderMaterial"
                     }
                 }
-                Pi.prototype.isRawShaderMaterial = !0;
-                const Di = Math.pow(2, 8),
-                    Ii = [.125, .215, .35, .446, .526, .582],
-                    Ni = 5 + Ii.length,
-                    Oi = new Ci,
+                Gr.prototype.isRawShaderMaterial = !0;
+                const Vr = 4,
+                    kr = 8,
+                    Wr = Math.pow(2, kr),
+                    jr = [.125, .215, .35, .446, .526, .582],
+                    Xr = kr - Vr + 1 + jr.length,
+                    qr = new Hr,
                     {
-                        _lodPlanes: Ui,
-                        _sizeLods: Bi,
-                        _sigmas: Fi
-                    } = ji(),
-                    zi = new zt;
-                let Hi = null;
-                const Gi = (1 + Math.sqrt(5)) / 2,
-                    Vi = 1 / Gi,
-                    ki = [new Zt(1, 1, 1), new Zt(-1, 1, 1), new Zt(1, 1, -1), new Zt(-1, 1, -1), new Zt(0, Gi, Vi), new Zt(0, Gi, -Vi), new Zt(Vi, 0, Gi), new Zt(-Vi, 0, Gi), new Zt(Gi, Vi, 0), new Zt(-Gi, Vi, 0)];
-                class Wi {
+                        _lodPlanes: Yr,
+                        _sizeLods: Jr,
+                        _sigmas: Zr
+                    } = is(),
+                    Kr = new Je;
+                let Qr = null;
+                const $r = (1 + Math.sqrt(5)) / 2,
+                    ts = 1 / $r,
+                    es = [new on(1, 1, 1), new on(-1, 1, 1), new on(1, 1, -1), new on(-1, 1, -1), new on(0, $r, ts), new on(0, $r, -ts), new on(ts, 0, $r), new on(-ts, 0, $r), new on($r, ts, 0), new on(-$r, ts, 0)];
+                class ns {
                     constructor(t) {
                         this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
                             const e = new Float32Array(20),
-                                n = new Zt(0, 1, 0);
-                            return new Pi({
+                                n = new on(0, 1, 0);
+                            return new Gr({
                                 name: "SphericalGaussianBlur",
                                 defines: {
                                     n: 20
                                 },
                                 uniforms: {
                                     envMap: {
                                         value: null
@@ -5604,149 +5891,149 @@
                                     },
                                     poleAxis: {
                                         value: n
                                     }
                                 },
                                 vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                 fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
-                                blending: 0,
+                                blending: d,
                                 depthTest: !1,
                                 depthWrite: !1
                             })
                         }(), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                     }
                     fromScene(t, e = 0, n = .1, i = 100) {
-                        Hi = this._renderer.getRenderTarget();
+                        Qr = this._renderer.getRenderTarget();
                         const r = this._allocateTargets();
                         return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
                     }
                     fromEquirectangular(t, e = null) {
                         return this._fromTexture(t, e)
                     }
                     fromCubemap(t, e = null) {
                         return this._fromTexture(t, e)
                     }
                     compileCubemapShader() {
-                        null === this._cubemapShader && (this._cubemapShader = Ji(), this._compileMaterial(this._cubemapShader))
+                        null === this._cubemapShader && (this._cubemapShader = os(), this._compileMaterial(this._cubemapShader))
                     }
                     compileEquirectangularShader() {
-                        null === this._equirectShader && (this._equirectShader = Yi(), this._compileMaterial(this._equirectShader))
+                        null === this._equirectShader && (this._equirectShader = as(), this._compileMaterial(this._equirectShader))
                     }
                     dispose() {
                         this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
-                        for (let t = 0; t < Ui.length; t++) Ui[t].dispose()
+                        for (let t = 0; t < Yr.length; t++) Yr[t].dispose()
                     }
                     _cleanup(t) {
-                        this._renderer.setRenderTarget(Hi), t.scissorTest = !1, qi(t, 0, 0, t.width, t.height)
+                        this._renderer.setRenderTarget(Qr), t.scissorTest = !1, ss(t, 0, 0, t.width, t.height)
                     }
                     _fromTexture(t, e) {
-                        Hi = this._renderer.getRenderTarget();
+                        Qr = this._renderer.getRenderTarget();
                         const n = e || this._allocateTargets(t);
                         return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
                     }
                     _allocateTargets(t) {
                         const e = {
-                                magFilter: v,
-                                minFilter: v,
+                                magFilter: ht,
+                                minFilter: ht,
                                 generateMipmaps: !1,
-                                type: S,
-                                format: T,
-                                encoding: ot,
+                                type: _t,
+                                format: Et,
+                                encoding: me,
                                 depthBuffer: !1
                             },
-                            n = Xi(e);
-                        return n.depthBuffer = !t, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = Xi(e)), n
+                            n = rs(e);
+                        return n.depthBuffer = !t, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = rs(e)), n
                     }
                     _compileMaterial(t) {
-                        const e = new Qn(Ui[0], t);
-                        this._renderer.compile(e, Oi)
+                        const e = new lr(Yr[0], t);
+                        this._renderer.compile(e, qr)
                     }
                     _sceneToCubeUV(t, e, n, i) {
-                        const r = new ai(90, 1, e, n),
+                        const r = new gr(90, 1, e, n),
                             s = [1, -1, 1, 1, 1, 1],
                             a = [1, 1, 1, -1, -1, -1],
                             o = this._renderer,
                             l = o.autoClear,
                             c = o.toneMapping;
-                        o.getClearColor(zi), o.toneMapping = 0, o.autoClear = !1;
-                        const h = new pn({
+                        o.getClearColor(Kr), o.toneMapping = j, o.autoClear = !1;
+                        const u = new wi({
                                 name: "PMREM.Background",
-                                side: 1,
+                                side: h,
                                 depthWrite: !1,
                                 depthTest: !1
                             }),
-                            u = new Qn(new ti, h);
-                        let d = !1;
-                        const p = t.background;
-                        p ? p.isColor && (h.color.copy(p), t.background = null, d = !0) : (h.color.copy(zi), d = !0);
+                            d = new lr(new hr, u);
+                        let p = !1;
+                        const m = t.background;
+                        m ? m.isColor && (u.color.copy(m), t.background = null, p = !0) : (u.color.copy(Kr), p = !0);
                         for (let e = 0; e < 6; e++) {
                             const n = e % 3;
-                            0 === n ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])), qi(i, n * Di, e > 2 ? Di : 0, Di, Di), o.setRenderTarget(i), d && o.render(u, r), o.render(t, r)
+                            0 === n ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])), ss(i, n * Wr, e > 2 ? Wr : 0, Wr, Wr), o.setRenderTarget(i), p && o.render(d, r), o.render(t, r)
                         }
-                        u.geometry.dispose(), u.material.dispose(), o.toneMapping = c, o.autoClear = l, t.background = p
+                        d.geometry.dispose(), d.material.dispose(), o.toneMapping = c, o.autoClear = l, t.background = m
                     }
                     _textureToCubeUV(t, e) {
                         const n = this._renderer,
-                            i = t.mapping === s || t.mapping === a;
-                        i ? (null === this._cubemapShader && (this._cubemapShader = Ji()), this._cubemapShader.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = Yi());
+                            i = t.mapping === Q || t.mapping === $;
+                        i ? (null === this._cubemapShader && (this._cubemapShader = os()), this._cubemapShader.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = as());
                         const r = i ? this._cubemapShader : this._equirectShader,
-                            o = new Qn(Ui[0], r),
-                            l = r.uniforms;
-                        l.envMap.value = t, i || l.texelSize.value.set(1 / t.image.width, 1 / t.image.height), qi(e, 0, 0, 3 * Di, 2 * Di), n.setRenderTarget(e), n.render(o, Oi)
+                            s = new lr(Yr[0], r),
+                            a = r.uniforms;
+                        a.envMap.value = t, i || a.texelSize.value.set(1 / t.image.width, 1 / t.image.height), ss(e, 0, 0, 3 * Wr, 2 * Wr), n.setRenderTarget(e), n.render(s, qr)
                     }
                     _applyPMREM(t) {
                         const e = this._renderer,
                             n = e.autoClear;
                         e.autoClear = !1;
-                        for (let e = 1; e < Ni; e++) {
-                            const n = Math.sqrt(Fi[e] * Fi[e] - Fi[e - 1] * Fi[e - 1]),
-                                i = ki[(e - 1) % ki.length];
+                        for (let e = 1; e < Xr; e++) {
+                            const n = Math.sqrt(Zr[e] * Zr[e] - Zr[e - 1] * Zr[e - 1]),
+                                i = es[(e - 1) % es.length];
                             this._blur(t, e - 1, e, n, i)
                         }
                         e.autoClear = n
                     }
                     _blur(t, e, n, i, r) {
                         const s = this._pingPongRenderTarget;
                         this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r)
                     }
                     _halfBlur(t, e, n, i, r, s, a) {
                         const o = this._renderer,
                             l = this._blurMaterial;
                         "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
-                        const c = new Qn(Ui[i], l),
+                        const c = new lr(Yr[i], l),
                             h = l.uniforms,
-                            u = Bi[n] - 1,
+                            u = Jr[n] - 1,
                             d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                             p = r / d,
                             m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                         m > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
                         const f = [];
                         let g = 0;
                         for (let t = 0; t < 20; ++t) {
                             const e = t / p,
                                 n = Math.exp(-e * e / 2);
                             f.push(n), 0 === t ? g += n : t < m && (g += 2 * n)
                         }
                         for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
-                        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = 8 - n;
-                        const v = Bi[i];
-                        qi(e, 3 * Math.max(0, Di - 2 * v), (0 === i ? 0 : 2 * Di) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), o.setRenderTarget(e), o.render(c, Oi)
+                        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = kr - n;
+                        const v = Jr[i];
+                        ss(e, 3 * Math.max(0, Wr - 2 * v), (0 === i ? 0 : 2 * Wr) + 2 * v * (i > kr - Vr ? i - kr + Vr : 0), 3 * v, 2 * v), o.setRenderTarget(e), o.render(c, qr)
                     }
                 }
 
-                function ji() {
+                function is() {
                     const t = [],
                         e = [],
                         n = [];
-                    let i = 8;
-                    for (let r = 0; r < Ni; r++) {
+                    let i = kr;
+                    for (let r = 0; r < Xr; r++) {
                         const s = Math.pow(2, i);
                         e.push(s);
                         let a = 1 / s;
-                        r > 4 ? a = Ii[r - 8 + 4 - 1] : 0 === r && (a = 0), n.push(a);
+                        r > kr - Vr ? a = jr[r - kr + Vr - 1] : 0 === r && (a = 0), n.push(a);
                         const o = 1 / (s - 1),
                             l = -o / 2,
                             c = 1 + o / 2,
                             h = [l, l, c, l, c, c, l, l, c, c, l, c],
                             u = 6,
                             d = 6,
                             p = 3,
@@ -5759,118 +6046,118 @@
                             const e = t % 3 * 2 / 3 - 1,
                                 n = t > 2 ? 0 : -1,
                                 i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                             g.set(i, p * d * t), v.set(h, m * d * t);
                             const r = [t, t, t, t, t, t];
                             x.set(r, f * d * t)
                         }
-                        const y = new Nn;
-                        y.setAttribute("position", new gn(g, p)), y.setAttribute("uv", new gn(v, m)), y.setAttribute("faceIndex", new gn(x, f)), t.push(y), i > 4 && i--
+                        const y = new Wi;
+                        y.setAttribute("position", new Ti(g, p)), y.setAttribute("uv", new Ti(v, m)), y.setAttribute("faceIndex", new Ti(x, f)), t.push(y), i > Vr && i--
                     }
                     return {
                         _lodPlanes: t,
                         _sizeLods: e,
                         _sigmas: n
                     }
                 }
 
-                function Xi(t) {
-                    const e = new Xt(3 * Di, 3 * Di, t);
-                    return e.texture.mapping = c, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
+                function rs(t) {
+                    const e = new nn(3 * Wr, 3 * Wr, t);
+                    return e.texture.mapping = nt, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
                 }
 
-                function qi(t, e, n, i, r) {
+                function ss(t, e, n, i, r) {
                     t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
                 }
 
-                function Yi() {
-                    const t = new At(1, 1);
-                    return new Pi({
+                function as() {
+                    const t = new Be(1, 1);
+                    return new Gr({
                         name: "EquirectangularToCubeUV",
                         uniforms: {
                             envMap: {
                                 value: null
                             },
                             texelSize: {
                                 value: t
                             }
                         },
                         vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                         fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",
-                        blending: 0,
+                        blending: d,
                         depthTest: !1,
                         depthWrite: !1
                     })
                 }
 
-                function Ji() {
-                    return new Pi({
+                function os() {
+                    return new Gr({
                         name: "CubemapToCubeUV",
                         uniforms: {
                             envMap: {
                                 value: null
                             },
                             flipEnvMap: {
                                 value: -1
                             }
                         },
                         vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                         fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
-                        blending: 0,
+                        blending: d,
                         depthTest: !1,
                         depthWrite: !1
                     })
                 }
 
-                function Zi(t) {
+                function ls(t) {
                     let e = new WeakMap,
                         n = null;
 
                     function i(t) {
                         const n = t.target;
                         n.removeEventListener("dispose", i);
                         const r = e.get(n);
                         void 0 !== r && (e.delete(n), r.dispose())
                     }
                     return {
                         get: function(r) {
                             if (r && r.isTexture) {
-                                const c = r.mapping,
-                                    h = c === o || c === l,
-                                    u = c === s || c === a;
-                                if (h || u) {
+                                const s = r.mapping,
+                                    a = s === tt || s === et,
+                                    o = s === Q || s === $;
+                                if (a || o) {
                                     if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                         r.needsPMREMUpdate = !1;
                                         let i = e.get(r);
-                                        return null === n && (n = new Wi(t)), i = h ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture
+                                        return null === n && (n = new ns(t)), i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture
                                     }
                                     if (e.has(r)) return e.get(r).texture; {
                                         const s = r.image;
-                                        if (h && s && s.height > 0 || u && s && function(t) {
+                                        if (a && s && s.height > 0 || o && s && function(t) {
                                                 let e = 0;
                                                 for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                                 return 6 === e
                                             }(s)) {
-                                            null === n && (n = new Wi(t));
-                                            const s = h ? n.fromEquirectangular(r) : n.fromCubemap(r);
+                                            null === n && (n = new ns(t));
+                                            const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                             return e.set(r, s), r.addEventListener("dispose", i), s.texture
                                         }
                                         return null
                                     }
                                 }
                             }
                             return r
                         },
                         dispose: function() {
                             e = new WeakMap, null !== n && (n.dispose(), n = null)
                         }
                     }
                 }
 
-                function Ki(t) {
+                function cs(t) {
                     const e = {};
 
                     function n(n) {
                         if (void 0 !== e[n]) return e[n];
                         let i;
                         switch (n) {
                             case "WEBGL_depth_texture":
@@ -5900,15 +6187,15 @@
                         get: function(t) {
                             const e = n(t);
                             return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                         }
                     }
                 }
 
-                function Qi(t, e, n, i) {
+                function hs(t, e, n, i) {
                     const r = {},
                         s = new WeakMap;
 
                     function a(t) {
                         const o = t.target;
                         null !== o.index && e.remove(o.index);
                         for (const t in o.attributes) e.remove(o.attributes[t]);
@@ -5937,15 +6224,15 @@
                             for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                                 const t = e + 0,
                                     i = e + 1,
                                     r = e + 2;
                                 n.push(t, i, i, r, r, t)
                             }
                         }
-                        const o = new(Lt(n) ? wn : Mn)(n, 1);
+                        const o = new(ze(n) ? Ii : Pi)(n, 1);
                         o.version = a;
                         const l = s.get(t);
                         l && e.remove(l), s.set(t, o)
                     }
                     return {
                         get: function(t, e) {
                             return !0 === r[e.id] || (e.addEventListener("dispose", a), r[e.id] = !0, n.memory.geometries++), e
@@ -5966,15 +6253,15 @@
                                 null !== n && e.version < n.version && o(t)
                             } else o(t);
                             return s.get(t)
                         }
                     }
                 }
 
-                function $i(t, e, n, i) {
+                function us(t, e, n, i) {
                     const r = i.isWebGL2;
                     let s, a, o;
                     this.setMode = function(t) {
                         s = t
                     }, this.setIndex = function(t) {
                         a = t.type, o = t.bytesPerElement
                     }, this.render = function(e, i) {
@@ -5984,15 +6271,15 @@
                         let h, u;
                         if (r) h = t, u = "drawElementsInstanced";
                         else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                         h[u](s, l, a, i * o, c), n.update(l, s, c)
                     }
                 }
 
-                function tr(t) {
+                function ds(t) {
                     const e = {
                         frame: 0,
                         calls: 0,
                         triangles: 0,
                         points: 0,
                         lines: 0
                     };
@@ -6026,44 +6313,44 @@
                                     break;
                                 default:
                                     console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                             }
                         }
                     }
                 }
-                class er extends kt {
+                class ps extends $e {
                     constructor(t = null, e = 1, n = 1, i = 1) {
                         super(null), this.image = {
                             data: t,
                             width: e,
                             height: n,
                             depth: i
-                        }, this.magFilter = m, this.minFilter = m, this.wrapR = d, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
+                        }, this.magFilter = ot, this.minFilter = ot, this.wrapR = st, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }
 
-                function nr(t, e) {
+                function ms(t, e) {
                     return t[0] - e[0]
                 }
 
-                function ir(t, e) {
+                function fs(t, e) {
                     return Math.abs(e[1]) - Math.abs(t[1])
                 }
 
-                function rr(t, e) {
+                function gs(t, e) {
                     let n = 1;
                     const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
                     i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), t.divideScalar(n)
                 }
 
-                function sr(t, e, n) {
+                function vs(t, e, n) {
                     const i = {},
                         r = new Float32Array(8),
                         s = new WeakMap,
-                        a = new Zt,
+                        a = new on,
                         o = [];
                     for (let t = 0; t < 8; t++) o[t] = [t, 0];
                     return {
                         update: function(l, c, h, u) {
                             const d = l.morphTargetInfluences;
                             if (!0 === e.isWebGL2) {
                                 const p = c.morphAttributes.position.length;
@@ -6073,74 +6360,74 @@
                                     const v = void 0 !== c.morphAttributes.normal,
                                         x = c.morphAttributes.position,
                                         y = c.morphAttributes.normal || [],
                                         _ = !0 === v ? 2 : 1;
                                     let M = c.attributes.position.count * _,
                                         b = 1;
                                     M > e.maxTextureSize && (b = Math.ceil(M / e.maxTextureSize), M = e.maxTextureSize);
-                                    const S = new Float32Array(M * b * 4 * p),
-                                        E = new er(S, M, b, p);
-                                    E.format = T, E.type = w, E.needsUpdate = !0;
-                                    const A = 4 * _;
-                                    for (let L = 0; L < p; L++) {
-                                        const C = x[L],
-                                            P = y[L],
-                                            D = M * b * 4 * L;
-                                        for (let I = 0; I < C.count; I++) {
-                                            a.fromBufferAttribute(C, I), !0 === C.normalized && rr(a, C);
-                                            const N = I * A;
-                                            S[D + N + 0] = a.x, S[D + N + 1] = a.y, S[D + N + 2] = a.z, S[D + N + 3] = 0, !0 === v && (a.fromBufferAttribute(P, I), !0 === P.normalized && rr(a, P), S[D + N + 4] = a.x, S[D + N + 5] = a.y, S[D + N + 6] = a.z, S[D + N + 7] = 0)
+                                    const w = new Float32Array(M * b * 4 * p),
+                                        S = new ps(w, M, b, p);
+                                    S.format = Et, S.type = yt, S.needsUpdate = !0;
+                                    const E = 4 * _;
+                                    for (let A = 0; A < p; A++) {
+                                        const R = x[A],
+                                            L = y[A],
+                                            C = M * b * 4 * A;
+                                        for (let P = 0; P < R.count; P++) {
+                                            a.fromBufferAttribute(R, P), !0 === R.normalized && gs(a, R);
+                                            const D = P * E;
+                                            w[C + D + 0] = a.x, w[C + D + 1] = a.y, w[C + D + 2] = a.z, w[C + D + 3] = 0, !0 === v && (a.fromBufferAttribute(L, P), !0 === L.normalized && gs(a, L), w[C + D + 4] = a.x, w[C + D + 5] = a.y, w[C + D + 6] = a.z, w[C + D + 7] = 0)
                                         }
                                     }
 
-                                    function R() {
-                                        E.dispose(), s.delete(c), c.removeEventListener("dispose", R)
+                                    function T() {
+                                        S.dispose(), s.delete(c), c.removeEventListener("dispose", T)
                                     }
                                     m = {
                                         count: p,
-                                        texture: E,
-                                        size: new At(M, b)
-                                    }, s.set(c, m), c.addEventListener("dispose", R)
+                                        texture: S,
+                                        size: new Be(M, b)
+                                    }, s.set(c, m), c.addEventListener("dispose", T)
                                 }
                                 let f = 0;
-                                for (let O = 0; O < d.length; O++) f += d[O];
+                                for (let I = 0; I < d.length; I++) f += d[I];
                                 const g = c.morphTargetsRelative ? 1 : 1 - f;
                                 u.getUniforms().setValue(t, "morphTargetBaseInfluence", g), u.getUniforms().setValue(t, "morphTargetInfluences", d), u.getUniforms().setValue(t, "morphTargetsTexture", m.texture, n), u.getUniforms().setValue(t, "morphTargetsTextureSize", m.size)
                             } else {
-                                const U = void 0 === d ? 0 : d.length;
-                                let B = i[c.id];
-                                if (void 0 === B || B.length !== U) {
-                                    B = [];
-                                    for (let V = 0; V < U; V++) B[V] = [V, 0];
-                                    i[c.id] = B
+                                const N = void 0 === d ? 0 : d.length;
+                                let O = i[c.id];
+                                if (void 0 === O || O.length !== N) {
+                                    O = [];
+                                    for (let H = 0; H < N; H++) O[H] = [H, 0];
+                                    i[c.id] = O
                                 }
-                                for (let k = 0; k < U; k++) {
-                                    const W = B[k];
-                                    W[0] = k, W[1] = d[k]
+                                for (let G = 0; G < N; G++) {
+                                    const V = O[G];
+                                    V[0] = G, V[1] = d[G]
                                 }
-                                B.sort(ir);
-                                for (let j = 0; j < 8; j++) j < U && B[j][1] ? (o[j][0] = B[j][0], o[j][1] = B[j][1]) : (o[j][0] = Number.MAX_SAFE_INTEGER, o[j][1] = 0);
-                                o.sort(nr);
-                                const F = c.morphAttributes.position,
-                                    z = c.morphAttributes.normal;
-                                let H = 0;
-                                for (let X = 0; X < 8; X++) {
-                                    const q = o[X],
-                                        Y = q[0],
-                                        J = q[1];
-                                    Y !== Number.MAX_SAFE_INTEGER && J ? (F && c.getAttribute("morphTarget" + X) !== F[Y] && c.setAttribute("morphTarget" + X, F[Y]), z && c.getAttribute("morphNormal" + X) !== z[Y] && c.setAttribute("morphNormal" + X, z[Y]), r[X] = J, H += J) : (F && !0 === c.hasAttribute("morphTarget" + X) && c.deleteAttribute("morphTarget" + X), z && !0 === c.hasAttribute("morphNormal" + X) && c.deleteAttribute("morphNormal" + X), r[X] = 0)
+                                O.sort(fs);
+                                for (let k = 0; k < 8; k++) k < N && O[k][1] ? (o[k][0] = O[k][0], o[k][1] = O[k][1]) : (o[k][0] = Number.MAX_SAFE_INTEGER, o[k][1] = 0);
+                                o.sort(ms);
+                                const U = c.morphAttributes.position,
+                                    B = c.morphAttributes.normal;
+                                let F = 0;
+                                for (let W = 0; W < 8; W++) {
+                                    const j = o[W],
+                                        X = j[0],
+                                        q = j[1];
+                                    X !== Number.MAX_SAFE_INTEGER && q ? (U && c.getAttribute("morphTarget" + W) !== U[X] && c.setAttribute("morphTarget" + W, U[X]), B && c.getAttribute("morphNormal" + W) !== B[X] && c.setAttribute("morphNormal" + W, B[X]), r[W] = q, F += q) : (U && !0 === c.hasAttribute("morphTarget" + W) && c.deleteAttribute("morphTarget" + W), B && !0 === c.hasAttribute("morphNormal" + W) && c.deleteAttribute("morphNormal" + W), r[W] = 0)
                                 }
-                                const G = c.morphTargetsRelative ? 1 : 1 - H;
-                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", G), u.getUniforms().setValue(t, "morphTargetInfluences", r)
+                                const z = c.morphTargetsRelative ? 1 : 1 - F;
+                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", z), u.getUniforms().setValue(t, "morphTargetInfluences", r)
                             }
                         }
                     }
                 }
 
-                function ar(t, e, n, i) {
+                function xs(t, e, n, i) {
                     let r = new WeakMap;
 
                     function s(t) {
                         const e = t.target;
                         e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                     }
                     return {
@@ -6151,693 +6438,693 @@
                             return r.get(c) !== o && (e.update(c), r.set(c, o)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s), n.update(a.instanceMatrix, t.ARRAY_BUFFER), null !== a.instanceColor && n.update(a.instanceColor, t.ARRAY_BUFFER)), c
                         },
                         dispose: function() {
                             r = new WeakMap
                         }
                     }
                 }
-                er.prototype.isDataTexture2DArray = !0;
-                class or extends kt {
+                ps.prototype.isDataTexture2DArray = !0;
+                class ys extends $e {
                     constructor(t = null, e = 1, n = 1, i = 1) {
                         super(null), this.image = {
                             data: t,
                             width: e,
                             height: n,
                             depth: i
-                        }, this.magFilter = m, this.minFilter = m, this.wrapR = d, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
+                        }, this.magFilter = ot, this.minFilter = ot, this.wrapR = st, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }
-                or.prototype.isDataTexture3D = !0;
-                const lr = new kt,
-                    cr = new er,
-                    hr = new or,
-                    ur = new ci,
-                    dr = [],
-                    pr = [],
-                    mr = new Float32Array(16),
-                    fr = new Float32Array(9),
-                    gr = new Float32Array(4);
+                ys.prototype.isDataTexture3D = !0;
+                const _s = new $e,
+                    Ms = new ps,
+                    bs = new ys,
+                    ws = new yr,
+                    Ss = [],
+                    Es = [],
+                    Ts = new Float32Array(16),
+                    As = new Float32Array(9),
+                    Rs = new Float32Array(4);
 
-                function vr(t, e, n) {
+                function Ls(t, e, n) {
                     const i = t[0];
                     if (i <= 0 || i > 0) return t;
                     const r = e * n;
-                    let s = dr[r];
-                    if (void 0 === s && (s = new Float32Array(r), dr[r] = s), 0 !== e) {
+                    let s = Ss[r];
+                    if (void 0 === s && (s = new Float32Array(r), Ss[r] = s), 0 !== e) {
                         i.toArray(s, 0);
                         for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r)
                     }
                     return s
                 }
 
-                function xr(t, e) {
+                function Cs(t, e) {
                     if (t.length !== e.length) return !1;
                     for (let n = 0, i = t.length; n < i; n++)
                         if (t[n] !== e[n]) return !1;
                     return !0
                 }
 
-                function yr(t, e) {
+                function Ps(t, e) {
                     for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
                 }
 
-                function _r(t, e) {
-                    let n = pr[e];
-                    void 0 === n && (n = new Int32Array(e), pr[e] = n);
+                function Ds(t, e) {
+                    let n = Es[e];
+                    void 0 === n && (n = new Int32Array(e), Es[e] = n);
                     for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                     return n
                 }
 
-                function Mr(t, e) {
+                function Is(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
                 }
 
-                function br(t, e) {
+                function Ns(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                     else {
-                        if (xr(n, e)) return;
-                        t.uniform2fv(this.addr, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniform2fv(this.addr, e), Ps(n, e)
                     }
                 }
 
-                function wr(t, e) {
+                function Os(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                     else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                     else {
-                        if (xr(n, e)) return;
-                        t.uniform3fv(this.addr, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniform3fv(this.addr, e), Ps(n, e)
                     }
                 }
 
-                function Sr(t, e) {
+                function Us(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                     else {
-                        if (xr(n, e)) return;
-                        t.uniform4fv(this.addr, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniform4fv(this.addr, e), Ps(n, e)
                     }
                 }
 
-                function Er(t, e) {
+                function Bs(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (xr(n, e)) return;
-                        t.uniformMatrix2fv(this.addr, !1, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniformMatrix2fv(this.addr, !1, e), Ps(n, e)
                     } else {
-                        if (xr(n, i)) return;
-                        gr.set(i), t.uniformMatrix2fv(this.addr, !1, gr), yr(n, i)
+                        if (Cs(n, i)) return;
+                        Rs.set(i), t.uniformMatrix2fv(this.addr, !1, Rs), Ps(n, i)
                     }
                 }
 
-                function Tr(t, e) {
+                function Fs(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (xr(n, e)) return;
-                        t.uniformMatrix3fv(this.addr, !1, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniformMatrix3fv(this.addr, !1, e), Ps(n, e)
                     } else {
-                        if (xr(n, i)) return;
-                        fr.set(i), t.uniformMatrix3fv(this.addr, !1, fr), yr(n, i)
+                        if (Cs(n, i)) return;
+                        As.set(i), t.uniformMatrix3fv(this.addr, !1, As), Ps(n, i)
                     }
                 }
 
-                function Ar(t, e) {
+                function zs(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (xr(n, e)) return;
-                        t.uniformMatrix4fv(this.addr, !1, e), yr(n, e)
+                        if (Cs(n, e)) return;
+                        t.uniformMatrix4fv(this.addr, !1, e), Ps(n, e)
                     } else {
-                        if (xr(n, i)) return;
-                        mr.set(i), t.uniformMatrix4fv(this.addr, !1, mr), yr(n, i)
+                        if (Cs(n, i)) return;
+                        Ts.set(i), t.uniformMatrix4fv(this.addr, !1, Ts), Ps(n, i)
                     }
                 }
 
-                function Rr(t, e) {
+                function Hs(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
                 }
 
-                function Lr(t, e) {
+                function Gs(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform2iv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform2iv(this.addr, e), Ps(n, e))
                 }
 
-                function Cr(t, e) {
+                function Vs(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform3iv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform3iv(this.addr, e), Ps(n, e))
                 }
 
-                function Pr(t, e) {
+                function ks(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform4iv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform4iv(this.addr, e), Ps(n, e))
                 }
 
-                function Dr(t, e) {
+                function Ws(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
                 }
 
-                function Ir(t, e) {
+                function js(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform2uiv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform2uiv(this.addr, e), Ps(n, e))
                 }
 
-                function Nr(t, e) {
+                function Xs(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform3uiv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform3uiv(this.addr, e), Ps(n, e))
                 }
 
-                function Or(t, e) {
+                function qs(t, e) {
                     const n = this.cache;
-                    xr(n, e) || (t.uniform4uiv(this.addr, e), yr(n, e))
+                    Cs(n, e) || (t.uniform4uiv(this.addr, e), Ps(n, e))
                 }
 
-                function Ur(t, e, n) {
+                function Ys(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || lr, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || _s, r)
                 }
 
-                function Br(t, e, n) {
+                function Js(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || hr, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || bs, r)
                 }
 
-                function Fr(t, e, n) {
+                function Zs(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || ur, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || ws, r)
                 }
 
-                function zr(t, e, n) {
+                function Ks(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || cr, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || Ms, r)
                 }
 
-                function Hr(t, e) {
+                function Qs(t, e) {
                     t.uniform1fv(this.addr, e)
                 }
 
-                function Gr(t, e) {
-                    const n = vr(e, this.size, 2);
+                function $s(t, e) {
+                    const n = Ls(e, this.size, 2);
                     t.uniform2fv(this.addr, n)
                 }
 
-                function Vr(t, e) {
-                    const n = vr(e, this.size, 3);
+                function ta(t, e) {
+                    const n = Ls(e, this.size, 3);
                     t.uniform3fv(this.addr, n)
                 }
 
-                function kr(t, e) {
-                    const n = vr(e, this.size, 4);
+                function ea(t, e) {
+                    const n = Ls(e, this.size, 4);
                     t.uniform4fv(this.addr, n)
                 }
 
-                function Wr(t, e) {
-                    const n = vr(e, this.size, 4);
+                function na(t, e) {
+                    const n = Ls(e, this.size, 4);
                     t.uniformMatrix2fv(this.addr, !1, n)
                 }
 
-                function jr(t, e) {
-                    const n = vr(e, this.size, 9);
+                function ia(t, e) {
+                    const n = Ls(e, this.size, 9);
                     t.uniformMatrix3fv(this.addr, !1, n)
                 }
 
-                function Xr(t, e) {
-                    const n = vr(e, this.size, 16);
+                function ra(t, e) {
+                    const n = Ls(e, this.size, 16);
                     t.uniformMatrix4fv(this.addr, !1, n)
                 }
 
-                function qr(t, e) {
+                function sa(t, e) {
                     t.uniform1iv(this.addr, e)
                 }
 
-                function Yr(t, e) {
+                function aa(t, e) {
                     t.uniform2iv(this.addr, e)
                 }
 
-                function Jr(t, e) {
+                function oa(t, e) {
                     t.uniform3iv(this.addr, e)
                 }
 
-                function Zr(t, e) {
+                function la(t, e) {
                     t.uniform4iv(this.addr, e)
                 }
 
-                function Kr(t, e) {
+                function ca(t, e) {
                     t.uniform1uiv(this.addr, e)
                 }
 
-                function Qr(t, e) {
+                function ha(t, e) {
                     t.uniform2uiv(this.addr, e)
                 }
 
-                function $r(t, e) {
+                function ua(t, e) {
                     t.uniform3uiv(this.addr, e)
                 }
 
-                function ts(t, e) {
+                function da(t, e) {
                     t.uniform4uiv(this.addr, e)
                 }
 
-                function es(t, e, n) {
+                function pa(t, e, n) {
                     const i = e.length,
-                        r = _r(n, i);
+                        r = Ds(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || lr, r[t])
+                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || _s, r[t])
                 }
 
-                function ns(t, e, n) {
+                function ma(t, e, n) {
                     const i = e.length,
-                        r = _r(n, i);
+                        r = Ds(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || hr, r[t])
+                    for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || bs, r[t])
                 }
 
-                function is(t, e, n) {
+                function fa(t, e, n) {
                     const i = e.length,
-                        r = _r(n, i);
+                        r = Ds(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || ur, r[t])
+                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || ws, r[t])
                 }
 
-                function rs(t, e, n) {
+                function ga(t, e, n) {
                     const i = e.length,
-                        r = _r(n, i);
+                        r = Ds(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || cr, r[t])
+                    for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || Ms, r[t])
                 }
 
-                function ss(t, e, n) {
+                function va(t, e, n) {
                     this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                         switch (t) {
                             case 5126:
-                                return Mr;
+                                return Is;
                             case 35664:
-                                return br;
+                                return Ns;
                             case 35665:
-                                return wr;
+                                return Os;
                             case 35666:
-                                return Sr;
+                                return Us;
                             case 35674:
-                                return Er;
+                                return Bs;
                             case 35675:
-                                return Tr;
+                                return Fs;
                             case 35676:
-                                return Ar;
+                                return zs;
                             case 5124:
                             case 35670:
-                                return Rr;
+                                return Hs;
                             case 35667:
                             case 35671:
-                                return Lr;
+                                return Gs;
                             case 35668:
                             case 35672:
-                                return Cr;
+                                return Vs;
                             case 35669:
                             case 35673:
-                                return Pr;
+                                return ks;
                             case 5125:
-                                return Dr;
+                                return Ws;
                             case 36294:
-                                return Ir;
+                                return js;
                             case 36295:
-                                return Nr;
+                                return Xs;
                             case 36296:
-                                return Or;
+                                return qs;
                             case 35678:
                             case 36198:
                             case 36298:
                             case 36306:
                             case 35682:
-                                return Ur;
+                                return Ys;
                             case 35679:
                             case 36299:
                             case 36307:
-                                return Br;
+                                return Js;
                             case 35680:
                             case 36300:
                             case 36308:
                             case 36293:
-                                return Fr;
+                                return Zs;
                             case 36289:
                             case 36303:
                             case 36311:
                             case 36292:
-                                return zr
+                                return Ks
                         }
                     }(e.type)
                 }
 
-                function as(t, e, n) {
+                function xa(t, e, n) {
                     this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                         switch (t) {
                             case 5126:
-                                return Hr;
+                                return Qs;
                             case 35664:
-                                return Gr;
+                                return $s;
                             case 35665:
-                                return Vr;
+                                return ta;
                             case 35666:
-                                return kr;
+                                return ea;
                             case 35674:
-                                return Wr;
+                                return na;
                             case 35675:
-                                return jr;
+                                return ia;
                             case 35676:
-                                return Xr;
+                                return ra;
                             case 5124:
                             case 35670:
-                                return qr;
+                                return sa;
                             case 35667:
                             case 35671:
-                                return Yr;
+                                return aa;
                             case 35668:
                             case 35672:
-                                return Jr;
+                                return oa;
                             case 35669:
                             case 35673:
-                                return Zr;
+                                return la;
                             case 5125:
-                                return Kr;
+                                return ca;
                             case 36294:
-                                return Qr;
+                                return ha;
                             case 36295:
-                                return $r;
+                                return ua;
                             case 36296:
-                                return ts;
+                                return da;
                             case 35678:
                             case 36198:
                             case 36298:
                             case 36306:
                             case 35682:
-                                return es;
+                                return pa;
                             case 35679:
                             case 36299:
                             case 36307:
-                                return ns;
+                                return ma;
                             case 35680:
                             case 36300:
                             case 36308:
                             case 36293:
-                                return is;
+                                return fa;
                             case 36289:
                             case 36303:
                             case 36311:
                             case 36292:
-                                return rs
+                                return ga
                         }
                     }(e.type)
                 }
 
-                function os(t) {
+                function ya(t) {
                     this.id = t, this.seq = [], this.map = {}
                 }
-                as.prototype.updateCache = function(t) {
+                xa.prototype.updateCache = function(t) {
                     const e = this.cache;
-                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), yr(e, t)
-                }, os.prototype.setValue = function(t, e, n) {
+                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Ps(e, t)
+                }, ya.prototype.setValue = function(t, e, n) {
                     const i = this.seq;
                     for (let r = 0, s = i.length; r !== s; ++r) {
                         const s = i[r];
                         s.setValue(t, e[s.id], n)
                     }
                 };
-                const ls = /(\w+)(\])?(\[|\.)?/g;
+                const _a = /(\w+)(\])?(\[|\.)?/g;
 
-                function cs(t, e) {
+                function Ma(t, e) {
                     t.seq.push(e), t.map[e.id] = e
                 }
 
-                function hs(t, e, n) {
+                function ba(t, e, n) {
                     const i = t.name,
                         r = i.length;
-                    for (ls.lastIndex = 0;;) {
-                        const s = ls.exec(i),
-                            a = ls.lastIndex;
+                    for (_a.lastIndex = 0;;) {
+                        const s = _a.exec(i),
+                            a = _a.lastIndex;
                         let o = s[1];
                         const l = "]" === s[2],
                             c = s[3];
                         if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === r) {
-                            cs(n, void 0 === c ? new ss(o, t, e) : new as(o, t, e));
+                            Ma(n, void 0 === c ? new va(o, t, e) : new xa(o, t, e));
                             break
                         } {
                             let t = n.map[o];
-                            void 0 === t && (t = new os(o), cs(n, t)), n = t
+                            void 0 === t && (t = new ya(o), Ma(n, t)), n = t
                         }
                     }
                 }
 
-                function us(t, e) {
+                function wa(t, e) {
                     this.seq = [], this.map = {};
                     const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                     for (let i = 0; i < n; ++i) {
                         const n = t.getActiveUniform(e, i);
-                        hs(n, t.getUniformLocation(e, n.name), this)
+                        ba(n, t.getUniformLocation(e, n.name), this)
                     }
                 }
 
-                function ds(t, e, n) {
+                function Sa(t, e, n) {
                     const i = t.createShader(e);
                     return t.shaderSource(i, n), t.compileShader(i), i
                 }
-                us.prototype.setValue = function(t, e, n, i) {
+                wa.prototype.setValue = function(t, e, n, i) {
                     const r = this.map[e];
                     void 0 !== r && r.setValue(t, n, i)
-                }, us.prototype.setOptional = function(t, e, n) {
+                }, wa.prototype.setOptional = function(t, e, n) {
                     const i = e[n];
                     void 0 !== i && this.setValue(t, n, i)
-                }, us.upload = function(t, e, n, i) {
+                }, wa.upload = function(t, e, n, i) {
                     for (let r = 0, s = e.length; r !== s; ++r) {
                         const s = e[r],
                             a = n[s.id];
                         !1 !== a.needsUpdate && s.setValue(t, a.value, i)
                     }
-                }, us.seqWithValue = function(t, e) {
+                }, wa.seqWithValue = function(t, e) {
                     const n = [];
                     for (let i = 0, r = t.length; i !== r; ++i) {
                         const r = t[i];
                         r.id in e && n.push(r)
                     }
                     return n
                 };
-                let ps = 0;
+                let Ea = 0;
 
-                function ms(t, e, n) {
+                function Ta(t, e, n) {
                     const i = t.getShaderParameter(e, t.COMPILE_STATUS),
                         r = t.getShaderInfoLog(e).trim();
                     return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function(t) {
                         const e = t.split("\n");
                         for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                         return e.join("\n")
                     }(t.getShaderSource(e))
                 }
 
-                function fs(t, e) {
+                function Aa(t, e) {
                     const n = function(t) {
                         switch (t) {
-                            case ot:
+                            case me:
                                 return ["Linear", "( value )"];
-                            case lt:
+                            case fe:
                                 return ["sRGB", "( value )"];
                             default:
                                 return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                         }
                     }(e);
                     return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                 }
 
-                function gs(t, e) {
+                function Ra(t, e) {
                     let n;
                     switch (e) {
-                        case 1:
+                        case X:
                             n = "Linear";
                             break;
-                        case 2:
+                        case q:
                             n = "Reinhard";
                             break;
-                        case 3:
+                        case Y:
                             n = "OptimizedCineon";
                             break;
-                        case 4:
+                        case J:
                             n = "ACESFilmic";
                             break;
-                        case 5:
+                        case Z:
                             n = "Custom";
                             break;
                         default:
                             console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                     }
                     return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                 }
 
-                function vs(t) {
+                function La(t) {
                     return "" !== t
                 }
 
-                function xs(t, e) {
+                function Ca(t, e) {
                     return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
                 }
 
-                function ys(t, e) {
+                function Pa(t, e) {
                     return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
                 }
-                const _s = /^[ \t]*#include +<([\w\d./]+)>/gm;
+                const Da = /^[ \t]*#include +<([\w\d./]+)>/gm;
 
-                function Ms(t) {
-                    return t.replace(_s, bs)
+                function Ia(t) {
+                    return t.replace(Da, Na)
                 }
 
-                function bs(t, e) {
-                    const n = Mi[e];
+                function Na(t, e) {
+                    const n = Pr[e];
                     if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
-                    return Ms(n)
+                    return Ia(n)
                 }
-                const ws = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
-                    Ss = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
+                const Oa = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
+                    Ua = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
 
-                function Es(t) {
-                    return t.replace(Ss, As).replace(ws, Ts)
+                function Ba(t) {
+                    return t.replace(Ua, za).replace(Oa, Fa)
                 }
 
-                function Ts(t, e, n, i) {
-                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), As(0, e, n, i)
+                function Fa(t, e, n, i) {
+                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), za(0, e, n, i)
                 }
 
-                function As(t, e, n, i) {
+                function za(t, e, n, i) {
                     let r = "";
                     for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
                     return r
                 }
 
-                function Rs(t) {
+                function Ha(t) {
                     let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                     return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
                 }
 
-                function Ls(t, e, n, i) {
+                function Ga(t, e, n, i) {
                     const r = t.getContext(),
-                        o = n.defines;
-                    let l = n.vertexShader,
-                        u = n.fragmentShader;
-                    const d = function(t) {
+                        s = n.defines;
+                    let c = n.vertexShader,
+                        h = n.fragmentShader;
+                    const u = function(t) {
                             let e = "SHADOWMAP_TYPE_BASIC";
-                            return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
+                            return t.shadowMapType === a ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === o ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === l && (e = "SHADOWMAP_TYPE_VSM"), e
                         }(n),
-                        p = function(t) {
+                        d = function(t) {
                             let e = "ENVMAP_TYPE_CUBE";
                             if (t.envMap) switch (t.envMapMode) {
-                                case s:
-                                case a:
+                                case Q:
+                                case $:
                                     e = "ENVMAP_TYPE_CUBE";
                                     break;
-                                case c:
-                                case h:
+                                case nt:
+                                case it:
                                     e = "ENVMAP_TYPE_CUBE_UV"
                             }
                             return e
                         }(n),
-                        m = function(t) {
+                        p = function(t) {
                             let e = "ENVMAP_MODE_REFLECTION";
                             if (t.envMap) switch (t.envMapMode) {
-                                case a:
-                                case h:
+                                case $:
+                                case it:
                                     e = "ENVMAP_MODE_REFRACTION"
                             }
                             return e
                         }(n),
-                        f = function(t) {
+                        m = function(t) {
                             let e = "ENVMAP_BLENDING_NONE";
                             if (t.envMap) switch (t.combine) {
-                                case 0:
+                                case V:
                                     e = "ENVMAP_BLENDING_MULTIPLY";
                                     break;
-                                case 1:
+                                case k:
                                     e = "ENVMAP_BLENDING_MIX";
                                     break;
-                                case 2:
+                                case W:
                                     e = "ENVMAP_BLENDING_ADD"
                             }
                             return e
                         }(n),
-                        g = n.isWebGL2 ? "" : function(t) {
-                            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(vs).join("\n")
+                        f = n.isWebGL2 ? "" : function(t) {
+                            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(La).join("\n")
                         }(n),
-                        v = function(t) {
+                        g = function(t) {
                             const e = [];
                             for (const n in t) {
                                 const i = t[n];
                                 !1 !== i && e.push("#define " + n + " " + i)
                             }
                             return e.join("\n")
-                        }(o),
-                        x = r.createProgram();
-                    let y, _, M = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
-                    n.isRawShaderMaterial ? (y = [v].filter(vs).join("\n"), y.length > 0 && (y += "\n"), _ = [g, v].filter(vs).join("\n"), _.length > 0 && (_ += "\n")) : (y = [Rs(n), "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(vs).join("\n"), _ = [g, Rs(n), "#define SHADER_NAME " + n.shaderName, v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Mi.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? gs("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.alphaWrite ? "" : "#define OPAQUE", Mi.encodings_pars_fragment, fs("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(vs).join("\n")), l = Ms(l), l = xs(l, n), l = ys(l, n), u = Ms(u), u = xs(u, n), u = ys(u, n), l = Es(l), u = Es(u), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (M = "#version 300 es\n", y = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, _ = ["#define varying in", n.glslVersion === dt ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === dt ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _);
-                    const b = M + y + l,
-                        w = M + _ + u,
-                        S = ds(r, r.VERTEX_SHADER, b),
-                        E = ds(r, r.FRAGMENT_SHADER, w);
-                    if (r.attachShader(x, S), r.attachShader(x, E), void 0 !== n.index0AttributeName ? r.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(x, 0, "position"), r.linkProgram(x), t.debug.checkShaderErrors) {
-                        const t = r.getProgramInfoLog(x).trim(),
-                            e = r.getShaderInfoLog(S).trim(),
-                            n = r.getShaderInfoLog(E).trim();
+                        }(s),
+                        v = r.createProgram();
+                    let x, y, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
+                    n.isRawShaderMaterial ? (x = [g].filter(La).join("\n"), x.length > 0 && (x += "\n"), y = [f, g].filter(La).join("\n"), y.length > 0 && (y += "\n")) : (x = [Ha(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(La).join("\n"), y = [f, Ha(n), "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== j ? "#define TONE_MAPPING" : "", n.toneMapping !== j ? Pr.tonemapping_pars_fragment : "", n.toneMapping !== j ? Ra("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.alphaWrite ? "" : "#define OPAQUE", Pr.encodings_pars_fragment, Aa("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(La).join("\n")), c = Ia(c), c = Ca(c, n), c = Pa(c, n), h = Ia(h), h = Ca(h, n), h = Pa(h, n), c = Ba(c), h = Ba(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, y = ["#define varying in", n.glslVersion === be ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === be ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
+                    const M = _ + x + c,
+                        b = _ + y + h,
+                        w = Sa(r, r.VERTEX_SHADER, M),
+                        S = Sa(r, r.FRAGMENT_SHADER, b);
+                    if (r.attachShader(v, w), r.attachShader(v, S), void 0 !== n.index0AttributeName ? r.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(v, 0, "position"), r.linkProgram(v), t.debug.checkShaderErrors) {
+                        const t = r.getProgramInfoLog(v).trim(),
+                            e = r.getShaderInfoLog(w).trim(),
+                            n = r.getShaderInfoLog(S).trim();
                         let i = !0,
                             s = !0;
-                        if (!1 === r.getProgramParameter(x, r.LINK_STATUS)) {
+                        if (!1 === r.getProgramParameter(v, r.LINK_STATUS)) {
                             i = !1;
-                            const e = ms(r, S, "vertex"),
-                                n = ms(r, E, "fragment");
-                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(x, r.VALIDATE_STATUS) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
+                            const e = Ta(r, w, "vertex"),
+                                n = Ta(r, S, "fragment");
+                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(v, r.VALIDATE_STATUS) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
                         } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (s = !1);
                         s && (this.diagnostics = {
                             runnable: i,
                             programLog: t,
                             vertexShader: {
                                 log: e,
-                                prefix: y
+                                prefix: x
                             },
                             fragmentShader: {
                                 log: n,
-                                prefix: _
+                                prefix: y
                             }
                         })
                     }
-                    let T, A;
-                    return r.deleteShader(S), r.deleteShader(E), this.getUniforms = function() {
-                        return void 0 === T && (T = new us(r, x)), T
+                    let E, T;
+                    return r.deleteShader(w), r.deleteShader(S), this.getUniforms = function() {
+                        return void 0 === E && (E = new wa(r, v)), E
                     }, this.getAttributes = function() {
-                        return void 0 === A && (A = function(t, e) {
+                        return void 0 === T && (T = function(t, e) {
                             const n = {},
                                 i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                             for (let r = 0; r < i; r++) {
                                 const i = t.getActiveAttrib(e, r),
                                     s = i.name;
                                 let a = 1;
                                 i.type === t.FLOAT_MAT2 && (a = 2), i.type === t.FLOAT_MAT3 && (a = 3), i.type === t.FLOAT_MAT4 && (a = 4), n[s] = {
                                     type: i.type,
                                     location: t.getAttribLocation(e, s),
                                     locationSize: a
                                 }
                             }
                             return n
-                        }(r, x)), A
+                        }(r, v)), T
                     }, this.destroy = function() {
-                        i.releaseStatesOfProgram(this), r.deleteProgram(x), this.program = void 0
-                    }, this.name = n.shaderName, this.id = ps++, this.cacheKey = e, this.usedTimes = 1, this.program = x, this.vertexShader = S, this.fragmentShader = E, this
+                        i.releaseStatesOfProgram(this), r.deleteProgram(v), this.program = void 0
+                    }, this.name = n.shaderName, this.id = Ea++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = w, this.fragmentShader = S, this
                 }
-                let Cs = 0;
-                class Ps {
+                let Va = 0;
+                class ka {
                     constructor() {
                         this.shaderCache = new Map, this.materialCache = new Map
                     }
                     update(t) {
                         const e = t.vertexShader,
                             n = t.fragmentShader,
                             i = this._getShaderStage(e),
@@ -6862,30 +7149,30 @@
                     _getShaderCacheForMaterial(t) {
                         const e = this.materialCache;
                         return !1 === e.has(t) && e.set(t, new Set), e.get(t)
                     }
                     _getShaderStage(t) {
                         const e = this.shaderCache;
                         if (!1 === e.has(t)) {
-                            const n = new Ds;
+                            const n = new Wa;
                             e.set(t, n)
                         }
                         return e.get(t)
                     }
                 }
-                class Ds {
+                class Wa {
                     constructor() {
-                        this.id = Cs++, this.usedTimes = 0
+                        this.id = Va++, this.usedTimes = 0
                     }
                 }
 
-                function Is(t, e, n, i, r, s, a) {
-                    const o = new Fe,
-                        l = new Ps,
-                        u = [],
+                function ja(t, e, n, i, r, s, a) {
+                    const o = new Jn,
+                        l = new ka,
+                        c = [],
                         d = r.isWebGL2,
                         p = r.logarithmicDepthBuffer,
                         m = r.floatVertexTextures,
                         f = r.maxVertexUniforms,
                         g = r.vertexTextures;
                     let v = r.precision;
                     const x = {
@@ -6902,15 +7189,15 @@
                         LineBasicMaterial: "basic",
                         LineDashedMaterial: "dashed",
                         PointsMaterial: "points",
                         ShadowMaterial: "shadow",
                         SpriteMaterial: "sprite"
                     };
                     return {
-                        getParameters: function(s, o, u, y, _) {
+                        getParameters: function(s, o, c, y, _) {
                             const M = y.fog,
                                 b = s.isMeshStandardMaterial ? y.environment : null,
                                 w = (s.isMeshStandardMaterial ? n : e).get(s.envMap || b),
                                 S = x[s.type],
                                 E = _.isSkinnedMesh ? function(t) {
                                     const e = t.skeleton.bones;
                                     if (m) return 1024; {
@@ -6918,15 +7205,15 @@
                                             n = Math.floor((t - 20) / 4),
                                             i = Math.min(n, e.length);
                                         return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                                     }
                                 }(_) : 0;
                             let T, A, R, L;
                             if (null !== s.precision && (v = r.getMaxPrecision(s.precision), v !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", v, "instead.")), S) {
-                                const t = wi[S];
+                                const t = Ir[S];
                                 T = t.vertexShader, A = t.fragmentShader
                             } else T = s.vertexShader, A = s.fragmentShader, l.update(s), R = l.getVertexShaderID(s), L = l.getFragmentShaderID(s);
                             const C = t.getRenderTarget(),
                                 P = s.alphaTest > 0,
                                 D = s.clearcoat > 0;
                             return {
                                 isWebGL2: d,
@@ -6939,28 +7226,28 @@
                                 customFragmentShaderID: L,
                                 isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                                 glslVersion: s.glslVersion,
                                 precision: v,
                                 instancing: !0 === _.isInstancedMesh,
                                 instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
                                 supportsVertexTextures: g,
-                                outputEncoding: null === C ? t.outputEncoding : !0 === C.isXRRenderTarget ? C.texture.encoding : ot,
+                                outputEncoding: null === C ? t.outputEncoding : !0 === C.isXRRenderTarget ? C.texture.encoding : me,
                                 map: !!s.map,
                                 matcap: !!s.matcap,
                                 envMap: !!w,
                                 envMapMode: w && w.mapping,
-                                envMapCubeUV: !!w && (w.mapping === c || w.mapping === h),
+                                envMapCubeUV: !!w && (w.mapping === nt || w.mapping === it),
                                 lightMap: !!s.lightMap,
                                 aoMap: !!s.aoMap,
                                 emissiveMap: !!s.emissiveMap,
                                 bumpMap: !!s.bumpMap,
                                 normalMap: !!s.normalMap,
-                                objectSpaceNormalMap: 1 === s.normalMapType,
-                                tangentSpaceNormalMap: 0 === s.normalMapType,
-                                decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === lt,
+                                objectSpaceNormalMap: s.normalMapType === xe,
+                                tangentSpaceNormalMap: s.normalMapType === ve,
+                                decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === fe,
                                 clearcoat: D,
                                 clearcoatMap: D && !!s.clearcoatMap,
                                 clearcoatRoughnessMap: D && !!s.clearcoatRoughnessMap,
                                 clearcoatNormalMap: D && !!s.clearcoatNormalMap,
                                 displacementMap: !!s.displacementMap,
                                 roughnessMap: !!s.roughnessMap,
                                 metalnessMap: !!s.metalnessMap,
@@ -7002,21 +7289,21 @@
                                 numHemiLights: o.hemi.length,
                                 numDirLightShadows: o.directionalShadowMap.length,
                                 numPointLightShadows: o.pointShadowMap.length,
                                 numSpotLightShadows: o.spotShadowMap.length,
                                 numClippingPlanes: a.numPlanes,
                                 numClipIntersection: a.numIntersection,
                                 dithering: s.dithering,
-                                shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
+                                shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                                 shadowMapType: t.shadowMap.type,
-                                toneMapping: s.toneMapped ? t.toneMapping : 0,
+                                toneMapping: s.toneMapped ? t.toneMapping : j,
                                 physicallyCorrectLights: t.physicallyCorrectLights,
                                 premultipliedAlpha: s.premultipliedAlpha,
-                                doubleSided: 2 === s.side,
-                                flipSided: 1 === s.side,
+                                doubleSided: s.side === u,
+                                flipSided: s.side === h,
                                 depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                                 index0AttributeName: s.index0AttributeName,
                                 extensionDerivatives: s.extensions && s.extensions.derivatives,
                                 extensionFragDepth: s.extensions && s.extensions.fragDepth,
                                 extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                                 extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                                 rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
@@ -7035,47 +7322,47 @@
                                 o.disableAll(), e.isWebGL2 && o.enable(0), e.supportsVertexTextures && o.enable(1), e.instancing && o.enable(2), e.instancingColor && o.enable(3), e.map && o.enable(4), e.matcap && o.enable(5), e.envMap && o.enable(6), e.envMapCubeUV && o.enable(7), e.lightMap && o.enable(8), e.aoMap && o.enable(9), e.emissiveMap && o.enable(10), e.bumpMap && o.enable(11), e.normalMap && o.enable(12), e.objectSpaceNormalMap && o.enable(13), e.tangentSpaceNormalMap && o.enable(14), e.clearcoat && o.enable(15), e.clearcoatMap && o.enable(16), e.clearcoatRoughnessMap && o.enable(17), e.clearcoatNormalMap && o.enable(18), e.displacementMap && o.enable(19), e.specularMap && o.enable(20), e.roughnessMap && o.enable(21), e.metalnessMap && o.enable(22), e.gradientMap && o.enable(23), e.alphaMap && o.enable(24), e.alphaTest && o.enable(25), e.vertexColors && o.enable(26), e.vertexAlphas && o.enable(27), e.vertexUvs && o.enable(28), e.vertexTangents && o.enable(29), e.uvsVertexOnly && o.enable(30), e.fog && o.enable(31), t.push(o.mask), o.disableAll(), e.useFog && o.enable(0), e.flatShading && o.enable(1), e.logarithmicDepthBuffer && o.enable(2), e.skinning && o.enable(3), e.useVertexTexture && o.enable(4), e.morphTargets && o.enable(5), e.morphNormals && o.enable(6), e.premultipliedAlpha && o.enable(7), e.shadowMapEnabled && o.enable(8), e.physicallyCorrectLights && o.enable(9), e.doubleSided && o.enable(10), e.flipSided && o.enable(11), e.depthPacking && o.enable(12), e.dithering && o.enable(13), e.specularIntensityMap && o.enable(14), e.specularColorMap && o.enable(15), e.transmission && o.enable(16), e.transmissionMap && o.enable(17), e.thicknessMap && o.enable(18), e.sheen && o.enable(19), e.sheenColorMap && o.enable(20), e.sheenRoughnessMap && o.enable(21), e.decodeVideoTexture && o.enable(22), t.push(o.mask)
                             }(n, e), n.push(t.outputEncoding)), n.push(e.customProgramCacheKey), n.join()
                         },
                         getUniforms: function(t) {
                             const e = x[t.type];
                             let n;
                             if (e) {
-                                const t = wi[e];
-                                n = ii.clone(t.uniforms)
+                                const t = Ir[e];
+                                n = pr.clone(t.uniforms)
                             } else n = t.uniforms;
                             return n
                         },
                         acquireProgram: function(e, n) {
                             let i;
-                            for (let t = 0, e = u.length; t < e; t++) {
-                                const e = u[t];
+                            for (let t = 0, e = c.length; t < e; t++) {
+                                const e = c[t];
                                 if (e.cacheKey === n) {
                                     i = e, ++i.usedTimes;
                                     break
                                 }
                             }
-                            return void 0 === i && (i = new Ls(t, n, e, s), u.push(i)), i
+                            return void 0 === i && (i = new Ga(t, n, e, s), c.push(i)), i
                         },
                         releaseProgram: function(t) {
                             if (0 == --t.usedTimes) {
-                                const e = u.indexOf(t);
-                                u[e] = u[u.length - 1], u.pop(), t.destroy()
+                                const e = c.indexOf(t);
+                                c[e] = c[c.length - 1], c.pop(), t.destroy()
                             }
                         },
                         releaseShaderCache: function(t) {
                             l.remove(t)
                         },
-                        programs: u,
+                        programs: c,
                         dispose: function() {
                             l.dispose()
                         }
                     }
                 }
 
-                function Ns() {
+                function Xa() {
                     let t = new WeakMap;
                     return {
                         get: function(e) {
                             let n = t.get(e);
                             return void 0 === n && (n = {}, t.set(e, n)), n
                         },
                         remove: function(e) {
@@ -7086,23 +7373,23 @@
                         },
                         dispose: function() {
                             t = new WeakMap
                         }
                     }
                 }
 
-                function Os(t, e) {
+                function qa(t, e) {
                     return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                 }
 
-                function Us(t, e) {
+                function Ya(t, e) {
                     return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                 }
 
-                function Bs() {
+                function Ja() {
                     const t = [];
                     let e = 0;
                     const n = [],
                         i = [],
                         r = [];
 
                     function s(n, i, r, s, a, o) {
@@ -7137,113 +7424,113 @@
                             for (let n = e, i = t.length; n < i; n++) {
                                 const e = t[n];
                                 if (null === e.id) break;
                                 e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                             }
                         },
                         sort: function(t, e) {
-                            n.length > 1 && n.sort(t || Os), i.length > 1 && i.sort(e || Us), r.length > 1 && r.sort(e || Us)
+                            n.length > 1 && n.sort(t || qa), i.length > 1 && i.sort(e || Ya), r.length > 1 && r.sort(e || Ya)
                         }
                     }
                 }
 
-                function Fs() {
+                function Za() {
                     let t = new WeakMap;
                     return {
                         get: function(e, n) {
                             let i;
-                            return !1 === t.has(e) ? (i = new Bs, t.set(e, [i])) : n >= t.get(e).length ? (i = new Bs, t.get(e).push(i)) : i = t.get(e)[n], i
+                            return !1 === t.has(e) ? (i = new Ja, t.set(e, [i])) : n >= t.get(e).length ? (i = new Ja, t.get(e).push(i)) : i = t.get(e)[n], i
                         },
                         dispose: function() {
                             t = new WeakMap
                         }
                     }
                 }
 
-                function zs() {
+                function Ka() {
                     const t = {};
                     return {
                         get: function(e) {
                             if (void 0 !== t[e.id]) return t[e.id];
                             let n;
                             switch (e.type) {
                                 case "DirectionalLight":
                                     n = {
-                                        direction: new Zt,
-                                        color: new zt
+                                        direction: new on,
+                                        color: new Je
                                     };
                                     break;
                                 case "SpotLight":
                                     n = {
-                                        position: new Zt,
-                                        direction: new Zt,
-                                        color: new zt,
+                                        position: new on,
+                                        direction: new on,
+                                        color: new Je,
                                         distance: 0,
                                         coneCos: 0,
                                         penumbraCos: 0,
                                         decay: 0
                                     };
                                     break;
                                 case "PointLight":
                                     n = {
-                                        position: new Zt,
-                                        color: new zt,
+                                        position: new on,
+                                        color: new Je,
                                         distance: 0,
                                         decay: 0
                                     };
                                     break;
                                 case "HemisphereLight":
                                     n = {
-                                        direction: new Zt,
-                                        skyColor: new zt,
-                                        groundColor: new zt
+                                        direction: new on,
+                                        skyColor: new Je,
+                                        groundColor: new Je
                                     };
                                     break;
                                 case "RectAreaLight":
                                     n = {
-                                        color: new zt,
-                                        position: new Zt,
-                                        halfWidth: new Zt,
-                                        halfHeight: new Zt
+                                        color: new Je,
+                                        position: new on,
+                                        halfWidth: new on,
+                                        halfHeight: new on
                                     }
                             }
                             return t[e.id] = n, n
                         }
                     }
                 }
-                let Hs = 0;
+                let Qa = 0;
 
-                function Gs(t, e) {
+                function $a(t, e) {
                     return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
                 }
 
-                function Vs(t, e) {
-                    const n = new zs,
+                function to(t, e) {
+                    const n = new Ka,
                         i = function() {
                             const t = {};
                             return {
                                 get: function(e) {
                                     if (void 0 !== t[e.id]) return t[e.id];
                                     let n;
                                     switch (e.type) {
                                         case "DirectionalLight":
                                         case "SpotLight":
                                             n = {
                                                 shadowBias: 0,
                                                 shadowNormalBias: 0,
                                                 shadowRadius: 1,
-                                                shadowMapSize: new At
+                                                shadowMapSize: new Be
                                             };
                                             break;
                                         case "PointLight":
                                             n = {
                                                 shadowBias: 0,
                                                 shadowNormalBias: 0,
                                                 shadowRadius: 1,
-                                                shadowMapSize: new At,
+                                                shadowMapSize: new Be,
                                                 shadowCameraNear: 1,
                                                 shadowCameraFar: 1e3
                                             }
                                     }
                                     return t[e.id] = n, n
                                 }
                             }
@@ -7275,33 +7562,33 @@
                             rectAreaLTC2: null,
                             point: [],
                             pointShadow: [],
                             pointShadowMap: [],
                             pointShadowMatrix: [],
                             hemi: []
                         };
-                    for (let t = 0; t < 9; t++) r.probe.push(new Zt);
-                    const s = new Zt,
-                        a = new Ae,
-                        o = new Ae;
+                    for (let t = 0; t < 9; t++) r.probe.push(new on);
+                    const s = new on,
+                        a = new Fn,
+                        o = new Fn;
                     return {
                         setup: function(s, a) {
                             let o = 0,
                                 l = 0,
                                 c = 0;
                             for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                             let h = 0,
                                 u = 0,
                                 d = 0,
                                 p = 0,
                                 m = 0,
                                 f = 0,
                                 g = 0,
                                 v = 0;
-                            s.sort(Gs);
+                            s.sort($a);
                             const x = !0 !== a ? Math.PI : 1;
                             for (let t = 0, e = s.length; t < e; t++) {
                                 const e = s[t],
                                     a = e.color,
                                     y = e.intensity,
                                     _ = e.distance,
                                     M = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
@@ -7336,17 +7623,17 @@
                                     }
                                     r.point[u] = t, u++
                                 } else if (e.isHemisphereLight) {
                                     const t = n.get(e);
                                     t.skyColor.copy(e.color).multiplyScalar(y * x), t.groundColor.copy(e.groundColor).multiplyScalar(y * x), r.hemi[m] = t, m++
                                 }
                             }
-                            p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = bi.LTC_FLOAT_1, r.rectAreaLTC2 = bi.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = bi.LTC_HALF_1, r.rectAreaLTC2 = bi.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
+                            p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Dr.LTC_FLOAT_1, r.rectAreaLTC2 = Dr.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Dr.LTC_HALF_1, r.rectAreaLTC2 = Dr.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
                             const y = r.hash;
-                            y.directionalLength === h && y.pointLength === u && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === m && y.numDirectionalShadows === f && y.numPointShadows === g && y.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, y.directionalLength = h, y.pointLength = u, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = m, y.numDirectionalShadows = f, y.numPointShadows = g, y.numSpotShadows = v, r.version = Hs++)
+                            y.directionalLength === h && y.pointLength === u && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === m && y.numDirectionalShadows === f && y.numPointShadows === g && y.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, y.directionalLength = h, y.pointLength = u, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = m, y.numDirectionalShadows = f, y.numPointShadows = g, y.numSpotShadows = v, r.version = Qa++)
                         },
                         setupView: function(t, e) {
                             let n = 0,
                                 i = 0,
                                 l = 0,
                                 c = 0,
                                 h = 0;
@@ -7371,16 +7658,16 @@
                                 }
                             }
                         },
                         state: r
                     }
                 }
 
-                function ks(t, e) {
-                    const n = new Vs(t, e),
+                function eo(t, e) {
+                    const n = new to(t, e),
                         i = [],
                         r = [];
                     return {
                         init: function() {
                             i.length = 0, r.length = 0
                         },
                         state: {
@@ -7399,182 +7686,185 @@
                         },
                         pushShadow: function(t) {
                             r.push(t)
                         }
                     }
                 }
 
-                function Ws(t, e) {
+                function no(t, e) {
                     let n = new WeakMap;
                     return {
                         get: function(i, r = 0) {
                             let s;
-                            return !1 === n.has(i) ? (s = new ks(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new ks(t, e), n.get(i).push(s)) : s = n.get(i)[r], s
+                            return !1 === n.has(i) ? (s = new eo(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new eo(t, e), n.get(i).push(s)) : s = n.get(i)[r], s
                         },
                         dispose: function() {
                             n = new WeakMap
                         }
                     }
                 }
-                class js extends dn {
+                class io extends bi {
                     constructor(t) {
                         super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                     }
                 }
-                js.prototype.isMeshDepthMaterial = !0;
-                class Xs extends dn {
+                io.prototype.isMeshDepthMaterial = !0;
+                class ro extends bi {
                     constructor(t) {
-                        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Zt, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
+                        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new on, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                     }
                 }
-
-                function qs(t, e, n) {
-                    let i = new vi;
-                    const r = new At,
-                        s = new At,
-                        a = new jt,
-                        o = new js({
-                            depthPacking: 3201
+                ro.prototype.isMeshDistanceMaterial = !0;
+                const so = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
+                    ao = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
+
+                function oo(t, e, n) {
+                    let i = new Ar;
+                    const r = new Be,
+                        s = new Be,
+                        o = new en,
+                        p = new io({
+                            depthPacking: ge
                         }),
-                        l = new Xs,
-                        c = {},
-                        h = n.maxTextureSize,
-                        u = {
-                            0: 1,
-                            1: 0,
-                            2: 2
+                        m = new ro,
+                        f = {},
+                        g = n.maxTextureSize,
+                        v = {
+                            0: h,
+                            1: c,
+                            2: u
                         },
-                        d = new ri({
+                        x = new mr({
                             defines: {
                                 VSM_SAMPLES: 8
                             },
                             uniforms: {
                                 shadow_pass: {
                                     value: null
                                 },
                                 resolution: {
-                                    value: new At
+                                    value: new Be
                                 },
                                 radius: {
                                     value: 4
                                 }
                             },
-                            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
-                            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
+                            vertexShader: so,
+                            fragmentShader: ao
                         }),
-                        p = d.clone();
-                    p.defines.HORIZONTAL_PASS = 1;
-                    const f = new Nn;
-                    f.setAttribute("position", new gn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
-                    const g = new Qn(f, d),
-                        x = this;
-
-                    function y(n, i) {
-                        const r = e.update(g);
-                        d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, d, g, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, p, g, null)
-                    }
-
-                    function _(e, n, i, r, s, a, h) {
-                        let d = null;
-                        const p = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
-                        if (d = void 0 !== p ? p : !0 === r.isPointLight ? l : o, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
-                            const t = d.uuid,
+                        y = x.clone();
+                    y.defines.HORIZONTAL_PASS = 1;
+                    const _ = new Wi;
+                    _.setAttribute("position", new Ti(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
+                    const M = new lr(_, x),
+                        b = this;
+
+                    function w(n, i) {
+                        const r = e.update(M);
+                        x.defines.VSM_SAMPLES !== n.blurSamples && (x.defines.VSM_SAMPLES = n.blurSamples, y.defines.VSM_SAMPLES = n.blurSamples, x.needsUpdate = !0, y.needsUpdate = !0), x.uniforms.shadow_pass.value = n.map.texture, x.uniforms.resolution.value = n.mapSize, x.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, x, M, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, y, M, null)
+                    }
+
+                    function S(e, n, i, r, s, a, o) {
+                        let c = null;
+                        const h = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
+                        if (c = void 0 !== h ? h : !0 === r.isPointLight ? m : p, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
+                            const t = c.uuid,
                                 e = i.uuid;
-                            let n = c[t];
-                            void 0 === n && (n = {}, c[t] = n);
+                            let n = f[t];
+                            void 0 === n && (n = {}, f[t] = n);
                             let r = n[e];
-                            void 0 === r && (r = d.clone(), n[e] = r), d = r
+                            void 0 === r && (r = c.clone(), n[e] = r), c = r
                         }
-                        return d.visible = i.visible, d.wireframe = i.wireframe, d.side = 3 === h ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], d.alphaMap = i.alphaMap, d.alphaTest = i.alphaTest, d.clipShadows = i.clipShadows, d.clippingPlanes = i.clippingPlanes, d.clipIntersection = i.clipIntersection, d.displacementMap = i.displacementMap, d.displacementScale = i.displacementScale, d.displacementBias = i.displacementBias, d.wireframeLinewidth = i.wireframeLinewidth, d.linewidth = i.linewidth, !0 === r.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(r.matrixWorld), d.nearDistance = s, d.farDistance = a), d
+                        return c.visible = i.visible, c.wireframe = i.wireframe, c.side = o === l ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : v[i.side], c.alphaMap = i.alphaMap, c.alphaTest = i.alphaTest, c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.displacementMap = i.displacementMap, c.displacementScale = i.displacementScale, c.displacementBias = i.displacementBias, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld), c.nearDistance = s, c.farDistance = a), c
                     }
 
-                    function M(n, r, s, a, o) {
+                    function E(n, r, s, a, o) {
                         if (!1 === n.visible) return;
-                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
+                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && o === l) && (!n.frustumCulled || i.intersectsObject(n))) {
                             n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                             const i = e.update(n),
                                 r = n.material;
                             if (Array.isArray(r)) {
                                 const e = i.groups;
                                 for (let l = 0, c = e.length; l < c; l++) {
                                     const c = e[l],
                                         h = r[c.materialIndex];
                                     if (h && h.visible) {
-                                        const e = _(n, 0, h, a, s.near, s.far, o);
+                                        const e = S(n, 0, h, a, s.near, s.far, o);
                                         t.renderBufferDirect(s, null, i, e, n, c)
                                     }
                                 }
                             } else if (r.visible) {
-                                const e = _(n, 0, r, a, s.near, s.far, o);
+                                const e = S(n, 0, r, a, s.near, s.far, o);
                                 t.renderBufferDirect(s, null, i, e, n, null)
                             }
                         }
-                        const l = n.children;
-                        for (let t = 0, e = l.length; t < e; t++) M(l[t], r, s, a, o)
+                        const c = n.children;
+                        for (let t = 0, e = c.length; t < e; t++) E(c[t], r, s, a, o)
                     }
-                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, n, o) {
-                        if (!1 === x.enabled) return;
-                        if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
+                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = a, this.render = function(e, n, a) {
+                        if (!1 === b.enabled) return;
+                        if (!1 === b.autoUpdate && !1 === b.needsUpdate) return;
                         if (0 === e.length) return;
-                        const l = t.getRenderTarget(),
-                            c = t.getActiveCubeFace(),
+                        const c = t.getRenderTarget(),
+                            h = t.getActiveCubeFace(),
                             u = t.getActiveMipmapLevel(),
-                            d = t.state;
-                        d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
-                        for (let l = 0, c = e.length; l < c; l++) {
-                            const c = e[l],
-                                u = c.shadow;
+                            p = t.state;
+                        p.setBlending(d), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
+                        for (let c = 0, h = e.length; c < h; c++) {
+                            const h = e[c],
+                                u = h.shadow;
                             if (void 0 === u) {
-                                console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
+                                console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
                                 continue
                             }
                             if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                             r.copy(u.mapSize);
-                            const p = u.getFrameExtents();
-                            if (r.multiply(p), s.copy(u.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / p.x), r.x = s.x * p.x, u.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / p.y), r.y = s.y * p.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && 3 === this.type) {
+                            const d = u.getFrameExtents();
+                            if (r.multiply(d), s.copy(u.mapSize), (r.x > g || r.y > g) && (r.x > g && (s.x = Math.floor(g / d.x), r.x = s.x * d.x, u.mapSize.x = s.x), r.y > g && (s.y = Math.floor(g / d.y), r.y = s.y * d.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && this.type === l) {
                                 const t = {
-                                    minFilter: v,
-                                    magFilter: v,
-                                    format: T
+                                    minFilter: ht,
+                                    magFilter: ht,
+                                    format: Et
                                 };
-                                u.map = new Xt(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new Xt(r.x, r.y, t), u.camera.updateProjectionMatrix()
+                                u.map = new nn(r.x, r.y, t), u.map.texture.name = h.name + ".shadowMap", u.mapPass = new nn(r.x, r.y, t), u.camera.updateProjectionMatrix()
                             }
                             if (null === u.map) {
                                 const t = {
-                                    minFilter: m,
-                                    magFilter: m,
-                                    format: T
+                                    minFilter: ot,
+                                    magFilter: ot,
+                                    format: Et
                                 };
-                                u.map = new Xt(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix()
+                                u.map = new nn(r.x, r.y, t), u.map.texture.name = h.name + ".shadowMap", u.camera.updateProjectionMatrix()
                             }
                             t.setRenderTarget(u.map), t.clear();
-                            const f = u.getViewportCount();
-                            for (let t = 0; t < f; t++) {
+                            const m = u.getViewportCount();
+                            for (let t = 0; t < m; t++) {
                                 const e = u.getViewport(t);
-                                a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(a), u.updateMatrices(c, t), i = u.getFrustum(), M(n, o, u.camera, c, this.type)
+                                o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), p.viewport(o), u.updateMatrices(h, t), i = u.getFrustum(), E(n, a, u.camera, h, this.type)
                             }
-                            u.isPointLightShadow || 3 !== this.type || y(u, o), u.needsUpdate = !1
+                            u.isPointLightShadow || this.type !== l || w(u, a), u.needsUpdate = !1
                         }
-                        x.needsUpdate = !1, t.setRenderTarget(l, c, u)
+                        b.needsUpdate = !1, t.setRenderTarget(c, h, u)
                     }
                 }
 
-                function Ys(t, e, n) {
-                    const r = n.isWebGL2,
-                        s = new function() {
+                function lo(t, e, n) {
+                    const a = n.isWebGL2,
+                        o = new function() {
                             let e = !1;
-                            const n = new jt;
+                            const n = new en;
                             let i = null;
-                            const r = new jt(0, 0, 0, 0);
+                            const r = new en(0, 0, 0, 0);
                             return {
                                 setMask: function(n) {
                                     i === n || e || (t.colorMask(n, n, n, n), i = n)
                                 },
                                 setLocked: function(t) {
                                     e = t
                                 },
@@ -7582,53 +7872,55 @@
                                     !0 === o && (e *= a, i *= a, s *= a), n.set(e, i, s, a), !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n))
                                 },
                                 reset: function() {
                                     e = !1, i = null, r.set(-1, 0, 0, 0)
                                 }
                             }
                         },
-                        a = new function() {
+                        l = new function() {
                             let e = !1,
                                 n = null,
                                 i = null,
                                 r = null;
                             return {
                                 setTest: function(e) {
-                                    e ? z(t.DEPTH_TEST) : H(t.DEPTH_TEST)
+                                    e ? yt(t.DEPTH_TEST) : _t(t.DEPTH_TEST)
                                 },
                                 setMask: function(i) {
                                     n === i || e || (t.depthMask(i), n = i)
                                 },
                                 setFunc: function(e) {
                                     if (i !== e) {
                                         if (e) switch (e) {
-                                            case 0:
+                                            case N:
                                                 t.depthFunc(t.NEVER);
                                                 break;
-                                            case 1:
+                                            case O:
                                                 t.depthFunc(t.ALWAYS);
                                                 break;
-                                            case 2:
+                                            case U:
                                                 t.depthFunc(t.LESS);
                                                 break;
-                                            case 3:
-                                            default:
+                                            case B:
                                                 t.depthFunc(t.LEQUAL);
                                                 break;
-                                            case 4:
+                                            case F:
                                                 t.depthFunc(t.EQUAL);
                                                 break;
-                                            case 5:
+                                            case z:
                                                 t.depthFunc(t.GEQUAL);
                                                 break;
-                                            case 6:
+                                            case H:
                                                 t.depthFunc(t.GREATER);
                                                 break;
-                                            case 7:
-                                                t.depthFunc(t.NOTEQUAL)
+                                            case G:
+                                                t.depthFunc(t.NOTEQUAL);
+                                                break;
+                                            default:
+                                                t.depthFunc(t.LEQUAL)
                                         } else t.depthFunc(t.LEQUAL);
                                         i = e
                                     }
                                 },
                                 setLocked: function(t) {
                                     e = t
                                 },
@@ -7636,27 +7928,27 @@
                                     r !== e && (t.clearDepth(e), r = e)
                                 },
                                 reset: function() {
                                     e = !1, n = null, i = null, r = null
                                 }
                             }
                         },
-                        o = new function() {
+                        c = new function() {
                             let e = !1,
                                 n = null,
                                 i = null,
                                 r = null,
                                 s = null,
                                 a = null,
                                 o = null,
                                 l = null,
                                 c = null;
                             return {
                                 setTest: function(n) {
-                                    e || (n ? z(t.STENCIL_TEST) : H(t.STENCIL_TEST))
+                                    e || (n ? yt(t.STENCIL_TEST) : _t(t.STENCIL_TEST))
                                 },
                                 setMask: function(i) {
                                     n === i || e || (t.stencilMask(i), n = i)
                                 },
                                 setFunc: function(e, n, a) {
                                     i === e && r === n && s === a || (t.stencilFunc(e, n, a), i = e, r = n, s = a)
                                 },
@@ -7670,196 +7962,196 @@
                                     c !== e && (t.clearStencil(e), c = e)
                                 },
                                 reset: function() {
                                     e = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null
                                 }
                             }
                         };
-                    let l = {},
-                        c = {},
-                        h = new WeakMap,
-                        u = [],
-                        d = null,
-                        p = !1,
-                        m = null,
-                        f = null,
-                        g = null,
-                        v = null,
-                        x = null,
-                        y = null,
-                        _ = null,
-                        M = !1,
-                        b = null,
-                        w = null,
-                        S = null,
-                        E = null,
-                        T = null;
-                    const A = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
-                    let R = !1,
-                        L = 0;
-                    const C = t.getParameter(t.VERSION); - 1 !== C.indexOf("WebGL") ? (L = parseFloat(/^WebGL (\d)/.exec(C)[1]), R = L >= 1) : -1 !== C.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL ES (\d)/.exec(C)[1]), R = L >= 2);
-                    let P = null,
-                        D = {};
-                    const I = t.getParameter(t.SCISSOR_BOX),
-                        N = t.getParameter(t.VIEWPORT),
-                        O = (new jt).fromArray(I),
-                        U = (new jt).fromArray(N);
+                    let V = {},
+                        k = {},
+                        W = new WeakMap,
+                        j = [],
+                        X = null,
+                        q = !1,
+                        Y = null,
+                        J = null,
+                        Z = null,
+                        K = null,
+                        Q = null,
+                        $ = null,
+                        tt = null,
+                        et = !1,
+                        nt = null,
+                        it = null,
+                        rt = null,
+                        st = null,
+                        at = null;
+                    const ot = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
+                    let lt = !1,
+                        ct = 0;
+                    const ht = t.getParameter(t.VERSION); - 1 !== ht.indexOf("WebGL") ? (ct = parseFloat(/^WebGL (\d)/.exec(ht)[1]), lt = ct >= 1) : -1 !== ht.indexOf("OpenGL ES") && (ct = parseFloat(/^OpenGL ES (\d)/.exec(ht)[1]), lt = ct >= 2);
+                    let ut = null,
+                        dt = {};
+                    const pt = t.getParameter(t.SCISSOR_BOX),
+                        mt = t.getParameter(t.VIEWPORT),
+                        ft = (new en).fromArray(pt),
+                        gt = (new en).fromArray(mt);
 
-                    function B(e, n, i) {
+                    function vt(e, n, i) {
                         const r = new Uint8Array(4),
                             s = t.createTexture();
                         t.bindTexture(e, s), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                         for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
                         return s
                     }
-                    const F = {};
+                    const xt = {};
 
-                    function z(e) {
-                        !0 !== l[e] && (t.enable(e), l[e] = !0)
+                    function yt(e) {
+                        !0 !== V[e] && (t.enable(e), V[e] = !0)
                     }
 
-                    function H(e) {
-                        !1 !== l[e] && (t.disable(e), l[e] = !1)
+                    function _t(e) {
+                        !1 !== V[e] && (t.disable(e), V[e] = !1)
                     }
-                    F[t.TEXTURE_2D] = B(t.TEXTURE_2D, t.TEXTURE_2D, 1), F[t.TEXTURE_CUBE_MAP] = B(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), s.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), z(t.DEPTH_TEST), a.setFunc(3), W(!1), j(1), z(t.CULL_FACE), k(0);
-                    const G = {
-                        [i]: t.FUNC_ADD,
-                        101: t.FUNC_SUBTRACT,
-                        102: t.FUNC_REVERSE_SUBTRACT
+                    xt[t.TEXTURE_2D] = vt(t.TEXTURE_2D, t.TEXTURE_2D, 1), xt[t.TEXTURE_CUBE_MAP] = vt(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), o.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), yt(t.DEPTH_TEST), l.setFunc(B), St(!1), Et(r), yt(t.CULL_FACE), wt(d);
+                    const Mt = {
+                        [x]: t.FUNC_ADD,
+                        [y]: t.FUNC_SUBTRACT,
+                        [_]: t.FUNC_REVERSE_SUBTRACT
                     };
-                    if (r) G[103] = t.MIN, G[104] = t.MAX;
+                    if (a) Mt[M] = t.MIN, Mt[b] = t.MAX;
                     else {
                         const t = e.get("EXT_blend_minmax");
-                        null !== t && (G[103] = t.MIN_EXT, G[104] = t.MAX_EXT)
+                        null !== t && (Mt[M] = t.MIN_EXT, Mt[b] = t.MAX_EXT)
                     }
-                    const V = {
-                        200: t.ZERO,
-                        201: t.ONE,
-                        202: t.SRC_COLOR,
-                        204: t.SRC_ALPHA,
-                        210: t.SRC_ALPHA_SATURATE,
-                        208: t.DST_COLOR,
-                        206: t.DST_ALPHA,
-                        203: t.ONE_MINUS_SRC_COLOR,
-                        205: t.ONE_MINUS_SRC_ALPHA,
-                        209: t.ONE_MINUS_DST_COLOR,
-                        207: t.ONE_MINUS_DST_ALPHA
+                    const bt = {
+                        [w]: t.ZERO,
+                        [S]: t.ONE,
+                        [E]: t.SRC_COLOR,
+                        [A]: t.SRC_ALPHA,
+                        [I]: t.SRC_ALPHA_SATURATE,
+                        [P]: t.DST_COLOR,
+                        [L]: t.DST_ALPHA,
+                        [T]: t.ONE_MINUS_SRC_COLOR,
+                        [R]: t.ONE_MINUS_SRC_ALPHA,
+                        [D]: t.ONE_MINUS_DST_COLOR,
+                        [C]: t.ONE_MINUS_DST_ALPHA
                     };
 
-                    function k(e, n, r, s, a, o, l, c) {
-                        if (0 !== e) {
-                            if (!1 === p && (z(t.BLEND), p = !0), 5 === e) a = a || n, o = o || r, l = l || s, n === f && a === x || (t.blendEquationSeparate(G[n], G[a]), f = n, x = a), r === g && s === v && o === y && l === _ || (t.blendFuncSeparate(V[r], V[s], V[o], V[l]), g = r, v = s, y = o, _ = l), m = e, M = null;
-                            else if (e !== m || c !== M) {
-                                if (f === i && x === i || (t.blendEquation(t.FUNC_ADD), f = i, x = i), c) switch (e) {
-                                    case 1:
+                    function wt(e, n, i, r, s, a, o, l) {
+                        if (e !== d) {
+                            if (!1 === q && (yt(t.BLEND), q = !0), e === v) s = s || n, a = a || i, o = o || r, n === J && s === Q || (t.blendEquationSeparate(Mt[n], Mt[s]), J = n, Q = s), i === Z && r === K && a === $ && o === tt || (t.blendFuncSeparate(bt[i], bt[r], bt[a], bt[o]), Z = i, K = r, $ = a, tt = o), Y = e, et = null;
+                            else if (e !== Y || l !== et) {
+                                if (J === x && Q === x || (t.blendEquation(t.FUNC_ADD), J = x, Q = x), l) switch (e) {
+                                    case p:
                                         t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                         break;
-                                    case 2:
+                                    case m:
                                         t.blendFunc(t.ONE, t.ONE);
                                         break;
-                                    case 3:
+                                    case f:
                                         t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                         break;
-                                    case 4:
+                                    case g:
                                         t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                         break;
                                     default:
                                         console.error("THREE.WebGLState: Invalid blending: ", e)
                                 } else switch (e) {
-                                    case 1:
+                                    case p:
                                         t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                         break;
-                                    case 2:
+                                    case m:
                                         t.blendFunc(t.SRC_ALPHA, t.ONE);
                                         break;
-                                    case 3:
+                                    case f:
                                         t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                         break;
-                                    case 4:
+                                    case g:
                                         t.blendFunc(t.ZERO, t.SRC_COLOR);
                                         break;
                                     default:
                                         console.error("THREE.WebGLState: Invalid blending: ", e)
                                 }
-                                g = null, v = null, y = null, _ = null, m = e, M = c
+                                Z = null, K = null, $ = null, tt = null, Y = e, et = l
                             }
-                        } else !0 === p && (H(t.BLEND), p = !1)
+                        } else !0 === q && (_t(t.BLEND), q = !1)
                     }
 
-                    function W(e) {
-                        b !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), b = e)
+                    function St(e) {
+                        nt !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), nt = e)
                     }
 
-                    function j(e) {
-                        0 !== e ? (z(t.CULL_FACE), e !== w && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : H(t.CULL_FACE), w = e
+                    function Et(e) {
+                        e !== i ? (yt(t.CULL_FACE), e !== it && (e === r ? t.cullFace(t.BACK) : e === s ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : _t(t.CULL_FACE), it = e
                     }
 
-                    function X(e, n, i) {
-                        e ? (z(t.POLYGON_OFFSET_FILL), E === n && T === i || (t.polygonOffset(n, i), E = n, T = i)) : H(t.POLYGON_OFFSET_FILL)
+                    function Tt(e, n, i) {
+                        e ? (yt(t.POLYGON_OFFSET_FILL), st === n && at === i || (t.polygonOffset(n, i), st = n, at = i)) : _t(t.POLYGON_OFFSET_FILL)
                     }
 
-                    function q(e) {
-                        void 0 === e && (e = t.TEXTURE0 + A - 1), P !== e && (t.activeTexture(e), P = e)
+                    function At(e) {
+                        void 0 === e && (e = t.TEXTURE0 + ot - 1), ut !== e && (t.activeTexture(e), ut = e)
                     }
                     return {
                         buffers: {
-                            color: s,
-                            depth: a,
-                            stencil: o
+                            color: o,
+                            depth: l,
+                            stencil: c
                         },
-                        enable: z,
-                        disable: H,
+                        enable: yt,
+                        disable: _t,
                         bindFramebuffer: function(e, n) {
-                            return c[e] !== n && (t.bindFramebuffer(e, n), c[e] = n, r && (e === t.DRAW_FRAMEBUFFER && (c[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (c[t.DRAW_FRAMEBUFFER] = n)), !0)
+                            return k[e] !== n && (t.bindFramebuffer(e, n), k[e] = n, a && (e === t.DRAW_FRAMEBUFFER && (k[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (k[t.DRAW_FRAMEBUFFER] = n)), !0)
                         },
                         drawBuffers: function(i, r) {
-                            let s = u,
+                            let s = j,
                                 a = !1;
                             if (i)
-                                if (s = h.get(r), void 0 === s && (s = [], h.set(r, s)), i.isWebGLMultipleRenderTargets) {
+                                if (s = W.get(r), void 0 === s && (s = [], W.set(r, s)), i.isWebGLMultipleRenderTargets) {
                                     const e = i.texture;
                                     if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
                                         for (let n = 0, i = e.length; n < i; n++) s[n] = t.COLOR_ATTACHMENT0 + n;
                                         s.length = e.length, a = !0
                                     }
                                 } else s[0] !== t.COLOR_ATTACHMENT0 && (s[0] = t.COLOR_ATTACHMENT0, a = !0);
                             else s[0] !== t.BACK && (s[0] = t.BACK, a = !0);
                             a && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                         },
                         useProgram: function(e) {
-                            return d !== e && (t.useProgram(e), d = e, !0)
+                            return X !== e && (t.useProgram(e), X = e, !0)
                         },
-                        setBlending: k,
+                        setBlending: wt,
                         setMaterial: function(e, n) {
-                            2 === e.side ? H(t.CULL_FACE) : z(t.CULL_FACE);
-                            let i = 1 === e.side;
-                            n && (i = !i), W(i), 1 === e.blending && !1 === e.transparent ? k(0) : k(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), s.setMask(e.colorWrite);
+                            e.side === u ? _t(t.CULL_FACE) : yt(t.CULL_FACE);
+                            let i = e.side === h;
+                            n && (i = !i), St(i), e.blending === p && !1 === e.transparent ? wt(d) : wt(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), l.setFunc(e.depthFunc), l.setTest(e.depthTest), l.setMask(e.depthWrite), o.setMask(e.colorWrite);
                             const r = e.stencilWrite;
-                            o.setTest(r), r && (o.setMask(e.stencilWriteMask), o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), X(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? z(t.SAMPLE_ALPHA_TO_COVERAGE) : H(t.SAMPLE_ALPHA_TO_COVERAGE)
+                            c.setTest(r), r && (c.setMask(e.stencilWriteMask), c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Tt(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? yt(t.SAMPLE_ALPHA_TO_COVERAGE) : _t(t.SAMPLE_ALPHA_TO_COVERAGE)
                         },
-                        setFlipSided: W,
-                        setCullFace: j,
+                        setFlipSided: St,
+                        setCullFace: Et,
                         setLineWidth: function(e) {
-                            e !== S && (R && t.lineWidth(e), S = e)
+                            e !== rt && (lt && t.lineWidth(e), rt = e)
                         },
-                        setPolygonOffset: X,
+                        setPolygonOffset: Tt,
                         setScissorTest: function(e) {
-                            e ? z(t.SCISSOR_TEST) : H(t.SCISSOR_TEST)
+                            e ? yt(t.SCISSOR_TEST) : _t(t.SCISSOR_TEST)
                         },
-                        activeTexture: q,
+                        activeTexture: At,
                         bindTexture: function(e, n) {
-                            null === P && q();
-                            let i = D[P];
+                            null === ut && At();
+                            let i = dt[ut];
                             void 0 === i && (i = {
                                 type: void 0,
                                 texture: void 0
-                            }, D[P] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || F[e]), i.type = e, i.texture = n)
+                            }, dt[ut] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || xt[e]), i.type = e, i.texture = n)
                         },
                         unbindTexture: function() {
-                            const e = D[P];
+                            const e = dt[ut];
                             void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                         },
                         compressedTexImage2D: function() {
                             try {
                                 t.compressedTexImage2D.apply(t, arguments)
                             } catch (t) {
                                 console.error("THREE.WebGLState:", t)
@@ -7911,100 +8203,100 @@
                             try {
                                 t.compressedTexSubImage2D.apply(t, arguments)
                             } catch (t) {
                                 console.error("THREE.WebGLState:", t)
                             }
                         },
                         scissor: function(e) {
-                            !1 === O.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), O.copy(e))
+                            !1 === ft.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ft.copy(e))
                         },
                         viewport: function(e) {
-                            !1 === U.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), U.copy(e))
+                            !1 === gt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), gt.copy(e))
                         },
                         reset: function() {
-                            t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), !0 === r && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), l = {}, P = null, D = {}, c = {}, h = new WeakMap, u = [], d = null, p = !1, m = null, f = null, g = null, v = null, x = null, y = null, _ = null, M = !1, b = null, w = null, S = null, E = null, T = null, O.set(0, 0, t.canvas.width, t.canvas.height), U.set(0, 0, t.canvas.width, t.canvas.height), s.reset(), a.reset(), o.reset()
+                            t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), !0 === a && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), V = {}, ut = null, dt = {}, k = {}, W = new WeakMap, j = [], X = null, q = !1, Y = null, J = null, Z = null, K = null, Q = null, $ = null, tt = null, et = !1, nt = null, it = null, rt = null, st = null, at = null, ft.set(0, 0, t.canvas.width, t.canvas.height), gt.set(0, 0, t.canvas.width, t.canvas.height), o.reset(), l.reset(), c.reset()
                         }
                     }
                 }
 
-                function Js(t, e, n, i, r, s, a) {
+                function co(t, e, n, i, r, s, a) {
                     const o = r.isWebGL2,
                         l = r.maxTextures,
                         c = r.maxCubemapSize,
                         h = r.maxTextureSize,
-                        L = r.maxSamples,
-                        C = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
-                        P = new WeakMap;
-                    let D, I = !1;
+                        u = r.maxSamples,
+                        d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
+                        p = new WeakMap;
+                    let m, f = !1;
                     try {
-                        I = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
+                        f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                     } catch (t) {}
 
-                    function N(t, e) {
-                        return I ? new OffscreenCanvas(t, e) : Dt("canvas")
+                    function g(t, e) {
+                        return f ? new OffscreenCanvas(t, e) : Ve("canvas")
                     }
 
-                    function O(t, e, n, i) {
+                    function v(t, e, n, i) {
                         let r = 1;
                         if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                             if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
-                                const i = e ? Et : Math.floor,
+                                const i = e ? Oe : Math.floor,
                                     s = i(r * t.width),
                                     a = i(r * t.height);
-                                void 0 === D && (D = N(s, a));
-                                const o = n ? N(s, a) : D;
+                                void 0 === m && (m = g(s, a));
+                                const o = n ? g(s, a) : m;
                                 return o.width = s, o.height = a, o.getContext("2d").drawImage(t, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."), o
                             }
                             return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                         }
                         return t
                     }
 
-                    function U(t) {
-                        return wt(t.width) && wt(t.height)
+                    function x(t) {
+                        return Ie(t.width) && Ie(t.height)
                     }
 
-                    function B(t, e) {
-                        return t.generateMipmaps && e && t.minFilter !== m && t.minFilter !== v
+                    function y(t, e) {
+                        return t.generateMipmaps && e && t.minFilter !== ot && t.minFilter !== ht
                     }
 
-                    function F(e) {
+                    function _(e) {
                         t.generateMipmap(e)
                     }
 
-                    function z(n, i, r, s, a = !1) {
+                    function M(n, i, r, s, a = !1) {
                         if (!1 === o) return i;
                         if (null !== n) {
                             if (void 0 !== t[n]) return t[n];
                             console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                         }
                         let l = i;
-                        return i === t.RED && (r === t.FLOAT && (l = t.R32F), r === t.HALF_FLOAT && (l = t.R16F), r === t.UNSIGNED_BYTE && (l = t.R8)), i === t.RG && (r === t.FLOAT && (l = t.RG32F), r === t.HALF_FLOAT && (l = t.RG16F), r === t.UNSIGNED_BYTE && (l = t.RG8)), i === t.RGBA && (r === t.FLOAT && (l = t.RGBA32F), r === t.HALF_FLOAT && (l = t.RGBA16F), r === t.UNSIGNED_BYTE && (l = s === lt && !1 === a ? t.SRGB8_ALPHA8 : t.RGBA8), r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4), r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)), l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"), l
+                        return i === t.RED && (r === t.FLOAT && (l = t.R32F), r === t.HALF_FLOAT && (l = t.R16F), r === t.UNSIGNED_BYTE && (l = t.R8)), i === t.RG && (r === t.FLOAT && (l = t.RG32F), r === t.HALF_FLOAT && (l = t.RG16F), r === t.UNSIGNED_BYTE && (l = t.RG8)), i === t.RGBA && (r === t.FLOAT && (l = t.RGBA32F), r === t.HALF_FLOAT && (l = t.RGBA16F), r === t.UNSIGNED_BYTE && (l = s === fe && !1 === a ? t.SRGB8_ALPHA8 : t.RGBA8), r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4), r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)), l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"), l
                     }
 
-                    function H(t, e, n) {
-                        return !0 === B(t, n) || t.isFramebufferTexture && t.minFilter !== m && t.minFilter !== v ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
+                    function b(t, e, n) {
+                        return !0 === y(t, n) || t.isFramebufferTexture && t.minFilter !== ot && t.minFilter !== ht ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
                     }
 
-                    function G(e) {
-                        return e === m || e === f || e === g ? t.NEAREST : t.LINEAR
+                    function w(e) {
+                        return e === ot || e === lt || e === ct ? t.NEAREST : t.LINEAR
                     }
 
-                    function V(e) {
+                    function S(e) {
                         const n = e.target;
-                        n.removeEventListener("dispose", V),
+                        n.removeEventListener("dispose", S),
                             function(e) {
                                 const n = i.get(e);
                                 void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e))
-                            }(n), n.isVideoTexture && P.delete(n), a.memory.textures--
+                            }(n), n.isVideoTexture && p.delete(n), a.memory.textures--
                     }
 
-                    function k(e) {
+                    function E(e) {
                         const n = e.target;
-                        n.removeEventListener("dispose", k),
+                        n.removeEventListener("dispose", E),
                             function(e) {
                                 const n = e.texture,
                                     r = i.get(e),
                                     s = i.get(n);
                                 if (e) {
                                     if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), a.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                         for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
@@ -8014,233 +8306,233 @@
                                             const r = i.get(n[e]);
                                             r.__webglTexture && (t.deleteTexture(r.__webglTexture), a.memory.textures--), i.remove(n[e])
                                         }
                                     i.remove(n), i.remove(e)
                                 }
                             }(n)
                     }
-                    let W = 0;
+                    let T = 0;
 
-                    function j(e, r) {
+                    function A(e, r) {
                         const s = i.get(e);
                         if (e.isVideoTexture && function(t) {
                                 const e = a.render.frame;
-                                P.get(t) !== e && (P.set(t, e), t.update())
+                                p.get(t) !== e && (p.set(t, e), t.update())
                             }(e), e.version > 0 && s.__version !== e.version) {
                             const t = e.image;
                             if (void 0 === t) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                             else {
-                                if (!1 !== t.complete) return void K(s, e, r);
+                                if (!1 !== t.complete) return void I(s, e, r);
                                 console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                             }
                         }
                         n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D, s.__webglTexture)
                     }
 
-                    function X(e, r) {
+                    function R(e, r) {
                         const a = i.get(e);
                         e.version > 0 && a.__version !== e.version ? function(e, i, r) {
                             if (6 !== i.image.length) return;
-                            Z(e, i), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
+                            D(e, i), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                             const a = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                                 l = i.image[0] && i.image[0].isDataTexture,
                                 h = [];
-                            for (let t = 0; t < 6; t++) h[t] = a || l ? l ? i.image[t].image : i.image[t] : O(i.image[t], !1, !0, c), h[t] = nt(i, h[t]);
+                            for (let t = 0; t < 6; t++) h[t] = a || l ? l ? i.image[t].image : i.image[t] : v(i.image[t], !1, !0, c), h[t] = F(i, h[t]);
                             const u = h[0],
-                                d = U(u) || o,
+                                d = x(u) || o,
                                 p = s.convert(i.format, i.encoding),
                                 m = s.convert(i.type),
-                                f = z(i.internalFormat, p, m, i.encoding),
+                                f = M(i.internalFormat, p, m, i.encoding),
                                 g = o && !0 !== i.isVideoTexture,
-                                v = void 0 === e.__version;
-                            let x, y = H(i, u, d);
-                            if (J(t.TEXTURE_CUBE_MAP, i, d), a) {
-                                g && v && n.texStorage2D(t.TEXTURE_CUBE_MAP, y, f, u.width, u.height);
+                                w = void 0 === e.__version;
+                            let S, E = b(i, u, d);
+                            if (P(t.TEXTURE_CUBE_MAP, i, d), a) {
+                                g && w && n.texStorage2D(t.TEXTURE_CUBE_MAP, E, f, u.width, u.height);
                                 for (let e = 0; e < 6; e++) {
-                                    x = h[e].mipmaps;
-                                    for (let r = 0; r < x.length; r++) {
-                                        const s = x[r];
-                                        i.format !== T ? null !== p ? g ? n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, s.width, s.height, p, s.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, f, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, s.width, s.height, p, m, s.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, f, s.width, s.height, 0, p, m, s.data)
+                                    S = h[e].mipmaps;
+                                    for (let r = 0; r < S.length; r++) {
+                                        const s = S[r];
+                                        i.format !== Et ? null !== p ? g ? n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, s.width, s.height, p, s.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, f, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, s.width, s.height, p, m, s.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, f, s.width, s.height, 0, p, m, s.data)
                                     }
                                 }
                             } else {
-                                x = i.mipmaps, g && v && (x.length > 0 && y++, n.texStorage2D(t.TEXTURE_CUBE_MAP, y, f, h[0].width, h[0].height));
+                                S = i.mipmaps, g && w && (S.length > 0 && E++, n.texStorage2D(t.TEXTURE_CUBE_MAP, E, f, h[0].width, h[0].height));
                                 for (let e = 0; e < 6; e++)
                                     if (l) {
                                         g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, h[e].width, h[e].height, p, m, h[e].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, f, h[e].width, h[e].height, 0, p, m, h[e].data);
-                                        for (let i = 0; i < x.length; i++) {
-                                            const r = x[i].image[e].image;
+                                        for (let i = 0; i < S.length; i++) {
+                                            const r = S[i].image[e].image;
                                             g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, r.width, r.height, p, m, r.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, f, r.width, r.height, 0, p, m, r.data)
                                         }
                                     } else {
                                         g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, p, m, h[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, f, p, m, h[e]);
-                                        for (let i = 0; i < x.length; i++) {
-                                            const r = x[i];
+                                        for (let i = 0; i < S.length; i++) {
+                                            const r = S[i];
                                             g ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, p, m, r.image[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, f, p, m, r.image[e])
                                         }
                                     }
                             }
-                            B(i, d) && F(t.TEXTURE_CUBE_MAP), e.__version = i.version, i.onUpdate && i.onUpdate(i)
+                            y(i, d) && _(t.TEXTURE_CUBE_MAP), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                         }(a, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture))
                     }
-                    const q = {
-                            [u]: t.REPEAT,
-                            [d]: t.CLAMP_TO_EDGE,
-                            [p]: t.MIRRORED_REPEAT
-                        },
-                        Y = {
-                            [m]: t.NEAREST,
-                            [f]: t.NEAREST_MIPMAP_NEAREST,
-                            [g]: t.NEAREST_MIPMAP_LINEAR,
-                            [v]: t.LINEAR,
-                            [x]: t.LINEAR_MIPMAP_NEAREST,
-                            [y]: t.LINEAR_MIPMAP_LINEAR
+                    const L = {
+                            [rt]: t.REPEAT,
+                            [st]: t.CLAMP_TO_EDGE,
+                            [at]: t.MIRRORED_REPEAT
+                        },
+                        C = {
+                            [ot]: t.NEAREST,
+                            [lt]: t.NEAREST_MIPMAP_NEAREST,
+                            [ct]: t.NEAREST_MIPMAP_LINEAR,
+                            [ht]: t.LINEAR,
+                            [ut]: t.LINEAR_MIPMAP_NEAREST,
+                            [dt]: t.LINEAR_MIPMAP_LINEAR
                         };
 
-                    function J(n, s, a) {
-                        if (a ? (t.texParameteri(n, t.TEXTURE_WRAP_S, q[s.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, q[s.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, q[s.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, Y[s.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, Y[s.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), s.wrapS === d && s.wrapT === d || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, G(s.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, G(s.minFilter)), s.minFilter !== m && s.minFilter !== v && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
+                    function P(n, s, a) {
+                        if (a ? (t.texParameteri(n, t.TEXTURE_WRAP_S, L[s.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, L[s.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, L[s.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, C[s.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, C[s.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), s.wrapS === st && s.wrapT === st || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, w(s.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, w(s.minFilter)), s.minFilter !== ot && s.minFilter !== ht && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                             const a = e.get("EXT_texture_filter_anisotropic");
-                            if (s.type === w && !1 === e.has("OES_texture_float_linear")) return;
-                            if (!1 === o && s.type === S && !1 === e.has("OES_texture_half_float_linear")) return;
+                            if (s.type === yt && !1 === e.has("OES_texture_float_linear")) return;
+                            if (!1 === o && s.type === _t && !1 === e.has("OES_texture_half_float_linear")) return;
                             (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                         }
                     }
 
-                    function Z(e, n) {
-                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", V), e.__webglTexture = t.createTexture(), a.memory.textures++)
+                    function D(e, n) {
+                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", S), e.__webglTexture = t.createTexture(), a.memory.textures++)
                     }
 
-                    function K(e, i, r) {
+                    function I(e, i, r) {
                         let a = t.TEXTURE_2D;
-                        i.isDataTexture2DArray && (a = t.TEXTURE_2D_ARRAY), i.isDataTexture3D && (a = t.TEXTURE_3D), Z(e, i), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(a, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
+                        i.isDataTexture2DArray && (a = t.TEXTURE_2D_ARRAY), i.isDataTexture3D && (a = t.TEXTURE_3D), D(e, i), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(a, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                         const l = function(t) {
-                            return !o && (t.wrapS !== d || t.wrapT !== d || t.minFilter !== m && t.minFilter !== v)
-                        }(i) && !1 === U(i.image);
-                        let c = O(i.image, l, !1, h);
-                        c = nt(i, c);
-                        const u = U(c) || o,
-                            p = s.convert(i.format, i.encoding);
-                        let f, g = s.convert(i.type),
-                            x = z(i.internalFormat, p, g, i.encoding, i.isVideoTexture);
-                        J(a, i, u);
-                        const y = i.mipmaps,
-                            _ = o && !0 !== i.isVideoTexture,
+                            return !o && (t.wrapS !== st || t.wrapT !== st || t.minFilter !== ot && t.minFilter !== ht)
+                        }(i) && !1 === x(i.image);
+                        let c = v(i.image, l, !1, h);
+                        c = F(i, c);
+                        const u = x(c) || o,
+                            d = s.convert(i.format, i.encoding);
+                        let p, m = s.convert(i.type),
+                            f = M(i.internalFormat, d, m, i.encoding, i.isVideoTexture);
+                        P(a, i, u);
+                        const g = i.mipmaps,
+                            w = o && !0 !== i.isVideoTexture,
                             S = void 0 === e.__version,
-                            L = H(i, c, u);
-                        if (i.isDepthTexture) x = t.DEPTH_COMPONENT, o ? x = i.type === w ? t.DEPTH_COMPONENT32F : i.type === b ? t.DEPTH_COMPONENT24 : i.type === E ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : i.type === w && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === A && x === t.DEPTH_COMPONENT && i.type !== M && i.type !== b && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = M, g = s.convert(i.type)), i.format === R && x === t.DEPTH_COMPONENT && (x = t.DEPTH_STENCIL, i.type !== E && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = E, g = s.convert(i.type))), _ && S ? n.texStorage2D(t.TEXTURE_2D, 1, x, c.width, c.height) : n.texImage2D(t.TEXTURE_2D, 0, x, c.width, c.height, 0, p, g, null);
+                            E = b(i, c, u);
+                        if (i.isDepthTexture) f = t.DEPTH_COMPONENT, o ? f = i.type === yt ? t.DEPTH_COMPONENT32F : i.type === xt ? t.DEPTH_COMPONENT24 : i.type === wt ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : i.type === yt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Rt && f === t.DEPTH_COMPONENT && i.type !== gt && i.type !== xt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = gt, m = s.convert(i.type)), i.format === Lt && f === t.DEPTH_COMPONENT && (f = t.DEPTH_STENCIL, i.type !== wt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = wt, m = s.convert(i.type))), w && S ? n.texStorage2D(t.TEXTURE_2D, 1, f, c.width, c.height) : n.texImage2D(t.TEXTURE_2D, 0, f, c.width, c.height, 0, d, m, null);
                         else if (i.isDataTexture)
-                            if (y.length > 0 && u) {
-                                _ && S && n.texStorage2D(t.TEXTURE_2D, L, x, y[0].width, y[0].height);
-                                for (let e = 0, i = y.length; e < i; e++) f = y[e], _ ? n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, f.width, f.height, p, g, f.data) : n.texImage2D(t.TEXTURE_2D, e, x, f.width, f.height, 0, p, g, f.data);
+                            if (g.length > 0 && u) {
+                                w && S && n.texStorage2D(t.TEXTURE_2D, E, f, g[0].width, g[0].height);
+                                for (let e = 0, i = g.length; e < i; e++) p = g[e], w ? n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, p.width, p.height, d, m, p.data) : n.texImage2D(t.TEXTURE_2D, e, f, p.width, p.height, 0, d, m, p.data);
                                 i.generateMipmaps = !1
-                            } else _ ? (S && n.texStorage2D(t.TEXTURE_2D, L, x, c.width, c.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, c.width, c.height, p, g, c.data)) : n.texImage2D(t.TEXTURE_2D, 0, x, c.width, c.height, 0, p, g, c.data);
+                            } else w ? (S && n.texStorage2D(t.TEXTURE_2D, E, f, c.width, c.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, c.width, c.height, d, m, c.data)) : n.texImage2D(t.TEXTURE_2D, 0, f, c.width, c.height, 0, d, m, c.data);
                         else if (i.isCompressedTexture) {
-                            _ && S && n.texStorage2D(t.TEXTURE_2D, L, x, y[0].width, y[0].height);
-                            for (let e = 0, r = y.length; e < r; e++) f = y[e], i.format !== T ? null !== p ? _ ? n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, f.width, f.height, p, f.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, x, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _ ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, f.width, f.height, p, g, f.data) : n.texImage2D(t.TEXTURE_2D, e, x, f.width, f.height, 0, p, g, f.data)
-                        } else if (i.isDataTexture2DArray) _ ? (S && n.texStorage3D(t.TEXTURE_2D_ARRAY, L, x, c.width, c.height, c.depth), n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, c.width, c.height, c.depth, p, g, c.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, x, c.width, c.height, c.depth, 0, p, g, c.data);
-                        else if (i.isDataTexture3D) _ ? (S && n.texStorage3D(t.TEXTURE_3D, L, x, c.width, c.height, c.depth), n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, c.width, c.height, c.depth, p, g, c.data)) : n.texImage3D(t.TEXTURE_3D, 0, x, c.width, c.height, c.depth, 0, p, g, c.data);
-                        else if (i.isFramebufferTexture) _ && S ? n.texStorage2D(t.TEXTURE_2D, L, x, c.width, c.height) : n.texImage2D(t.TEXTURE_2D, 0, x, c.width, c.height, 0, p, g, null);
-                        else if (y.length > 0 && u) {
-                            _ && S && n.texStorage2D(t.TEXTURE_2D, L, x, y[0].width, y[0].height);
-                            for (let e = 0, i = y.length; e < i; e++) f = y[e], _ ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, p, g, f) : n.texImage2D(t.TEXTURE_2D, e, x, p, g, f);
+                            w && S && n.texStorage2D(t.TEXTURE_2D, E, f, g[0].width, g[0].height);
+                            for (let e = 0, r = g.length; e < r; e++) p = g[e], i.format !== Et ? null !== d ? w ? n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, p.width, p.height, d, p.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : w ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, p.width, p.height, d, m, p.data) : n.texImage2D(t.TEXTURE_2D, e, f, p.width, p.height, 0, d, m, p.data)
+                        } else if (i.isDataTexture2DArray) w ? (S && n.texStorage3D(t.TEXTURE_2D_ARRAY, E, f, c.width, c.height, c.depth), n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, c.width, c.height, c.depth, d, m, c.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, f, c.width, c.height, c.depth, 0, d, m, c.data);
+                        else if (i.isDataTexture3D) w ? (S && n.texStorage3D(t.TEXTURE_3D, E, f, c.width, c.height, c.depth), n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, c.width, c.height, c.depth, d, m, c.data)) : n.texImage3D(t.TEXTURE_3D, 0, f, c.width, c.height, c.depth, 0, d, m, c.data);
+                        else if (i.isFramebufferTexture) w && S ? n.texStorage2D(t.TEXTURE_2D, E, f, c.width, c.height) : n.texImage2D(t.TEXTURE_2D, 0, f, c.width, c.height, 0, d, m, null);
+                        else if (g.length > 0 && u) {
+                            w && S && n.texStorage2D(t.TEXTURE_2D, E, f, g[0].width, g[0].height);
+                            for (let e = 0, i = g.length; e < i; e++) p = g[e], w ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, d, m, p) : n.texImage2D(t.TEXTURE_2D, e, f, d, m, p);
                             i.generateMipmaps = !1
-                        } else _ ? (S && n.texStorage2D(t.TEXTURE_2D, L, x, c.width, c.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, p, g, c)) : n.texImage2D(t.TEXTURE_2D, 0, x, p, g, c);
-                        B(i, u) && F(a), e.__version = i.version, i.onUpdate && i.onUpdate(i)
+                        } else w ? (S && n.texStorage2D(t.TEXTURE_2D, E, f, c.width, c.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, d, m, c)) : n.texImage2D(t.TEXTURE_2D, 0, f, d, m, c);
+                        y(i, u) && _(a), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                     }
 
-                    function Q(e, r, a, o, l) {
+                    function N(e, r, a, o, l) {
                         const c = s.convert(a.format, a.encoding),
                             h = s.convert(a.type),
-                            u = z(a.internalFormat, c, h, a.encoding);
-                        i.get(r).__hasExternalTextures || (l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(t.FRAMEBUFFER, e), r.useRenderToTexture ? C.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, o, l, i.get(a).__webglTexture, 0, et(r)) : t.framebufferTexture2D(t.FRAMEBUFFER, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(t.FRAMEBUFFER, null)
+                            u = M(a.internalFormat, c, h, a.encoding);
+                        i.get(r).__hasExternalTextures || (l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(t.FRAMEBUFFER, e), r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, o, l, i.get(a).__webglTexture, 0, B(r)) : t.framebufferTexture2D(t.FRAMEBUFFER, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(t.FRAMEBUFFER, null)
                     }
 
-                    function $(e, n, i) {
+                    function O(e, n, i) {
                         if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
                             let r = t.DEPTH_COMPONENT16;
                             if (i || n.useRenderToTexture) {
                                 const e = n.depthTexture;
-                                e && e.isDepthTexture && (e.type === w ? r = t.DEPTH_COMPONENT32F : e.type === b && (r = t.DEPTH_COMPONENT24));
-                                const i = et(n);
-                                n.useRenderToTexture ? C.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height)
+                                e && e.isDepthTexture && (e.type === yt ? r = t.DEPTH_COMPONENT32F : e.type === xt && (r = t.DEPTH_COMPONENT24));
+                                const i = B(n);
+                                n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height)
                             } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
                             t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
                         } else if (n.depthBuffer && n.stencilBuffer) {
-                            const r = et(n);
-                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : n.useRenderToTexture ? C.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
+                            const r = B(n);
+                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
                         } else {
                             const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                                 r = s.convert(e.format, e.encoding),
                                 a = s.convert(e.type),
-                                o = z(e.internalFormat, r, a, e.encoding),
-                                l = et(n);
-                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, l, o, n.width, n.height) : n.useRenderToTexture ? C.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, l, o, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, o, n.width, n.height)
+                                o = M(e.internalFormat, r, a, e.encoding),
+                                l = B(n);
+                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, l, o, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, l, o, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, o, n.width, n.height)
                         }
                         t.bindRenderbuffer(t.RENDERBUFFER, null)
                     }
 
-                    function tt(e) {
+                    function U(e) {
                         const r = i.get(e),
                             s = !0 === e.isWebGLCubeRenderTarget;
                         if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                             if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                             ! function(e, r) {
                                 if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                 if (n.bindFramebuffer(t.FRAMEBUFFER, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
-                                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), j(r.depthTexture, 0);
+                                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), A(r.depthTexture, 0);
                                 const s = i.get(r.depthTexture).__webglTexture,
-                                    a = et(r);
-                                if (r.depthTexture.format === A) r.useRenderToTexture ? C.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);
+                                    a = B(r);
+                                if (r.depthTexture.format === Rt) r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);
                                 else {
-                                    if (r.depthTexture.format !== R) throw new Error("Unknown depthTexture format");
-                                    r.useRenderToTexture ? C.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0)
+                                    if (r.depthTexture.format !== Lt) throw new Error("Unknown depthTexture format");
+                                    r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0)
                                 }
                             }(r.__webglFramebuffer, e)
                         } else if (s) {
                             r.__webglDepthbuffer = [];
-                            for (let i = 0; i < 6; i++) n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), $(r.__webglDepthbuffer[i], e, !1)
-                        } else n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), $(r.__webglDepthbuffer, e, !1);
+                            for (let i = 0; i < 6; i++) n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), O(r.__webglDepthbuffer[i], e, !1)
+                        } else n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), O(r.__webglDepthbuffer, e, !1);
                         n.bindFramebuffer(t.FRAMEBUFFER, null)
                     }
 
-                    function et(t) {
-                        return o && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(L, t.samples) : 0
+                    function B(t) {
+                        return o && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(u, t.samples) : 0
                     }
 
-                    function nt(t, n) {
+                    function F(t, n) {
                         const i = t.encoding,
                             r = t.format,
                             s = t.type;
-                        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === pt || i !== ot && (i === lt ? !1 === o ? !0 === e.has("EXT_sRGB") && r === T ? (t.format = pt, t.minFilter = v, t.generateMipmaps = !1) : n = Gt.sRGBToLinear(n) : r === T && s === _ || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n
+                        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === we || i !== me && (i === fe ? !1 === o ? !0 === e.has("EXT_sRGB") && r === Et ? (t.format = we, t.minFilter = ht, t.generateMipmaps = !1) : n = Ke.sRGBToLinear(n) : r === Et && s === pt || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n
                     }
-                    let it = !1,
-                        rt = !1;
+                    let z = !1,
+                        H = !1;
                     this.allocateTextureUnit = function() {
-                        const t = W;
-                        return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), W += 1, t
+                        const t = T;
+                        return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), T += 1, t
                     }, this.resetTextureUnits = function() {
-                        W = 0
-                    }, this.setTexture2D = j, this.setTexture2DArray = function(e, r) {
+                        T = 0
+                    }, this.setTexture2D = A, this.setTexture2DArray = function(e, r) {
                         const s = i.get(e);
-                        e.version > 0 && s.__version !== e.version ? K(s, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture))
+                        e.version > 0 && s.__version !== e.version ? I(s, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture))
                     }, this.setTexture3D = function(e, r) {
                         const s = i.get(e);
-                        e.version > 0 && s.__version !== e.version ? K(s, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_3D, s.__webglTexture))
-                    }, this.setTextureCube = X, this.rebindTextures = function(e, n, r) {
+                        e.version > 0 && s.__version !== e.version ? I(s, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_3D, s.__webglTexture))
+                    }, this.setTextureCube = R, this.rebindTextures = function(e, n, r) {
                         const s = i.get(e);
-                        void 0 !== n && Q(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), void 0 !== r && tt(e)
+                        void 0 !== n && N(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), void 0 !== r && U(e)
                     }, this.setupRenderTarget = function(e) {
                         const l = e.texture,
                             c = i.get(e),
                             h = i.get(l);
-                        e.addEventListener("dispose", k), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()), h.__version = l.version, a.memory.textures++);
+                        e.addEventListener("dispose", E), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()), h.__version = l.version, a.memory.textures++);
                         const u = !0 === e.isWebGLCubeRenderTarget,
                             d = !0 === e.isWebGLMultipleRenderTargets,
                             p = l.isDataTexture3D || l.isDataTexture2DArray,
-                            m = U(e) || o;
+                            m = x(e) || o;
                         if (u) {
                             c.__webglFramebuffer = [];
                             for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
                         } else if (c.__webglFramebuffer = t.createFramebuffer(), d)
                             if (r.drawBuffers) {
                                 const n = e.texture;
                                 for (let e = 0, r = n.length; e < r; e++) {
@@ -8249,173 +8541,172 @@
                                 }
                             } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                         else if (e.useRenderbuffer)
                             if (o) {
                                 c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, c.__webglColorRenderbuffer);
                                 const i = s.convert(l.format, l.encoding),
                                     r = s.convert(l.type),
-                                    a = z(l.internalFormat, i, r, l.encoding),
-                                    o = et(e);
-                                t.renderbufferStorageMultisample(t.RENDERBUFFER, o, a, e.width, e.height), n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, c.__webglColorRenderbuffer), t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), $(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
+                                    a = M(l.internalFormat, i, r, l.encoding),
+                                    o = B(e);
+                                t.renderbufferStorageMultisample(t.RENDERBUFFER, o, a, e.width, e.height), n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, c.__webglColorRenderbuffer), t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), O(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
                             } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                         if (u) {
-                            n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture), J(t.TEXTURE_CUBE_MAP, l, m);
-                            for (let n = 0; n < 6; n++) Q(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n);
-                            B(l, m) && F(t.TEXTURE_CUBE_MAP), n.unbindTexture()
+                            n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture), P(t.TEXTURE_CUBE_MAP, l, m);
+                            for (let n = 0; n < 6; n++) N(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n);
+                            y(l, m) && _(t.TEXTURE_CUBE_MAP), n.unbindTexture()
                         } else if (d) {
                             const r = e.texture;
                             for (let s = 0, a = r.length; s < a; s++) {
                                 const a = r[s],
                                     o = i.get(a);
-                                n.bindTexture(t.TEXTURE_2D, o.__webglTexture), J(t.TEXTURE_2D, a, m), Q(c.__webglFramebuffer, e, a, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D), B(a, m) && F(t.TEXTURE_2D)
+                                n.bindTexture(t.TEXTURE_2D, o.__webglTexture), P(t.TEXTURE_2D, a, m), N(c.__webglFramebuffer, e, a, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D), y(a, m) && _(t.TEXTURE_2D)
                             }
                             n.unbindTexture()
                         } else {
                             let i = t.TEXTURE_2D;
-                            p && (o ? i = l.isDataTexture3D ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(i, h.__webglTexture), J(i, l, m), Q(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i), B(l, m) && F(i), n.unbindTexture()
+                            p && (o ? i = l.isDataTexture3D ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(i, h.__webglTexture), P(i, l, m), N(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i), y(l, m) && _(i), n.unbindTexture()
                         }
-                        e.depthBuffer && tt(e)
+                        e.depthBuffer && U(e)
                     }, this.updateRenderTargetMipmap = function(e) {
-                        const r = U(e) || o,
+                        const r = x(e) || o,
                             s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                         for (let a = 0, o = s.length; a < o; a++) {
                             const o = s[a];
-                            if (B(o, r)) {
+                            if (y(o, r)) {
                                 const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                                     s = i.get(o).__webglTexture;
-                                n.bindTexture(r, s), F(r), n.unbindTexture()
+                                n.bindTexture(r, s), _(r), n.unbindTexture()
                             }
                         }
                     }, this.updateMultisampleRenderTarget = function(e) {
                         if (e.useRenderbuffer)
                             if (o) {
                                 const r = e.width,
                                     s = e.height;
                                 let a = t.COLOR_BUFFER_BIT;
                                 const o = [t.COLOR_ATTACHMENT0],
                                     l = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                                 e.depthBuffer && o.push(l), e.ignoreDepthForMultisampleCopy || (e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && (a |= t.STENCIL_BUFFER_BIT));
                                 const c = i.get(e);
                                 n.bindFramebuffer(t.READ_FRAMEBUFFER, c.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, c.__webglFramebuffer), e.ignoreDepthForMultisampleCopy && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [l]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [l])), t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, t.NEAREST), t.invalidateFramebuffer(t.READ_FRAMEBUFFER, o), n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, c.__webglMultisampledFramebuffer)
                             } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
-                    }, this.setupDepthRenderbuffer = tt, this.setupFrameBufferTexture = Q, this.safeSetTexture2D = function(t, e) {
-                        t && t.isWebGLRenderTarget && (!1 === it && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), it = !0), t = t.texture), j(t, e)
+                    }, this.setupDepthRenderbuffer = U, this.setupFrameBufferTexture = N, this.safeSetTexture2D = function(t, e) {
+                        t && t.isWebGLRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), z = !0), t = t.texture), A(t, e)
                     }, this.safeSetTextureCube = function(t, e) {
-                        t && t.isWebGLCubeRenderTarget && (!1 === rt && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), rt = !0), t = t.texture), X(t, e)
+                        t && t.isWebGLCubeRenderTarget && (!1 === H && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), H = !0), t = t.texture), R(t, e)
                     }
                 }
 
-                function Zs(t, e, n) {
+                function ho(t, e, n) {
                     const i = n.isWebGL2;
                     return {
                         convert: function(n, r = null) {
                             let s;
-                            if (n === _) return t.UNSIGNED_BYTE;
-                            if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
-                            if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
-                            if (1010 === n) return t.BYTE;
-                            if (1011 === n) return t.SHORT;
-                            if (n === M) return t.UNSIGNED_SHORT;
-                            if (1013 === n) return t.INT;
-                            if (n === b) return t.UNSIGNED_INT;
-                            if (n === w) return t.FLOAT;
-                            if (n === S) return i ? t.HALF_FLOAT : (s = e.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
-                            if (1021 === n) return t.ALPHA;
-                            if (n === T) return t.RGBA;
-                            if (1024 === n) return t.LUMINANCE;
-                            if (1025 === n) return t.LUMINANCE_ALPHA;
-                            if (n === A) return t.DEPTH_COMPONENT;
-                            if (n === R) return t.DEPTH_STENCIL;
-                            if (1028 === n) return t.RED;
-                            if (n === pt) return s = e.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
-                            if (1029 === n) return t.RED_INTEGER;
-                            if (1030 === n) return t.RG;
-                            if (1031 === n) return t.RG_INTEGER;
-                            if (1033 === n) return t.RGBA_INTEGER;
-                            if (n === L || n === C || n === P || n === D)
-                                if (r === lt) {
+                            if (n === pt) return t.UNSIGNED_BYTE;
+                            if (n === Mt) return t.UNSIGNED_SHORT_4_4_4_4;
+                            if (n === bt) return t.UNSIGNED_SHORT_5_5_5_1;
+                            if (n === mt) return t.BYTE;
+                            if (n === ft) return t.SHORT;
+                            if (n === gt) return t.UNSIGNED_SHORT;
+                            if (n === vt) return t.INT;
+                            if (n === xt) return t.UNSIGNED_INT;
+                            if (n === yt) return t.FLOAT;
+                            if (n === _t) return i ? t.HALF_FLOAT : (s = e.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
+                            if (n === St) return t.ALPHA;
+                            if (n === Et) return t.RGBA;
+                            if (n === Tt) return t.LUMINANCE;
+                            if (n === At) return t.LUMINANCE_ALPHA;
+                            if (n === Rt) return t.DEPTH_COMPONENT;
+                            if (n === Lt) return t.DEPTH_STENCIL;
+                            if (n === Ct) return t.RED;
+                            if (n === we) return s = e.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
+                            if (n === Pt) return t.RED_INTEGER;
+                            if (n === Dt) return t.RG;
+                            if (n === It) return t.RG_INTEGER;
+                            if (n === Nt) return t.RGBA_INTEGER;
+                            if (n === Ot || n === Ut || n === Bt || n === Ft)
+                                if (r === fe) {
                                     if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
-                                    if (n === L) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
-                                    if (n === C) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
-                                    if (n === P) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
-                                    if (n === D) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
+                                    if (n === Ot) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
+                                    if (n === Ut) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
+                                    if (n === Bt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
+                                    if (n === Ft) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                 } else {
                                     if (s = e.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
-                                    if (n === L) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
-                                    if (n === C) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
-                                    if (n === P) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
-                                    if (n === D) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
-                                } if (n === I || n === N || n === O || n === U) {
+                                    if (n === Ot) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
+                                    if (n === Ut) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
+                                    if (n === Bt) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
+                                    if (n === Ft) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
+                                } if (n === zt || n === Ht || n === Gt || n === Vt) {
                                 if (s = e.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
-                                if (n === I) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
-                                if (n === N) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
-                                if (n === O) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
-                                if (n === U) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
+                                if (n === zt) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
+                                if (n === Ht) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
+                                if (n === Gt) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
+                                if (n === Vt) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                             }
-                            if (36196 === n) return s = e.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
-                            if (n === B || n === F) {
+                            if (n === kt) return s = e.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
+                            if (n === Wt || n === jt) {
                                 if (s = e.get("WEBGL_compressed_texture_etc"), null === s) return null;
-                                if (n === B) return r === lt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
-                                if (n === F) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
+                                if (n === Wt) return r === fe ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
+                                if (n === jt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
                             }
-                            if (n === z || n === H || n === G || n === V || n === k || n === W || n === j || n === X || n === q || n === Y || n === J || n === Z || n === K || n === Q) {
+                            if (n === Xt || n === qt || n === Yt || n === Jt || n === Zt || n === Kt || n === Qt || n === $t || n === te || n === ee || n === ne || n === ie || n === re || n === se) {
                                 if (s = e.get("WEBGL_compressed_texture_astc"), null === s) return null;
-                                if (n === z) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
-                                if (n === H) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
-                                if (n === G) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
-                                if (n === V) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
-                                if (n === k) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
-                                if (n === W) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
-                                if (n === j) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
-                                if (n === X) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
-                                if (n === q) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
-                                if (n === Y) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
-                                if (n === J) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
-                                if (n === Z) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
-                                if (n === K) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
-                                if (n === Q) return r === lt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
+                                if (n === Xt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
+                                if (n === qt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
+                                if (n === Yt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
+                                if (n === Jt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
+                                if (n === Zt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
+                                if (n === Kt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
+                                if (n === Qt) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
+                                if (n === $t) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
+                                if (n === te) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
+                                if (n === ee) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
+                                if (n === ne) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
+                                if (n === ie) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
+                                if (n === re) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
+                                if (n === se) return r === fe ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
                             }
-                            if (n === $) {
+                            if (n === ae) {
                                 if (s = e.get("EXT_texture_compression_bptc"), null === s) return null;
-                                if (n === $) return r === lt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
+                                if (n === ae) return r === fe ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
                             }
-                            return n === E ? i ? t.UNSIGNED_INT_24_8 : (s = e.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0
+                            return n === wt ? i ? t.UNSIGNED_INT_24_8 : (s = e.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                         }
                     }
                 }
-                Xs.prototype.isMeshDistanceMaterial = !0;
-                class Ks extends ai {
+                class uo extends gr {
                     constructor(t = []) {
                         super(), this.cameras = t
                     }
                 }
-                Ks.prototype.isArrayCamera = !0;
-                class Qs extends Qe {
+                uo.prototype.isArrayCamera = !0;
+                class po extends ci {
                     constructor() {
                         super(), this.type = "Group"
                     }
                 }
-                Qs.prototype.isGroup = !0;
-                const $s = {
+                po.prototype.isGroup = !0;
+                const mo = {
                     type: "move"
                 };
-                class ta {
+                class fo {
                     constructor() {
                         this._targetRay = null, this._grip = null, this._hand = null
                     }
                     getHandSpace() {
-                        return null === this._hand && (this._hand = new Qs, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
+                        return null === this._hand && (this._hand = new po, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                             pinching: !1
                         }), this._hand
                     }
                     getTargetRaySpace() {
-                        return null === this._targetRay && (this._targetRay = new Qs, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Zt, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Zt), this._targetRay
+                        return null === this._targetRay && (this._targetRay = new po, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new on, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new on), this._targetRay
                     }
                     getGripSpace() {
-                        return null === this._grip && (this._grip = new Qs, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Zt, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Zt), this._grip
+                        return null === this._grip && (this._grip = new po, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new on, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new on), this._grip
                     }
                     dispatchEvent(t) {
                         return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                     }
                     disconnect(t) {
                         return this.dispatchEvent({
                             type: "disconnected",
@@ -8426,20 +8717,20 @@
                         let i = null,
                             r = null,
                             s = null;
                         const a = this._targetRay,
                             o = this._grip,
                             l = this._hand;
                         if (t && "visible-blurred" !== e.session.visibilityState)
-                            if (null !== a && (i = e.getPose(t.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent($s))), l && t.hand) {
+                            if (null !== a && (i = e.getPose(t.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(mo))), l && t.hand) {
                                 s = !0;
                                 for (const i of t.hand.values()) {
                                     const t = e.getJointPose(i, n);
                                     if (void 0 === l.joints[i.jointName]) {
-                                        const t = new Qs;
+                                        const t = new po;
                                         t.matrixAutoUpdate = !1, t.visible = !1, l.joints[i.jointName] = t, l.add(t)
                                     }
                                     const r = l.joints[i.jointName];
                                     null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
                                 }
                                 const i = l.joints["index-finger-tip"],
                                     r = l.joints["thumb-tip"],
@@ -8455,25 +8746,25 @@
                                     handedness: t.handedness,
                                     target: this
                                 }))
                             } else null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                         return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
                     }
                 }
-                class ea extends kt {
+                class go extends $e {
                     constructor(t, e, n, i, r, s, a, o, l, c) {
-                        if ((c = void 0 !== c ? c : A) !== A && c !== R) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
-                        void 0 === n && c === A && (n = M), void 0 === n && c === R && (n = E), super(null, i, r, s, a, o, c, n, l), this.image = {
+                        if ((c = void 0 !== c ? c : Rt) !== Rt && c !== Lt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
+                        void 0 === n && c === Rt && (n = gt), void 0 === n && c === Lt && (n = wt), super(null, i, r, s, a, o, c, n, l), this.image = {
                             width: t,
                             height: e
-                        }, this.magFilter = void 0 !== a ? a : m, this.minFilter = void 0 !== o ? o : m, this.flipY = !1, this.generateMipmaps = !1
+                        }, this.magFilter = void 0 !== a ? a : ot, this.minFilter = void 0 !== o ? o : ot, this.flipY = !1, this.generateMipmaps = !1
                     }
                 }
-                ea.prototype.isDepthTexture = !0;
-                class na extends mt {
+                go.prototype.isDepthTexture = !0;
+                class vo extends Se {
                     constructor(t, e) {
                         super();
                         const n = this;
                         let i = null,
                             r = 1,
                             s = null,
                             a = "local-floor";
@@ -8485,41 +8776,41 @@
                             d = !1,
                             p = null;
                         const m = e.getContextAttributes();
                         let f = null,
                             g = null;
                         const v = [],
                             x = new Map,
-                            y = new ai;
-                        y.layers.enable(1), y.viewport = new jt;
-                        const b = new ai;
-                        b.layers.enable(2), b.viewport = new jt;
-                        const w = [y, b],
-                            S = new Ks;
-                        S.layers.enable(1), S.layers.enable(2);
-                        let L = null,
-                            C = null;
+                            y = new gr;
+                        y.layers.enable(1), y.viewport = new en;
+                        const _ = new gr;
+                        _.layers.enable(2), _.viewport = new en;
+                        const M = [y, _],
+                            b = new uo;
+                        b.layers.enable(1), b.layers.enable(2);
+                        let w = null,
+                            S = null;
 
-                        function P(t) {
+                        function E(t) {
                             const e = x.get(t.inputSource);
                             e && e.dispatchEvent({
                                 type: t.type,
                                 data: t.inputSource
                             })
                         }
 
-                        function D() {
+                        function T() {
                             x.forEach((function(t, e) {
                                 t.disconnect(e)
-                            })), x.clear(), L = null, C = null, t.setRenderTarget(f), u = null, h = null, c = null, i = null, g = null, F.stop(), n.isPresenting = !1, n.dispatchEvent({
+                            })), x.clear(), w = null, S = null, t.setRenderTarget(f), u = null, h = null, c = null, i = null, g = null, D.stop(), n.isPresenting = !1, n.dispatchEvent({
                                 type: "sessionend"
                             })
                         }
 
-                        function I(t) {
+                        function A(t) {
                             const e = i.inputSources;
                             for (let t = 0; t < v.length; t++) x.set(e[t], v[t]);
                             for (let e = 0; e < t.removed.length; e++) {
                                 const n = t.removed[e],
                                     i = x.get(n);
                                 i && (i.dispatchEvent({
                                     type: "disconnected",
@@ -8533,21 +8824,21 @@
                                     type: "connected",
                                     data: n
                                 })
                             }
                         }
                         this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                             let e = v[t];
-                            return void 0 === e && (e = new ta, v[t] = e), e.getTargetRaySpace()
+                            return void 0 === e && (e = new fo, v[t] = e), e.getTargetRaySpace()
                         }, this.getControllerGrip = function(t) {
                             let e = v[t];
-                            return void 0 === e && (e = new ta, v[t] = e), e.getGripSpace()
+                            return void 0 === e && (e = new fo, v[t] = e), e.getGripSpace()
                         }, this.getHand = function(t) {
                             let e = v[t];
-                            return void 0 === e && (e = new ta, v[t] = e), e.getHandSpace()
+                            return void 0 === e && (e = new fo, v[t] = e), e.getHandSpace()
                         }, this.setFramebufferScaleFactor = function(t) {
                             r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                         }, this.setReferenceSpaceType = function(t) {
                             a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                         }, this.getReferenceSpace = function() {
                             return s
                         }, this.getBaseLayer = function() {
@@ -8556,86 +8847,86 @@
                             return c
                         }, this.getFrame = function() {
                             return p
                         }, this.getSession = function() {
                             return i
                         }, this.setSession = async function(l) {
                             if (i = l, null !== i) {
-                                if (f = t.getRenderTarget(), i.addEventListener("select", P), i.addEventListener("selectstart", P), i.addEventListener("selectend", P), i.addEventListener("squeeze", P), i.addEventListener("squeezestart", P), i.addEventListener("squeezeend", P), i.addEventListener("end", D), i.addEventListener("inputsourceschange", I), !0 !== m.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
+                                if (f = t.getRenderTarget(), i.addEventListener("select", E), i.addEventListener("selectstart", E), i.addEventListener("selectend", E), i.addEventListener("squeeze", E), i.addEventListener("squeezestart", E), i.addEventListener("squeezeend", E), i.addEventListener("end", T), i.addEventListener("inputsourceschange", A), !0 !== m.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                                     const n = {
                                         antialias: void 0 !== i.renderState.layers || m.antialias,
                                         alpha: m.alpha,
                                         depth: m.depth,
                                         stencil: m.stencil,
                                         framebufferScaleFactor: r
                                     };
                                     u = new XRWebGLLayer(i, e, n), i.updateRenderState({
                                         baseLayer: u
-                                    }), g = new Xt(u.framebufferWidth, u.framebufferHeight, {
-                                        format: T,
-                                        type: _,
+                                    }), g = new nn(u.framebufferWidth, u.framebufferHeight, {
+                                        format: Et,
+                                        type: pt,
                                         encoding: t.outputEncoding
                                     })
                                 } else {
                                     d = m.antialias;
                                     let n = null,
                                         s = null,
                                         a = null;
-                                    m.depth && (a = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, n = m.stencil ? R : A, s = m.stencil ? E : M);
+                                    m.depth && (a = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, n = m.stencil ? Lt : Rt, s = m.stencil ? wt : gt);
                                     const l = {
-                                        colorFormat: t.outputEncoding === lt ? e.SRGB8_ALPHA8 : e.RGBA8,
+                                        colorFormat: t.outputEncoding === fe ? e.SRGB8_ALPHA8 : e.RGBA8,
                                         depthFormat: a,
                                         scaleFactor: r
                                     };
                                     c = new XRWebGLBinding(i, e), h = c.createProjectionLayer(l), i.updateRenderState({
                                         layers: [h]
-                                    }), g = d ? new Yt(h.textureWidth, h.textureHeight, {
-                                        format: T,
-                                        type: _,
-                                        depthTexture: new ea(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
+                                    }), g = d ? new sn(h.textureWidth, h.textureHeight, {
+                                        format: Et,
+                                        type: pt,
+                                        depthTexture: new go(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                         stencilBuffer: m.stencil,
                                         ignoreDepth: h.ignoreDepthValues,
                                         useRenderToTexture: o,
                                         encoding: t.outputEncoding
-                                    }) : new Xt(h.textureWidth, h.textureHeight, {
-                                        format: T,
-                                        type: _,
-                                        depthTexture: new ea(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
+                                    }) : new nn(h.textureWidth, h.textureHeight, {
+                                        format: Et,
+                                        type: pt,
+                                        depthTexture: new go(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                         stencilBuffer: m.stencil,
                                         ignoreDepth: h.ignoreDepthValues,
                                         encoding: t.outputEncoding
                                     })
                                 }
-                                g.isXRRenderTarget = !0, this.setFoveation(1), s = await i.requestReferenceSpace(a), F.setContext(i), F.start(), n.isPresenting = !0, n.dispatchEvent({
+                                g.isXRRenderTarget = !0, this.setFoveation(1), s = await i.requestReferenceSpace(a), D.setContext(i), D.start(), n.isPresenting = !0, n.dispatchEvent({
                                     type: "sessionstart"
                                 })
                             }
                         };
-                        const N = new Zt,
-                            O = new Zt;
+                        const R = new on,
+                            L = new on;
 
-                        function U(t, e) {
+                        function C(t, e) {
                             null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                         }
                         this.updateCamera = function(t) {
                             if (null === i) return;
-                            S.near = b.near = y.near = t.near, S.far = b.far = y.far = t.far, L === S.near && C === S.far || (i.updateRenderState({
-                                depthNear: S.near,
-                                depthFar: S.far
-                            }), L = S.near, C = S.far);
+                            b.near = _.near = y.near = t.near, b.far = _.far = y.far = t.far, w === b.near && S === b.far || (i.updateRenderState({
+                                depthNear: b.near,
+                                depthFar: b.far
+                            }), w = b.near, S = b.far);
                             const e = t.parent,
-                                n = S.cameras;
-                            U(S, e);
-                            for (let t = 0; t < n.length; t++) U(n[t], e);
-                            S.matrixWorld.decompose(S.position, S.quaternion, S.scale), t.position.copy(S.position), t.quaternion.copy(S.quaternion), t.scale.copy(S.scale), t.matrix.copy(S.matrix), t.matrixWorld.copy(S.matrixWorld);
+                                n = b.cameras;
+                            C(b, e);
+                            for (let t = 0; t < n.length; t++) C(n[t], e);
+                            b.matrixWorld.decompose(b.position, b.quaternion, b.scale), t.position.copy(b.position), t.quaternion.copy(b.quaternion), t.scale.copy(b.scale), t.matrix.copy(b.matrix), t.matrixWorld.copy(b.matrixWorld);
                             const r = t.children;
                             for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
                             2 === n.length ? function(t, e, n) {
-                                N.setFromMatrixPosition(e.matrixWorld), O.setFromMatrixPosition(n.matrixWorld);
-                                const i = N.distanceTo(O),
+                                R.setFromMatrixPosition(e.matrixWorld), L.setFromMatrixPosition(n.matrixWorld);
+                                const i = R.distanceTo(L),
                                     r = e.projectionMatrix.elements,
                                     s = n.projectionMatrix.elements,
                                     a = r[14] / (r[10] - 1),
                                     o = r[14] / (r[10] + 1),
                                     l = (r[9] + 1) / r[5],
                                     c = (r[9] - 1) / r[5],
                                     h = (r[8] - 1) / r[0],
@@ -8648,87 +8939,87 @@
                                 const g = a + m,
                                     v = o + m,
                                     x = d - f,
                                     y = p + (i - f),
                                     _ = l * o / v * g,
                                     M = c * o / v * g;
                                 t.projectionMatrix.makePerspective(x, y, _, M, g, v)
-                            }(S, y, b) : S.projectionMatrix.copy(y.projectionMatrix)
+                            }(b, y, _) : b.projectionMatrix.copy(y.projectionMatrix)
                         }, this.getCamera = function() {
-                            return S
+                            return b
                         }, this.getFoveation = function() {
                             return null !== h ? h.fixedFoveation : null !== u ? u.fixedFoveation : void 0
                         }, this.setFoveation = function(t) {
                             null !== h && (h.fixedFoveation = t), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = t)
                         };
-                        let B = null;
-                        const F = new xi;
-                        F.setAnimationLoop((function(e, n) {
+                        let P = null;
+                        const D = new Rr;
+                        D.setAnimationLoop((function(e, n) {
                             if (l = n.getViewerPose(s), p = n, null !== l) {
                                 const e = l.views;
                                 null !== u && (t.setRenderTargetFramebuffer(g, u.framebuffer), t.setRenderTarget(g));
                                 let n = !1;
-                                e.length !== S.cameras.length && (S.cameras.length = 0, n = !0);
+                                e.length !== b.cameras.length && (b.cameras.length = 0, n = !0);
                                 for (let i = 0; i < e.length; i++) {
                                     const r = e[i];
                                     let s = null;
                                     if (null !== u) s = u.getViewport(r);
                                     else {
                                         const e = c.getViewSubImage(h, r);
                                         s = e.viewport, 0 === i && (t.setRenderTargetTextures(g, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(g))
                                     }
-                                    const a = w[i];
-                                    a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && S.matrix.copy(a.matrix), !0 === n && S.cameras.push(a)
+                                    const a = M[i];
+                                    a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && b.matrix.copy(a.matrix), !0 === n && b.cameras.push(a)
                                 }
                             }
                             const r = i.inputSources;
                             for (let t = 0; t < v.length; t++) {
                                 const e = v[t],
                                     i = r[t];
                                 e.update(i, n, s)
                             }
-                            B && B(e, n), p = null
+                            P && P(e, n), p = null
                         })), this.setAnimationLoop = function(t) {
-                            B = t
+                            P = t
                         }, this.dispose = function() {}
                     }
                 }
 
-                function ia(t) {
+                function xo(t) {
                     function e(e, n) {
                         e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
                         const i = t.get(n).envMap;
                         let r, s;
                         i && (e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.ior.value = n.ior, e.refractionRatio.value = n.refractionRatio), n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
                     }
 
                     function n(e, n) {
-                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
+                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === h && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === h && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
                     }
                     return {
                         refreshFogUniforms: function(t, e) {
                             t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                         },
                         refreshMaterialUniforms: function(t, i, r, s, a) {
                             i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) {
                                 e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                             }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) {
-                                e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) {
-                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function(t, e, i) {
-                                n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
+                                n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === h && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                             }(t, i, a) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) {
-                                e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) {
                                 e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) {
                                 e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                             }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) {
-                                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                             }(t, i), i.isLineDashedMaterial && function(t, e) {
                                 t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                             }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                                 let r;
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
@@ -8736,561 +9027,561 @@
                                 let n;
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                             }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                         }
                     }
                 }
 
-                function ra(t = {}) {
+                function yo(t = {}) {
                     const e = void 0 !== t.canvas ? t.canvas : function() {
-                            const t = Dt("canvas");
+                            const t = Ve("canvas");
                             return t.style.display = "block", t
                         }(),
-                        n = void 0 !== t.context ? t.context : null,
-                        i = void 0 !== t.alpha && t.alpha,
-                        r = void 0 === t.depth || t.depth,
-                        s = void 0 === t.stencil || t.stencil,
-                        a = void 0 !== t.antialias && t.antialias,
-                        o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
-                        l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
-                        c = void 0 !== t.powerPreference ? t.powerPreference : "default",
-                        h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
-                    let u = null,
-                        p = null;
-                    const f = [],
-                        g = [];
+                        i = void 0 !== t.context ? t.context : null,
+                        r = void 0 !== t.alpha && t.alpha,
+                        s = void 0 === t.depth || t.depth,
+                        a = void 0 === t.stencil || t.stencil,
+                        o = void 0 !== t.antialias && t.antialias,
+                        l = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
+                        d = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
+                        p = void 0 !== t.powerPreference ? t.powerPreference : "default",
+                        m = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
+                    let f = null,
+                        g = null;
+                    const v = [],
+                        x = [];
                     this.domElement = e, this.debug = {
                         checkShaderErrors: !0
-                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = ot, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
-                    const v = this;
-                    let x = !1,
+                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = me, this.physicallyCorrectLights = !1, this.toneMapping = j, this.toneMappingExposure = 1;
+                    const y = this;
+                    let _ = !1,
                         M = 0,
                         b = 0,
-                        E = null,
-                        A = -1,
-                        R = null;
-                    const L = new jt,
-                        C = new jt;
-                    let P = null,
-                        D = e.width,
-                        I = e.height,
-                        N = 1,
-                        O = null,
-                        U = null;
-                    const B = new jt(0, 0, D, I),
-                        F = new jt(0, 0, D, I);
-                    let z = !1;
-                    const H = new vi;
-                    let G = !1,
-                        V = !1,
-                        k = null;
-                    const W = new Ae,
-                        j = new Zt,
-                        X = {
+                        w = null,
+                        S = -1,
+                        E = null;
+                    const T = new en,
+                        A = new en;
+                    let R = null,
+                        L = e.width,
+                        C = e.height,
+                        P = 1,
+                        D = null,
+                        I = null;
+                    const N = new en(0, 0, L, C),
+                        O = new en(0, 0, L, C);
+                    let U = !1;
+                    const B = new Ar;
+                    let F = !1,
+                        z = !1,
+                        H = null;
+                    const G = new Fn,
+                        V = new on,
+                        k = {
                             background: null,
                             fog: null,
                             environment: null,
                             overrideMaterial: null,
                             isScene: !0
                         };
 
-                    function q() {
-                        return null === E ? N : 1
+                    function W() {
+                        return null === w ? P : 1
                     }
-                    let Y, J, Z, K, Q, $, tt, et, nt, it, rt, st, at, lt, ct, ht, ut, dt, pt, mt, ft, gt, vt, xt = n;
+                    let X, q, Y, J, Z, K, Q, $, tt, et, nt, it, rt, at, lt, ct, ht, ut, mt, ft, gt, vt, xt, Mt = i;
 
-                    function yt(t, n) {
+                    function bt(t, n) {
                         for (let i = 0; i < t.length; i++) {
                             const r = t[i],
                                 s = e.getContext(r, n);
                             if (null !== s) return s
                         }
                         return null
                     }
                     try {
                         const t = {
                             alpha: !0,
-                            depth: r,
-                            stencil: s,
-                            antialias: a,
-                            premultipliedAlpha: o,
-                            preserveDrawingBuffer: l,
-                            powerPreference: c,
-                            failIfMajorPerformanceCaveat: h
+                            depth: s,
+                            stencil: a,
+                            antialias: o,
+                            premultipliedAlpha: l,
+                            preserveDrawingBuffer: d,
+                            powerPreference: p,
+                            failIfMajorPerformanceCaveat: m
                         };
-                        if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r137"), e.addEventListener("webglcontextlost", bt, !1), e.addEventListener("webglcontextrestored", wt, !1), null === xt) {
+                        if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${n}`), e.addEventListener("webglcontextlost", Tt, !1), e.addEventListener("webglcontextrestored", At, !1), null === Mt) {
                             const e = ["webgl2", "webgl", "experimental-webgl"];
-                            if (!0 === v.isWebGL1Renderer && e.shift(), xt = yt(e, t), null === xt) throw yt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
+                            if (!0 === y.isWebGL1Renderer && e.shift(), Mt = bt(e, t), null === Mt) throw bt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                         }
-                        void 0 === xt.getShaderPrecisionFormat && (xt.getShaderPrecisionFormat = function() {
+                        void 0 === Mt.getShaderPrecisionFormat && (Mt.getShaderPrecisionFormat = function() {
                             return {
                                 rangeMin: 1,
                                 rangeMax: 1,
                                 precision: 1
                             }
                         })
                     } catch (t) {
                         throw console.error("THREE.WebGLRenderer: " + t.message), t
                     }
 
-                    function _t() {
-                        Y = new Ki(xt), J = new Ai(xt, Y, t), Y.init(J), gt = new Zs(xt, Y, J), Z = new Ys(xt, Y, J), K = new tr(xt), Q = new Ns, $ = new Js(xt, Y, Z, Q, J, gt, K), tt = new Li(v), et = new Zi(v), nt = new yi(xt, J), vt = new Ei(xt, Y, nt, J), it = new Qi(xt, nt, K, vt), rt = new ar(xt, it, nt, K), pt = new sr(xt, J, $), ht = new Ri(Q), st = new Is(v, tt, et, Y, J, vt, ht), at = new ia(Q), lt = new Fs, ct = new Ws(Y, J), dt = new Si(v, tt, Z, rt, i, o), ut = new qs(v, rt, J), mt = new Ti(xt, Y, K, J), ft = new $i(xt, Y, K, J), K.programs = st.programs, v.capabilities = J, v.extensions = Y, v.properties = Q, v.renderLists = lt, v.shadowMap = ut, v.state = Z, v.info = K
+                    function wt() {
+                        X = new cs(Mt), q = new Br(Mt, X, t), X.init(q), vt = new ho(Mt, X, q), Y = new lo(Mt, X, q), J = new ds(Mt), Z = new Xa, K = new co(Mt, X, Y, Z, q, vt, J), Q = new zr(y), $ = new ls(y), tt = new Lr(Mt, q), xt = new Or(Mt, X, tt, q), et = new hs(Mt, tt, J, xt), nt = new xs(Mt, et, tt, J), mt = new vs(Mt, q, K), ct = new Fr(Z), it = new ja(y, Q, $, X, q, xt, ct), rt = new xo(Z), at = new Za, lt = new no(X, q), ut = new Nr(y, Q, Y, nt, r, l), ht = new oo(y, nt, q), ft = new Ur(Mt, X, J, q), gt = new us(Mt, X, J, q), J.programs = it.programs, y.capabilities = q, y.extensions = X, y.properties = Z, y.renderLists = at, y.shadowMap = ht, y.state = Y, y.info = J
                     }
-                    _t();
-                    const Mt = new na(v, xt);
+                    wt();
+                    const St = new vo(y, Mt);
 
-                    function bt(t) {
-                        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0
+                    function Tt(t) {
+                        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0
                     }
 
-                    function wt() {
-                        console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
-                        const t = K.autoReset,
-                            e = ut.enabled,
-                            n = ut.autoUpdate,
-                            i = ut.needsUpdate,
-                            r = ut.type;
-                        _t(), K.autoReset = t, ut.enabled = e, ut.autoUpdate = n, ut.needsUpdate = i, ut.type = r
+                    function At() {
+                        console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
+                        const t = J.autoReset,
+                            e = ht.enabled,
+                            n = ht.autoUpdate,
+                            i = ht.needsUpdate,
+                            r = ht.type;
+                        wt(), J.autoReset = t, ht.enabled = e, ht.autoUpdate = n, ht.needsUpdate = i, ht.type = r
                     }
 
-                    function St(t) {
+                    function Rt(t) {
                         const e = t.target;
-                        e.removeEventListener("dispose", St),
+                        e.removeEventListener("dispose", Rt),
                             function(t) {
                                 (function(t) {
-                                    const e = Q.get(t).programs;
+                                    const e = Z.get(t).programs;
                                     void 0 !== e && (e.forEach((function(t) {
-                                        st.releaseProgram(t)
-                                    })), t.isShaderMaterial && st.releaseShaderCache(t))
-                                })(t), Q.remove(t)
+                                        it.releaseProgram(t)
+                                    })), t.isShaderMaterial && it.releaseShaderCache(t))
+                                })(t), Z.remove(t)
                             }(e)
                     }
-                    this.xr = Mt, this.getContext = function() {
-                        return xt
+                    this.xr = St, this.getContext = function() {
+                        return Mt
                     }, this.getContextAttributes = function() {
-                        return xt.getContextAttributes()
+                        return Mt.getContextAttributes()
                     }, this.forceContextLoss = function() {
-                        const t = Y.get("WEBGL_lose_context");
+                        const t = X.get("WEBGL_lose_context");
                         t && t.loseContext()
                     }, this.forceContextRestore = function() {
-                        const t = Y.get("WEBGL_lose_context");
+                        const t = X.get("WEBGL_lose_context");
                         t && t.restoreContext()
                     }, this.getPixelRatio = function() {
-                        return N
+                        return P
                     }, this.setPixelRatio = function(t) {
-                        void 0 !== t && (N = t, this.setSize(D, I, !1))
+                        void 0 !== t && (P = t, this.setSize(L, C, !1))
                     }, this.getSize = function(t) {
-                        return t.set(D, I)
+                        return t.set(L, C)
                     }, this.setSize = function(t, n, i) {
-                        Mt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (D = t, I = n, e.width = Math.floor(t * N), e.height = Math.floor(n * N), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
+                        St.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (L = t, C = n, e.width = Math.floor(t * P), e.height = Math.floor(n * P), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                     }, this.getDrawingBufferSize = function(t) {
-                        return t.set(D * N, I * N).floor()
+                        return t.set(L * P, C * P).floor()
                     }, this.setDrawingBufferSize = function(t, n, i) {
-                        D = t, I = n, N = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
+                        L = t, C = n, P = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
                     }, this.getCurrentViewport = function(t) {
-                        return t.copy(L)
+                        return t.copy(T)
                     }, this.getViewport = function(t) {
-                        return t.copy(B)
+                        return t.copy(N)
                     }, this.setViewport = function(t, e, n, i) {
-                        t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, i), Z.viewport(L.copy(B).multiplyScalar(N).floor())
+                        t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i), Y.viewport(T.copy(N).multiplyScalar(P).floor())
                     }, this.getScissor = function(t) {
-                        return t.copy(F)
+                        return t.copy(O)
                     }, this.setScissor = function(t, e, n, i) {
-                        t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i), Z.scissor(C.copy(F).multiplyScalar(N).floor())
+                        t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i), Y.scissor(A.copy(O).multiplyScalar(P).floor())
                     }, this.getScissorTest = function() {
-                        return z
+                        return U
                     }, this.setScissorTest = function(t) {
-                        Z.setScissorTest(z = t)
+                        Y.setScissorTest(U = t)
                     }, this.setOpaqueSort = function(t) {
-                        O = t
+                        D = t
                     }, this.setTransparentSort = function(t) {
-                        U = t
+                        I = t
                     }, this.getClearColor = function(t) {
-                        return t.copy(dt.getClearColor())
+                        return t.copy(ut.getClearColor())
                     }, this.setClearColor = function() {
-                        dt.setClearColor.apply(dt, arguments)
+                        ut.setClearColor.apply(ut, arguments)
                     }, this.getClearAlpha = function() {
-                        return dt.getClearAlpha()
+                        return ut.getClearAlpha()
                     }, this.setClearAlpha = function() {
-                        dt.setClearAlpha.apply(dt, arguments)
+                        ut.setClearAlpha.apply(ut, arguments)
                     }, this.clear = function(t, e, n) {
                         let i = 0;
-                        (void 0 === t || t) && (i |= xt.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= xt.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= xt.STENCIL_BUFFER_BIT), xt.clear(i)
+                        (void 0 === t || t) && (i |= Mt.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= Mt.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= Mt.STENCIL_BUFFER_BIT), Mt.clear(i)
                     }, this.clearColor = function() {
                         this.clear(!0, !1, !1)
                     }, this.clearDepth = function() {
                         this.clear(!1, !0, !1)
                     }, this.clearStencil = function() {
                         this.clear(!1, !1, !0)
                     }, this.dispose = function() {
-                        e.removeEventListener("webglcontextlost", bt, !1), e.removeEventListener("webglcontextrestored", wt, !1), lt.dispose(), ct.dispose(), Q.dispose(), tt.dispose(), et.dispose(), rt.dispose(), vt.dispose(), st.dispose(), Mt.dispose(), Mt.removeEventListener("sessionstart", Tt), Mt.removeEventListener("sessionend", At), k && (k.dispose(), k = null), Rt.stop()
+                        e.removeEventListener("webglcontextlost", Tt, !1), e.removeEventListener("webglcontextrestored", At, !1), at.dispose(), lt.dispose(), Z.dispose(), Q.dispose(), $.dispose(), nt.dispose(), xt.dispose(), it.dispose(), St.dispose(), St.removeEventListener("sessionstart", Ct), St.removeEventListener("sessionend", Pt), H && (H.dispose(), H = null), Dt.stop()
                     }, this.renderBufferDirect = function(t, e, n, i, r, s) {
-                        null === e && (e = X);
+                        null === e && (e = k);
                         const a = r.isMesh && r.matrixWorld.determinant() < 0,
                             o = function(t, e, n, i, r) {
-                                !0 !== e.isScene && (e = X), $.resetTextureUnits();
+                                !0 !== e.isScene && (e = k), K.resetTextureUnits();
                                 const s = e.fog,
                                     a = i.isMeshStandardMaterial ? e.environment : null,
-                                    o = null === E ? v.outputEncoding : !0 === E.isXRRenderTarget ? E.texture.encoding : ot,
-                                    l = (i.isMeshStandardMaterial ? et : tt).get(i.envMap || a),
+                                    o = null === w ? y.outputEncoding : !0 === w.isXRRenderTarget ? w.texture.encoding : me,
+                                    l = (i.isMeshStandardMaterial ? $ : Q).get(i.envMap || a),
                                     c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                     h = !!i.normalMap && !!n.attributes.tangent,
                                     u = !!n.morphAttributes.position,
                                     d = !!n.morphAttributes.normal,
-                                    m = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
-                                    f = i.toneMapped ? v.toneMapping : 0,
-                                    g = Q.get(i),
-                                    x = p.state.lights;
-                                if (!0 === G && (!0 === V || t !== R)) {
-                                    const e = t === R && i.id === A;
-                                    ht.setState(i, t, e)
-                                }
-                                let y = !1;
-                                i.version === g.__version ? g.needsLights && g.lightsStateVersion !== x.state.version || g.outputEncoding !== o || r.isInstancedMesh && !1 === g.instancing ? y = !0 : r.isInstancedMesh || !0 !== g.instancing ? r.isSkinnedMesh && !1 === g.skinning ? y = !0 : r.isSkinnedMesh || !0 !== g.skinning ? g.envMap !== l || i.fog && g.fog !== s ? y = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === ht.numPlanes && g.numIntersection === ht.numIntersection ? (g.vertexAlphas !== c || g.vertexTangents !== h || g.morphTargets !== u || g.morphNormals !== d || g.toneMapping !== f || !0 === J.isWebGL2 && g.morphTargetsCount !== m) && (y = !0) : y = !0 : y = !0 : y = !0 : (y = !0, g.__version = i.version);
-                                let _ = g.currentProgram;
-                                !0 === y && (_ = Nt(i, e, r));
+                                    p = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
+                                    m = i.toneMapped ? y.toneMapping : j,
+                                    f = Z.get(i),
+                                    v = g.state.lights;
+                                if (!0 === F && (!0 === z || t !== E)) {
+                                    const e = t === E && i.id === S;
+                                    ct.setState(i, t, e)
+                                }
+                                let x = !1;
+                                i.version === f.__version ? f.needsLights && f.lightsStateVersion !== v.state.version || f.outputEncoding !== o || r.isInstancedMesh && !1 === f.instancing ? x = !0 : r.isInstancedMesh || !0 !== f.instancing ? r.isSkinnedMesh && !1 === f.skinning ? x = !0 : r.isSkinnedMesh || !0 !== f.skinning ? f.envMap !== l || i.fog && f.fog !== s ? x = !0 : void 0 === f.numClippingPlanes || f.numClippingPlanes === ct.numPlanes && f.numIntersection === ct.numIntersection ? (f.vertexAlphas !== c || f.vertexTangents !== h || f.morphTargets !== u || f.morphNormals !== d || f.toneMapping !== m || !0 === q.isWebGL2 && f.morphTargetsCount !== p) && (x = !0) : x = !0 : x = !0 : x = !0 : (x = !0, f.__version = i.version);
+                                let _ = f.currentProgram;
+                                !0 === x && (_ = Bt(i, e, r));
                                 let M = !1,
                                     b = !1,
-                                    w = !1;
-                                const S = _.getUniforms(),
-                                    T = g.uniforms;
-                                if (Z.useProgram(_.program) && (M = !0, b = !0, w = !0), i.id !== A && (A = i.id, b = !0), M || R !== t) {
-                                    if (S.setValue(xt, "projectionMatrix", t.projectionMatrix), J.logarithmicDepthBuffer && S.setValue(xt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), R !== t && (R = t, b = !0, w = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
-                                        const e = S.map.cameraPosition;
-                                        void 0 !== e && e.setValue(xt, j.setFromMatrixPosition(t.matrixWorld))
-                                    }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && S.setValue(xt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && S.setValue(xt, "viewMatrix", t.matrixWorldInverse)
+                                    T = !1;
+                                const A = _.getUniforms(),
+                                    R = f.uniforms;
+                                if (Y.useProgram(_.program) && (M = !0, b = !0, T = !0), i.id !== S && (S = i.id, b = !0), M || E !== t) {
+                                    if (A.setValue(Mt, "projectionMatrix", t.projectionMatrix), q.logarithmicDepthBuffer && A.setValue(Mt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), E !== t && (E = t, b = !0, T = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
+                                        const e = A.map.cameraPosition;
+                                        void 0 !== e && e.setValue(Mt, V.setFromMatrixPosition(t.matrixWorld))
+                                    }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && A.setValue(Mt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && A.setValue(Mt, "viewMatrix", t.matrixWorldInverse)
                                 }
                                 if (r.isSkinnedMesh) {
-                                    S.setOptional(xt, r, "bindMatrix"), S.setOptional(xt, r, "bindMatrixInverse");
+                                    A.setOptional(Mt, r, "bindMatrix"), A.setOptional(Mt, r, "bindMatrixInverse");
                                     const t = r.skeleton;
-                                    t && (J.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), S.setValue(xt, "boneTexture", t.boneTexture, $), S.setValue(xt, "boneTextureSize", t.boneTextureSize)) : S.setOptional(xt, t, "boneMatrices"))
+                                    t && (q.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), A.setValue(Mt, "boneTexture", t.boneTexture, K), A.setValue(Mt, "boneTextureSize", t.boneTextureSize)) : A.setOptional(Mt, t, "boneMatrices"))
                                 }
-                                var L, C;
-                                return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || pt.update(r, n, i, _), (b || g.receiveShadow !== r.receiveShadow) && (g.receiveShadow = r.receiveShadow, S.setValue(xt, "receiveShadow", r.receiveShadow)), b && (S.setValue(xt, "toneMappingExposure", v.toneMappingExposure), g.needsLights && (C = w, (L = T).ambientLightColor.needsUpdate = C, L.lightProbe.needsUpdate = C, L.directionalLights.needsUpdate = C, L.directionalLightShadows.needsUpdate = C, L.pointLights.needsUpdate = C, L.pointLightShadows.needsUpdate = C, L.spotLights.needsUpdate = C, L.spotLightShadows.needsUpdate = C, L.rectAreaLights.needsUpdate = C, L.hemisphereLights.needsUpdate = C), s && i.fog && at.refreshFogUniforms(T, s), at.refreshMaterialUniforms(T, i, N, I, k), us.upload(xt, g.uniformsList, T, $)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (us.upload(xt, g.uniformsList, T, $), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && S.setValue(xt, "center", r.center), S.setValue(xt, "modelViewMatrix", r.modelViewMatrix), S.setValue(xt, "normalMatrix", r.normalMatrix), S.setValue(xt, "modelMatrix", r.matrixWorld), _
+                                var L, D;
+                                return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || mt.update(r, n, i, _), (b || f.receiveShadow !== r.receiveShadow) && (f.receiveShadow = r.receiveShadow, A.setValue(Mt, "receiveShadow", r.receiveShadow)), b && (A.setValue(Mt, "toneMappingExposure", y.toneMappingExposure), f.needsLights && (D = T, (L = R).ambientLightColor.needsUpdate = D, L.lightProbe.needsUpdate = D, L.directionalLights.needsUpdate = D, L.directionalLightShadows.needsUpdate = D, L.pointLights.needsUpdate = D, L.pointLightShadows.needsUpdate = D, L.spotLights.needsUpdate = D, L.spotLightShadows.needsUpdate = D, L.rectAreaLights.needsUpdate = D, L.hemisphereLights.needsUpdate = D), s && i.fog && rt.refreshFogUniforms(R, s), rt.refreshMaterialUniforms(R, i, P, C, H), wa.upload(Mt, f.uniformsList, R, K)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (wa.upload(Mt, f.uniformsList, R, K), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && A.setValue(Mt, "center", r.center), A.setValue(Mt, "modelViewMatrix", r.modelViewMatrix), A.setValue(Mt, "normalMatrix", r.normalMatrix), A.setValue(Mt, "modelMatrix", r.matrixWorld), _
                             }(t, e, n, i, r);
-                        Z.setMaterial(i, a);
+                        Y.setMaterial(i, a);
                         let l = n.index;
                         const c = n.attributes.position;
                         if (null === l) {
                             if (void 0 === c || 0 === c.count) return
                         } else if (0 === l.count) return;
                         let h, u = 1;
-                        !0 === i.wireframe && (l = it.getWireframeAttribute(n), u = 2), vt.setup(r, i, o, n, l);
-                        let d = mt;
-                        null !== l && (h = nt.get(l), d = ft, d.setIndex(h));
-                        const m = null !== l ? l.count : c.count,
-                            f = n.drawRange.start * u,
-                            g = n.drawRange.count * u,
-                            x = null !== s ? s.start * u : 0,
-                            y = null !== s ? s.count * u : 1 / 0,
-                            _ = Math.max(f, x),
-                            M = Math.min(m, f + g, x + y) - 1,
+                        !0 === i.wireframe && (l = et.getWireframeAttribute(n), u = 2), xt.setup(r, i, o, n, l);
+                        let d = ft;
+                        null !== l && (h = tt.get(l), d = gt, d.setIndex(h));
+                        const p = null !== l ? l.count : c.count,
+                            m = n.drawRange.start * u,
+                            f = n.drawRange.count * u,
+                            v = null !== s ? s.start * u : 0,
+                            x = null !== s ? s.count * u : 1 / 0,
+                            _ = Math.max(m, v),
+                            M = Math.min(p, m + f, v + x) - 1,
                             b = Math.max(0, M - _ + 1);
                         if (0 !== b) {
-                            if (r.isMesh) !0 === i.wireframe ? (Z.setLineWidth(i.wireframeLinewidth * q()), d.setMode(xt.LINES)) : d.setMode(xt.TRIANGLES);
+                            if (r.isMesh) !0 === i.wireframe ? (Y.setLineWidth(i.wireframeLinewidth * W()), d.setMode(Mt.LINES)) : d.setMode(Mt.TRIANGLES);
                             else if (r.isLine) {
                                 let t = i.linewidth;
-                                void 0 === t && (t = 1), Z.setLineWidth(t * q()), r.isLineSegments ? d.setMode(xt.LINES) : r.isLineLoop ? d.setMode(xt.LINE_LOOP) : d.setMode(xt.LINE_STRIP)
-                            } else r.isPoints ? d.setMode(xt.POINTS) : r.isSprite && d.setMode(xt.TRIANGLES);
+                                void 0 === t && (t = 1), Y.setLineWidth(t * W()), r.isLineSegments ? d.setMode(Mt.LINES) : r.isLineLoop ? d.setMode(Mt.LINE_LOOP) : d.setMode(Mt.LINE_STRIP)
+                            } else r.isPoints ? d.setMode(Mt.POINTS) : r.isSprite && d.setMode(Mt.TRIANGLES);
                             if (r.isInstancedMesh) d.renderInstances(_, b, r.count);
                             else if (n.isInstancedBufferGeometry) {
                                 const t = Math.min(n.instanceCount, n._maxInstanceCount);
                                 d.renderInstances(_, b, t)
                             } else d.render(_, b)
                         }
                     }, this.compile = function(t, e) {
-                        p = ct.get(t), p.init(), g.push(p), t.traverseVisible((function(t) {
-                            t.isLight && t.layers.test(e.layers) && (p.pushLight(t), t.castShadow && p.pushShadow(t))
-                        })), p.setupLights(v.physicallyCorrectLights), t.traverse((function(e) {
+                        g = lt.get(t), g.init(), x.push(g), t.traverseVisible((function(t) {
+                            t.isLight && t.layers.test(e.layers) && (g.pushLight(t), t.castShadow && g.pushShadow(t))
+                        })), g.setupLights(y.physicallyCorrectLights), t.traverse((function(e) {
                             const n = e.material;
                             if (n)
                                 if (Array.isArray(n))
-                                    for (let i = 0; i < n.length; i++) Nt(n[i], t, e);
-                                else Nt(n, t, e)
-                        })), g.pop(), p = null
+                                    for (let i = 0; i < n.length; i++) Bt(n[i], t, e);
+                                else Bt(n, t, e)
+                        })), x.pop(), g = null
                     };
-                    let Et = null;
+                    let Lt = null;
 
-                    function Tt() {
-                        Rt.stop()
+                    function Ct() {
+                        Dt.stop()
                     }
 
-                    function At() {
-                        Rt.start()
+                    function Pt() {
+                        Dt.start()
                     }
-                    const Rt = new xi;
+                    const Dt = new Rr;
 
-                    function Lt(t, e, n, i) {
+                    function It(t, e, n, i) {
                         if (!1 === t.visible) return;
                         if (t.layers.test(e.layers))
                             if (t.isGroup) n = t.renderOrder;
                             else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
-                        else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t);
+                        else if (t.isLight) g.pushLight(t), t.castShadow && g.pushShadow(t);
                         else if (t.isSprite) {
-                            if (!t.frustumCulled || H.intersectsSprite(t)) {
-                                i && j.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W);
-                                const e = rt.update(t),
+                            if (!t.frustumCulled || B.intersectsSprite(t)) {
+                                i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
+                                const e = nt.update(t),
                                     r = t.material;
-                                r.visible && u.push(t, e, r, n, j.z, null)
+                                r.visible && f.push(t, e, r, n, V.z, null)
                             }
-                        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== K.render.frame && (t.skeleton.update(), t.skeleton.frame = K.render.frame), !t.frustumCulled || H.intersectsObject(t))) {
-                            i && j.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W);
-                            const e = rt.update(t),
+                        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== J.render.frame && (t.skeleton.update(), t.skeleton.frame = J.render.frame), !t.frustumCulled || B.intersectsObject(t))) {
+                            i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
+                            const e = nt.update(t),
                                 r = t.material;
                             if (Array.isArray(r)) {
                                 const i = e.groups;
                                 for (let s = 0, a = i.length; s < a; s++) {
                                     const a = i[s],
                                         o = r[a.materialIndex];
-                                    o && o.visible && u.push(t, e, o, n, j.z, a)
+                                    o && o.visible && f.push(t, e, o, n, V.z, a)
                                 }
-                            } else r.visible && u.push(t, e, r, n, j.z, null)
+                            } else r.visible && f.push(t, e, r, n, V.z, null)
                         }
                         const r = t.children;
-                        for (let t = 0, s = r.length; t < s; t++) Lt(r[t], e, n, i)
+                        for (let t = 0, s = r.length; t < s; t++) It(r[t], e, n, i)
                     }
 
-                    function Ct(t, e, n, i) {
+                    function Nt(t, e, n, i) {
                         const r = t.opaque,
                             s = t.transmissive,
-                            o = t.transparent;
-                        p.setupLightsView(n), s.length > 0 && function(t, e, n) {
-                            if (null === k) {
-                                const t = !0 === a && !0 === J.isWebGL2;
-                                k = new(t ? Yt : Xt)(1024, 1024, {
+                            a = t.transparent;
+                        g.setupLightsView(n), s.length > 0 && function(t, e, n) {
+                            if (null === H) {
+                                const t = !0 === o && !0 === q.isWebGL2;
+                                H = new(t ? sn : nn)(1024, 1024, {
                                     generateMipmaps: !0,
-                                    type: null !== gt.convert(S) ? S : _,
-                                    minFilter: y,
-                                    magFilter: m,
-                                    wrapS: d,
-                                    wrapT: d,
-                                    useRenderToTexture: Y.has("WEBGL_multisampled_render_to_texture")
+                                    type: null !== vt.convert(_t) ? _t : pt,
+                                    minFilter: dt,
+                                    magFilter: ot,
+                                    wrapS: st,
+                                    wrapT: st,
+                                    useRenderToTexture: X.has("WEBGL_multisampled_render_to_texture")
                                 })
                             }
-                            const i = v.getRenderTarget();
-                            v.setRenderTarget(k), v.clear();
-                            const r = v.toneMapping;
-                            v.toneMapping = 0, Pt(t, e, n), v.toneMapping = r, $.updateMultisampleRenderTarget(k), $.updateRenderTargetMipmap(k), v.setRenderTarget(i)
-                        }(r, e, n), i && Z.viewport(L.copy(i)), r.length > 0 && Pt(r, e, n), s.length > 0 && Pt(s, e, n), o.length > 0 && Pt(o, e, n)
+                            const i = y.getRenderTarget();
+                            y.setRenderTarget(H), y.clear();
+                            const r = y.toneMapping;
+                            y.toneMapping = j, Ot(t, e, n), y.toneMapping = r, K.updateMultisampleRenderTarget(H), K.updateRenderTargetMipmap(H), y.setRenderTarget(i)
+                        }(r, e, n), i && Y.viewport(T.copy(i)), r.length > 0 && Ot(r, e, n), s.length > 0 && Ot(s, e, n), a.length > 0 && Ot(a, e, n)
                     }
 
-                    function Pt(t, e, n) {
+                    function Ot(t, e, n) {
                         const i = !0 === e.isScene ? e.overrideMaterial : null;
                         for (let r = 0, s = t.length; r < s; r++) {
                             const s = t[r],
                                 a = s.object,
                                 o = s.geometry,
                                 l = null === i ? s.material : i,
                                 c = s.group;
-                            a.layers.test(n.layers) && It(a, e, n, o, l, c)
+                            a.layers.test(n.layers) && Ut(a, e, n, o, l, c)
                         }
                     }
 
-                    function It(t, e, n, i, r, s) {
-                        t.onBeforeRender(v, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(v, e, n, i, t, s), !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, v.renderBufferDirect(n, e, i, r, t, s), r.side = 0, r.needsUpdate = !0, v.renderBufferDirect(n, e, i, r, t, s), r.side = 2) : v.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(v, e, n, i, r, s)
+                    function Ut(t, e, n, i, r, s) {
+                        t.onBeforeRender(y, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(y, e, n, i, t, s), !0 === r.transparent && r.side === u ? (r.side = h, r.needsUpdate = !0, y.renderBufferDirect(n, e, i, r, t, s), r.side = c, r.needsUpdate = !0, y.renderBufferDirect(n, e, i, r, t, s), r.side = u) : y.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(y, e, n, i, r, s)
                     }
 
-                    function Nt(t, e, n) {
-                        !0 !== e.isScene && (e = X);
-                        const i = Q.get(t),
-                            r = p.state.lights,
-                            s = p.state.shadowsArray,
+                    function Bt(t, e, n) {
+                        !0 !== e.isScene && (e = k);
+                        const i = Z.get(t),
+                            r = g.state.lights,
+                            s = g.state.shadowsArray,
                             a = r.state.version,
-                            o = st.getParameters(t, r.state, s, e, n),
-                            l = st.getProgramCacheKey(o);
+                            o = it.getParameters(t, r.state, s, e, n),
+                            l = it.getProgramCacheKey(o);
                         let c = i.programs;
-                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? et : tt).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", St), c = new Map, i.programs = c);
+                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? $ : Q).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", Rt), c = new Map, i.programs = c);
                         let h = c.get(l);
                         if (void 0 !== h) {
-                            if (i.currentProgram === h && i.lightsStateVersion === a) return Ot(t, o), h
-                        } else o.uniforms = st.getUniforms(t), t.onBuild(n, o, v), t.onBeforeCompile(o, v), h = st.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
+                            if (i.currentProgram === h && i.lightsStateVersion === a) return Ft(t, o), h
+                        } else o.uniforms = it.getUniforms(t), t.onBuild(n, o, y), t.onBeforeCompile(o, y), h = it.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
                         const u = i.uniforms;
-                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = ht.uniform), Ot(t, o), i.needsLights = function(t) {
+                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = ct.uniform), Ft(t, o), i.needsLights = function(t) {
                             return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                         }(t), i.lightsStateVersion = a, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                         const d = h.getUniforms(),
-                            m = us.seqWithValue(d.seq, u);
-                        return i.currentProgram = h, i.uniformsList = m, h
+                            p = wa.seqWithValue(d.seq, u);
+                        return i.currentProgram = h, i.uniformsList = p, h
                     }
 
-                    function Ot(t, e) {
-                        const n = Q.get(t);
+                    function Ft(t, e) {
+                        const n = Z.get(t);
                         n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
                     }
-                    Rt.setAnimationLoop((function(t) {
-                        Et && Et(t)
-                    })), "undefined" != typeof window && Rt.setContext(window), this.setAnimationLoop = function(t) {
-                        Et = t, Mt.setAnimationLoop(t), null === t ? Rt.stop() : Rt.start()
-                    }, Mt.addEventListener("sessionstart", Tt), Mt.addEventListener("sessionend", At), this.render = function(t, e) {
+                    Dt.setAnimationLoop((function(t) {
+                        Lt && Lt(t)
+                    })), "undefined" != typeof window && Dt.setContext(window), this.setAnimationLoop = function(t) {
+                        Lt = t, St.setAnimationLoop(t), null === t ? Dt.stop() : Dt.start()
+                    }, St.addEventListener("sessionstart", Ct), St.addEventListener("sessionend", Pt), this.render = function(t, e) {
                         if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
-                        if (!0 === x) return;
-                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === Mt.enabled && !0 === Mt.isPresenting && (!0 === Mt.cameraAutoUpdate && Mt.updateCamera(e), e = Mt.getCamera()), !0 === t.isScene && t.onBeforeRender(v, t, e, E), p = ct.get(t, g.length), p.init(), g.push(p), W.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), H.setFromProjectionMatrix(W), V = this.localClippingEnabled, G = ht.init(this.clippingPlanes, V, e), u = lt.get(t, f.length), u.init(), f.push(u), Lt(t, e, 0, v.sortObjects), u.finish(), !0 === v.sortObjects && u.sort(O, U), !0 === G && ht.beginShadows();
-                        const n = p.state.shadowsArray;
-                        if (ut.render(n, t, e), !0 === G && ht.endShadows(), !0 === this.info.autoReset && this.info.reset(), dt.render(u, t), p.setupLights(v.physicallyCorrectLights), e.isArrayCamera) {
+                        if (!0 === _) return;
+                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === St.enabled && !0 === St.isPresenting && (!0 === St.cameraAutoUpdate && St.updateCamera(e), e = St.getCamera()), !0 === t.isScene && t.onBeforeRender(y, t, e, w), g = lt.get(t, x.length), g.init(), x.push(g), G.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), B.setFromProjectionMatrix(G), z = this.localClippingEnabled, F = ct.init(this.clippingPlanes, z, e), f = at.get(t, v.length), f.init(), v.push(f), It(t, e, 0, y.sortObjects), f.finish(), !0 === y.sortObjects && f.sort(D, I), !0 === F && ct.beginShadows();
+                        const n = g.state.shadowsArray;
+                        if (ht.render(n, t, e), !0 === F && ct.endShadows(), !0 === this.info.autoReset && this.info.reset(), ut.render(f, t), g.setupLights(y.physicallyCorrectLights), e.isArrayCamera) {
                             const n = e.cameras;
                             for (let e = 0, i = n.length; e < i; e++) {
                                 const i = n[e];
-                                Ct(u, t, i, i.viewport)
+                                Nt(f, t, i, i.viewport)
                             }
-                        } else Ct(u, t, e);
-                        null !== E && ($.updateMultisampleRenderTarget(E), $.updateRenderTargetMipmap(E)), !0 === t.isScene && t.onAfterRender(v, t, e), Z.buffers.depth.setTest(!0), Z.buffers.depth.setMask(!0), Z.buffers.color.setMask(!0), Z.setPolygonOffset(!1), vt.resetDefaultState(), A = -1, R = null, g.pop(), p = g.length > 0 ? g[g.length - 1] : null, f.pop(), u = f.length > 0 ? f[f.length - 1] : null
+                        } else Nt(f, t, e);
+                        null !== w && (K.updateMultisampleRenderTarget(w), K.updateRenderTargetMipmap(w)), !0 === t.isScene && t.onAfterRender(y, t, e), Y.buffers.depth.setTest(!0), Y.buffers.depth.setMask(!0), Y.buffers.color.setMask(!0), Y.setPolygonOffset(!1), xt.resetDefaultState(), S = -1, E = null, x.pop(), g = x.length > 0 ? x[x.length - 1] : null, v.pop(), f = v.length > 0 ? v[v.length - 1] : null
                     }, this.getActiveCubeFace = function() {
                         return M
                     }, this.getActiveMipmapLevel = function() {
                         return b
                     }, this.getRenderTarget = function() {
-                        return E
+                        return w
                     }, this.setRenderTargetTextures = function(t, e, n) {
-                        Q.get(t.texture).__webglTexture = e, Q.get(t.depthTexture).__webglTexture = n;
-                        const i = Q.get(t);
+                        Z.get(t.texture).__webglTexture = e, Z.get(t.depthTexture).__webglTexture = n;
+                        const i = Z.get(t);
                         i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || t.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), t.useRenderToTexture = !1, t.useRenderbuffer = !0))
                     }, this.setRenderTargetFramebuffer = function(t, e) {
-                        const n = Q.get(t);
+                        const n = Z.get(t);
                         n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
                     }, this.setRenderTarget = function(t, e = 0, n = 0) {
-                        E = t, M = e, b = n;
+                        w = t, M = e, b = n;
                         let i = !0;
                         if (t) {
-                            const e = Q.get(t);
-                            void 0 !== e.__useDefaultFramebuffer ? (Z.bindFramebuffer(xt.FRAMEBUFFER, null), i = !1) : void 0 === e.__webglFramebuffer ? $.setupRenderTarget(t) : e.__hasExternalTextures && $.rebindTextures(t, Q.get(t.texture).__webglTexture, Q.get(t.depthTexture).__webglTexture)
+                            const e = Z.get(t);
+                            void 0 !== e.__useDefaultFramebuffer ? (Y.bindFramebuffer(Mt.FRAMEBUFFER, null), i = !1) : void 0 === e.__webglFramebuffer ? K.setupRenderTarget(t) : e.__hasExternalTextures && K.rebindTextures(t, Z.get(t.texture).__webglTexture, Z.get(t.depthTexture).__webglTexture)
                         }
                         let r = null,
                             s = !1,
                             a = !1;
                         if (t) {
                             const n = t.texture;
                             (n.isDataTexture3D || n.isDataTexture2DArray) && (a = !0);
-                            const i = Q.get(t).__webglFramebuffer;
-                            t.isWebGLCubeRenderTarget ? (r = i[e], s = !0) : r = t.useRenderbuffer ? Q.get(t).__webglMultisampledFramebuffer : i, L.copy(t.viewport), C.copy(t.scissor), P = t.scissorTest
-                        } else L.copy(B).multiplyScalar(N).floor(), C.copy(F).multiplyScalar(N).floor(), P = z;
-                        if (Z.bindFramebuffer(xt.FRAMEBUFFER, r) && J.drawBuffers && i && Z.drawBuffers(t, r), Z.viewport(L), Z.scissor(C), Z.setScissorTest(P), s) {
-                            const i = Q.get(t.texture);
-                            xt.framebufferTexture2D(xt.FRAMEBUFFER, xt.COLOR_ATTACHMENT0, xt.TEXTURE_CUBE_MAP_POSITIVE_X + e, i.__webglTexture, n)
+                            const i = Z.get(t).__webglFramebuffer;
+                            t.isWebGLCubeRenderTarget ? (r = i[e], s = !0) : r = t.useRenderbuffer ? Z.get(t).__webglMultisampledFramebuffer : i, T.copy(t.viewport), A.copy(t.scissor), R = t.scissorTest
+                        } else T.copy(N).multiplyScalar(P).floor(), A.copy(O).multiplyScalar(P).floor(), R = U;
+                        if (Y.bindFramebuffer(Mt.FRAMEBUFFER, r) && q.drawBuffers && i && Y.drawBuffers(t, r), Y.viewport(T), Y.scissor(A), Y.setScissorTest(R), s) {
+                            const i = Z.get(t.texture);
+                            Mt.framebufferTexture2D(Mt.FRAMEBUFFER, Mt.COLOR_ATTACHMENT0, Mt.TEXTURE_CUBE_MAP_POSITIVE_X + e, i.__webglTexture, n)
                         } else if (a) {
-                            const i = Q.get(t.texture),
+                            const i = Z.get(t.texture),
                                 r = e || 0;
-                            xt.framebufferTextureLayer(xt.FRAMEBUFFER, xt.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
+                            Mt.framebufferTextureLayer(Mt.FRAMEBUFFER, Mt.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                         }
-                        A = -1
+                        S = -1
                     }, this.readRenderTargetPixels = function(t, e, n, i, r, s, a) {
                         if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
-                        let o = Q.get(t).__webglFramebuffer;
+                        let o = Z.get(t).__webglFramebuffer;
                         if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
-                            Z.bindFramebuffer(xt.FRAMEBUFFER, o);
+                            Y.bindFramebuffer(Mt.FRAMEBUFFER, o);
                             try {
                                 const a = t.texture,
                                     o = a.format,
                                     l = a.type;
-                                if (o !== T && gt.convert(o) !== xt.getParameter(xt.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
-                                const c = l === S && (Y.has("EXT_color_buffer_half_float") || J.isWebGL2 && Y.has("EXT_color_buffer_float"));
-                                if (!(l === _ || gt.convert(l) === xt.getParameter(xt.IMPLEMENTATION_COLOR_READ_TYPE) || l === w && (J.isWebGL2 || Y.has("OES_texture_float") || Y.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
-                                xt.checkFramebufferStatus(xt.FRAMEBUFFER) === xt.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && xt.readPixels(e, n, i, r, gt.convert(o), gt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
+                                if (o !== Et && vt.convert(o) !== Mt.getParameter(Mt.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
+                                const c = l === _t && (X.has("EXT_color_buffer_half_float") || q.isWebGL2 && X.has("EXT_color_buffer_float"));
+                                if (!(l === pt || vt.convert(l) === Mt.getParameter(Mt.IMPLEMENTATION_COLOR_READ_TYPE) || l === yt && (q.isWebGL2 || X.has("OES_texture_float") || X.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
+                                Mt.checkFramebufferStatus(Mt.FRAMEBUFFER) === Mt.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && Mt.readPixels(e, n, i, r, vt.convert(o), vt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                             } finally {
-                                const t = null !== E ? Q.get(E).__webglFramebuffer : null;
-                                Z.bindFramebuffer(xt.FRAMEBUFFER, t)
+                                const t = null !== w ? Z.get(w).__webglFramebuffer : null;
+                                Y.bindFramebuffer(Mt.FRAMEBUFFER, t)
                             }
                         }
                     }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                         if (!0 !== e.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
                         const i = Math.pow(2, -n),
                             r = Math.floor(e.image.width * i),
                             s = Math.floor(e.image.height * i);
-                        $.setTexture2D(e, 0), xt.copyTexSubImage2D(xt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s), Z.unbindTexture()
+                        K.setTexture2D(e, 0), Mt.copyTexSubImage2D(Mt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s), Y.unbindTexture()
                     }, this.copyTextureToTexture = function(t, e, n, i = 0) {
                         const r = e.image.width,
                             s = e.image.height,
-                            a = gt.convert(n.format),
-                            o = gt.convert(n.type);
-                        $.setTexture2D(n, 0), xt.pixelStorei(xt.UNPACK_FLIP_Y_WEBGL, n.flipY), xt.pixelStorei(xt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), xt.pixelStorei(xt.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? xt.texSubImage2D(xt.TEXTURE_2D, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? xt.compressedTexSubImage2D(xt.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : xt.texSubImage2D(xt.TEXTURE_2D, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && xt.generateMipmap(xt.TEXTURE_2D), Z.unbindTexture()
+                            a = vt.convert(n.format),
+                            o = vt.convert(n.type);
+                        K.setTexture2D(n, 0), Mt.pixelStorei(Mt.UNPACK_FLIP_Y_WEBGL, n.flipY), Mt.pixelStorei(Mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), Mt.pixelStorei(Mt.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? Mt.texSubImage2D(Mt.TEXTURE_2D, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? Mt.compressedTexSubImage2D(Mt.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : Mt.texSubImage2D(Mt.TEXTURE_2D, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && Mt.generateMipmap(Mt.TEXTURE_2D), Y.unbindTexture()
                     }, this.copyTextureToTexture3D = function(t, e, n, i, r = 0) {
-                        if (v.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
+                        if (y.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                         const s = t.max.x - t.min.x + 1,
                             a = t.max.y - t.min.y + 1,
                             o = t.max.z - t.min.z + 1,
-                            l = gt.convert(i.format),
-                            c = gt.convert(i.type);
+                            l = vt.convert(i.format),
+                            c = vt.convert(i.type);
                         let h;
-                        if (i.isDataTexture3D) $.setTexture3D(i, 0), h = xt.TEXTURE_3D;
+                        if (i.isDataTexture3D) K.setTexture3D(i, 0), h = Mt.TEXTURE_3D;
                         else {
                             if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
-                            $.setTexture2DArray(i, 0), h = xt.TEXTURE_2D_ARRAY
+                            K.setTexture2DArray(i, 0), h = Mt.TEXTURE_2D_ARRAY
                         }
-                        xt.pixelStorei(xt.UNPACK_FLIP_Y_WEBGL, i.flipY), xt.pixelStorei(xt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), xt.pixelStorei(xt.UNPACK_ALIGNMENT, i.unpackAlignment);
-                        const u = xt.getParameter(xt.UNPACK_ROW_LENGTH),
-                            d = xt.getParameter(xt.UNPACK_IMAGE_HEIGHT),
-                            p = xt.getParameter(xt.UNPACK_SKIP_PIXELS),
-                            m = xt.getParameter(xt.UNPACK_SKIP_ROWS),
-                            f = xt.getParameter(xt.UNPACK_SKIP_IMAGES),
+                        Mt.pixelStorei(Mt.UNPACK_FLIP_Y_WEBGL, i.flipY), Mt.pixelStorei(Mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), Mt.pixelStorei(Mt.UNPACK_ALIGNMENT, i.unpackAlignment);
+                        const u = Mt.getParameter(Mt.UNPACK_ROW_LENGTH),
+                            d = Mt.getParameter(Mt.UNPACK_IMAGE_HEIGHT),
+                            p = Mt.getParameter(Mt.UNPACK_SKIP_PIXELS),
+                            m = Mt.getParameter(Mt.UNPACK_SKIP_ROWS),
+                            f = Mt.getParameter(Mt.UNPACK_SKIP_IMAGES),
                             g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
-                        xt.pixelStorei(xt.UNPACK_ROW_LENGTH, g.width), xt.pixelStorei(xt.UNPACK_IMAGE_HEIGHT, g.height), xt.pixelStorei(xt.UNPACK_SKIP_PIXELS, t.min.x), xt.pixelStorei(xt.UNPACK_SKIP_ROWS, t.min.y), xt.pixelStorei(xt.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isDataTexture3D ? xt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), xt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data)) : xt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g), xt.pixelStorei(xt.UNPACK_ROW_LENGTH, u), xt.pixelStorei(xt.UNPACK_IMAGE_HEIGHT, d), xt.pixelStorei(xt.UNPACK_SKIP_PIXELS, p), xt.pixelStorei(xt.UNPACK_SKIP_ROWS, m), xt.pixelStorei(xt.UNPACK_SKIP_IMAGES, f), 0 === r && i.generateMipmaps && xt.generateMipmap(h), Z.unbindTexture()
+                        Mt.pixelStorei(Mt.UNPACK_ROW_LENGTH, g.width), Mt.pixelStorei(Mt.UNPACK_IMAGE_HEIGHT, g.height), Mt.pixelStorei(Mt.UNPACK_SKIP_PIXELS, t.min.x), Mt.pixelStorei(Mt.UNPACK_SKIP_ROWS, t.min.y), Mt.pixelStorei(Mt.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isDataTexture3D ? Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Mt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data)) : Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g), Mt.pixelStorei(Mt.UNPACK_ROW_LENGTH, u), Mt.pixelStorei(Mt.UNPACK_IMAGE_HEIGHT, d), Mt.pixelStorei(Mt.UNPACK_SKIP_PIXELS, p), Mt.pixelStorei(Mt.UNPACK_SKIP_ROWS, m), Mt.pixelStorei(Mt.UNPACK_SKIP_IMAGES, f), 0 === r && i.generateMipmaps && Mt.generateMipmap(h), Y.unbindTexture()
                     }, this.initTexture = function(t) {
-                        $.setTexture2D(t, 0), Z.unbindTexture()
+                        K.setTexture2D(t, 0), Y.unbindTexture()
                     }, this.resetState = function() {
-                        M = 0, b = 0, E = null, Z.reset(), vt.reset()
+                        M = 0, b = 0, w = null, Y.reset(), xt.reset()
                     }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                         detail: this
                     }))
                 }
-                ra.prototype.isWebGLRenderer = !0;
-                class sa extends ra {}
-                sa.prototype.isWebGL1Renderer = !0;
-                class aa {
+                yo.prototype.isWebGLRenderer = !0;
+                class _o extends yo {}
+                _o.prototype.isWebGL1Renderer = !0;
+                class Mo {
                     constructor(t, e = 25e-5) {
-                        this.name = "", this.color = new zt(t), this.density = e
+                        this.name = "", this.color = new Je(t), this.density = e
                     }
                     clone() {
-                        return new aa(this.color, this.density)
+                        return new Mo(this.color, this.density)
                     }
                     toJSON() {
                         return {
                             type: "FogExp2",
                             color: this.color.getHex(),
                             density: this.density
                         }
                     }
                 }
-                aa.prototype.isFogExp2 = !0;
-                class oa {
+                Mo.prototype.isFogExp2 = !0;
+                class bo {
                     constructor(t, e = 1, n = 1e3) {
-                        this.name = "", this.color = new zt(t), this.near = e, this.far = n
+                        this.name = "", this.color = new Je(t), this.near = e, this.far = n
                     }
                     clone() {
-                        return new oa(this.color, this.near, this.far)
+                        return new bo(this.color, this.near, this.far)
                     }
                     toJSON() {
                         return {
                             type: "Fog",
                             color: this.color.getHex(),
                             near: this.near,
                             far: this.far
                         }
                     }
                 }
-                oa.prototype.isFog = !0;
-                class la extends Qe {
+                bo.prototype.isFog = !0;
+                class wo extends ci {
                     constructor() {
                         super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                             detail: this
                         }))
                     }
                     copy(t, e) {
                         return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                     }
                 }
-                la.prototype.isScene = !0;
-                class ca {
+                wo.prototype.isScene = !0;
+                class So {
                     constructor(t, e) {
-                        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = ht, this.updateRange = {
+                        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = _e, this.updateRange = {
                             offset: 0,
                             count: -1
-                        }, this.version = 0, this.uuid = yt()
+                        }, this.version = 0, this.uuid = Le()
                     }
                     onUploadCallback() {}
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                     setUsage(t) {
                         return this.usage = t, this
@@ -9303,56 +9594,56 @@
                         for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                         return this
                     }
                     set(t, e = 0) {
                         return this.array.set(t, e), this
                     }
                     clone(t) {
-                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = yt()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
+                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Le()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                         const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                             n = new this.constructor(e, this.stride);
                         return n.setUsage(this.usage), n
                     }
                     onUpload(t) {
                         return this.onUploadCallback = t, this
                     }
                     toJSON(t) {
-                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = yt()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
+                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Le()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                             uuid: this.uuid,
                             buffer: this.array.buffer._uuid,
                             type: this.array.constructor.name,
                             stride: this.stride
                         }
                     }
                 }
-                ca.prototype.isInterleavedBuffer = !0;
-                const ha = new Zt;
-                class ua {
+                So.prototype.isInterleavedBuffer = !0;
+                const Eo = new on;
+                class To {
                     constructor(t, e, n, i = !1) {
                         this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
                     }
                     get count() {
                         return this.data.count
                     }
                     get array() {
                         return this.data.array
                     }
                     set needsUpdate(t) {
                         this.data.needsUpdate = t
                     }
                     applyMatrix4(t) {
-                        for (let e = 0, n = this.data.count; e < n; e++) ha.x = this.getX(e), ha.y = this.getY(e), ha.z = this.getZ(e), ha.applyMatrix4(t), this.setXYZ(e, ha.x, ha.y, ha.z);
+                        for (let e = 0, n = this.data.count; e < n; e++) Eo.x = this.getX(e), Eo.y = this.getY(e), Eo.z = this.getZ(e), Eo.applyMatrix4(t), this.setXYZ(e, Eo.x, Eo.y, Eo.z);
                         return this
                     }
                     applyNormalMatrix(t) {
-                        for (let e = 0, n = this.count; e < n; e++) ha.x = this.getX(e), ha.y = this.getY(e), ha.z = this.getZ(e), ha.applyNormalMatrix(t), this.setXYZ(e, ha.x, ha.y, ha.z);
+                        for (let e = 0, n = this.count; e < n; e++) Eo.x = this.getX(e), Eo.y = this.getY(e), Eo.z = this.getZ(e), Eo.applyNormalMatrix(t), this.setXYZ(e, Eo.x, Eo.y, Eo.z);
                         return this
                     }
                     transformDirection(t) {
-                        for (let e = 0, n = this.count; e < n; e++) ha.x = this.getX(e), ha.y = this.getY(e), ha.z = this.getZ(e), ha.transformDirection(t), this.setXYZ(e, ha.x, ha.y, ha.z);
+                        for (let e = 0, n = this.count; e < n; e++) Eo.x = this.getX(e), Eo.y = this.getY(e), Eo.z = this.getZ(e), Eo.transformDirection(t), this.setXYZ(e, Eo.x, Eo.y, Eo.z);
                         return this
                     }
                     setX(t, e) {
                         return this.data.array[t * this.data.stride + this.offset] = e, this
                     }
                     setY(t, e) {
                         return this.data.array[t * this.data.stride + this.offset + 1] = e, this
@@ -9388,17 +9679,17 @@
                         if (void 0 === t) {
                             console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                             const t = [];
                             for (let e = 0; e < this.count; e++) {
                                 const n = e * this.data.stride + this.offset;
                                 for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                             }
-                            return new gn(new this.array.constructor(t), this.itemSize, this.normalized)
+                            return new Ti(new this.array.constructor(t), this.itemSize, this.normalized)
                         }
-                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ua(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
+                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new To(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                     }
                     toJSON(t) {
                         if (void 0 === t) {
                             console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                             const t = [];
                             for (let e = 0; e < this.count; e++) {
                                 const n = e * this.data.stride + this.offset;
@@ -9416,77 +9707,77 @@
                             itemSize: this.itemSize,
                             data: this.data.uuid,
                             offset: this.offset,
                             normalized: this.normalized
                         }
                     }
                 }
-                ua.prototype.isInterleavedBufferAttribute = !0;
-                class da extends dn {
+                To.prototype.isInterleavedBufferAttribute = !0;
+                class Ao extends bi {
                     constructor(t) {
-                        super(), this.type = "SpriteMaterial", this.color = new zt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
+                        super(), this.type = "SpriteMaterial", this.color = new Je(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
                     }
                 }
-                let pa;
-                da.prototype.isSpriteMaterial = !0;
-                const ma = new Zt,
-                    fa = new Zt,
-                    ga = new Zt,
-                    va = new At,
-                    xa = new At,
-                    ya = new Ae,
-                    _a = new Zt,
-                    Ma = new Zt,
-                    ba = new Zt,
-                    wa = new At,
-                    Sa = new At,
-                    Ea = new At;
-                class Ta extends Qe {
+                let Ro;
+                Ao.prototype.isSpriteMaterial = !0;
+                const Lo = new on,
+                    Co = new on,
+                    Po = new on,
+                    Do = new Be,
+                    Io = new Be,
+                    No = new Fn,
+                    Oo = new on,
+                    Uo = new on,
+                    Bo = new on,
+                    Fo = new Be,
+                    zo = new Be,
+                    Ho = new Be;
+                class Go extends ci {
                     constructor(t) {
-                        if (super(), this.type = "Sprite", void 0 === pa) {
-                            pa = new Nn;
+                        if (super(), this.type = "Sprite", void 0 === Ro) {
+                            Ro = new Wi;
                             const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
-                                e = new ca(t, 5);
-                            pa.setIndex([0, 1, 2, 0, 2, 3]), pa.setAttribute("position", new ua(e, 3, 0, !1)), pa.setAttribute("uv", new ua(e, 2, 3, !1))
+                                e = new So(t, 5);
+                            Ro.setIndex([0, 1, 2, 0, 2, 3]), Ro.setAttribute("position", new To(e, 3, 0, !1)), Ro.setAttribute("uv", new To(e, 2, 3, !1))
                         }
-                        this.geometry = pa, this.material = void 0 !== t ? t : new da, this.center = new At(.5, .5)
+                        this.geometry = Ro, this.material = void 0 !== t ? t : new Ao, this.center = new Be(.5, .5)
                     }
                     raycast(t, e) {
-                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), fa.setFromMatrixScale(this.matrixWorld), ya.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ga.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && fa.multiplyScalar(-ga.z);
+                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Co.setFromMatrixScale(this.matrixWorld), No.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Po.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Co.multiplyScalar(-Po.z);
                         const n = this.material.rotation;
                         let i, r;
                         0 !== n && (r = Math.cos(n), i = Math.sin(n));
                         const s = this.center;
-                        Aa(_a.set(-.5, -.5, 0), ga, s, fa, i, r), Aa(Ma.set(.5, -.5, 0), ga, s, fa, i, r), Aa(ba.set(.5, .5, 0), ga, s, fa, i, r), wa.set(0, 0), Sa.set(1, 0), Ea.set(1, 1);
-                        let a = t.ray.intersectTriangle(_a, Ma, ba, !1, ma);
-                        if (null === a && (Aa(Ma.set(-.5, .5, 0), ga, s, fa, i, r), Sa.set(0, 1), a = t.ray.intersectTriangle(_a, ba, Ma, !1, ma), null === a)) return;
-                        const o = t.ray.origin.distanceTo(ma);
+                        Vo(Oo.set(-.5, -.5, 0), Po, s, Co, i, r), Vo(Uo.set(.5, -.5, 0), Po, s, Co, i, r), Vo(Bo.set(.5, .5, 0), Po, s, Co, i, r), Fo.set(0, 0), zo.set(1, 0), Ho.set(1, 1);
+                        let a = t.ray.intersectTriangle(Oo, Uo, Bo, !1, Lo);
+                        if (null === a && (Vo(Uo.set(-.5, .5, 0), Po, s, Co, i, r), zo.set(0, 1), a = t.ray.intersectTriangle(Oo, Bo, Uo, !1, Lo), null === a)) return;
+                        const o = t.ray.origin.distanceTo(Lo);
                         o < t.near || o > t.far || e.push({
                             distance: o,
-                            point: ma.clone(),
-                            uv: hn.getUV(ma, _a, Ma, ba, wa, Sa, Ea, new At),
+                            point: Lo.clone(),
+                            uv: _i.getUV(Lo, Oo, Uo, Bo, Fo, zo, Ho, new Be),
                             face: null,
                             object: this
                         })
                     }
                     copy(t) {
                         return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                     }
                 }
 
-                function Aa(t, e, n, i, r, s) {
-                    va.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (xa.x = s * va.x - r * va.y, xa.y = r * va.x + s * va.y) : xa.copy(va), t.copy(e), t.x += xa.x, t.y += xa.y, t.applyMatrix4(ya)
+                function Vo(t, e, n, i, r, s) {
+                    Do.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (Io.x = s * Do.x - r * Do.y, Io.y = r * Do.x + s * Do.y) : Io.copy(Do), t.copy(e), t.x += Io.x, t.y += Io.y, t.applyMatrix4(No)
                 }
-                Ta.prototype.isSprite = !0;
-                const Ra = new Zt,
-                    La = new Zt;
-                class Ca extends Qe {
+                Go.prototype.isSprite = !0;
+                const ko = new on,
+                    Wo = new on;
+                class jo extends ci {
                     constructor() {
                         super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                             levels: {
                                 enumerable: !0,
                                 value: []
                             },
                             isLOD: {
@@ -9523,24 +9814,24 @@
                             for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                             return e[n - 1].object
                         }
                         return null
                     }
                     raycast(t, e) {
                         if (this.levels.length > 0) {
-                            Ra.setFromMatrixPosition(this.matrixWorld);
-                            const n = t.ray.origin.distanceTo(Ra);
+                            ko.setFromMatrixPosition(this.matrixWorld);
+                            const n = t.ray.origin.distanceTo(ko);
                             this.getObjectForDistance(n).raycast(t, e)
                         }
                     }
                     update(t) {
                         const e = this.levels;
                         if (e.length > 1) {
-                            Ra.setFromMatrixPosition(t.matrixWorld), La.setFromMatrixPosition(this.matrixWorld);
-                            const n = Ra.distanceTo(La) / t.zoom;
+                            ko.setFromMatrixPosition(t.matrixWorld), Wo.setFromMatrixPosition(this.matrixWorld);
+                            const n = ko.distanceTo(Wo) / t.zoom;
                             let i, r;
                             for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                             for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1
                         }
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
@@ -9552,94 +9843,94 @@
                                 object: i.object.uuid,
                                 distance: i.distance
                             })
                         }
                         return e
                     }
                 }
-                const Pa = new Zt,
-                    Da = new jt,
-                    Ia = new jt,
-                    Na = new Zt,
-                    Oa = new Ae;
-                class Ua extends Qn {
+                const Xo = new on,
+                    qo = new en,
+                    Yo = new en,
+                    Jo = new on,
+                    Zo = new Fn;
+                class Ko extends lr {
                     constructor(t, e) {
-                        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ae, this.bindMatrixInverse = new Ae
+                        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Fn, this.bindMatrixInverse = new Fn
                     }
                     copy(t) {
                         return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                     }
                     bind(t, e) {
                         this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                     }
                     pose() {
                         this.skeleton.pose()
                     }
                     normalizeSkinWeights() {
-                        const t = new jt,
+                        const t = new en,
                             e = this.geometry.attributes.skinWeight;
                         for (let n = 0, i = e.count; n < i; n++) {
                             t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                             const i = 1 / t.manhattanLength();
                             i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                         }
                     }
                     updateMatrixWorld(t) {
                         super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                     }
                     boneTransform(t, e) {
                         const n = this.skeleton,
                             i = this.geometry;
-                        Da.fromBufferAttribute(i.attributes.skinIndex, t), Ia.fromBufferAttribute(i.attributes.skinWeight, t), Pa.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
+                        qo.fromBufferAttribute(i.attributes.skinIndex, t), Yo.fromBufferAttribute(i.attributes.skinWeight, t), Xo.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                         for (let t = 0; t < 4; t++) {
-                            const i = Ia.getComponent(t);
+                            const i = Yo.getComponent(t);
                             if (0 !== i) {
-                                const r = Da.getComponent(t);
-                                Oa.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Na.copy(Pa).applyMatrix4(Oa), i)
+                                const r = qo.getComponent(t);
+                                Zo.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Jo.copy(Xo).applyMatrix4(Zo), i)
                             }
                         }
                         return e.applyMatrix4(this.bindMatrixInverse)
                     }
                 }
-                Ua.prototype.isSkinnedMesh = !0;
-                class Ba extends Qe {
+                Ko.prototype.isSkinnedMesh = !0;
+                class Qo extends ci {
                     constructor() {
                         super(), this.type = "Bone"
                     }
                 }
-                Ba.prototype.isBone = !0;
-                class Fa extends kt {
-                    constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, h, u) {
+                Qo.prototype.isBone = !0;
+                class $o extends $e {
+                    constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = ot, c = ot, h, u) {
                         super(null, s, a, o, l, c, i, r, h, u), this.image = {
                             data: t,
                             width: e,
                             height: n
                         }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }
-                Fa.prototype.isDataTexture = !0;
-                const za = new Ae,
-                    Ha = new Ae;
-                class Ga {
+                $o.prototype.isDataTexture = !0;
+                const tl = new Fn,
+                    el = new Fn;
+                class nl {
                     constructor(t = [], e = []) {
-                        this.uuid = yt(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
+                        this.uuid = Le(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                     }
                     init() {
                         const t = this.bones,
                             e = this.boneInverses;
                         if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                         else if (t.length !== e.length) {
                             console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
-                            for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Ae)
+                            for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Fn)
                         }
                     }
                     calculateInverses() {
                         this.boneInverses.length = 0;
                         for (let t = 0, e = this.bones.length; t < e; t++) {
-                            const e = new Ae;
+                            const e = new Fn;
                             this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                         }
                     }
                     pose() {
                         for (let t = 0, e = this.bones.length; t < e; t++) {
                             const e = this.bones[t];
                             e && e.matrixWorld.copy(this.boneInverses[t]).invert()
@@ -9651,28 +9942,28 @@
                     }
                     update() {
                         const t = this.bones,
                             e = this.boneInverses,
                             n = this.boneMatrices,
                             i = this.boneTexture;
                         for (let i = 0, r = t.length; i < r; i++) {
-                            const r = t[i] ? t[i].matrixWorld : Ha;
-                            za.multiplyMatrices(r, e[i]), za.toArray(n, 16 * i)
+                            const r = t[i] ? t[i].matrixWorld : el;
+                            tl.multiplyMatrices(r, e[i]), tl.toArray(n, 16 * i)
                         }
                         null !== i && (i.needsUpdate = !0)
                     }
                     clone() {
-                        return new Ga(this.bones, this.boneInverses)
+                        return new nl(this.bones, this.boneInverses)
                     }
                     computeBoneTexture() {
                         let t = Math.sqrt(4 * this.bones.length);
-                        t = St(t), t = Math.max(t, 4);
+                        t = Ne(t), t = Math.max(t, 4);
                         const e = new Float32Array(t * t * 4);
                         e.set(this.boneMatrices);
-                        const n = new Fa(e, t, t, T, w);
+                        const n = new $o(e, t, t, Et, yt);
                         return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this
                     }
                     getBoneByName(t) {
                         for (let e = 0, n = this.bones.length; e < n; e++) {
                             const n = this.bones[e];
                             if (n.name === t) return n
                         }
@@ -9681,15 +9972,15 @@
                         null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                     }
                     fromJSON(t, e) {
                         this.uuid = t.uuid;
                         for (let n = 0, i = t.bones.length; n < i; n++) {
                             const i = t.bones[n];
                             let r = e[i];
-                            void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Ba), this.bones.push(r), this.boneInverses.push((new Ae).fromArray(t.boneInverses[n]))
+                            void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Qo), this.bones.push(r), this.boneInverses.push((new Fn).fromArray(t.boneInverses[n]))
                         }
                         return this.init(), this
                     }
                     toJSON() {
                         const t = {
                             metadata: {
                                 version: 4.5,
@@ -9707,139 +9998,139 @@
                             t.bones.push(r.uuid);
                             const s = n[i];
                             t.boneInverses.push(s.toArray())
                         }
                         return t
                     }
                 }
-                class Va extends gn {
+                class il extends Ti {
                     constructor(t, e, n, i = 1) {
                         "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = i
                     }
                     copy(t) {
                         return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                     }
                 }
-                Va.prototype.isInstancedBufferAttribute = !0;
-                const ka = new Ae,
-                    Wa = new Ae,
-                    ja = [],
-                    Xa = new Qn;
-                class qa extends Qn {
+                il.prototype.isInstancedBufferAttribute = !0;
+                const rl = new Fn,
+                    sl = new Fn,
+                    al = [],
+                    ol = new lr;
+                class ll extends lr {
                     constructor(t, e, n) {
-                        super(t, e), this.instanceMatrix = new Va(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
+                        super(t, e), this.instanceMatrix = new il(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
                     }
                     copy(t) {
                         return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
                     }
                     getColorAt(t, e) {
                         e.fromArray(this.instanceColor.array, 3 * t)
                     }
                     getMatrixAt(t, e) {
                         e.fromArray(this.instanceMatrix.array, 16 * t)
                     }
                     raycast(t, e) {
                         const n = this.matrixWorld,
                             i = this.count;
-                        if (Xa.geometry = this.geometry, Xa.material = this.material, void 0 !== Xa.material)
+                        if (ol.geometry = this.geometry, ol.material = this.material, void 0 !== ol.material)
                             for (let r = 0; r < i; r++) {
-                                this.getMatrixAt(r, ka), Wa.multiplyMatrices(n, ka), Xa.matrixWorld = Wa, Xa.raycast(t, ja);
-                                for (let t = 0, n = ja.length; t < n; t++) {
-                                    const n = ja[t];
+                                this.getMatrixAt(r, rl), sl.multiplyMatrices(n, rl), ol.matrixWorld = sl, ol.raycast(t, al);
+                                for (let t = 0, n = al.length; t < n; t++) {
+                                    const n = al[t];
                                     n.instanceId = r, n.object = this, e.push(n)
                                 }
-                                ja.length = 0
+                                al.length = 0
                             }
                     }
                     setColorAt(t, e) {
-                        null === this.instanceColor && (this.instanceColor = new Va(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
+                        null === this.instanceColor && (this.instanceColor = new il(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                     }
                     setMatrixAt(t, e) {
                         e.toArray(this.instanceMatrix.array, 16 * t)
                     }
                     updateMorphTargets() {}
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }
-                qa.prototype.isInstancedMesh = !0;
-                class Ya extends dn {
+                ll.prototype.isInstancedMesh = !0;
+                class cl extends bi {
                     constructor(t) {
-                        super(), this.type = "LineBasicMaterial", this.color = new zt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
+                        super(), this.type = "LineBasicMaterial", this.color = new Je(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
                     }
                 }
-                Ya.prototype.isLineBasicMaterial = !0;
-                const Ja = new Zt,
-                    Za = new Zt,
-                    Ka = new Ae,
-                    Qa = new Te,
-                    $a = new xe;
-                class to extends Qe {
-                    constructor(t = new Nn, e = new Ya) {
+                cl.prototype.isLineBasicMaterial = !0;
+                const hl = new on,
+                    ul = new on,
+                    dl = new Fn,
+                    pl = new Bn,
+                    ml = new Ln;
+                class fl extends ci {
+                    constructor(t = new Wi, e = new cl) {
                         super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                     }
                     computeLineDistances() {
                         const t = this.geometry;
                         if (t.isBufferGeometry)
                             if (null === t.index) {
                                 const e = t.attributes.position,
                                     n = [0];
-                                for (let t = 1, i = e.count; t < i; t++) Ja.fromBufferAttribute(e, t - 1), Za.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Ja.distanceTo(Za);
-                                t.setAttribute("lineDistance", new En(n, 1))
+                                for (let t = 1, i = e.count; t < i; t++) hl.fromBufferAttribute(e, t - 1), ul.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += hl.distanceTo(ul);
+                                t.setAttribute("lineDistance", new Oi(n, 1))
                             } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                         else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                         return this
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.matrixWorld,
                             r = t.params.Line.threshold,
                             s = n.drawRange;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), $a.copy(n.boundingSphere), $a.applyMatrix4(i), $a.radius += r, !1 === t.ray.intersectsSphere($a)) return;
-                        Ka.copy(i).invert(), Qa.copy(t.ray).applyMatrix4(Ka);
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), ml.copy(n.boundingSphere), ml.applyMatrix4(i), ml.radius += r, !1 === t.ray.intersectsSphere(ml)) return;
+                        dl.copy(i).invert(), pl.copy(t.ray).applyMatrix4(dl);
                         const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                             o = a * a,
-                            l = new Zt,
-                            c = new Zt,
-                            h = new Zt,
-                            u = new Zt,
+                            l = new on,
+                            c = new on,
+                            h = new on,
+                            u = new on,
                             d = this.isLineSegments ? 2 : 1;
                         if (n.isBufferGeometry) {
                             const i = n.index,
                                 r = n.attributes.position;
                             if (null !== i)
                                 for (let n = Math.max(0, s.start), a = Math.min(i.count, s.start + s.count) - 1; n < a; n += d) {
                                     const s = i.getX(n),
                                         a = i.getX(n + 1);
-                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a), Qa.distanceSqToSegment(l, c, u, h) > o) continue;
+                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a), pl.distanceSqToSegment(l, c, u, h) > o) continue;
                                     u.applyMatrix4(this.matrixWorld);
                                     const d = t.ray.origin.distanceTo(u);
                                     d < t.near || d > t.far || e.push({
                                         distance: d,
                                         point: h.clone().applyMatrix4(this.matrixWorld),
                                         index: n,
                                         face: null,
                                         faceIndex: null,
                                         object: this
                                     })
                                 } else
                                     for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
-                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), Qa.distanceSqToSegment(l, c, u, h) > o) continue;
+                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), pl.distanceSqToSegment(l, c, u, h) > o) continue;
                                         u.applyMatrix4(this.matrixWorld);
                                         const i = t.ray.origin.distanceTo(u);
                                         i < t.near || i > t.far || e.push({
                                             distance: i,
                                             point: h.clone().applyMatrix4(this.matrixWorld),
                                             index: n,
                                             face: null,
@@ -9866,79 +10157,79 @@
                             }
                         } else {
                             const e = t.morphTargets;
                             void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                         }
                     }
                 }
-                to.prototype.isLine = !0;
-                const eo = new Zt,
-                    no = new Zt;
-                class io extends to {
+                fl.prototype.isLine = !0;
+                const gl = new on,
+                    vl = new on;
+                class xl extends fl {
                     constructor(t, e) {
                         super(t, e), this.type = "LineSegments"
                     }
                     computeLineDistances() {
                         const t = this.geometry;
                         if (t.isBufferGeometry)
                             if (null === t.index) {
                                 const e = t.attributes.position,
                                     n = [];
-                                for (let t = 0, i = e.count; t < i; t += 2) eo.fromBufferAttribute(e, t), no.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + eo.distanceTo(no);
-                                t.setAttribute("lineDistance", new En(n, 1))
+                                for (let t = 0, i = e.count; t < i; t += 2) gl.fromBufferAttribute(e, t), vl.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + gl.distanceTo(vl);
+                                t.setAttribute("lineDistance", new Oi(n, 1))
                             } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                         else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                         return this
                     }
                 }
-                io.prototype.isLineSegments = !0;
-                class ro extends to {
+                xl.prototype.isLineSegments = !0;
+                class yl extends fl {
                     constructor(t, e) {
                         super(t, e), this.type = "LineLoop"
                     }
                 }
-                ro.prototype.isLineLoop = !0;
-                class so extends dn {
+                yl.prototype.isLineLoop = !0;
+                class _l extends bi {
                     constructor(t) {
-                        super(), this.type = "PointsMaterial", this.color = new zt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
+                        super(), this.type = "PointsMaterial", this.color = new Je(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
                     }
                 }
-                so.prototype.isPointsMaterial = !0;
-                const ao = new Ae,
-                    oo = new Te,
-                    lo = new xe,
-                    co = new Zt;
-                class ho extends Qe {
-                    constructor(t = new Nn, e = new so) {
+                _l.prototype.isPointsMaterial = !0;
+                const Ml = new Fn,
+                    bl = new Bn,
+                    wl = new Ln,
+                    Sl = new on;
+                class El extends ci {
+                    constructor(t = new Wi, e = new _l) {
                         super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.matrixWorld,
                             r = t.params.Points.threshold,
                             s = n.drawRange;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), lo.copy(n.boundingSphere), lo.applyMatrix4(i), lo.radius += r, !1 === t.ray.intersectsSphere(lo)) return;
-                        ao.copy(i).invert(), oo.copy(t.ray).applyMatrix4(ao);
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), wl.copy(n.boundingSphere), wl.applyMatrix4(i), wl.radius += r, !1 === t.ray.intersectsSphere(wl)) return;
+                        Ml.copy(i).invert(), bl.copy(t.ray).applyMatrix4(Ml);
                         const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                             o = a * a;
                         if (n.isBufferGeometry) {
                             const r = n.index,
                                 a = n.attributes.position;
                             if (null !== r)
                                 for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                                     const s = r.getX(n);
-                                    co.fromBufferAttribute(a, s), uo(co, s, o, i, t, e, this)
+                                    Sl.fromBufferAttribute(a, s), Tl(Sl, s, o, i, t, e, this)
                                 } else
-                                    for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++) co.fromBufferAttribute(a, n), uo(co, n, o, i, t, e, this)
+                                    for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++) Sl.fromBufferAttribute(a, n), Tl(Sl, n, o, i, t, e, this)
                         } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                     }
                     updateMorphTargets() {
                         const t = this.geometry;
                         if (t.isBufferGeometry) {
                             const e = t.morphAttributes,
                                 n = Object.keys(e);
@@ -9955,100 +10246,100 @@
                         } else {
                             const e = t.morphTargets;
                             void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                         }
                     }
                 }
 
-                function uo(t, e, n, i, r, s, a) {
-                    const o = oo.distanceSqToPoint(t);
+                function Tl(t, e, n, i, r, s, a) {
+                    const o = bl.distanceSqToPoint(t);
                     if (o < n) {
-                        const n = new Zt;
-                        oo.closestPointToPoint(t, n), n.applyMatrix4(i);
+                        const n = new on;
+                        bl.closestPointToPoint(t, n), n.applyMatrix4(i);
                         const l = r.ray.origin.distanceTo(n);
                         if (l < r.near || l > r.far) return;
                         s.push({
                             distance: l,
                             distanceToRay: Math.sqrt(o),
                             point: n,
                             index: e,
                             face: null,
                             object: a
                         })
                     }
                 }
-                ho.prototype.isPoints = !0;
-                class po extends kt {
+                El.prototype.isPoints = !0;
+                class Al extends $e {
                     constructor(t, e, n, i, r, s, a, o, l) {
-                        super(t, e, n, i, r, s, a, o, l), this.minFilter = void 0 !== s ? s : v, this.magFilter = void 0 !== r ? r : v, this.generateMipmaps = !1;
+                        super(t, e, n, i, r, s, a, o, l), this.minFilter = void 0 !== s ? s : ht, this.magFilter = void 0 !== r ? r : ht, this.generateMipmaps = !1;
                         const c = this;
                         "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                             c.needsUpdate = !0, t.requestVideoFrameCallback(e)
                         }))
                     }
                     clone() {
                         return new this.constructor(this.image).copy(this)
                     }
                     update() {
                         const t = this.image;
                         !1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                     }
                 }
-                po.prototype.isVideoTexture = !0;
-                class mo extends kt {
+                Al.prototype.isVideoTexture = !0;
+                class Rl extends $e {
                     constructor(t, e, n) {
                         super({
                             width: t,
                             height: e
-                        }), this.format = n, this.magFilter = m, this.minFilter = m, this.generateMipmaps = !1, this.needsUpdate = !0
+                        }), this.format = n, this.magFilter = ot, this.minFilter = ot, this.generateMipmaps = !1, this.needsUpdate = !0
                     }
                 }
-                mo.prototype.isFramebufferTexture = !0;
-                class fo extends kt {
+                Rl.prototype.isFramebufferTexture = !0;
+                class Ll extends $e {
                     constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
                         super(null, s, a, o, l, c, i, r, h, u), this.image = {
                             width: e,
                             height: n
                         }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                     }
                 }
-                fo.prototype.isCompressedTexture = !0;
-                class go extends kt {
+                Ll.prototype.isCompressedTexture = !0;
+                class Cl extends $e {
                     constructor(t, e, n, i, r, s, a, o, l) {
                         super(t, e, n, i, r, s, a, o, l), this.needsUpdate = !0
                     }
                 }
-                go.prototype.isCanvasTexture = !0;
-                class vo extends Nn {
+                Cl.prototype.isCanvasTexture = !0;
+                class Pl extends Wi {
                     constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {
                         super(), this.type = "CircleGeometry", this.parameters = {
                             radius: t,
                             segments: e,
                             thetaStart: n,
                             thetaLength: i
                         }, e = Math.max(3, e);
                         const r = [],
                             s = [],
                             a = [],
                             o = [],
-                            l = new Zt,
-                            c = new At;
+                            l = new on,
+                            c = new Be;
                         s.push(0, 0, 0), a.push(0, 0, 1), o.push(.5, .5);
                         for (let r = 0, h = 3; r <= e; r++, h += 3) {
                             const u = n + r / e * i;
                             l.x = t * Math.cos(u), l.y = t * Math.sin(u), s.push(l.x, l.y, l.z), a.push(0, 0, 1), c.x = (s[h] / t + 1) / 2, c.y = (s[h + 1] / t + 1) / 2, o.push(c.x, c.y)
                         }
                         for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
-                        this.setIndex(r), this.setAttribute("position", new En(s, 3)), this.setAttribute("normal", new En(a, 3)), this.setAttribute("uv", new En(o, 2))
+                        this.setIndex(r), this.setAttribute("position", new Oi(s, 3)), this.setAttribute("normal", new Oi(a, 3)), this.setAttribute("uv", new Oi(o, 2))
                     }
                     static fromJSON(t) {
-                        return new vo(t.radius, t.segments, t.thetaStart, t.thetaLength)
+                        return new Pl(t.radius, t.segments, t.thetaStart, t.thetaLength)
                     }
                 }
-                class xo extends Nn {
+                class Dl extends Wi {
                     constructor(t = 1, e = 1, n = 1, i = 8, r = 1, s = !1, a = 0, o = 2 * Math.PI) {
                         super(), this.type = "CylinderGeometry", this.parameters = {
                             radiusTop: t,
                             radiusBottom: e,
                             height: n,
                             radialSegments: i,
                             heightSegments: r,
@@ -10065,16 +10356,16 @@
                         let p = 0;
                         const m = [],
                             f = n / 2;
                         let g = 0;
 
                         function v(n) {
                             const r = p,
-                                s = new At,
-                                m = new Zt;
+                                s = new Be,
+                                m = new on;
                             let v = 0;
                             const x = !0 === n ? t : e,
                                 y = !0 === n ? 1 : -1;
                             for (let t = 1; t <= i; t++) h.push(0, f * y, 0), u.push(0, y, 0), d.push(.5, .5), p++;
                             const _ = p;
                             for (let t = 0; t <= i; t++) {
                                 const e = t / i * o + a,
@@ -10085,16 +10376,16 @@
                             for (let t = 0; t < i; t++) {
                                 const e = r + t,
                                     i = _ + t;
                                 !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), v += 3
                             }
                             l.addGroup(g, v, !0 === n ? 1 : 2), g += v
                         }! function() {
-                            const s = new Zt,
-                                v = new Zt;
+                            const s = new on,
+                                v = new on;
                             let x = 0;
                             const y = (e - t) / n;
                             for (let l = 0; l <= r; l++) {
                                 const c = [],
                                     g = l / r,
                                     x = g * (e - t) + t;
                                 for (let t = 0; t <= i; t++) {
@@ -10111,37 +10402,37 @@
                                     const n = m[e][t],
                                         i = m[e + 1][t],
                                         r = m[e + 1][t + 1],
                                         s = m[e][t + 1];
                                     c.push(n, i, s), c.push(i, r, s), x += 6
                                 }
                             l.addGroup(g, x, 0), g += x
-                        }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new En(h, 3)), this.setAttribute("normal", new En(u, 3)), this.setAttribute("uv", new En(d, 2))
+                        }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new Oi(h, 3)), this.setAttribute("normal", new Oi(u, 3)), this.setAttribute("uv", new Oi(d, 2))
                     }
                     static fromJSON(t) {
-                        return new xo(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
+                        return new Dl(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
                     }
                 }
-                class yo extends xo {
+                class Il extends Dl {
                     constructor(t = 1, e = 1, n = 8, i = 1, r = !1, s = 0, a = 2 * Math.PI) {
                         super(0, t, e, n, i, r, s, a), this.type = "ConeGeometry", this.parameters = {
                             radius: t,
                             height: e,
                             radialSegments: n,
                             heightSegments: i,
                             openEnded: r,
                             thetaStart: s,
                             thetaLength: a
                         }
                     }
                     static fromJSON(t) {
-                        return new yo(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
+                        return new Il(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
                     }
                 }
-                class _o extends Nn {
+                class Nl extends Wi {
                     constructor(t = [], e = [], n = 1, i = 0) {
                         super(), this.type = "PolyhedronGeometry", this.parameters = {
                             vertices: t,
                             indices: e,
                             radius: n,
                             detail: i
                         };
@@ -10177,40 +10468,40 @@
                         function c(t, e, n, i) {
                             i < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + .5)
                         }
 
                         function h(t) {
                             return Math.atan2(t.z, -t.x)
                         }! function(t) {
-                            const n = new Zt,
-                                i = new Zt,
-                                r = new Zt;
+                            const n = new on,
+                                i = new on,
+                                r = new on;
                             for (let s = 0; s < e.length; s += 3) l(e[s + 0], n), l(e[s + 1], i), l(e[s + 2], r), a(n, i, r, t)
                         }(i),
                         function(t) {
-                            const e = new Zt;
+                            const e = new on;
                             for (let n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z
                         }(n),
                         function() {
-                            const t = new Zt;
+                            const t = new on;
                             for (let n = 0; n < r.length; n += 3) {
                                 t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2];
                                 const i = h(t) / 2 / Math.PI + .5,
                                     a = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
                                 s.push(i, 1 - a)
                             }
                             var e;
                             (function() {
-                                const t = new Zt,
-                                    e = new Zt,
-                                    n = new Zt,
-                                    i = new Zt,
-                                    a = new At,
-                                    o = new At,
-                                    l = new At;
+                                const t = new on,
+                                    e = new on,
+                                    n = new on,
+                                    i = new on,
+                                    a = new Be,
+                                    o = new Be,
+                                    l = new Be;
                                 for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                                     t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), a.set(s[d + 0], s[d + 1]), o.set(s[d + 2], s[d + 3]), l.set(s[d + 4], s[d + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                                     const p = h(i);
                                     c(a, d + 0, t, p), c(o, d + 2, e, p), c(l, d + 4, n, p)
                                 }
                             })(),
                             function() {
@@ -10219,89 +10510,89 @@
                                         n = s[t + 2],
                                         i = s[t + 4],
                                         r = Math.max(e, n, i),
                                         a = Math.min(e, n, i);
                                     r > .9 && a < .1 && (e < .2 && (s[t + 0] += 1), n < .2 && (s[t + 2] += 1), i < .2 && (s[t + 4] += 1))
                                 }
                             }()
-                        }(), this.setAttribute("position", new En(r, 3)), this.setAttribute("normal", new En(r.slice(), 3)), this.setAttribute("uv", new En(s, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
+                        }(), this.setAttribute("position", new Oi(r, 3)), this.setAttribute("normal", new Oi(r.slice(), 3)), this.setAttribute("uv", new Oi(s, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
                     }
                     static fromJSON(t) {
-                        return new _o(t.vertices, t.indices, t.radius, t.details)
+                        return new Nl(t.vertices, t.indices, t.radius, t.details)
                     }
                 }
-                class Mo extends _o {
+                class Ol extends Nl {
                     constructor(t = 1, e = 0) {
                         const n = (1 + Math.sqrt(5)) / 2,
                             i = 1 / n;
                         super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = {
                             radius: t,
                             detail: e
                         }
                     }
                     static fromJSON(t) {
-                        return new Mo(t.radius, t.detail)
+                        return new Ol(t.radius, t.detail)
                     }
                 }
-                const bo = new Zt,
-                    wo = new Zt,
-                    So = new Zt,
-                    Eo = new hn;
-                class To extends Nn {
+                const Ul = new on,
+                    Bl = new on,
+                    Fl = new on,
+                    zl = new _i;
+                class Hl extends Wi {
                     constructor(t = null, e = 1) {
                         if (super(), this.type = "EdgesGeometry", this.parameters = {
                                 geometry: t,
                                 thresholdAngle: e
                             }, null !== t) {
                             const n = 4,
                                 i = Math.pow(10, n),
-                                r = Math.cos(vt * e),
+                                r = Math.cos(Ae * e),
                                 s = t.getIndex(),
                                 a = t.getAttribute("position"),
                                 o = s ? s.count : a.count,
                                 l = [0, 0, 0],
                                 c = ["a", "b", "c"],
                                 h = new Array(3),
                                 u = {},
                                 d = [];
                             for (let t = 0; t < o; t += 3) {
                                 s ? (l[0] = s.getX(t), l[1] = s.getX(t + 1), l[2] = s.getX(t + 2)) : (l[0] = t, l[1] = t + 1, l[2] = t + 2);
                                 const {
                                     a: e,
                                     b: n,
                                     c: o
-                                } = Eo;
-                                if (e.fromBufferAttribute(a, l[0]), n.fromBufferAttribute(a, l[1]), o.fromBufferAttribute(a, l[2]), Eo.getNormal(So), h[0] = `${Math.round(e.x*i)},${Math.round(e.y*i)},${Math.round(e.z*i)}`, h[1] = `${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`, h[2] = `${Math.round(o.x*i)},${Math.round(o.y*i)},${Math.round(o.z*i)}`, h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
+                                } = zl;
+                                if (e.fromBufferAttribute(a, l[0]), n.fromBufferAttribute(a, l[1]), o.fromBufferAttribute(a, l[2]), zl.getNormal(Fl), h[0] = `${Math.round(e.x*i)},${Math.round(e.y*i)},${Math.round(e.z*i)}`, h[1] = `${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`, h[2] = `${Math.round(o.x*i)},${Math.round(o.y*i)},${Math.round(o.z*i)}`, h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
                                     for (let t = 0; t < 3; t++) {
                                         const e = (t + 1) % 3,
                                             n = h[t],
                                             i = h[e],
-                                            s = Eo[c[t]],
-                                            a = Eo[c[e]],
+                                            s = zl[c[t]],
+                                            a = zl[c[e]],
                                             o = `${n}_${i}`,
                                             p = `${i}_${n}`;
-                                        p in u && u[p] ? (So.dot(u[p].normal) <= r && (d.push(s.x, s.y, s.z), d.push(a.x, a.y, a.z)), u[p] = null) : o in u || (u[o] = {
+                                        p in u && u[p] ? (Fl.dot(u[p].normal) <= r && (d.push(s.x, s.y, s.z), d.push(a.x, a.y, a.z)), u[p] = null) : o in u || (u[o] = {
                                             index0: l[t],
                                             index1: l[e],
-                                            normal: So.clone()
+                                            normal: Fl.clone()
                                         })
                                     }
                             }
                             for (const t in u)
                                 if (u[t]) {
                                     const {
                                         index0: e,
                                         index1: n
                                     } = u[t];
-                                    bo.fromBufferAttribute(a, e), wo.fromBufferAttribute(a, n), d.push(bo.x, bo.y, bo.z), d.push(wo.x, wo.y, wo.z)
-                                } this.setAttribute("position", new En(d, 3))
+                                    Ul.fromBufferAttribute(a, e), Bl.fromBufferAttribute(a, n), d.push(Ul.x, Ul.y, Ul.z), d.push(Bl.x, Bl.y, Bl.z)
+                                } this.setAttribute("position", new Oi(d, 3))
                         }
                     }
                 }
-                class Ao {
+                class Gl {
                     constructor() {
                         this.type = "Curve", this.arcLengthDivisions = 200
                     }
                     getPoint() {
                         return console.warn("THREE.Curve: .getPoint() not implemented."), null
                     }
                     getPointAt(t, e) {
@@ -10358,48 +10649,48 @@
                     getTangent(t, e) {
                         const n = 1e-4;
                         let i = t - n,
                             r = t + n;
                         i < 0 && (i = 0), r > 1 && (r = 1);
                         const s = this.getPoint(i),
                             a = this.getPoint(r),
-                            o = e || (s.isVector2 ? new At : new Zt);
+                            o = e || (s.isVector2 ? new Be : new on);
                         return o.copy(a).sub(s).normalize(), o
                     }
                     getTangentAt(t, e) {
                         const n = this.getUtoTmapping(t);
                         return this.getTangent(n, e)
                     }
                     computeFrenetFrames(t, e) {
-                        const n = new Zt,
+                        const n = new on,
                             i = [],
                             r = [],
                             s = [],
-                            a = new Zt,
-                            o = new Ae;
+                            a = new on,
+                            o = new Fn;
                         for (let e = 0; e <= t; e++) {
                             const n = e / t;
-                            i[e] = this.getTangentAt(n, new Zt)
+                            i[e] = this.getTangentAt(n, new on)
                         }
-                        r[0] = new Zt, s[0] = new Zt;
+                        r[0] = new on, s[0] = new on;
                         let l = Number.MAX_VALUE;
                         const c = Math.abs(i[0].x),
                             h = Math.abs(i[0].y),
                             u = Math.abs(i[0].z);
                         c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), s[0].crossVectors(i[0], r[0]);
                         for (let e = 1; e <= t; e++) {
                             if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), a.crossVectors(i[e - 1], i[e]), a.length() > Number.EPSILON) {
                                 a.normalize();
-                                const t = Math.acos(_t(i[e - 1].dot(i[e]), -1, 1));
+                                const t = Math.acos(Ce(i[e - 1].dot(i[e]), -1, 1));
                                 r[e].applyMatrix4(o.makeRotationAxis(a, t))
                             }
                             s[e].crossVectors(i[e], r[e])
                         }
                         if (!0 === e) {
-                            let e = Math.acos(_t(r[0].dot(r[t]), -1, 1));
+                            let e = Math.acos(Ce(r[0].dot(r[t]), -1, 1));
                             e /= t, i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                             for (let n = 1; n <= t; n++) r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
                         }
                         return {
                             tangents: i,
                             normals: r,
                             binormals: s
@@ -10421,20 +10712,20 @@
                         };
                         return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                     }
                     fromJSON(t) {
                         return this.arcLengthDivisions = t.arcLengthDivisions, this
                     }
                 }
-                class Ro extends Ao {
+                class Vl extends Gl {
                     constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
                         super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
                     }
                     getPoint(t, e) {
-                        const n = e || new At,
+                        const n = e || new Be,
                             i = 2 * Math.PI;
                         let r = this.aEndAngle - this.aStartAngle;
                         const s = Math.abs(r) < Number.EPSILON;
                         for (; r < 0;) r += i;
                         for (; r > i;) r -= i;
                         r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                         const a = this.aStartAngle + t * r;
@@ -10456,22 +10747,22 @@
                         const t = super.toJSON();
                         return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                     }
                 }
-                Ro.prototype.isEllipseCurve = !0;
-                class Lo extends Ro {
+                Vl.prototype.isEllipseCurve = !0;
+                class kl extends Vl {
                     constructor(t, e, n, i, r, s) {
                         super(t, e, n, n, i, r, s), this.type = "ArcCurve"
                     }
                 }
 
-                function Co() {
+                function Wl() {
                     let t = 0,
                         e = 0,
                         n = 0,
                         i = 0;
 
                     function r(r, s, a, o) {
                         t = r, e = a, n = -3 * r + 3 * s - 2 * a - o, i = 2 * r - 2 * s + a + o
@@ -10487,41 +10778,41 @@
                         },
                         calc: function(r) {
                             const s = r * r;
                             return t + e * r + n * s + i * (s * r)
                         }
                     }
                 }
-                Lo.prototype.isArcCurve = !0;
-                const Po = new Zt,
-                    Do = new Co,
-                    Io = new Co,
-                    No = new Co;
-                class Oo extends Ao {
+                kl.prototype.isArcCurve = !0;
+                const jl = new on,
+                    Xl = new Wl,
+                    ql = new Wl,
+                    Yl = new Wl;
+                class Jl extends Gl {
                     constructor(t = [], e = !1, n = "centripetal", i = .5) {
                         super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i
                     }
-                    getPoint(t, e = new Zt) {
+                    getPoint(t, e = new on) {
                         const n = e,
                             i = this.points,
                             r = i.length,
                             s = (r - (this.closed ? 0 : 1)) * t;
                         let a, o, l = Math.floor(s),
                             c = s - l;
-                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (Po.subVectors(i[0], i[1]).add(i[0]), a = Po);
+                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (jl.subVectors(i[0], i[1]).add(i[0]), a = jl);
                         const h = i[l % r],
                             u = i[(l + 1) % r];
-                        if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (Po.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = Po), "centripetal" === this.curveType || "chordal" === this.curveType) {
+                        if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (jl.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = jl), "centripetal" === this.curveType || "chordal" === this.curveType) {
                             const t = "chordal" === this.curveType ? .5 : .25;
                             let e = Math.pow(a.distanceToSquared(h), t),
                                 n = Math.pow(h.distanceToSquared(u), t),
                                 i = Math.pow(u.distanceToSquared(o), t);
-                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Do.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i), Io.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i), No.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i)
-                        } else "catmullrom" === this.curveType && (Do.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), Io.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), No.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
-                        return n.set(Do.calc(c), Io.calc(c), No.calc(c)), n
+                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Xl.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i), ql.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i), Yl.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i)
+                        } else "catmullrom" === this.curveType && (Xl.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), ql.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), Yl.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
+                        return n.set(Xl.calc(c), ql.calc(c), Yl.calc(c)), n
                     }
                     copy(t) {
                         super.copy(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
                             this.points.push(n.clone())
                         }
@@ -10536,132 +10827,132 @@
                         }
                         return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
-                            this.points.push((new Zt).fromArray(n))
+                            this.points.push((new on).fromArray(n))
                         }
                         return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                     }
                 }
 
-                function Uo(t, e, n, i, r) {
+                function Zl(t, e, n, i, r) {
                     const s = .5 * (i - e),
                         a = .5 * (r - n),
                         o = t * t;
                     return (2 * n - 2 * i + s + a) * (t * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * t + n
                 }
 
-                function Bo(t, e, n, i) {
+                function Kl(t, e, n, i) {
                     return function(t, e) {
                         const n = 1 - t;
                         return n * n * e
                     }(t, e) + function(t, e) {
                         return 2 * (1 - t) * t * e
                     }(t, n) + function(t, e) {
                         return t * t * e
                     }(t, i)
                 }
 
-                function Fo(t, e, n, i, r) {
+                function Ql(t, e, n, i, r) {
                     return function(t, e) {
                         const n = 1 - t;
                         return n * n * n * e
                     }(t, e) + function(t, e) {
                         const n = 1 - t;
                         return 3 * n * n * t * e
                     }(t, n) + function(t, e) {
                         return 3 * (1 - t) * t * t * e
                     }(t, i) + function(t, e) {
                         return t * t * t * e
                     }(t, r)
                 }
-                Oo.prototype.isCatmullRomCurve3 = !0;
-                class zo extends Ao {
-                    constructor(t = new At, e = new At, n = new At, i = new At) {
+                Jl.prototype.isCatmullRomCurve3 = !0;
+                class $l extends Gl {
+                    constructor(t = new Be, e = new Be, n = new Be, i = new Be) {
                         super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                     }
-                    getPoint(t, e = new At) {
+                    getPoint(t, e = new Be) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2,
                             a = this.v3;
-                        return n.set(Fo(t, i.x, r.x, s.x, a.x), Fo(t, i.y, r.y, s.y, a.y)), n
+                        return n.set(Ql(t, i.x, r.x, s.x, a.x), Ql(t, i.y, r.y, s.y, a.y)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                     }
                 }
-                zo.prototype.isCubicBezierCurve = !0;
-                class Ho extends Ao {
-                    constructor(t = new Zt, e = new Zt, n = new Zt, i = new Zt) {
+                $l.prototype.isCubicBezierCurve = !0;
+                class tc extends Gl {
+                    constructor(t = new on, e = new on, n = new on, i = new on) {
                         super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                     }
-                    getPoint(t, e = new Zt) {
+                    getPoint(t, e = new on) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2,
                             a = this.v3;
-                        return n.set(Fo(t, i.x, r.x, s.x, a.x), Fo(t, i.y, r.y, s.y, a.y), Fo(t, i.z, r.z, s.z, a.z)), n
+                        return n.set(Ql(t, i.x, r.x, s.x, a.x), Ql(t, i.y, r.y, s.y, a.y), Ql(t, i.z, r.z, s.z, a.z)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                     }
                 }
-                Ho.prototype.isCubicBezierCurve3 = !0;
-                class Go extends Ao {
-                    constructor(t = new At, e = new At) {
+                tc.prototype.isCubicBezierCurve3 = !0;
+                class ec extends Gl {
+                    constructor(t = new Be, e = new Be) {
                         super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
                     }
-                    getPoint(t, e = new At) {
+                    getPoint(t, e = new Be) {
                         const n = e;
                         return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                     }
                     getPointAt(t, e) {
                         return this.getPoint(t, e)
                     }
                     getTangent(t, e) {
-                        const n = e || new At;
+                        const n = e || new Be;
                         return n.copy(this.v2).sub(this.v1).normalize(), n
                     }
                     copy(t) {
                         return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                Go.prototype.isLineCurve = !0;
-                class Vo extends Ao {
-                    constructor(t = new Zt, e = new Zt) {
+                ec.prototype.isLineCurve = !0;
+                class nc extends Gl {
+                    constructor(t = new on, e = new on) {
                         super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                     }
-                    getPoint(t, e = new Zt) {
+                    getPoint(t, e = new on) {
                         const n = e;
                         return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                     }
                     getPointAt(t, e) {
                         return this.getPoint(t, e)
                     }
                     copy(t) {
@@ -10671,75 +10962,75 @@
                         const t = super.toJSON();
                         return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                class ko extends Ao {
-                    constructor(t = new At, e = new At, n = new At) {
+                class ic extends Gl {
+                    constructor(t = new Be, e = new Be, n = new Be) {
                         super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
                     }
-                    getPoint(t, e = new At) {
+                    getPoint(t, e = new Be) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2;
-                        return n.set(Bo(t, i.x, r.x, s.x), Bo(t, i.y, r.y, s.y)), n
+                        return n.set(Kl(t, i.x, r.x, s.x), Kl(t, i.y, r.y, s.y)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                ko.prototype.isQuadraticBezierCurve = !0;
-                class Wo extends Ao {
-                    constructor(t = new Zt, e = new Zt, n = new Zt) {
+                ic.prototype.isQuadraticBezierCurve = !0;
+                class rc extends Gl {
+                    constructor(t = new on, e = new on, n = new on) {
                         super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
                     }
-                    getPoint(t, e = new Zt) {
+                    getPoint(t, e = new on) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2;
-                        return n.set(Bo(t, i.x, r.x, s.x), Bo(t, i.y, r.y, s.y), Bo(t, i.z, r.z, s.z)), n
+                        return n.set(Kl(t, i.x, r.x, s.x), Kl(t, i.y, r.y, s.y), Kl(t, i.z, r.z, s.z)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                Wo.prototype.isQuadraticBezierCurve3 = !0;
-                class jo extends Ao {
+                rc.prototype.isQuadraticBezierCurve3 = !0;
+                class sc extends Gl {
                     constructor(t = []) {
                         super(), this.type = "SplineCurve", this.points = t
                     }
-                    getPoint(t, e = new At) {
+                    getPoint(t, e = new Be) {
                         const n = e,
                             i = this.points,
                             r = (i.length - 1) * t,
                             s = Math.floor(r),
                             a = r - s,
                             o = i[0 === s ? s : s - 1],
                             l = i[s],
                             c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                             h = i[s > i.length - 3 ? i.length - 1 : s + 2];
-                        return n.set(Uo(a, o.x, l.x, c.x, h.x), Uo(a, o.y, l.y, c.y, h.y)), n
+                        return n.set(Zl(a, o.x, l.x, c.x, h.x), Zl(a, o.y, l.y, c.y, h.y)), n
                     }
                     copy(t) {
                         super.copy(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
                             this.points.push(n.clone())
                         }
@@ -10754,44 +11045,44 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
-                            this.points.push((new At).fromArray(n))
+                            this.points.push((new Be).fromArray(n))
                         }
                         return this
                     }
                 }
-                jo.prototype.isSplineCurve = !0;
-                var Xo = Object.freeze({
+                sc.prototype.isSplineCurve = !0;
+                var ac = Object.freeze({
                     __proto__: null,
-                    ArcCurve: Lo,
-                    CatmullRomCurve3: Oo,
-                    CubicBezierCurve: zo,
-                    CubicBezierCurve3: Ho,
-                    EllipseCurve: Ro,
-                    LineCurve: Go,
-                    LineCurve3: Vo,
-                    QuadraticBezierCurve: ko,
-                    QuadraticBezierCurve3: Wo,
-                    SplineCurve: jo
+                    ArcCurve: kl,
+                    CatmullRomCurve3: Jl,
+                    CubicBezierCurve: $l,
+                    CubicBezierCurve3: tc,
+                    EllipseCurve: Vl,
+                    LineCurve: ec,
+                    LineCurve3: nc,
+                    QuadraticBezierCurve: ic,
+                    QuadraticBezierCurve3: rc,
+                    SplineCurve: sc
                 });
-                class qo extends Ao {
+                class oc extends Gl {
                     constructor() {
                         super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                     }
                     add(t) {
                         this.curves.push(t)
                     }
                     closePath() {
                         const t = this.curves[0].getPoint(0),
                             e = this.curves[this.curves.length - 1].getPoint(1);
-                        t.equals(e) || this.curves.push(new Go(e, t))
+                        t.equals(e) || this.curves.push(new ec(e, t))
                     }
                     getPoint(t, e) {
                         const n = t * this.getLength(),
                             i = this.getCurveLengths();
                         let r = 0;
                         for (; r < i.length;) {
                             if (i[r] >= n) {
@@ -10855,46 +11146,46 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                         for (let e = 0, n = t.curves.length; e < n; e++) {
                             const n = t.curves[e];
-                            this.curves.push((new Xo[n.type]).fromJSON(n))
+                            this.curves.push((new ac[n.type]).fromJSON(n))
                         }
                         return this
                     }
                 }
-                class Yo extends qo {
+                class lc extends oc {
                     constructor(t) {
-                        super(), this.type = "Path", this.currentPoint = new At, t && this.setFromPoints(t)
+                        super(), this.type = "Path", this.currentPoint = new Be, t && this.setFromPoints(t)
                     }
                     setFromPoints(t) {
                         this.moveTo(t[0].x, t[0].y);
                         for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                         return this
                     }
                     moveTo(t, e) {
                         return this.currentPoint.set(t, e), this
                     }
                     lineTo(t, e) {
-                        const n = new Go(this.currentPoint.clone(), new At(t, e));
+                        const n = new ec(this.currentPoint.clone(), new Be(t, e));
                         return this.curves.push(n), this.currentPoint.set(t, e), this
                     }
                     quadraticCurveTo(t, e, n, i) {
-                        const r = new ko(this.currentPoint.clone(), new At(t, e), new At(n, i));
+                        const r = new ic(this.currentPoint.clone(), new Be(t, e), new Be(n, i));
                         return this.curves.push(r), this.currentPoint.set(n, i), this
                     }
                     bezierCurveTo(t, e, n, i, r, s) {
-                        const a = new zo(this.currentPoint.clone(), new At(t, e), new At(n, i), new At(r, s));
+                        const a = new $l(this.currentPoint.clone(), new Be(t, e), new Be(n, i), new Be(r, s));
                         return this.curves.push(a), this.currentPoint.set(r, s), this
                     }
                     splineThru(t) {
                         const e = [this.currentPoint.clone()].concat(t),
-                            n = new jo(e);
+                            n = new sc(e);
                         return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                     }
                     arc(t, e, n, i, r, s) {
                         const a = this.currentPoint.x,
                             o = this.currentPoint.y;
                         return this.absarc(t + a, e + o, n, i, r, s), this
                     }
@@ -10903,15 +11194,15 @@
                     }
                     ellipse(t, e, n, i, r, s, a, o) {
                         const l = this.currentPoint.x,
                             c = this.currentPoint.y;
                         return this.absellipse(t + l, e + c, n, i, r, s, a, o), this
                     }
                     absellipse(t, e, n, i, r, s, a, o) {
-                        const l = new Ro(t, e, n, i, r, s, a, o);
+                        const l = new Vl(t, e, n, i, r, s, a, o);
                         if (this.curves.length > 0) {
                             const t = l.getPoint(0);
                             t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                         }
                         this.curves.push(l);
                         const c = l.getPoint(1);
                         return this.currentPoint.copy(c), this
@@ -10923,17 +11214,17 @@
                         const t = super.toJSON();
                         return t.currentPoint = this.currentPoint.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                     }
                 }
-                class Jo extends Yo {
+                class cc extends lc {
                     constructor(t) {
-                        super(t), this.uuid = yt(), this.type = "Shape", this.holes = []
+                        super(t), this.uuid = Le(), this.type = "Shape", this.holes = []
                     }
                     getPointsHoles(t) {
                         const e = [];
                         for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                         return e
                     }
                     extractPoints(t) {
@@ -10959,53 +11250,53 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                         for (let e = 0, n = t.holes.length; e < n; e++) {
                             const n = t.holes[e];
-                            this.holes.push((new Yo).fromJSON(n))
+                            this.holes.push((new lc).fromJSON(n))
                         }
                         return this
                     }
                 }
 
-                function Zo(t, e, n, i, r) {
+                function hc(t, e, n, i, r) {
                     let s, a;
                     if (r === function(t, e, n, i) {
                             let r = 0;
                             for (let s = e, a = n - i; s < n; s += i) r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;
                             return r
                         }(t, e, n, i) > 0)
-                        for (s = e; s < n; s += i) a = vl(s, t[s], t[s + 1], a);
+                        for (s = e; s < n; s += i) a = Pc(s, t[s], t[s + 1], a);
                     else
-                        for (s = n - i; s >= e; s -= i) a = vl(s, t[s], t[s + 1], a);
-                    return a && ul(a, a.next) && (xl(a), a = a.next), a
+                        for (s = n - i; s >= e; s -= i) a = Pc(s, t[s], t[s + 1], a);
+                    return a && Ec(a, a.next) && (Dc(a), a = a.next), a
                 }
 
-                function Ko(t, e) {
+                function uc(t, e) {
                     if (!t) return t;
                     e || (e = t);
                     let n, i = t;
                     do {
-                        if (n = !1, i.steiner || !ul(i, i.next) && 0 !== hl(i.prev, i, i.next)) i = i.next;
+                        if (n = !1, i.steiner || !Ec(i, i.next) && 0 !== Sc(i.prev, i, i.next)) i = i.next;
                         else {
-                            if (xl(i), i = e = i.prev, i === i.next) break;
+                            if (Dc(i), i = e = i.prev, i === i.next) break;
                             n = !0
                         }
                     } while (n || i !== e);
                     return e
                 }
 
-                function Qo(t, e, n, i, r, s, a) {
+                function dc(t, e, n, i, r, s, a) {
                     if (!t) return;
                     !a && s && function(t, e, n, i) {
                         let r = t;
                         do {
-                            null === r.z && (r.z = al(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
+                            null === r.z && (r.z = _c(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                         } while (r !== t);
                         r.prevZ.nextZ = null, r.prevZ = null,
                             function(t) {
                                 let e, n, i, r, s, a, o, l, c = 1;
                                 do {
                                     for (n = t, t = null, s = null, a = 0; n;) {
                                         for (a++, i = n, o = 0, e = 0; e < c && (o++, i = i.nextZ, i); e++);
@@ -11014,93 +11305,93 @@
                                     }
                                     s.nextZ = null, c *= 2
                                 } while (a > 1)
                             }(r)
                     }(t, i, r, s);
                     let o, l, c = t;
                     for (; t.prev !== t.next;)
-                        if (o = t.prev, l = t.next, s ? tl(t, i, r, s) : $o(t)) e.push(o.i / n), e.push(t.i / n), e.push(l.i / n), xl(t), t = l.next, c = l.next;
+                        if (o = t.prev, l = t.next, s ? mc(t, i, r, s) : pc(t)) e.push(o.i / n), e.push(t.i / n), e.push(l.i / n), Dc(t), t = l.next, c = l.next;
                         else if ((t = l) === c) {
-                        a ? 1 === a ? Qo(t = el(Ko(t), e, n), e, n, i, r, s, 2) : 2 === a && nl(t, e, n, i, r, s) : Qo(Ko(t), e, n, i, r, s, 1);
+                        a ? 1 === a ? dc(t = fc(uc(t), e, n), e, n, i, r, s, 2) : 2 === a && gc(t, e, n, i, r, s) : dc(uc(t), e, n, i, r, s, 1);
                         break
                     }
                 }
 
-                function $o(t) {
+                function pc(t) {
                     const e = t.prev,
                         n = t,
                         i = t.next;
-                    if (hl(e, n, i) >= 0) return !1;
+                    if (Sc(e, n, i) >= 0) return !1;
                     let r = t.next.next;
                     for (; r !== t.prev;) {
-                        if (ll(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && hl(r.prev, r, r.next) >= 0) return !1;
+                        if (bc(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Sc(r.prev, r, r.next) >= 0) return !1;
                         r = r.next
                     }
                     return !0
                 }
 
-                function tl(t, e, n, i) {
+                function mc(t, e, n, i) {
                     const r = t.prev,
                         s = t,
                         a = t.next;
-                    if (hl(r, s, a) >= 0) return !1;
+                    if (Sc(r, s, a) >= 0) return !1;
                     const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x,
                         l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y,
                         c = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x,
                         h = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y,
-                        u = al(o, l, e, n, i),
-                        d = al(c, h, e, n, i);
+                        u = _c(o, l, e, n, i),
+                        d = _c(c, h, e, n, i);
                     let p = t.prevZ,
                         m = t.nextZ;
                     for (; p && p.z >= u && m && m.z <= d;) {
-                        if (p !== t.prev && p !== t.next && ll(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && hl(p.prev, p, p.next) >= 0) return !1;
-                        if (p = p.prevZ, m !== t.prev && m !== t.next && ll(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && hl(m.prev, m, m.next) >= 0) return !1;
+                        if (p !== t.prev && p !== t.next && bc(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Sc(p.prev, p, p.next) >= 0) return !1;
+                        if (p = p.prevZ, m !== t.prev && m !== t.next && bc(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Sc(m.prev, m, m.next) >= 0) return !1;
                         m = m.nextZ
                     }
                     for (; p && p.z >= u;) {
-                        if (p !== t.prev && p !== t.next && ll(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && hl(p.prev, p, p.next) >= 0) return !1;
+                        if (p !== t.prev && p !== t.next && bc(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Sc(p.prev, p, p.next) >= 0) return !1;
                         p = p.prevZ
                     }
                     for (; m && m.z <= d;) {
-                        if (m !== t.prev && m !== t.next && ll(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && hl(m.prev, m, m.next) >= 0) return !1;
+                        if (m !== t.prev && m !== t.next && bc(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Sc(m.prev, m, m.next) >= 0) return !1;
                         m = m.nextZ
                     }
                     return !0
                 }
 
-                function el(t, e, n) {
+                function fc(t, e, n) {
                     let i = t;
                     do {
                         const r = i.prev,
                             s = i.next.next;
-                        !ul(r, s) && dl(r, i, i.next, s) && fl(r, s) && fl(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), xl(i), xl(i.next), i = t = s), i = i.next
+                        !Ec(r, s) && Tc(r, i, i.next, s) && Lc(r, s) && Lc(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), Dc(i), Dc(i.next), i = t = s), i = i.next
                     } while (i !== t);
-                    return Ko(i)
+                    return uc(i)
                 }
 
-                function nl(t, e, n, i, r, s) {
+                function gc(t, e, n, i, r, s) {
                     let a = t;
                     do {
                         let t = a.next.next;
                         for (; t !== a.prev;) {
-                            if (a.i !== t.i && cl(a, t)) {
-                                let o = gl(a, t);
-                                return a = Ko(a, a.next), o = Ko(o, o.next), Qo(a, e, n, i, r, s), void Qo(o, e, n, i, r, s)
+                            if (a.i !== t.i && wc(a, t)) {
+                                let o = Cc(a, t);
+                                return a = uc(a, a.next), o = uc(o, o.next), dc(a, e, n, i, r, s), void dc(o, e, n, i, r, s)
                             }
                             t = t.next
                         }
                         a = a.next
                     } while (a !== t)
                 }
 
-                function il(t, e) {
+                function vc(t, e) {
                     return t.x - e.x
                 }
 
-                function rl(t, e) {
+                function xc(t, e) {
                     if (e = function(t, e) {
                             let n = e;
                             const i = t.x,
                                 r = t.y;
                             let s, a = -1 / 0;
                             do {
                                 if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
@@ -11119,165 +11410,165 @@
                             if (i === a) return s;
                             const o = s,
                                 l = s.x,
                                 c = s.y;
                             let h, u = 1 / 0;
                             n = s;
                             do {
-                                i >= n.x && n.x >= l && i !== n.x && ll(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), fl(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && sl(s, n))) && (s = n, u = h)), n = n.next
+                                i >= n.x && n.x >= l && i !== n.x && bc(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), Lc(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && yc(s, n))) && (s = n, u = h)), n = n.next
                             } while (n !== o);
                             return s
                         }(t, e), e) {
-                        const n = gl(e, t);
-                        Ko(e, e.next), Ko(n, n.next)
+                        const n = Cc(e, t);
+                        uc(e, e.next), uc(n, n.next)
                     }
                 }
 
-                function sl(t, e) {
-                    return hl(t.prev, t, e.prev) < 0 && hl(e.next, t, t.next) < 0
+                function yc(t, e) {
+                    return Sc(t.prev, t, e.prev) < 0 && Sc(e.next, t, t.next) < 0
                 }
 
-                function al(t, e, n, i, r) {
+                function _c(t, e, n, i, r) {
                     return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                 }
 
-                function ol(t) {
+                function Mc(t) {
                     let e = t,
                         n = t;
                     do {
                         (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                     } while (e !== t);
                     return n
                 }
 
-                function ll(t, e, n, i, r, s, a, o) {
+                function bc(t, e, n, i, r, s, a, o) {
                     return (r - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (i - o) - (n - a) * (e - o) >= 0 && (n - a) * (s - o) - (r - a) * (i - o) >= 0
                 }
 
-                function cl(t, e) {
+                function wc(t, e) {
                     return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                         let n = t;
                         do {
-                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && dl(n, n.next, t, e)) return !0;
+                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Tc(n, n.next, t, e)) return !0;
                             n = n.next
                         } while (n !== t);
                         return !1
-                    }(t, e) && (fl(t, e) && fl(e, t) && function(t, e) {
+                    }(t, e) && (Lc(t, e) && Lc(e, t) && function(t, e) {
                         let n = t,
                             i = !1;
                         const r = (t.x + e.x) / 2,
                             s = (t.y + e.y) / 2;
                         do {
                             n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                         } while (n !== t);
                         return i
-                    }(t, e) && (hl(t.prev, t, e.prev) || hl(t, e.prev, e)) || ul(t, e) && hl(t.prev, t, t.next) > 0 && hl(e.prev, e, e.next) > 0)
+                    }(t, e) && (Sc(t.prev, t, e.prev) || Sc(t, e.prev, e)) || Ec(t, e) && Sc(t.prev, t, t.next) > 0 && Sc(e.prev, e, e.next) > 0)
                 }
 
-                function hl(t, e, n) {
+                function Sc(t, e, n) {
                     return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
                 }
 
-                function ul(t, e) {
+                function Ec(t, e) {
                     return t.x === e.x && t.y === e.y
                 }
 
-                function dl(t, e, n, i) {
-                    const r = ml(hl(t, e, n)),
-                        s = ml(hl(t, e, i)),
-                        a = ml(hl(n, i, t)),
-                        o = ml(hl(n, i, e));
-                    return r !== s && a !== o || !(0 !== r || !pl(t, n, e)) || !(0 !== s || !pl(t, i, e)) || !(0 !== a || !pl(n, t, i)) || !(0 !== o || !pl(n, e, i))
+                function Tc(t, e, n, i) {
+                    const r = Rc(Sc(t, e, n)),
+                        s = Rc(Sc(t, e, i)),
+                        a = Rc(Sc(n, i, t)),
+                        o = Rc(Sc(n, i, e));
+                    return r !== s && a !== o || !(0 !== r || !Ac(t, n, e)) || !(0 !== s || !Ac(t, i, e)) || !(0 !== a || !Ac(n, t, i)) || !(0 !== o || !Ac(n, e, i))
                 }
 
-                function pl(t, e, n) {
+                function Ac(t, e, n) {
                     return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
                 }
 
-                function ml(t) {
+                function Rc(t) {
                     return t > 0 ? 1 : t < 0 ? -1 : 0
                 }
 
-                function fl(t, e) {
-                    return hl(t.prev, t, t.next) < 0 ? hl(t, e, t.next) >= 0 && hl(t, t.prev, e) >= 0 : hl(t, e, t.prev) < 0 || hl(t, t.next, e) < 0
+                function Lc(t, e) {
+                    return Sc(t.prev, t, t.next) < 0 ? Sc(t, e, t.next) >= 0 && Sc(t, t.prev, e) >= 0 : Sc(t, e, t.prev) < 0 || Sc(t, t.next, e) < 0
                 }
 
-                function gl(t, e) {
-                    const n = new yl(t.i, t.x, t.y),
-                        i = new yl(e.i, e.x, e.y),
+                function Cc(t, e) {
+                    const n = new Ic(t.i, t.x, t.y),
+                        i = new Ic(e.i, e.x, e.y),
                         r = t.next,
                         s = e.prev;
                     return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
                 }
 
-                function vl(t, e, n, i) {
-                    const r = new yl(t, e, n);
+                function Pc(t, e, n, i) {
+                    const r = new Ic(t, e, n);
                     return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
                 }
 
-                function xl(t) {
+                function Dc(t) {
                     t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                 }
 
-                function yl(t, e, n) {
+                function Ic(t, e, n) {
                     this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
                 }
-                class _l {
+                class Nc {
                     static area(t) {
                         const e = t.length;
                         let n = 0;
                         for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                         return .5 * n
                     }
                     static isClockWise(t) {
-                        return _l.area(t) < 0
+                        return Nc.area(t) < 0
                     }
                     static triangulateShape(t, e) {
                         const n = [],
                             i = [],
                             r = [];
-                        Ml(t), bl(n, t);
+                        Oc(t), Uc(n, t);
                         let s = t.length;
-                        e.forEach(Ml);
-                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, bl(n, e[t]);
+                        e.forEach(Oc);
+                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, Uc(n, e[t]);
                         const a = function(t, e, n = 2) {
                             const i = e && e.length,
                                 r = i ? e[0] * n : t.length;
-                            let s = Zo(t, 0, r, n, !0);
+                            let s = hc(t, 0, r, n, !0);
                             const a = [];
                             if (!s || s.next === s.prev) return a;
                             let o, l, c, h, u, d, p;
                             if (i && (s = function(t, e, n, i) {
                                     const r = [];
                                     let s, a, o, l, c;
-                                    for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : t.length, c = Zo(t, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(ol(c));
-                                    for (r.sort(il), s = 0; s < r.length; s++) rl(r[s], n), n = Ko(n, n.next);
+                                    for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : t.length, c = hc(t, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(Mc(c));
+                                    for (r.sort(vc), s = 0; s < r.length; s++) xc(r[s], n), n = uc(n, n.next);
                                     return n
                                 }(t, e, s, n)), t.length > 80 * n) {
                                 o = c = t[0], l = h = t[1];
                                 for (let e = n; e < r; e += n) u = t[e], d = t[e + 1], u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
                                 p = Math.max(c - o, h - l), p = 0 !== p ? 1 / p : 0
                             }
-                            return Qo(s, a, n, o, l, p), a
+                            return dc(s, a, n, o, l, p), a
                         }(n, i);
                         for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
                         return r
                     }
                 }
 
-                function Ml(t) {
+                function Oc(t) {
                     const e = t.length;
                     e > 2 && t[e - 1].equals(t[0]) && t.pop()
                 }
 
-                function bl(t, e) {
+                function Uc(t, e) {
                     for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
                 }
-                class wl extends Nn {
-                    constructor(t = new Jo([new At(.5, .5), new At(-.5, .5), new At(-.5, -.5), new At(.5, -.5)]), e = {}) {
+                class Bc extends Wi {
+                    constructor(t = new cc([new Be(.5, .5), new Be(-.5, .5), new Be(-.5, -.5), new Be(.5, -.5)]), e = {}) {
                         super(), this.type = "ExtrudeGeometry", this.parameters = {
                             shapes: t,
                             options: e
                         }, t = Array.isArray(t) ? t : [t];
                         const n = this,
                             i = [],
                             r = [];
@@ -11290,29 +11581,29 @@
                             let l = void 0 !== e.depth ? e.depth : 1,
                                 c = void 0 === e.bevelEnabled || e.bevelEnabled,
                                 h = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                                 u = void 0 !== e.bevelSize ? e.bevelSize : h - .1,
                                 d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                 p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                             const m = e.extrudePath,
-                                f = void 0 !== e.UVGenerator ? e.UVGenerator : Sl;
+                                f = void 0 !== e.UVGenerator ? e.UVGenerator : Fc;
                             void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                             let g, v, x, y, _, M = !1;
-                            m && (g = m.getSpacedPoints(o), M = !0, c = !1, v = m.computeFrenetFrames(o, !1), x = new Zt, y = new Zt, _ = new Zt), c || (p = 0, h = 0, u = 0, d = 0);
+                            m && (g = m.getSpacedPoints(o), M = !0, c = !1, v = m.computeFrenetFrames(o, !1), x = new on, y = new on, _ = new on), c || (p = 0, h = 0, u = 0, d = 0);
                             const b = t.extractPoints(a);
                             let w = b.shape;
                             const S = b.holes;
-                            if (!_l.isClockWise(w)) {
+                            if (!Nc.isClockWise(w)) {
                                 w = w.reverse();
                                 for (let t = 0, e = S.length; t < e; t++) {
                                     const e = S[t];
-                                    _l.isClockWise(e) && (S[t] = e.reverse())
+                                    Nc.isClockWise(e) && (S[t] = e.reverse())
                                 }
                             }
-                            const E = _l.triangulateShape(w, S),
+                            const E = Nc.triangulateShape(w, S),
                                 T = w;
                             for (let t = 0, e = S.length; t < e; t++) {
                                 const e = S[t];
                                 w = w.concat(e)
                             }
 
                             function A(t, e, n) {
@@ -11333,21 +11624,21 @@
                                     const u = Math.sqrt(h),
                                         d = Math.sqrt(l * l + c * c),
                                         p = e.x - o / u,
                                         m = e.y + a / u,
                                         f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (a * c - o * l);
                                     i = p + a * f - t.x, r = m + o * f - t.y;
                                     const g = i * i + r * r;
-                                    if (g <= 2) return new At(i, r);
+                                    if (g <= 2) return new Be(i, r);
                                     s = Math.sqrt(g / 2)
                                 } else {
                                     let t = !1;
                                     a > Number.EPSILON ? l > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(c) && (t = !0), t ? (i = -o, r = a, s = Math.sqrt(h)) : (i = a, r = o, s = Math.sqrt(h / 2))
                                 }
-                                return new At(i / s, r / s)
+                                return new Be(i / s, r / s)
                             }
                             const P = [];
                             for (let t = 0, e = T.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), P[t] = C(T[t], T[n], T[i]);
                             const D = [];
                             let I, N = P.concat();
                             for (let t = 0, e = S.length; t < e; t++) {
                                 const e = S[t];
@@ -11471,15 +11762,15 @@
                                 for (let t = 0, n = S.length; t < n; t++) {
                                     const n = S[t];
                                     U(n, e), e += n.length
                                 }
                                 n.addGroup(t, i.length / 3 - t, 1)
                             }()
                         }
-                        this.setAttribute("position", new En(i, 3)), this.setAttribute("uv", new En(r, 2)), this.computeVertexNormals()
+                        this.setAttribute("position", new Oi(i, 3)), this.setAttribute("uv", new Oi(r, 2)), this.computeVertexNormals()
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return function(t, e, n) {
                             if (n.shapes = [], Array.isArray(t))
                                 for (let e = 0, i = t.length; e < i; e++) {
                                     const i = t[e];
@@ -11491,74 +11782,74 @@
                     static fromJSON(t, e) {
                         const n = [];
                         for (let i = 0, r = t.shapes.length; i < r; i++) {
                             const r = e[t.shapes[i]];
                             n.push(r)
                         }
                         const i = t.options.extrudePath;
-                        return void 0 !== i && (t.options.extrudePath = (new Xo[i.type]).fromJSON(i)), new wl(n, t.options)
+                        return void 0 !== i && (t.options.extrudePath = (new ac[i.type]).fromJSON(i)), new Bc(n, t.options)
                     }
                 }
-                const Sl = {
+                const Fc = {
                     generateTopUV: function(t, e, n, i, r) {
                         const s = e[3 * n],
                             a = e[3 * n + 1],
                             o = e[3 * i],
                             l = e[3 * i + 1],
                             c = e[3 * r],
                             h = e[3 * r + 1];
-                        return [new At(s, a), new At(o, l), new At(c, h)]
+                        return [new Be(s, a), new Be(o, l), new Be(c, h)]
                     },
                     generateSideWallUV: function(t, e, n, i, r, s) {
                         const a = e[3 * n],
                             o = e[3 * n + 1],
                             l = e[3 * n + 2],
                             c = e[3 * i],
                             h = e[3 * i + 1],
                             u = e[3 * i + 2],
                             d = e[3 * r],
                             p = e[3 * r + 1],
                             m = e[3 * r + 2],
                             f = e[3 * s],
                             g = e[3 * s + 1],
                             v = e[3 * s + 2];
-                        return Math.abs(o - h) < Math.abs(a - c) ? [new At(a, 1 - l), new At(c, 1 - u), new At(d, 1 - m), new At(f, 1 - v)] : [new At(o, 1 - l), new At(h, 1 - u), new At(p, 1 - m), new At(g, 1 - v)]
+                        return Math.abs(o - h) < Math.abs(a - c) ? [new Be(a, 1 - l), new Be(c, 1 - u), new Be(d, 1 - m), new Be(f, 1 - v)] : [new Be(o, 1 - l), new Be(h, 1 - u), new Be(p, 1 - m), new Be(g, 1 - v)]
                     }
                 };
-                class El extends _o {
+                class zc extends Nl {
                     constructor(t = 1, e = 0) {
                         const n = (1 + Math.sqrt(5)) / 2;
                         super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = {
                             radius: t,
                             detail: e
                         }
                     }
                     static fromJSON(t) {
-                        return new El(t.radius, t.detail)
+                        return new zc(t.radius, t.detail)
                     }
                 }
-                class Tl extends Nn {
-                    constructor(t = [new At(0, .5), new At(.5, 0), new At(0, -.5)], e = 12, n = 0, i = 2 * Math.PI) {
+                class Hc extends Wi {
+                    constructor(t = [new Be(0, .5), new Be(.5, 0), new Be(0, -.5)], e = 12, n = 0, i = 2 * Math.PI) {
                         super(), this.type = "LatheGeometry", this.parameters = {
                             points: t,
                             segments: e,
                             phiStart: n,
                             phiLength: i
-                        }, e = Math.floor(e), i = _t(i, 0, 2 * Math.PI);
+                        }, e = Math.floor(e), i = Ce(i, 0, 2 * Math.PI);
                         const r = [],
                             s = [],
                             a = [],
                             o = [],
                             l = [],
                             c = 1 / e,
-                            h = new Zt,
-                            u = new At,
-                            d = new Zt,
-                            p = new Zt,
-                            m = new Zt;
+                            h = new on,
+                            u = new Be,
+                            d = new on,
+                            p = new on,
+                            m = new on;
                         let f = 0,
                             g = 0;
                         for (let e = 0; e <= t.length - 1; e++) switch (e) {
                             case 0:
                                 f = t[e + 1].x - t[e].x, g = t[e + 1].y - t[e].y, d.x = 1 * g, d.y = -f, d.z = 0 * g, m.copy(d), d.normalize(), o.push(d.x, d.y, d.z);
                                 break;
                             case t.length - 1:
@@ -11584,32 +11875,32 @@
                                 const i = e + n * t.length,
                                     s = i,
                                     a = i + t.length,
                                     o = i + t.length + 1,
                                     l = i + 1;
                                 r.push(s, a, l), r.push(o, l, a)
                             }
-                        this.setIndex(r), this.setAttribute("position", new En(s, 3)), this.setAttribute("uv", new En(a, 2)), this.setAttribute("normal", new En(l, 3))
+                        this.setIndex(r), this.setAttribute("position", new Oi(s, 3)), this.setAttribute("uv", new Oi(a, 2)), this.setAttribute("normal", new Oi(l, 3))
                     }
                     static fromJSON(t) {
-                        return new Tl(t.points, t.segments, t.phiStart, t.phiLength)
+                        return new Hc(t.points, t.segments, t.phiStart, t.phiLength)
                     }
                 }
-                class Al extends _o {
+                class Gc extends Nl {
                     constructor(t = 1, e = 0) {
                         super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = {
                             radius: t,
                             detail: e
                         }
                     }
                     static fromJSON(t) {
-                        return new Al(t.radius, t.detail)
+                        return new Gc(t.radius, t.detail)
                     }
                 }
-                class Rl extends Nn {
+                class Vc extends Wi {
                     constructor(t = .5, e = 1, n = 8, i = 1, r = 0, s = 2 * Math.PI) {
                         super(), this.type = "RingGeometry", this.parameters = {
                             innerRadius: t,
                             outerRadius: e,
                             thetaSegments: n,
                             phiSegments: i,
                             thetaStart: r,
@@ -11617,16 +11908,16 @@
                         }, n = Math.max(3, n);
                         const a = [],
                             o = [],
                             l = [],
                             c = [];
                         let h = t;
                         const u = (e - t) / (i = Math.max(1, i)),
-                            d = new Zt,
-                            p = new At;
+                            d = new on,
+                            p = new Be;
                         for (let t = 0; t <= i; t++) {
                             for (let t = 0; t <= n; t++) {
                                 const i = r + t / n * s;
                                 d.x = h * Math.cos(i), d.y = h * Math.sin(i), o.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / e + 1) / 2, p.y = (d.y / e + 1) / 2, c.push(p.x, p.y)
                             }
                             h += u
                         }
@@ -11637,22 +11928,22 @@
                                     r = i,
                                     s = i + n + 1,
                                     o = i + n + 2,
                                     l = i + 1;
                                 a.push(r, s, l), a.push(s, o, l)
                             }
                         }
-                        this.setIndex(a), this.setAttribute("position", new En(o, 3)), this.setAttribute("normal", new En(l, 3)), this.setAttribute("uv", new En(c, 2))
+                        this.setIndex(a), this.setAttribute("position", new Oi(o, 3)), this.setAttribute("normal", new Oi(l, 3)), this.setAttribute("uv", new Oi(c, 2))
                     }
                     static fromJSON(t) {
-                        return new Rl(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
+                        return new Vc(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
                     }
                 }
-                class Ll extends Nn {
-                    constructor(t = new Jo([new At(0, .5), new At(-.5, -.5), new At(.5, -.5)]), e = 12) {
+                class kc extends Wi {
+                    constructor(t = new cc([new Be(0, .5), new Be(-.5, -.5), new Be(.5, -.5)]), e = 12) {
                         super(), this.type = "ShapeGeometry", this.parameters = {
                             shapes: t,
                             curveSegments: e
                         };
                         const n = [],
                             i = [],
                             r = [],
@@ -11664,20 +11955,20 @@
                             for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(a, o, e), a += o, o = 0;
 
                         function l(t) {
                             const a = i.length / 3,
                                 l = t.extractPoints(e);
                             let c = l.shape;
                             const h = l.holes;
-                            !1 === _l.isClockWise(c) && (c = c.reverse());
+                            !1 === Nc.isClockWise(c) && (c = c.reverse());
                             for (let t = 0, e = h.length; t < e; t++) {
                                 const e = h[t];
-                                !0 === _l.isClockWise(e) && (h[t] = e.reverse())
+                                !0 === Nc.isClockWise(e) && (h[t] = e.reverse())
                             }
-                            const u = _l.triangulateShape(c, h);
+                            const u = Nc.triangulateShape(c, h);
                             for (let t = 0, e = h.length; t < e; t++) {
                                 const e = h[t];
                                 c = c.concat(e)
                             }
                             for (let t = 0, e = c.length; t < e; t++) {
                                 const e = c[t];
                                 i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
@@ -11686,15 +11977,15 @@
                                 const e = u[t],
                                     i = e[0] + a,
                                     r = e[1] + a,
                                     s = e[2] + a;
                                 n.push(i, r, s), o += 3
                             }
                         }
-                        this.setIndex(n), this.setAttribute("position", new En(i, 3)), this.setAttribute("normal", new En(r, 3)), this.setAttribute("uv", new En(s, 2))
+                        this.setIndex(n), this.setAttribute("position", new Oi(i, 3)), this.setAttribute("normal", new Oi(r, 3)), this.setAttribute("uv", new Oi(s, 2))
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return function(t, e) {
                             if (e.shapes = [], Array.isArray(t))
                                 for (let n = 0, i = t.length; n < i; n++) {
                                     const i = t[n];
@@ -11705,33 +11996,33 @@
                     }
                     static fromJSON(t, e) {
                         const n = [];
                         for (let i = 0, r = t.shapes.length; i < r; i++) {
                             const r = e[t.shapes[i]];
                             n.push(r)
                         }
-                        return new Ll(n, t.curveSegments)
+                        return new kc(n, t.curveSegments)
                     }
                 }
-                class Cl extends Nn {
+                class Wc extends Wi {
                     constructor(t = 1, e = 32, n = 16, i = 0, r = 2 * Math.PI, s = 0, a = Math.PI) {
                         super(), this.type = "SphereGeometry", this.parameters = {
                             radius: t,
                             widthSegments: e,
                             heightSegments: n,
                             phiStart: i,
                             phiLength: r,
                             thetaStart: s,
                             thetaLength: a
                         }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
                         const o = Math.min(s + a, Math.PI);
                         let l = 0;
                         const c = [],
-                            h = new Zt,
-                            u = new Zt,
+                            h = new on,
+                            u = new on,
                             d = [],
                             p = [],
                             m = [],
                             f = [];
                         for (let d = 0; d <= n; d++) {
                             const g = [],
                                 v = d / n;
@@ -11747,88 +12038,88 @@
                             for (let i = 0; i < e; i++) {
                                 const e = c[t][i + 1],
                                     r = c[t][i],
                                     a = c[t + 1][i],
                                     l = c[t + 1][i + 1];
                                 (0 !== t || s > 0) && d.push(e, r, l), (t !== n - 1 || o < Math.PI) && d.push(r, a, l)
                             }
-                        this.setIndex(d), this.setAttribute("position", new En(p, 3)), this.setAttribute("normal", new En(m, 3)), this.setAttribute("uv", new En(f, 2))
+                        this.setIndex(d), this.setAttribute("position", new Oi(p, 3)), this.setAttribute("normal", new Oi(m, 3)), this.setAttribute("uv", new Oi(f, 2))
                     }
                     static fromJSON(t) {
-                        return new Cl(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
+                        return new Wc(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
                     }
                 }
-                class Pl extends _o {
+                class jc extends Nl {
                     constructor(t = 1, e = 0) {
                         super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = {
                             radius: t,
                             detail: e
                         }
                     }
                     static fromJSON(t) {
-                        return new Pl(t.radius, t.detail)
+                        return new jc(t.radius, t.detail)
                     }
                 }
-                class Dl extends Nn {
+                class Xc extends Wi {
                     constructor(t = 1, e = .4, n = 8, i = 6, r = 2 * Math.PI) {
                         super(), this.type = "TorusGeometry", this.parameters = {
                             radius: t,
                             tube: e,
                             radialSegments: n,
                             tubularSegments: i,
                             arc: r
                         }, n = Math.floor(n), i = Math.floor(i);
                         const s = [],
                             a = [],
                             o = [],
                             l = [],
-                            c = new Zt,
-                            h = new Zt,
-                            u = new Zt;
+                            c = new on,
+                            h = new on,
+                            u = new on;
                         for (let s = 0; s <= n; s++)
                             for (let d = 0; d <= i; d++) {
                                 const p = d / i * r,
                                     m = s / n * Math.PI * 2;
                                 h.x = (t + e * Math.cos(m)) * Math.cos(p), h.y = (t + e * Math.cos(m)) * Math.sin(p), h.z = e * Math.sin(m), a.push(h.x, h.y, h.z), c.x = t * Math.cos(p), c.y = t * Math.sin(p), u.subVectors(h, c).normalize(), o.push(u.x, u.y, u.z), l.push(d / i), l.push(s / n)
                             }
                         for (let t = 1; t <= n; t++)
                             for (let e = 1; e <= i; e++) {
                                 const n = (i + 1) * t + e - 1,
                                     r = (i + 1) * (t - 1) + e - 1,
                                     a = (i + 1) * (t - 1) + e,
                                     o = (i + 1) * t + e;
                                 s.push(n, r, o), s.push(r, a, o)
                             }
-                        this.setIndex(s), this.setAttribute("position", new En(a, 3)), this.setAttribute("normal", new En(o, 3)), this.setAttribute("uv", new En(l, 2))
+                        this.setIndex(s), this.setAttribute("position", new Oi(a, 3)), this.setAttribute("normal", new Oi(o, 3)), this.setAttribute("uv", new Oi(l, 2))
                     }
                     static fromJSON(t) {
-                        return new Dl(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
+                        return new Xc(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
                     }
                 }
-                class Il extends Nn {
+                class qc extends Wi {
                     constructor(t = 1, e = .4, n = 64, i = 8, r = 2, s = 3) {
                         super(), this.type = "TorusKnotGeometry", this.parameters = {
                             radius: t,
                             tube: e,
                             tubularSegments: n,
                             radialSegments: i,
                             p: r,
                             q: s
                         }, n = Math.floor(n), i = Math.floor(i);
                         const a = [],
                             o = [],
                             l = [],
                             c = [],
-                            h = new Zt,
-                            u = new Zt,
-                            d = new Zt,
-                            p = new Zt,
-                            m = new Zt,
-                            f = new Zt,
-                            g = new Zt;
+                            h = new on,
+                            u = new on,
+                            d = new on,
+                            p = new on,
+                            m = new on,
+                            f = new on,
+                            g = new on;
                         for (let a = 0; a <= n; ++a) {
                             const x = a / n * r * Math.PI * 2;
                             v(x, r, s, t, d), v(x + .01, r, s, t, p), f.subVectors(p, d), g.addVectors(p, d), m.crossVectors(f, g), g.crossVectors(m, f), m.normalize(), g.normalize();
                             for (let t = 0; t <= i; ++t) {
                                 const r = t / i * Math.PI * 2,
                                     s = -e * Math.cos(r),
                                     p = e * Math.sin(r);
@@ -11847,35 +12138,35 @@
                         function v(t, e, n, i, r) {
                             const s = Math.cos(t),
                                 a = Math.sin(t),
                                 o = n / e * t,
                                 l = Math.cos(o);
                             r.x = i * (2 + l) * .5 * s, r.y = i * (2 + l) * a * .5, r.z = i * Math.sin(o) * .5
                         }
-                        this.setIndex(a), this.setAttribute("position", new En(o, 3)), this.setAttribute("normal", new En(l, 3)), this.setAttribute("uv", new En(c, 2))
+                        this.setIndex(a), this.setAttribute("position", new Oi(o, 3)), this.setAttribute("normal", new Oi(l, 3)), this.setAttribute("uv", new Oi(c, 2))
                     }
                     static fromJSON(t) {
-                        return new Il(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q)
+                        return new qc(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q)
                     }
                 }
-                class Nl extends Nn {
-                    constructor(t = new Wo(new Zt(-1, -1, 0), new Zt(-1, 1, 0), new Zt(1, 1, 0)), e = 64, n = 1, i = 8, r = !1) {
+                class Yc extends Wi {
+                    constructor(t = new rc(new on(-1, -1, 0), new on(-1, 1, 0), new on(1, 1, 0)), e = 64, n = 1, i = 8, r = !1) {
                         super(), this.type = "TubeGeometry", this.parameters = {
                             path: t,
                             tubularSegments: e,
                             radius: n,
                             radialSegments: i,
                             closed: r
                         };
                         const s = t.computeFrenetFrames(e, r);
                         this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
-                        const a = new Zt,
-                            o = new Zt,
-                            l = new At;
-                        let c = new Zt;
+                        const a = new on,
+                            o = new on,
+                            l = new Be;
+                        let c = new on;
                         const h = [],
                             u = [],
                             d = [],
                             p = [];
 
                         function m(r) {
                             c = t.getPointAt(r / e, c);
@@ -11900,33 +12191,33 @@
                                             const n = (i + 1) * (t - 1) + (e - 1),
                                                 r = (i + 1) * t + (e - 1),
                                                 s = (i + 1) * t + e,
                                                 a = (i + 1) * (t - 1) + e;
                                             p.push(n, r, a), p.push(r, s, a)
                                         }
                                 }()
-                        }(), this.setIndex(p), this.setAttribute("position", new En(h, 3)), this.setAttribute("normal", new En(u, 3)), this.setAttribute("uv", new En(d, 2))
+                        }(), this.setIndex(p), this.setAttribute("position", new Oi(h, 3)), this.setAttribute("normal", new Oi(u, 3)), this.setAttribute("uv", new Oi(d, 2))
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.path = this.parameters.path.toJSON(), t
                     }
                     static fromJSON(t) {
-                        return new Nl((new Xo[t.path.type]).fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed)
+                        return new Yc((new ac[t.path.type]).fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed)
                     }
                 }
-                class Ol extends Nn {
+                class Jc extends Wi {
                     constructor(t = null) {
                         if (super(), this.type = "WireframeGeometry", this.parameters = {
                                 geometry: t
                             }, null !== t) {
                             const e = [],
                                 n = new Set,
-                                i = new Zt,
-                                r = new Zt;
+                                i = new on,
+                                r = new on;
                             if (null !== t.index) {
                                 const s = t.attributes.position,
                                     a = t.index;
                                 let o = t.groups;
                                 0 === o.length && (o = [{
                                     start: 0,
                                     count: a.count,
@@ -11935,112 +12226,112 @@
                                 for (let t = 0, l = o.length; t < l; ++t) {
                                     const l = o[t],
                                         c = l.start;
                                     for (let t = c, o = c + l.count; t < o; t += 3)
                                         for (let o = 0; o < 3; o++) {
                                             const l = a.getX(t + o),
                                                 c = a.getX(t + (o + 1) % 3);
-                                            i.fromBufferAttribute(s, l), r.fromBufferAttribute(s, c), !0 === Ul(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
+                                            i.fromBufferAttribute(s, l), r.fromBufferAttribute(s, c), !0 === Zc(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
                                         }
                                 }
                             } else {
                                 const s = t.attributes.position;
                                 for (let t = 0, a = s.count / 3; t < a; t++)
                                     for (let a = 0; a < 3; a++) {
                                         const o = 3 * t + a,
                                             l = 3 * t + (a + 1) % 3;
-                                        i.fromBufferAttribute(s, o), r.fromBufferAttribute(s, l), !0 === Ul(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
+                                        i.fromBufferAttribute(s, o), r.fromBufferAttribute(s, l), !0 === Zc(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
                                     }
                             }
-                            this.setAttribute("position", new En(e, 3))
+                            this.setAttribute("position", new Oi(e, 3))
                         }
                     }
                 }
 
-                function Ul(t, e, n) {
+                function Zc(t, e, n) {
                     const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
                         r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
                     return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i, r), !0)
                 }
-                var Bl = Object.freeze({
+                var Kc = Object.freeze({
                     __proto__: null,
-                    BoxGeometry: ti,
-                    BoxBufferGeometry: ti,
-                    CircleGeometry: vo,
-                    CircleBufferGeometry: vo,
-                    ConeGeometry: yo,
-                    ConeBufferGeometry: yo,
-                    CylinderGeometry: xo,
-                    CylinderBufferGeometry: xo,
-                    DodecahedronGeometry: Mo,
-                    DodecahedronBufferGeometry: Mo,
-                    EdgesGeometry: To,
-                    ExtrudeGeometry: wl,
-                    ExtrudeBufferGeometry: wl,
-                    IcosahedronGeometry: El,
-                    IcosahedronBufferGeometry: El,
-                    LatheGeometry: Tl,
-                    LatheBufferGeometry: Tl,
-                    OctahedronGeometry: Al,
-                    OctahedronBufferGeometry: Al,
-                    PlaneGeometry: _i,
-                    PlaneBufferGeometry: _i,
-                    PolyhedronGeometry: _o,
-                    PolyhedronBufferGeometry: _o,
-                    RingGeometry: Rl,
-                    RingBufferGeometry: Rl,
-                    ShapeGeometry: Ll,
-                    ShapeBufferGeometry: Ll,
-                    SphereGeometry: Cl,
-                    SphereBufferGeometry: Cl,
-                    TetrahedronGeometry: Pl,
-                    TetrahedronBufferGeometry: Pl,
-                    TorusGeometry: Dl,
-                    TorusBufferGeometry: Dl,
-                    TorusKnotGeometry: Il,
-                    TorusKnotBufferGeometry: Il,
-                    TubeGeometry: Nl,
-                    TubeBufferGeometry: Nl,
-                    WireframeGeometry: Ol
+                    BoxGeometry: hr,
+                    BoxBufferGeometry: hr,
+                    CircleGeometry: Pl,
+                    CircleBufferGeometry: Pl,
+                    ConeGeometry: Il,
+                    ConeBufferGeometry: Il,
+                    CylinderGeometry: Dl,
+                    CylinderBufferGeometry: Dl,
+                    DodecahedronGeometry: Ol,
+                    DodecahedronBufferGeometry: Ol,
+                    EdgesGeometry: Hl,
+                    ExtrudeGeometry: Bc,
+                    ExtrudeBufferGeometry: Bc,
+                    IcosahedronGeometry: zc,
+                    IcosahedronBufferGeometry: zc,
+                    LatheGeometry: Hc,
+                    LatheBufferGeometry: Hc,
+                    OctahedronGeometry: Gc,
+                    OctahedronBufferGeometry: Gc,
+                    PlaneGeometry: Cr,
+                    PlaneBufferGeometry: Cr,
+                    PolyhedronGeometry: Nl,
+                    PolyhedronBufferGeometry: Nl,
+                    RingGeometry: Vc,
+                    RingBufferGeometry: Vc,
+                    ShapeGeometry: kc,
+                    ShapeBufferGeometry: kc,
+                    SphereGeometry: Wc,
+                    SphereBufferGeometry: Wc,
+                    TetrahedronGeometry: jc,
+                    TetrahedronBufferGeometry: jc,
+                    TorusGeometry: Xc,
+                    TorusBufferGeometry: Xc,
+                    TorusKnotGeometry: qc,
+                    TorusKnotBufferGeometry: qc,
+                    TubeGeometry: Yc,
+                    TubeBufferGeometry: Yc,
+                    WireframeGeometry: Jc
                 });
-                class Fl extends dn {
+                class Qc extends bi {
                     constructor(t) {
-                        super(), this.type = "ShadowMaterial", this.color = new zt(0), this.transparent = !0, this.setValues(t)
+                        super(), this.type = "ShadowMaterial", this.color = new Je(0), this.transparent = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this
                     }
                 }
-                Fl.prototype.isShadowMaterial = !0;
-                class zl extends dn {
+                Qc.prototype.isShadowMaterial = !0;
+                class $c extends bi {
                     constructor(t) {
                         super(), this.defines = {
                             STANDARD: ""
-                        }, this.type = "MeshStandardMaterial", this.color = new zt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new At(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
+                        }, this.type = "MeshStandardMaterial", this.color = new Je(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ve, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.defines = {
                             STANDARD: ""
                         }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                     }
                 }
-                zl.prototype.isMeshStandardMaterial = !0;
-                class Hl extends zl {
+                $c.prototype.isMeshStandardMaterial = !0;
+                class th extends $c {
                     constructor(t) {
                         super(), this.defines = {
                             STANDARD: "",
                             PHYSICAL: ""
-                        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new At(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
+                        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Be(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                             get: function() {
-                                return _t(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
+                                return Ce(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                             },
                             set: function(t) {
                                 this.ior = (1 + .4 * t) / (1 - .4 * t)
                             }
-                        }), this.sheenColor = new zt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new zt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new zt(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
+                        }), this.sheenColor = new Je(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Je(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Je(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
                     }
                     get sheen() {
                         return this._sheen
                     }
                     set sheen(t) {
                         this._sheen > 0 != t > 0 && this.version++, this._sheen = t
                     }
@@ -12059,99 +12350,99 @@
                     copy(t) {
                         return super.copy(t), this.defines = {
                             STANDARD: "",
                             PHYSICAL: ""
                         }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
                     }
                 }
-                Hl.prototype.isMeshPhysicalMaterial = !0;
-                class Gl extends dn {
+                th.prototype.isMeshPhysicalMaterial = !0;
+                class eh extends bi {
                     constructor(t) {
-                        super(), this.type = "MeshPhongMaterial", this.color = new zt(16777215), this.specular = new zt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new At(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
+                        super(), this.type = "MeshPhongMaterial", this.color = new Je(16777215), this.specular = new Je(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ve, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                     }
                 }
-                Gl.prototype.isMeshPhongMaterial = !0;
-                class Vl extends dn {
+                eh.prototype.isMeshPhongMaterial = !0;
+                class nh extends bi {
                     constructor(t) {
                         super(), this.defines = {
                             TOON: ""
-                        }, this.type = "MeshToonMaterial", this.color = new zt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new At(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        }, this.type = "MeshToonMaterial", this.color = new Je(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ve, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }
-                Vl.prototype.isMeshToonMaterial = !0;
-                class kl extends dn {
+                nh.prototype.isMeshToonMaterial = !0;
+                class ih extends bi {
                     constructor(t) {
-                        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new At(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
+                        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ve, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
                     }
                 }
-                kl.prototype.isMeshNormalMaterial = !0;
-                class Wl extends dn {
+                ih.prototype.isMeshNormalMaterial = !0;
+                class rh extends bi {
                     constructor(t) {
-                        super(), this.type = "MeshLambertMaterial", this.color = new zt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        super(), this.type = "MeshLambertMaterial", this.color = new Je(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }
-                Wl.prototype.isMeshLambertMaterial = !0;
-                class jl extends dn {
+                rh.prototype.isMeshLambertMaterial = !0;
+                class sh extends bi {
                     constructor(t) {
                         super(), this.defines = {
                             MATCAP: ""
-                        }, this.type = "MeshMatcapMaterial", this.color = new zt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new At(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
+                        }, this.type = "MeshMatcapMaterial", this.color = new Je(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ve, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.defines = {
                             MATCAP: ""
                         }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this
                     }
                 }
-                jl.prototype.isMeshMatcapMaterial = !0;
-                class Xl extends Ya {
+                sh.prototype.isMeshMatcapMaterial = !0;
+                class ah extends cl {
                     constructor(t) {
                         super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
                     }
                 }
-                Xl.prototype.isLineDashedMaterial = !0;
-                var ql = Object.freeze({
+                ah.prototype.isLineDashedMaterial = !0;
+                var oh = Object.freeze({
                     __proto__: null,
-                    ShadowMaterial: Fl,
-                    SpriteMaterial: da,
-                    RawShaderMaterial: Pi,
-                    ShaderMaterial: ri,
-                    PointsMaterial: so,
-                    MeshPhysicalMaterial: Hl,
-                    MeshStandardMaterial: zl,
-                    MeshPhongMaterial: Gl,
-                    MeshToonMaterial: Vl,
-                    MeshNormalMaterial: kl,
-                    MeshLambertMaterial: Wl,
-                    MeshDepthMaterial: js,
-                    MeshDistanceMaterial: Xs,
-                    MeshBasicMaterial: pn,
-                    MeshMatcapMaterial: jl,
-                    LineDashedMaterial: Xl,
-                    LineBasicMaterial: Ya,
-                    Material: dn
+                    ShadowMaterial: Qc,
+                    SpriteMaterial: Ao,
+                    RawShaderMaterial: Gr,
+                    ShaderMaterial: mr,
+                    PointsMaterial: _l,
+                    MeshPhysicalMaterial: th,
+                    MeshStandardMaterial: $c,
+                    MeshPhongMaterial: eh,
+                    MeshToonMaterial: nh,
+                    MeshNormalMaterial: ih,
+                    MeshLambertMaterial: rh,
+                    MeshDepthMaterial: io,
+                    MeshDistanceMaterial: ro,
+                    MeshBasicMaterial: wi,
+                    MeshMatcapMaterial: sh,
+                    LineDashedMaterial: ah,
+                    LineBasicMaterial: cl,
+                    Material: bi
                 });
-                const Yl = {
+                const lh = {
                     arraySlice: function(t, e, n) {
-                        return Yl.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
+                        return lh.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                     },
                     convertArray: function(t, e, n) {
                         return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                     },
                     isTypedArray: function(t) {
                         return ArrayBuffer.isView(t) && !(t instanceof DataView)
                     },
@@ -12204,15 +12495,15 @@
                             for (let t = 0; t < e.times.length; ++t) {
                                 const s = e.times[t] * r;
                                 if (!(s < n || s >= i)) {
                                     l.push(e.times[t]);
                                     for (let n = 0; n < o; ++n) c.push(e.values[t * o + n])
                                 }
                             }
-                            0 !== l.length && (e.times = Yl.convertArray(l, e.times.constructor), e.values = Yl.convertArray(c, e.values.constructor), a.push(e))
+                            0 !== l.length && (e.times = lh.convertArray(l, e.times.constructor), e.values = lh.convertArray(c, e.values.constructor), a.push(e))
                         }
                         s.tracks = a;
                         let o = 1 / 0;
                         for (let t = 0; t < s.tracks.length; ++t) o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
                         for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);
                         return s.resetDuration(), s
                     },
@@ -12235,40 +12526,40 @@
                             const h = a.getValueSize();
                             a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                             const u = i.times.length - 1;
                             let d;
                             if (s <= i.times[0]) {
                                 const t = o,
                                     e = l - o;
-                                d = Yl.arraySlice(i.values, t, e)
+                                d = lh.arraySlice(i.values, t, e)
                             } else if (s >= i.times[u]) {
                                 const t = u * l + o,
                                     e = t + l - o;
-                                d = Yl.arraySlice(i.values, t, e)
+                                d = lh.arraySlice(i.values, t, e)
                             } else {
                                 const t = i.createInterpolant(),
                                     e = o,
                                     n = l - o;
-                                t.evaluate(s), d = Yl.arraySlice(t.resultBuffer, e, n)
+                                t.evaluate(s), d = lh.arraySlice(t.resultBuffer, e, n)
                             }
-                            "quaternion" === r && (new Jt).fromArray(d).normalize().conjugate().toArray(d);
+                            "quaternion" === r && (new an).fromArray(d).normalize().conjugate().toArray(d);
                             const p = a.times.length;
                             for (let t = 0; t < p; ++t) {
                                 const e = t * h + c;
-                                if ("quaternion" === r) Jt.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
+                                if ("quaternion" === r) an.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                                 else {
                                     const t = h - 2 * c;
                                     for (let n = 0; n < t; ++n) a.values[e + n] -= d[n]
                                 }
                             }
                         }
-                        return t.blendMode = at, t
+                        return t.blendMode = pe, t
                     }
                 };
-                class Jl {
+                class ch {
                     constructor(t, e, n, i) {
                         this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                     }
                     evaluate(t) {
                         const e = this.parameterPositions;
                         let n = this._cachedIndex,
                             i = e[n],
@@ -12325,43 +12616,43 @@
                         return e
                     }
                     interpolate_() {
                         throw new Error("call to abstract method")
                     }
                     intervalChanged_() {}
                 }
-                Jl.prototype.beforeStart_ = Jl.prototype.copySampleValue_, Jl.prototype.afterEnd_ = Jl.prototype.copySampleValue_;
-                class Zl extends Jl {
+                ch.prototype.beforeStart_ = ch.prototype.copySampleValue_, ch.prototype.afterEnd_ = ch.prototype.copySampleValue_;
+                class hh extends ch {
                     constructor(t, e, n, i) {
                         super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
-                            endingStart: it,
-                            endingEnd: it
+                            endingStart: he,
+                            endingEnd: he
                         }
                     }
                     intervalChanged_(t, e, n) {
                         const i = this.parameterPositions;
                         let r = t - 2,
                             s = t + 1,
                             a = i[r],
                             o = i[s];
                         if (void 0 === a) switch (this.getSettings_().endingStart) {
-                            case rt:
+                            case ue:
                                 r = t, a = 2 * e - n;
                                 break;
-                            case st:
+                            case de:
                                 r = i.length - 2, a = e + i[r] - i[r + 1];
                                 break;
                             default:
                                 r = t, a = n
                         }
                         if (void 0 === o) switch (this.getSettings_().endingEnd) {
-                            case rt:
+                            case ue:
                                 s = t, o = 2 * n - e;
                                 break;
-                            case st:
+                            case de:
                                 s = 1, o = n + i[1] - i[0];
                                 break;
                             default:
                                 s = t - 1, o = e
                         }
                         const l = .5 * (n - e),
                             c = this.valueSize;
@@ -12384,15 +12675,15 @@
                             v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                             x = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                             y = d * f - d * m;
                         for (let t = 0; t !== a; ++t) r[t] = g * s[c + t] + v * s[l + t] + x * s[o + t] + y * s[h + t];
                         return r
                     }
                 }
-                class Kl extends Jl {
+                class uh extends ch {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t, e, n, i) {
                         const r = this.resultBuffer,
                             s = this.sampleValues,
                             a = this.valueSize,
@@ -12400,62 +12691,62 @@
                             l = o - a,
                             c = (n - e) / (i - e),
                             h = 1 - c;
                         for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;
                         return r
                     }
                 }
-                class Ql extends Jl {
+                class dh extends ch {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t) {
                         return this.copySampleValue_(t - 1)
                     }
                 }
-                class $l {
+                class ph {
                     constructor(t, e, n, i) {
                         if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                         if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
-                        this.name = t, this.times = Yl.convertArray(e, this.TimeBufferType), this.values = Yl.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
+                        this.name = t, this.times = lh.convertArray(e, this.TimeBufferType), this.values = lh.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                     }
                     static toJSON(t) {
                         const e = t.constructor;
                         let n;
                         if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                         else {
                             n = {
                                 name: t.name,
-                                times: Yl.convertArray(t.times, Array),
-                                values: Yl.convertArray(t.values, Array)
+                                times: lh.convertArray(t.times, Array),
+                                values: lh.convertArray(t.values, Array)
                             };
                             const e = t.getInterpolation();
                             e !== t.DefaultInterpolation && (n.interpolation = e)
                         }
                         return n.type = t.ValueTypeName, n
                     }
                     InterpolantFactoryMethodDiscrete(t) {
-                        return new Ql(this.times, this.values, this.getValueSize(), t)
+                        return new dh(this.times, this.values, this.getValueSize(), t)
                     }
                     InterpolantFactoryMethodLinear(t) {
-                        return new Kl(this.times, this.values, this.getValueSize(), t)
+                        return new uh(this.times, this.values, this.getValueSize(), t)
                     }
                     InterpolantFactoryMethodSmooth(t) {
-                        return new Zl(this.times, this.values, this.getValueSize(), t)
+                        return new hh(this.times, this.values, this.getValueSize(), t)
                     }
                     setInterpolation(t) {
                         let e;
                         switch (t) {
-                            case tt:
+                            case oe:
                                 e = this.InterpolantFactoryMethodDiscrete;
                                 break;
-                            case et:
+                            case le:
                                 e = this.InterpolantFactoryMethodLinear;
                                 break;
-                            case nt:
+                            case ce:
                                 e = this.InterpolantFactoryMethodSmooth
                         }
                         if (void 0 === e) {
                             const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                             if (void 0 === this.createInterpolant) {
                                 if (t === this.DefaultInterpolation) throw new Error(e);
                                 this.setInterpolation(this.DefaultInterpolation)
@@ -12463,19 +12754,19 @@
                             return console.warn("THREE.KeyframeTrack:", e), this
                         }
                         return this.createInterpolant = e, this
                     }
                     getInterpolation() {
                         switch (this.createInterpolant) {
                             case this.InterpolantFactoryMethodDiscrete:
-                                return tt;
+                                return oe;
                             case this.InterpolantFactoryMethodLinear:
-                                return et;
+                                return le;
                             case this.InterpolantFactoryMethodSmooth:
-                                return nt
+                                return ce
                         }
                     }
                     getValueSize() {
                         return this.values.length / this.times.length
                     }
                     shift(t) {
                         if (0 !== t) {
@@ -12497,15 +12788,15 @@
                         let r = 0,
                             s = i - 1;
                         for (; r !== i && n[r] < t;) ++r;
                         for (; - 1 !== s && n[s] > e;) --s;
                         if (++s, 0 !== r || s !== i) {
                             r >= s && (s = Math.max(s, 1), r = s - 1);
                             const t = this.getValueSize();
-                            this.times = Yl.arraySlice(n, r, s), this.values = Yl.arraySlice(this.values, r * t, s * t)
+                            this.times = lh.arraySlice(n, r, s), this.values = lh.arraySlice(this.values, r * t, s * t)
                         }
                         return this
                     }
                     validate() {
                         let t = !0;
                         const e = this.getValueSize();
                         e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
@@ -12522,29 +12813,29 @@
                             }
                             if (null !== s && s > i) {
                                 console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1;
                                 break
                             }
                             s = i
                         }
-                        if (void 0 !== i && Yl.isTypedArray(i))
+                        if (void 0 !== i && lh.isTypedArray(i))
                             for (let e = 0, n = i.length; e !== n; ++e) {
                                 const n = i[e];
                                 if (isNaN(n)) {
                                     console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                                     break
                                 }
                             }
                         return t
                     }
                     optimize() {
-                        const t = Yl.arraySlice(this.times),
-                            e = Yl.arraySlice(this.values),
+                        const t = lh.arraySlice(this.times),
+                            e = lh.arraySlice(this.values),
                             n = this.getValueSize(),
-                            i = this.getInterpolation() === nt,
+                            i = this.getInterpolation() === ce,
                             r = t.length - 1;
                         let s = 1;
                         for (let a = 1; a < r; ++a) {
                             let r = !1;
                             const o = t[a];
                             if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                                 if (i) r = !0;
@@ -12569,88 +12860,88 @@
                             }
                         }
                         if (r > 0) {
                             t[s] = t[r];
                             for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
                             ++s
                         }
-                        return s !== t.length ? (this.times = Yl.arraySlice(t, 0, s), this.values = Yl.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
+                        return s !== t.length ? (this.times = lh.arraySlice(t, 0, s), this.values = lh.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
                     }
                     clone() {
-                        const t = Yl.arraySlice(this.times, 0),
-                            e = Yl.arraySlice(this.values, 0),
+                        const t = lh.arraySlice(this.times, 0),
+                            e = lh.arraySlice(this.values, 0),
                             n = new(0, this.constructor)(this.name, t, e);
                         return n.createInterpolant = this.createInterpolant, n
                     }
                 }
-                $l.prototype.TimeBufferType = Float32Array, $l.prototype.ValueBufferType = Float32Array, $l.prototype.DefaultInterpolation = et;
-                class tc extends $l {}
-                tc.prototype.ValueTypeName = "bool", tc.prototype.ValueBufferType = Array, tc.prototype.DefaultInterpolation = tt, tc.prototype.InterpolantFactoryMethodLinear = void 0, tc.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class ec extends $l {}
-                ec.prototype.ValueTypeName = "color";
-                class nc extends $l {}
-                nc.prototype.ValueTypeName = "number";
-                class ic extends Jl {
+                ph.prototype.TimeBufferType = Float32Array, ph.prototype.ValueBufferType = Float32Array, ph.prototype.DefaultInterpolation = le;
+                class mh extends ph {}
+                mh.prototype.ValueTypeName = "bool", mh.prototype.ValueBufferType = Array, mh.prototype.DefaultInterpolation = oe, mh.prototype.InterpolantFactoryMethodLinear = void 0, mh.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class fh extends ph {}
+                fh.prototype.ValueTypeName = "color";
+                class gh extends ph {}
+                gh.prototype.ValueTypeName = "number";
+                class vh extends ch {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t, e, n, i) {
                         const r = this.resultBuffer,
                             s = this.sampleValues,
                             a = this.valueSize,
                             o = (n - e) / (i - e);
                         let l = t * a;
-                        for (let t = l + a; l !== t; l += 4) Jt.slerpFlat(r, 0, s, l - a, s, l, o);
+                        for (let t = l + a; l !== t; l += 4) an.slerpFlat(r, 0, s, l - a, s, l, o);
                         return r
                     }
                 }
-                class rc extends $l {
+                class xh extends ph {
                     InterpolantFactoryMethodLinear(t) {
-                        return new ic(this.times, this.values, this.getValueSize(), t)
+                        return new vh(this.times, this.values, this.getValueSize(), t)
                     }
                 }
-                rc.prototype.ValueTypeName = "quaternion", rc.prototype.DefaultInterpolation = et, rc.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class sc extends $l {}
-                sc.prototype.ValueTypeName = "string", sc.prototype.ValueBufferType = Array, sc.prototype.DefaultInterpolation = tt, sc.prototype.InterpolantFactoryMethodLinear = void 0, sc.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class ac extends $l {}
-                ac.prototype.ValueTypeName = "vector";
-                class oc {
+                xh.prototype.ValueTypeName = "quaternion", xh.prototype.DefaultInterpolation = le, xh.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class yh extends ph {}
+                yh.prototype.ValueTypeName = "string", yh.prototype.ValueBufferType = Array, yh.prototype.DefaultInterpolation = oe, yh.prototype.InterpolantFactoryMethodLinear = void 0, yh.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class _h extends ph {}
+                _h.prototype.ValueTypeName = "vector";
+                class Mh {
                     constructor(t, e = -1, n, i = 2500) {
-                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = yt(), this.duration < 0 && this.resetDuration()
+                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Le(), this.duration < 0 && this.resetDuration()
                     }
                     static parse(t) {
                         const e = [],
                             n = t.tracks,
                             i = 1 / (t.fps || 1);
-                        for (let t = 0, r = n.length; t !== r; ++t) e.push(lc(n[t]).scale(i));
+                        for (let t = 0, r = n.length; t !== r; ++t) e.push(bh(n[t]).scale(i));
                         const r = new this(t.name, t.duration, e, t.blendMode);
                         return r.uuid = t.uuid, r
                     }
                     static toJSON(t) {
                         const e = [],
                             n = t.tracks,
                             i = {
                                 name: t.name,
                                 duration: t.duration,
                                 tracks: e,
                                 uuid: t.uuid,
                                 blendMode: t.blendMode
                             };
-                        for (let t = 0, i = n.length; t !== i; ++t) e.push($l.toJSON(n[t]));
+                        for (let t = 0, i = n.length; t !== i; ++t) e.push(ph.toJSON(n[t]));
                         return i
                     }
                     static CreateFromMorphTargetSequence(t, e, n, i) {
                         const r = e.length,
                             s = [];
                         for (let t = 0; t < r; t++) {
                             let a = [],
                                 o = [];
                             a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
-                            const l = Yl.getKeyframeOrder(a);
-                            a = Yl.sortedArray(a, 1, l), o = Yl.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new nc(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / n))
+                            const l = lh.getKeyframeOrder(a);
+                            a = lh.sortedArray(a, 1, l), o = lh.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new gh(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / n))
                         }
                         return new this(t, -1, s)
                     }
                     static findByName(t, e) {
                         let n = t;
                         if (!Array.isArray(t)) {
                             const e = t;
@@ -12678,15 +12969,15 @@
                     }
                     static parseAnimation(t, e) {
                         if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                         const n = function(t, e, n, i, r) {
                                 if (0 !== n.length) {
                                     const s = [],
                                         a = [];
-                                    Yl.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a))
+                                    lh.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a))
                                 }
                             },
                             i = [],
                             r = t.name || "default",
                             s = t.fps || 30,
                             a = t.blendMode;
                         let o = t.length || -1;
@@ -12703,20 +12994,20 @@
                                     for (const n in t) {
                                         const t = [],
                                             s = [];
                                         for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                             const i = r[e];
                                             t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                         }
-                                        i.push(new nc(".morphTargetInfluence[" + n + "]", t, s))
+                                        i.push(new gh(".morphTargetInfluence[" + n + "]", t, s))
                                     }
                                     o = t.length * (s || 1)
                                 } else {
                                     const s = ".bones[" + e[t].name + "]";
-                                    n(ac, s + ".position", r, "pos", i), n(rc, s + ".quaternion", r, "rot", i), n(ac, s + ".scale", r, "scl", i)
+                                    n(_h, s + ".position", r, "pos", i), n(xh, s + ".quaternion", r, "rot", i), n(_h, s + ".scale", r, "scl", i)
                                 }
                         }
                         return 0 === i.length ? null : new this(r, o, i, a)
                     }
                     resetDuration() {
                         let t = 0;
                         for (let e = 0, n = this.tracks.length; e !== n; ++e) {
@@ -12744,49 +13035,49 @@
                         return new this.constructor(this.name, this.duration, t, this.blendMode)
                     }
                     toJSON() {
                         return this.constructor.toJSON(this)
                     }
                 }
 
-                function lc(t) {
+                function bh(t) {
                     if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                     const e = function(t) {
                         switch (t.toLowerCase()) {
                             case "scalar":
                             case "double":
                             case "float":
                             case "number":
                             case "integer":
-                                return nc;
+                                return gh;
                             case "vector":
                             case "vector2":
                             case "vector3":
                             case "vector4":
-                                return ac;
+                                return _h;
                             case "color":
-                                return ec;
+                                return fh;
                             case "quaternion":
-                                return rc;
+                                return xh;
                             case "bool":
                             case "boolean":
-                                return tc;
+                                return mh;
                             case "string":
-                                return sc
+                                return yh
                         }
                         throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                     }(t.type);
                     if (void 0 === t.times) {
                         const e = [],
                             n = [];
-                        Yl.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
+                        lh.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                     }
                     return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                 }
-                const cc = {
+                const wh = {
                     enabled: !1,
                     files: {},
                     add: function(t, e) {
                         !1 !== this.enabled && (this.files[t] = e)
                     },
                     get: function(t) {
                         if (!1 !== this.enabled) return this.files[t]
@@ -12794,15 +13085,15 @@
                     remove: function(t) {
                         delete this.files[t]
                     },
                     clear: function() {
                         this.files = {}
                     }
                 };
-                class hc {
+                class Sh {
                     constructor(t, e, n) {
                         const i = this;
                         let r, s = !1,
                             a = 0,
                             o = 0;
                         const l = [];
                         this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
@@ -12826,18 +13117,18 @@
                                     i = l[e + 1];
                                 if (n.global && (n.lastIndex = 0), n.test(t)) return i
                             }
                             return null
                         }
                     }
                 }
-                const uc = new hc;
-                class dc {
+                const Eh = new Sh;
+                class Th {
                     constructor(t) {
-                        this.manager = void 0 !== t ? t : uc, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
+                        this.manager = void 0 !== t ? t : Eh, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                     }
                     load() {}
                     loadAsync(t, e) {
                         const n = this;
                         return new Promise((function(i, r) {
                             n.load(t, i, e, r)
                         }))
@@ -12855,45 +13146,45 @@
                     setResourcePath(t) {
                         return this.resourcePath = t, this
                     }
                     setRequestHeader(t) {
                         return this.requestHeader = t, this
                     }
                 }
-                const pc = {};
-                class mc extends dc {
+                const Ah = {};
+                class Rh extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
-                        const r = cc.get(t);
+                        const r = wh.get(t);
                         if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => {
                             e && e(r), this.manager.itemEnd(t)
                         }), 0), r;
-                        if (void 0 !== pc[t]) return void pc[t].push({
+                        if (void 0 !== Ah[t]) return void Ah[t].push({
                             onLoad: e,
                             onProgress: n,
                             onError: i
                         });
-                        pc[t] = [], pc[t].push({
+                        Ah[t] = [], Ah[t].push({
                             onLoad: e,
                             onProgress: n,
                             onError: i
                         });
                         const s = new Request(t, {
                                 headers: new Headers(this.requestHeader),
                                 credentials: this.withCredentials ? "include" : "same-origin"
                             }),
                             a = this.mimeType,
                             o = this.responseType;
                         fetch(s).then((e => {
                             if (200 === e.status || 0 === e.status) {
                                 if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body.getReader) return e;
-                                const n = pc[t],
+                                const n = Ah[t],
                                     i = e.body.getReader(),
                                     r = e.headers.get("Content-Length"),
                                     s = r ? parseInt(r) : 0,
                                     a = 0 !== s;
                                 let o = 0;
                                 const l = new ReadableStream({
                                     start(t) {
@@ -12938,25 +13229,25 @@
                                         const e = /charset="?([^;"\s]*)"?/i.exec(a),
                                             n = e && e[1] ? e[1].toLowerCase() : void 0,
                                             i = new TextDecoder(n);
                                         return t.arrayBuffer().then((t => i.decode(t)))
                                     }
                             }
                         })).then((e => {
-                            cc.add(t, e);
-                            const n = pc[t];
-                            delete pc[t];
+                            wh.add(t, e);
+                            const n = Ah[t];
+                            delete Ah[t];
                             for (let t = 0, i = n.length; t < i; t++) {
                                 const i = n[t];
                                 i.onLoad && i.onLoad(e)
                             }
                         })).catch((e => {
-                            const n = pc[t];
+                            const n = Ah[t];
                             if (void 0 === n) throw this.manager.itemError(t), e;
-                            delete pc[t];
+                            delete Ah[t];
                             for (let t = 0, i = n.length; t < i; t++) {
                                 const i = n[t];
                                 i.onError && i.onError(e)
                             }
                             this.manager.itemError(t)
                         })).finally((() => {
                             this.manager.itemEnd(t)
@@ -12965,126 +13256,126 @@
                     setResponseType(t) {
                         return this.responseType = t, this
                     }
                     setMimeType(t) {
                         return this.mimeType = t, this
                     }
                 }
-                class fc extends dc {
+                class Lh extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                         const r = this,
-                            s = cc.get(t);
+                            s = wh.get(t);
                         if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                             e && e(s), r.manager.itemEnd(t)
                         }), 0), s;
-                        const a = Dt("img");
+                        const a = Ve("img");
 
                         function o() {
-                            c(), cc.add(t, this), e && e(this), r.manager.itemEnd(t)
+                            c(), wh.add(t, this), e && e(this), r.manager.itemEnd(t)
                         }
 
                         function l(e) {
                             c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                         }
 
                         function c() {
                             a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
                         }
                         return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                     }
                 }
-                class gc extends dc {
+                class Ch extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
-                        const r = new ci,
-                            s = new fc(this.manager);
+                        const r = new yr,
+                            s = new Lh(this.manager);
                         s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                         let a = 0;
 
                         function o(n) {
                             s.load(t[n], (function(t) {
                                 r.images[n] = t, a++, 6 === a && (r.needsUpdate = !0, e && e(r))
                             }), void 0, i)
                         }
                         for (let e = 0; e < t.length; ++e) o(e);
                         return r
                     }
                 }
-                class vc extends dc {
+                class Ph extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new Fa,
-                            a = new mc(this.manager);
+                            s = new $o,
+                            a = new Rh(this.manager);
                         return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(t, (function(t) {
                             const n = r.parse(t);
-                            n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : d, s.wrapT = void 0 !== n.wrapT ? n.wrapT : d, s.magFilter = void 0 !== n.magFilter ? n.magFilter : v, s.minFilter = void 0 !== n.minFilter ? n.minFilter : v, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = y), 1 === n.mipmapCount && (s.minFilter = v), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, e && e(s, n))
+                            n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : st, s.wrapT = void 0 !== n.wrapT ? n.wrapT : st, s.magFilter = void 0 !== n.magFilter ? n.magFilter : ht, s.minFilter = void 0 !== n.minFilter ? n.minFilter : ht, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = dt), 1 === n.mipmapCount && (s.minFilter = ht), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, e && e(s, n))
                         }), n, i), s
                     }
                 }
-                class xc extends dc {
+                class Dh extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
-                        const r = new kt,
-                            s = new fc(this.manager);
+                        const r = new $e,
+                            s = new Lh(this.manager);
                         return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(t) {
                             r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                         }), n, i), r
                     }
                 }
-                class yc extends Qe {
+                class Ih extends ci {
                     constructor(t, e = 1) {
-                        super(), this.type = "Light", this.color = new zt(t), this.intensity = e
+                        super(), this.type = "Light", this.color = new Je(t), this.intensity = e
                     }
                     dispose() {}
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                     }
                 }
-                yc.prototype.isLight = !0;
-                class _c extends yc {
+                Ih.prototype.isLight = !0;
+                class Nh extends Ih {
                     constructor(t, e, n) {
-                        super(t, n), this.type = "HemisphereLight", this.position.copy(Qe.DefaultUp), this.updateMatrix(), this.groundColor = new zt(e)
+                        super(t, n), this.type = "HemisphereLight", this.position.copy(ci.DefaultUp), this.updateMatrix(), this.groundColor = new Je(e)
                     }
                     copy(t) {
-                        return yc.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
+                        return Ih.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                     }
                 }
-                _c.prototype.isHemisphereLight = !0;
-                const Mc = new Ae,
-                    bc = new Zt,
-                    wc = new Zt;
-                class Sc {
+                Nh.prototype.isHemisphereLight = !0;
+                const Oh = new Fn,
+                    Uh = new on,
+                    Bh = new on;
+                class Fh {
                     constructor(t) {
-                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new At(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ae, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new vi, this._frameExtents = new At(1, 1), this._viewportCount = 1, this._viewports = [new jt(0, 0, 1, 1)]
+                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Be(512, 512), this.map = null, this.mapPass = null, this.matrix = new Fn, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ar, this._frameExtents = new Be(1, 1), this._viewportCount = 1, this._viewports = [new en(0, 0, 1, 1)]
                     }
                     getViewportCount() {
                         return this._viewportCount
                     }
                     getFrustum() {
                         return this._frustum
                     }
                     updateMatrices(t) {
                         const e = this.camera,
                             n = this.matrix;
-                        bc.setFromMatrixPosition(t.matrixWorld), e.position.copy(bc), wc.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(wc), e.updateMatrixWorld(), Mc.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Mc), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
+                        Uh.setFromMatrixPosition(t.matrixWorld), e.position.copy(Uh), Bh.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Bh), e.updateMatrixWorld(), Oh.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Oh), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                     }
                     getViewport(t) {
                         return this._viewports[t]
                     }
                     getFrameExtents() {
                         return this._frameExtents
                     }
@@ -13098,106 +13389,106 @@
                         return (new this.constructor).copy(this)
                     }
                     toJSON() {
                         const t = {};
                         return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                     }
                 }
-                class Ec extends Sc {
+                class zh extends Fh {
                     constructor() {
-                        super(new ai(50, 1, .5, 500)), this.focus = 1
+                        super(new gr(50, 1, .5, 500)), this.focus = 1
                     }
                     updateMatrices(t) {
                         const e = this.camera,
-                            n = 2 * xt * t.angle * this.focus,
+                            n = 2 * Re * t.angle * this.focus,
                             i = this.mapSize.width / this.mapSize.height,
                             r = t.distance || e.far;
                         n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                     }
                     copy(t) {
                         return super.copy(t), this.focus = t.focus, this
                     }
                 }
-                Ec.prototype.isSpotLightShadow = !0;
-                class Tc extends yc {
+                zh.prototype.isSpotLightShadow = !0;
+                class Hh extends Ih {
                     constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
-                        super(t, e), this.type = "SpotLight", this.position.copy(Qe.DefaultUp), this.updateMatrix(), this.target = new Qe, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new Ec
+                        super(t, e), this.type = "SpotLight", this.position.copy(ci.DefaultUp), this.updateMatrix(), this.target = new ci, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new zh
                     }
                     get power() {
                         return this.intensity * Math.PI
                     }
                     set power(t) {
                         this.intensity = t / Math.PI
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                     }
                 }
-                Tc.prototype.isSpotLight = !0;
-                const Ac = new Ae,
-                    Rc = new Zt,
-                    Lc = new Zt;
-                class Cc extends Sc {
+                Hh.prototype.isSpotLight = !0;
+                const Gh = new Fn,
+                    Vh = new on,
+                    kh = new on;
+                class Wh extends Fh {
                     constructor() {
-                        super(new ai(90, 1, .5, 500)), this._frameExtents = new At(4, 2), this._viewportCount = 6, this._viewports = [new jt(2, 1, 1, 1), new jt(0, 1, 1, 1), new jt(3, 1, 1, 1), new jt(1, 1, 1, 1), new jt(3, 0, 1, 1), new jt(1, 0, 1, 1)], this._cubeDirections = [new Zt(1, 0, 0), new Zt(-1, 0, 0), new Zt(0, 0, 1), new Zt(0, 0, -1), new Zt(0, 1, 0), new Zt(0, -1, 0)], this._cubeUps = [new Zt(0, 1, 0), new Zt(0, 1, 0), new Zt(0, 1, 0), new Zt(0, 1, 0), new Zt(0, 0, 1), new Zt(0, 0, -1)]
+                        super(new gr(90, 1, .5, 500)), this._frameExtents = new Be(4, 2), this._viewportCount = 6, this._viewports = [new en(2, 1, 1, 1), new en(0, 1, 1, 1), new en(3, 1, 1, 1), new en(1, 1, 1, 1), new en(3, 0, 1, 1), new en(1, 0, 1, 1)], this._cubeDirections = [new on(1, 0, 0), new on(-1, 0, 0), new on(0, 0, 1), new on(0, 0, -1), new on(0, 1, 0), new on(0, -1, 0)], this._cubeUps = [new on(0, 1, 0), new on(0, 1, 0), new on(0, 1, 0), new on(0, 1, 0), new on(0, 0, 1), new on(0, 0, -1)]
                     }
                     updateMatrices(t, e = 0) {
                         const n = this.camera,
                             i = this.matrix,
                             r = t.distance || n.far;
-                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Rc.setFromMatrixPosition(t.matrixWorld), n.position.copy(Rc), Lc.copy(n.position), Lc.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Lc), n.updateMatrixWorld(), i.makeTranslation(-Rc.x, -Rc.y, -Rc.z), Ac.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ac)
+                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Vh.setFromMatrixPosition(t.matrixWorld), n.position.copy(Vh), kh.copy(n.position), kh.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(kh), n.updateMatrixWorld(), i.makeTranslation(-Vh.x, -Vh.y, -Vh.z), Gh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Gh)
                     }
                 }
-                Cc.prototype.isPointLightShadow = !0;
-                class Pc extends yc {
+                Wh.prototype.isPointLightShadow = !0;
+                class jh extends Ih {
                     constructor(t, e, n = 0, i = 1) {
-                        super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Cc
+                        super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Wh
                     }
                     get power() {
                         return 4 * this.intensity * Math.PI
                     }
                     set power(t) {
                         this.intensity = t / (4 * Math.PI)
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                     }
                 }
-                Pc.prototype.isPointLight = !0;
-                class Dc extends Sc {
+                jh.prototype.isPointLight = !0;
+                class Xh extends Fh {
                     constructor() {
-                        super(new Ci(-5, 5, 5, -5, .5, 500))
+                        super(new Hr(-5, 5, 5, -5, .5, 500))
                     }
                 }
-                Dc.prototype.isDirectionalLightShadow = !0;
-                class Ic extends yc {
+                Xh.prototype.isDirectionalLightShadow = !0;
+                class qh extends Ih {
                     constructor(t, e) {
-                        super(t, e), this.type = "DirectionalLight", this.position.copy(Qe.DefaultUp), this.updateMatrix(), this.target = new Qe, this.shadow = new Dc
+                        super(t, e), this.type = "DirectionalLight", this.position.copy(ci.DefaultUp), this.updateMatrix(), this.target = new ci, this.shadow = new Xh
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                     }
                 }
-                Ic.prototype.isDirectionalLight = !0;
-                class Nc extends yc {
+                qh.prototype.isDirectionalLight = !0;
+                class Yh extends Ih {
                     constructor(t, e) {
                         super(t, e), this.type = "AmbientLight"
                     }
                 }
-                Nc.prototype.isAmbientLight = !0;
-                class Oc extends yc {
+                Yh.prototype.isAmbientLight = !0;
+                class Jh extends Ih {
                     constructor(t, e, n = 10, i = 10) {
                         super(t, e), this.type = "RectAreaLight", this.width = n, this.height = i
                     }
                     get power() {
                         return this.intensity * this.width * this.height * Math.PI
                     }
                     set power(t) {
@@ -13207,19 +13498,19 @@
                         return super.copy(t), this.width = t.width, this.height = t.height, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.width = this.width, e.object.height = this.height, e
                     }
                 }
-                Oc.prototype.isRectAreaLight = !0;
-                class Uc {
+                Jh.prototype.isRectAreaLight = !0;
+                class Zh {
                     constructor() {
                         this.coefficients = [];
-                        for (let t = 0; t < 9; t++) this.coefficients.push(new Zt)
+                        for (let t = 0; t < 9; t++) this.coefficients.push(new on)
                     }
                     set(t) {
                         for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                         return this
                     }
                     zero() {
                         for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
@@ -13279,95 +13570,95 @@
                     static getBasisAt(t, e) {
                         const n = t.x,
                             i = t.y,
                             r = t.z;
                         e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                     }
                 }
-                Uc.prototype.isSphericalHarmonics3 = !0;
-                class Bc extends yc {
-                    constructor(t = new Uc, e = 1) {
+                Zh.prototype.isSphericalHarmonics3 = !0;
+                class Kh extends Ih {
+                    constructor(t = new Zh, e = 1) {
                         super(void 0, e), this.sh = t
                     }
                     copy(t) {
                         return super.copy(t), this.sh.copy(t.sh), this
                     }
                     fromJSON(t) {
                         return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.sh = this.sh.toArray(), e
                     }
                 }
-                Bc.prototype.isLightProbe = !0;
-                class Fc extends dc {
+                Kh.prototype.isLightProbe = !0;
+                class Qh extends Th {
                     constructor(t) {
                         super(t), this.textures = {}
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new mc(r.manager);
+                            s = new Rh(r.manager);
                         s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) {
                             try {
                                 e(r.parse(JSON.parse(n)))
                             } catch (e) {
                                 i ? i(e) : console.error(e), r.manager.itemError(t)
                             }
                         }), n, i)
                     }
                     parse(t) {
                         const e = this.textures;
 
                         function n(t) {
                             return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                         }
-                        const i = new ql[t.type];
-                        if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = t.sheen), void 0 !== t.sheenColor && (i.sheenColor = (new zt).setHex(t.sheenColor)), void 0 !== t.sheenRoughness && (i.sheenRoughness = t.sheenRoughness), void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular), void 0 !== t.specularIntensity && (i.specularIntensity = t.specularIntensity), void 0 !== t.specularColor && void 0 !== i.specularColor && i.specularColor.setHex(t.specularColor), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.thickness && (i.thickness = t.thickness), void 0 !== t.attenuationDistance && (i.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationColor && void 0 !== i.attenuationColor && i.attenuationColor.setHex(t.attenuationColor), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.alphaWrite && (i.alphaWrite = t.alphaWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
+                        const i = new oh[t.type];
+                        if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = t.sheen), void 0 !== t.sheenColor && (i.sheenColor = (new Je).setHex(t.sheenColor)), void 0 !== t.sheenRoughness && (i.sheenRoughness = t.sheenRoughness), void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular), void 0 !== t.specularIntensity && (i.specularIntensity = t.specularIntensity), void 0 !== t.specularColor && void 0 !== i.specularColor && i.specularColor.setHex(t.specularColor), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.thickness && (i.thickness = t.thickness), void 0 !== t.attenuationDistance && (i.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationColor && void 0 !== i.attenuationColor && i.attenuationColor.setHex(t.attenuationColor), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.alphaWrite && (i.alphaWrite = t.alphaWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                             for (const e in t.uniforms) {
                                 const r = t.uniforms[e];
                                 switch (i.uniforms[e] = {}, r.type) {
                                     case "t":
                                         i.uniforms[e].value = n(r.value);
                                         break;
                                     case "c":
-                                        i.uniforms[e].value = (new zt).setHex(r.value);
+                                        i.uniforms[e].value = (new Je).setHex(r.value);
                                         break;
                                     case "v2":
-                                        i.uniforms[e].value = (new At).fromArray(r.value);
+                                        i.uniforms[e].value = (new Be).fromArray(r.value);
                                         break;
                                     case "v3":
-                                        i.uniforms[e].value = (new Zt).fromArray(r.value);
+                                        i.uniforms[e].value = (new on).fromArray(r.value);
                                         break;
                                     case "v4":
-                                        i.uniforms[e].value = (new jt).fromArray(r.value);
+                                        i.uniforms[e].value = (new en).fromArray(r.value);
                                         break;
                                     case "m3":
-                                        i.uniforms[e].value = (new Rt).fromArray(r.value);
+                                        i.uniforms[e].value = (new Fe).fromArray(r.value);
                                         break;
                                     case "m4":
-                                        i.uniforms[e].value = (new Ae).fromArray(r.value);
+                                        i.uniforms[e].value = (new Fn).fromArray(r.value);
                                         break;
                                     default:
                                         i.uniforms[e].value = r.value
                                 }
                             }
                         if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                             for (const e in t.extensions) i.extensions[e] = t.extensions[e];
                         if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                             let e = t.normalScale;
-                            !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new At).fromArray(e)
+                            !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new Be).fromArray(e)
                         }
-                        return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.specularIntensityMap && (i.specularIntensityMap = n(t.specularIntensityMap)), void 0 !== t.specularColorMap && (i.specularColorMap = n(t.specularColorMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new At).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)), void 0 !== t.sheenColorMap && (i.sheenColorMap = n(t.sheenColorMap)), void 0 !== t.sheenRoughnessMap && (i.sheenRoughnessMap = n(t.sheenRoughnessMap)), i
+                        return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.specularIntensityMap && (i.specularIntensityMap = n(t.specularIntensityMap)), void 0 !== t.specularColorMap && (i.specularColorMap = n(t.specularColorMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new Be).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)), void 0 !== t.sheenColorMap && (i.sheenColorMap = n(t.sheenColorMap)), void 0 !== t.sheenRoughnessMap && (i.sheenRoughnessMap = n(t.sheenRoughnessMap)), i
                     }
                     setTextures(t) {
                         return this.textures = t, this
                     }
                 }
-                class zc {
+                class $h {
                     static decodeText(t) {
                         if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                         let e = "";
                         for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                         try {
                             return decodeURIComponent(escape(e))
                         } catch (t) {
@@ -13378,37 +13669,37 @@
                         const e = t.lastIndexOf("/");
                         return -1 === e ? "./" : t.substr(0, e + 1)
                     }
                     static resolveURL(t, e) {
                         return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                     }
                 }
-                class Hc extends Nn {
+                class tu extends Wi {
                     constructor() {
                         super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                     }
                     copy(t) {
                         return super.copy(t), this.instanceCount = t.instanceCount, this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     toJSON() {
                         const t = super.toJSON(this);
                         return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                     }
                 }
-                Hc.prototype.isInstancedBufferGeometry = !0;
-                class Gc extends dc {
+                tu.prototype.isInstancedBufferGeometry = !0;
+                class eu extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new mc(r.manager);
+                            s = new Rh(r.manager);
                         s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) {
                             try {
                                 e(r.parse(JSON.parse(n)))
                             } catch (e) {
                                 i ? i(e) : console.error(e), r.manager.itemError(t)
                             }
                         }), n, i)
@@ -13422,208 +13713,208 @@
                             const r = t.interleavedBuffers[i],
                                 s = function(t, e) {
                                     if (void 0 !== n[e]) return n[e];
                                     const i = t.arrayBuffers[e],
                                         r = new Uint32Array(i).buffer;
                                     return n[e] = r, r
                                 }(t, r.buffer),
-                                a = Pt(r.type, s),
-                                o = new ca(a, r.stride);
+                                a = Ge(r.type, s),
+                                o = new So(a, r.stride);
                             return o.uuid = r.uuid, e[i] = o, o
                         }
-                        const r = t.isInstancedBufferGeometry ? new Hc : new Nn,
+                        const r = t.isInstancedBufferGeometry ? new tu : new Wi,
                             s = t.data.index;
                         if (void 0 !== s) {
-                            const t = Pt(s.type, s.array);
-                            r.setIndex(new gn(t, 1))
+                            const t = Ge(s.type, s.array);
+                            r.setIndex(new Ti(t, 1))
                         }
                         const a = t.data.attributes;
                         for (const e in a) {
                             const n = a[e];
                             let s;
                             if (n.isInterleavedBufferAttribute) {
                                 const e = i(t.data, n.data);
-                                s = new ua(e, n.itemSize, n.offset, n.normalized)
+                                s = new To(e, n.itemSize, n.offset, n.normalized)
                             } else {
-                                const t = Pt(n.type, n.array);
-                                s = new(n.isInstancedBufferAttribute ? Va : gn)(t, n.itemSize, n.normalized)
+                                const t = Ge(n.type, n.array);
+                                s = new(n.isInstancedBufferAttribute ? il : Ti)(t, n.itemSize, n.normalized)
                             }
                             void 0 !== n.name && (s.name = n.name), void 0 !== n.usage && s.setUsage(n.usage), void 0 !== n.updateRange && (s.updateRange.offset = n.updateRange.offset, s.updateRange.count = n.updateRange.count), r.setAttribute(e, s)
                         }
                         const o = t.data.morphAttributes;
                         if (o)
                             for (const e in o) {
                                 const n = o[e],
                                     s = [];
                                 for (let e = 0, r = n.length; e < r; e++) {
                                     const r = n[e];
                                     let a;
                                     if (r.isInterleavedBufferAttribute) {
                                         const e = i(t.data, r.data);
-                                        a = new ua(e, r.itemSize, r.offset, r.normalized)
+                                        a = new To(e, r.itemSize, r.offset, r.normalized)
                                     } else {
-                                        const t = Pt(r.type, r.array);
-                                        a = new gn(t, r.itemSize, r.normalized)
+                                        const t = Ge(r.type, r.array);
+                                        a = new Ti(t, r.itemSize, r.normalized)
                                     }
                                     void 0 !== r.name && (a.name = r.name), s.push(a)
                                 }
                                 r.morphAttributes[e] = s
                             }
                         t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
                         const l = t.data.groups || t.data.drawcalls || t.data.offsets;
                         if (void 0 !== l)
                             for (let t = 0, e = l.length; t !== e; ++t) {
                                 const e = l[t];
                                 r.addGroup(e.start, e.count, e.materialIndex)
                             }
                         const c = t.data.boundingSphere;
                         if (void 0 !== c) {
-                            const t = new Zt;
-                            void 0 !== c.center && t.fromArray(c.center), r.boundingSphere = new xe(t, c.radius)
+                            const t = new on;
+                            void 0 !== c.center && t.fromArray(c.center), r.boundingSphere = new Ln(t, c.radius)
                         }
                         return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
                     }
                 }
-                const Vc = {
-                        UVMapping: r,
-                        CubeReflectionMapping: s,
-                        CubeRefractionMapping: a,
-                        EquirectangularReflectionMapping: o,
-                        EquirectangularRefractionMapping: l,
-                        CubeUVReflectionMapping: c,
-                        CubeUVRefractionMapping: h
-                    },
-                    kc = {
-                        RepeatWrapping: u,
-                        ClampToEdgeWrapping: d,
-                        MirroredRepeatWrapping: p
-                    },
-                    Wc = {
-                        NearestFilter: m,
-                        NearestMipmapNearestFilter: f,
-                        NearestMipmapLinearFilter: g,
-                        LinearFilter: v,
-                        LinearMipmapNearestFilter: x,
-                        LinearMipmapLinearFilter: y
+                const nu = {
+                        UVMapping: K,
+                        CubeReflectionMapping: Q,
+                        CubeRefractionMapping: $,
+                        EquirectangularReflectionMapping: tt,
+                        EquirectangularRefractionMapping: et,
+                        CubeUVReflectionMapping: nt,
+                        CubeUVRefractionMapping: it
+                    },
+                    iu = {
+                        RepeatWrapping: rt,
+                        ClampToEdgeWrapping: st,
+                        MirroredRepeatWrapping: at
+                    },
+                    ru = {
+                        NearestFilter: ot,
+                        NearestMipmapNearestFilter: lt,
+                        NearestMipmapLinearFilter: ct,
+                        LinearFilter: ht,
+                        LinearMipmapNearestFilter: ut,
+                        LinearMipmapLinearFilter: dt
                     };
-                class jc extends dc {
+                class su extends Th {
                     constructor(t) {
                         super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                             premultiplyAlpha: "none"
                         }
                     }
                     setOptions(t) {
                         return this.options = t, this
                     }
                     load(t, e, n, i) {
                         void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                         const r = this,
-                            s = cc.get(t);
+                            s = wh.get(t);
                         if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                             e && e(s), r.manager.itemEnd(t)
                         }), 0), s;
                         const a = {};
                         a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(t, a).then((function(t) {
                             return t.blob()
                         })).then((function(t) {
                             return createImageBitmap(t, Object.assign(r.options, {
                                 colorSpaceConversion: "none"
                             }))
                         })).then((function(n) {
-                            cc.add(t, n), e && e(n), r.manager.itemEnd(t)
+                            wh.add(t, n), e && e(n), r.manager.itemEnd(t)
                         })).catch((function(e) {
                             i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                         })), r.manager.itemStart(t)
                     }
                 }
-                let Xc;
-                jc.prototype.isImageBitmapLoader = !0;
-                const qc = {
+                let au;
+                su.prototype.isImageBitmapLoader = !0;
+                const ou = {
                     getContext: function() {
-                        return void 0 === Xc && (Xc = new(window.AudioContext || window.webkitAudioContext)), Xc
+                        return void 0 === au && (au = new(window.AudioContext || window.webkitAudioContext)), au
                     },
                     setContext: function(t) {
-                        Xc = t
+                        au = t
                     }
                 };
-                class Yc extends dc {
+                class lu extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new mc(this.manager);
+                            s = new Rh(this.manager);
                         s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                             try {
                                 const t = n.slice(0);
-                                qc.getContext().decodeAudioData(t, (function(t) {
+                                ou.getContext().decodeAudioData(t, (function(t) {
                                     e(t)
                                 }))
                             } catch (e) {
                                 i ? i(e) : console.error(e), r.manager.itemError(t)
                             }
                         }), n, i)
                     }
                 }
-                class Jc extends Bc {
+                class cu extends Kh {
                     constructor(t, e, n = 1) {
                         super(void 0, n);
-                        const i = (new zt).set(t),
-                            r = (new zt).set(e),
-                            s = new Zt(i.r, i.g, i.b),
-                            a = new Zt(r.r, r.g, r.b),
+                        const i = (new Je).set(t),
+                            r = (new Je).set(e),
+                            s = new on(i.r, i.g, i.b),
+                            a = new on(r.r, r.g, r.b),
                             o = Math.sqrt(Math.PI),
                             l = o * Math.sqrt(.75);
                         this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
                     }
                 }
-                Jc.prototype.isHemisphereLightProbe = !0;
-                class Zc extends Bc {
+                cu.prototype.isHemisphereLightProbe = !0;
+                class hu extends Kh {
                     constructor(t, e = 1) {
                         super(void 0, e);
-                        const n = (new zt).set(t);
+                        const n = (new Je).set(t);
                         this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                     }
                 }
-                Zc.prototype.isAmbientLightProbe = !0;
-                const Kc = new Ae,
-                    Qc = new Ae,
-                    $c = new Ae;
-                class th {
+                hu.prototype.isAmbientLightProbe = !0;
+                const uu = new Fn,
+                    du = new Fn,
+                    pu = new Fn;
+                class mu {
                     constructor(t = !0) {
                         this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                     }
                     start() {
-                        this.startTime = eh(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
+                        this.startTime = fu(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                     }
                     stop() {
                         this.getElapsedTime(), this.running = !1, this.autoStart = !1
                     }
                     getElapsedTime() {
                         return this.getDelta(), this.elapsedTime
                     }
                     getDelta() {
                         let t = 0;
                         if (this.autoStart && !this.running) return this.start(), 0;
                         if (this.running) {
-                            const e = eh();
+                            const e = fu();
                             t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                         }
                         return t
                     }
                 }
 
-                function eh() {
+                function fu() {
                     return ("undefined" == typeof performance ? Date : performance).now()
                 }
-                const nh = new Zt,
-                    ih = new Jt,
-                    rh = new Zt,
-                    sh = new Zt;
-                class ah extends Qe {
+                const gu = new on,
+                    vu = new an,
+                    xu = new on,
+                    yu = new on;
+                class _u extends ci {
                     constructor(t) {
                         super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                     }
                     getOutput() {
                         return this.gain
                     }
                     setNodeSource(t) {
@@ -13713,33 +14004,33 @@
                     getVolume() {
                         return this.gain.gain.value
                     }
                     setVolume(t) {
                         return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                     }
                 }
-                const oh = new Zt,
-                    lh = new Jt,
-                    ch = new Zt,
-                    hh = new Zt;
-                class uh {
+                const Mu = new on,
+                    bu = new an,
+                    wu = new on,
+                    Su = new on;
+                class Eu {
                     constructor(t, e = 2048) {
                         this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
                     }
                     getFrequencyData() {
                         return this.analyser.getByteFrequencyData(this.data), this.data
                     }
                     getAverageFrequency() {
                         let t = 0;
                         const e = this.getFrequencyData();
                         for (let n = 0; n < e.length; n++) t += e[n];
                         return t / e.length
                     }
                 }
-                class dh {
+                class Tu {
                     constructor(t, e, n) {
                         let i, r, s;
                         switch (this.binding = t, this.valueSize = n, e) {
                             case "quaternion":
                                 i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                                 break;
                             case "string":
@@ -13817,19 +14108,19 @@
                         for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                     }
                     _select(t, e, n, i, r) {
                         if (i >= .5)
                             for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
                     }
                     _slerp(t, e, n, i) {
-                        Jt.slerpFlat(t, e, t, e, t, n, i)
+                        an.slerpFlat(t, e, t, e, t, n, i)
                     }
                     _slerpAdditive(t, e, n, i, r) {
                         const s = this._workIndex * r;
-                        Jt.multiplyQuaternionsFlat(t, s, t, e, t, n), Jt.slerpFlat(t, e, t, e, t, s, i)
+                        an.multiplyQuaternionsFlat(t, s, t, e, t, n), an.slerpFlat(t, e, t, e, t, s, i)
                     }
                     _lerp(t, e, n, i, r) {
                         const s = 1 - i;
                         for (let a = 0; a !== r; ++a) {
                             const r = e + a;
                             t[r] = t[r] * s + t[n + a] * i
                         }
@@ -13837,46 +14128,47 @@
                     _lerpAdditive(t, e, n, i, r) {
                         for (let s = 0; s !== r; ++s) {
                             const r = e + s;
                             t[r] = t[r] + t[n + s] * i
                         }
                     }
                 }
-                const ph = new RegExp("[\\[\\]\\.:\\/]", "g"),
-                    mh = "[^\\[\\]\\.:\\/]",
-                    fh = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
-                    gh = /((?:WC+[\/:])*)/.source.replace("WC", mh),
-                    vh = /(WCOD+)?/.source.replace("WCOD", fh),
-                    xh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", mh),
-                    yh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", mh),
-                    _h = new RegExp("^" + gh + vh + xh + yh + "$"),
-                    Mh = ["material", "materials", "bones"];
-                class bh {
+                const Au = "\\[\\]\\.:\\/",
+                    Ru = new RegExp("[" + Au + "]", "g"),
+                    Lu = "[^" + Au + "]",
+                    Cu = "[^" + Au.replace("\\.", "") + "]",
+                    Pu = /((?:WC+[\/:])*)/.source.replace("WC", Lu),
+                    Du = /(WCOD+)?/.source.replace("WCOD", Cu),
+                    Iu = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Lu),
+                    Nu = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Lu),
+                    Ou = new RegExp("^" + Pu + Du + Iu + Nu + "$"),
+                    Uu = ["material", "materials", "bones"];
+                class Bu {
                     constructor(t, e, n) {
-                        this.path = e, this.parsedPath = n || bh.parseTrackName(e), this.node = bh.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
+                        this.path = e, this.parsedPath = n || Bu.parseTrackName(e), this.node = Bu.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                     }
                     static create(t, e, n) {
-                        return t && t.isAnimationObjectGroup ? new bh.Composite(t, e, n) : new bh(t, e, n)
+                        return t && t.isAnimationObjectGroup ? new Bu.Composite(t, e, n) : new Bu(t, e, n)
                     }
                     static sanitizeNodeName(t) {
-                        return t.replace(/\s/g, "_").replace(ph, "")
+                        return t.replace(/\s/g, "_").replace(Ru, "")
                     }
                     static parseTrackName(t) {
-                        const e = _h.exec(t);
+                        const e = Ou.exec(t);
                         if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                         const n = {
                                 nodeName: e[2],
                                 objectName: e[3],
                                 objectIndex: e[4],
                                 propertyName: e[5],
                                 propertyIndex: e[6]
                             },
                             i = n.nodeName && n.nodeName.lastIndexOf(".");
                         if (void 0 !== i && -1 !== i) {
-                            const t = n.nodeName.substring(i + 1); - 1 !== Mh.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
+                            const t = n.nodeName.substring(i + 1); - 1 !== Uu.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                         }
                         if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                         return n
                     }
                     static findNode(t, e) {
                         if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                         if (t.skeleton) {
@@ -13962,15 +14254,15 @@
                     }
                     bind() {
                         let t = this.node;
                         const e = this.parsedPath,
                             n = e.objectName,
                             i = e.propertyName;
                         let r = e.propertyIndex;
-                        if (t || (t = bh.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
+                        if (t || (t = Bu.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                         if (n) {
                             let i = e.objectIndex;
                             switch (n) {
                                 case "materials":
                                     if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                     if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                     t = t.material.materials;
@@ -14011,17 +14303,17 @@
                         } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                         this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
                     }
                     unbind() {
                         this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                     }
                 }
-                bh.Composite = class {
+                Bu.Composite = class {
                     constructor(t, e, n) {
-                        const i = n || bh.parseTrackName(e);
+                        const i = n || Bu.parseTrackName(e);
                         this._targetGroup = t, this._bindings = t.subscribe_(e, i)
                     }
                     getValue(t, e) {
                         this.bind();
                         const n = this._targetGroup.nCachedObjects_,
                             i = this._bindings[n];
                         void 0 !== i && i.getValue(t, e)
@@ -14034,32 +14326,32 @@
                         const t = this._bindings;
                         for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                     }
                     unbind() {
                         const t = this._bindings;
                         for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                     }
-                }, bh.prototype.BindingType = {
+                }, Bu.prototype.BindingType = {
                     Direct: 0,
                     EntireArray: 1,
                     ArrayElement: 2,
                     HasFromToArray: 3
-                }, bh.prototype.Versioning = {
+                }, Bu.prototype.Versioning = {
                     None: 0,
                     NeedsUpdate: 1,
                     MatrixWorldNeedsUpdate: 2
-                }, bh.prototype.GetterByBindingType = [bh.prototype._getValue_direct, bh.prototype._getValue_array, bh.prototype._getValue_arrayElement, bh.prototype._getValue_toArray], bh.prototype.SetterByBindingTypeAndVersioning = [
-                    [bh.prototype._setValue_direct, bh.prototype._setValue_direct_setNeedsUpdate, bh.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
-                    [bh.prototype._setValue_array, bh.prototype._setValue_array_setNeedsUpdate, bh.prototype._setValue_array_setMatrixWorldNeedsUpdate],
-                    [bh.prototype._setValue_arrayElement, bh.prototype._setValue_arrayElement_setNeedsUpdate, bh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
-                    [bh.prototype._setValue_fromArray, bh.prototype._setValue_fromArray_setNeedsUpdate, bh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
+                }, Bu.prototype.GetterByBindingType = [Bu.prototype._getValue_direct, Bu.prototype._getValue_array, Bu.prototype._getValue_arrayElement, Bu.prototype._getValue_toArray], Bu.prototype.SetterByBindingTypeAndVersioning = [
+                    [Bu.prototype._setValue_direct, Bu.prototype._setValue_direct_setNeedsUpdate, Bu.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
+                    [Bu.prototype._setValue_array, Bu.prototype._setValue_array_setNeedsUpdate, Bu.prototype._setValue_array_setMatrixWorldNeedsUpdate],
+                    [Bu.prototype._setValue_arrayElement, Bu.prototype._setValue_arrayElement_setNeedsUpdate, Bu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
+                    [Bu.prototype._setValue_fromArray, Bu.prototype._setValue_fromArray_setNeedsUpdate, Bu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                 ];
-                class wh {
+                class Fu {
                     constructor() {
-                        this.uuid = yt(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
+                        this.uuid = Le(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                         const t = {};
                         this._indicesByUUID = t;
                         for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                         this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                         const e = this;
                         this.stats = {
                             objects: {
@@ -14086,25 +14378,25 @@
                             l = this.nCachedObjects_;
                         for (let c = 0, h = arguments.length; c !== h; ++c) {
                             const h = arguments[c],
                                 u = h.uuid;
                             let d = e[u];
                             if (void 0 === d) {
                                 d = o++, e[u] = d, t.push(h);
-                                for (let t = 0, e = s; t !== e; ++t) r[t].push(new bh(h, n[t], i[t]))
+                                for (let t = 0, e = s; t !== e; ++t) r[t].push(new Bu(h, n[t], i[t]))
                             } else if (d < l) {
                                 a = t[d];
                                 const o = --l,
                                     c = t[o];
                                 e[c.uuid] = d, t[d] = c, e[u] = o, t[o] = h;
                                 for (let t = 0, e = s; t !== e; ++t) {
                                     const e = r[t],
                                         s = e[o];
                                     let a = e[d];
-                                    e[d] = s, void 0 === a && (a = new bh(h, n[t], i[t])), e[o] = a
+                                    e[d] = s, void 0 === a && (a = new Bu(h, n[t], i[t])), e[o] = a
                                 }
                             } else t[d] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                         }
                         this.nCachedObjects_ = l
                     }
                     remove() {
                         const t = this._objects,
@@ -14175,15 +14467,15 @@
                             o = this._objects,
                             l = o.length,
                             c = this.nCachedObjects_,
                             h = new Array(l);
                         i = r.length, n[t] = i, s.push(t), a.push(e), r.push(h);
                         for (let n = c, i = o.length; n !== i; ++n) {
                             const i = o[n];
-                            h[n] = new bh(i, t, e)
+                            h[n] = new Bu(i, t, e)
                         }
                         return h
                     }
                     unsubscribe_(t) {
                         const e = this._bindingsIndicesByPath,
                             n = e[t];
                         if (void 0 !== n) {
@@ -14192,24 +14484,24 @@
                                 s = this._bindings,
                                 a = s.length - 1,
                                 o = s[a];
                             e[t[a]] = n, s[n] = o, s.pop(), r[n] = r[a], r.pop(), i[n] = i[a], i.pop()
                         }
                     }
                 }
-                wh.prototype.isAnimationObjectGroup = !0;
-                class Sh {
+                Fu.prototype.isAnimationObjectGroup = !0;
+                class zu {
                     constructor(t, e, n = null, i = e.blendMode) {
                         this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                         const r = e.tracks,
                             s = r.length,
                             a = new Array(s),
                             o = {
-                                endingStart: it,
-                                endingEnd: it
+                                endingStart: he,
+                                endingEnd: he
                             };
                         for (let t = 0; t !== s; ++t) {
                             const e = r[t].createInterpolant(null);
                             a[t] = e, e.settings = o
                         }
                         this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                     }
@@ -14311,15 +14603,15 @@
                         }
                         e *= this._updateTimeScale(t);
                         const s = this._updateTime(e),
                             a = this._updateWeight(t);
                         if (a > 0) {
                             const t = this._interpolants,
                                 e = this._propertyBindings;
-                            if (this.blendMode === at)
+                            if (this.blendMode === pe)
                                 for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulateAdditive(a);
                             else
                                 for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, a)
                         }
                     }
                     _updateWeight(t) {
                         let e = 0;
@@ -14392,27 +14684,27 @@
                             } else this.time = i;
                             if (s && 1 == (1 & r)) return e - i
                         }
                         return i
                     }
                     _setEndings(t, e, n) {
                         const i = this._interpolantSettings;
-                        n ? (i.endingStart = rt, i.endingEnd = rt) : (i.endingStart = t ? this.zeroSlopeAtStart ? rt : it : st, i.endingEnd = e ? this.zeroSlopeAtEnd ? rt : it : st)
+                        n ? (i.endingStart = ue, i.endingEnd = ue) : (i.endingStart = t ? this.zeroSlopeAtStart ? ue : he : de, i.endingEnd = e ? this.zeroSlopeAtEnd ? ue : he : de)
                     }
                     _scheduleFading(t, e, n) {
                         const i = this._mixer,
                             r = i.time;
                         let s = this._weightInterpolant;
                         null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                         const a = s.parameterPositions,
                             o = s.sampleValues;
                         return a[0] = r, o[0] = e, a[1] = r + t, o[1] = n, this
                     }
                 }
-                class Eh extends mt {
+                class Hu extends Se {
                     constructor(t) {
                         super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                     }
                     _bindAction(t, e) {
                         const n = t._localRoot || this._root,
                             i = t._clip.tracks,
                             r = i.length,
@@ -14429,15 +14721,15 @@
                             if (void 0 !== h) ++h.referenceCount, s[t] = h;
                             else {
                                 if (h = s[t], void 0 !== h) {
                                     null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l));
                                     continue
                                 }
                                 const i = e && e._propertyBindings[t].binding.parsedPath;
-                                h = new dh(bh.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), s[t] = h
+                                h = new Tu(Bu.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), s[t] = h
                             }
                             a[t].resultBuffer = h.buffer
                         }
                     }
                     _activateAction(t) {
                         if (!this._isActiveAction(t)) {
                             if (null === t._cacheIndex) {
@@ -14577,43 +14869,43 @@
                             r = e[i];
                         t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                     }
                     _lendControlInterpolant() {
                         const t = this._controlInterpolants,
                             e = this._nActiveControlInterpolants++;
                         let n = t[e];
-                        return void 0 === n && (n = new Kl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
+                        return void 0 === n && (n = new uh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                     }
                     _takeBackControlInterpolant(t) {
                         const e = this._controlInterpolants,
                             n = t.__cacheIndex,
                             i = --this._nActiveControlInterpolants,
                             r = e[i];
                         t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                     }
                     clipAction(t, e, n) {
                         const i = e || this._root,
                             r = i.uuid;
-                        let s = "string" == typeof t ? oc.findByName(i, t) : t;
+                        let s = "string" == typeof t ? Mh.findByName(i, t) : t;
                         const a = null !== s ? s.uuid : t,
                             o = this._actionsByClip[a];
                         let l = null;
                         if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o) {
                             const t = o.actionByRoot[r];
                             if (void 0 !== t && t.blendMode === n) return t;
                             l = o.knownActions[0], null === s && (s = l._clip)
                         }
                         if (null === s) return null;
-                        const c = new Sh(this, s, e, n);
+                        const c = new zu(this, s, e, n);
                         return this._bindAction(c, l), this._addInactiveAction(c, a, r), c
                     }
                     existingAction(t, e) {
                         const n = e || this._root,
                             i = n.uuid,
-                            r = "string" == typeof t ? oc.findByName(n, t) : t,
+                            r = "string" == typeof t ? Mh.findByName(n, t) : t,
                             s = r ? r.uuid : t,
                             a = this._actionsByClip[s];
                         return void 0 !== a && a.actionByRoot[i] || null
                     }
                     stopAllAction() {
                         const t = this._actions;
                         for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
@@ -14672,24 +14964,24 @@
                             }
                     }
                     uncacheAction(t, e) {
                         const n = this.existingAction(t, e);
                         null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                     }
                 }
-                Eh.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
-                class Th {
+                Hu.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
+                class Gu {
                     constructor(t) {
                         "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                     }
                     clone() {
-                        return new Th(void 0 === this.value.clone ? this.value : this.value.clone())
+                        return new Gu(void 0 === this.value.clone ? this.value : this.value.clone())
                     }
                 }
-                class Ah extends ca {
+                class Vu extends So {
                     constructor(t, e, n = 1) {
                         super(t, e), this.meshPerAttribute = n
                     }
                     copy(t) {
                         return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                     }
                     clone(t) {
@@ -14697,16 +14989,16 @@
                         return e.meshPerAttribute = this.meshPerAttribute, e
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                     }
                 }
-                Ah.prototype.isInstancedInterleavedBuffer = !0;
-                class Rh {
+                Vu.prototype.isInstancedInterleavedBuffer = !0;
+                class ku {
                     constructor(t, e, n, i, r) {
                         this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0
                     }
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                     setBuffer(t) {
@@ -14719,40 +15011,40 @@
                         return this.itemSize = t, this
                     }
                     setCount(t) {
                         return this.count = t, this
                     }
                 }
 
-                function Lh(t, e) {
+                function Wu(t, e) {
                     return t.distance - e.distance
                 }
 
-                function Ch(t, e, n, i) {
+                function ju(t, e, n, i) {
                     if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
                         const i = t.children;
-                        for (let t = 0, r = i.length; t < r; t++) Ch(i[t], e, n, !0)
+                        for (let t = 0, r = i.length; t < r; t++) ju(i[t], e, n, !0)
                     }
                 }
-                Rh.prototype.isGLBufferAttribute = !0;
-                const Ph = new At;
-                class Dh {
-                    constructor(t = new At(1 / 0, 1 / 0), e = new At(-1 / 0, -1 / 0)) {
+                ku.prototype.isGLBufferAttribute = !0;
+                const Xu = new Be;
+                class qu {
+                    constructor(t = new Be(1 / 0, 1 / 0), e = new Be(-1 / 0, -1 / 0)) {
                         this.min = t, this.max = e
                     }
                     set(t, e) {
                         return this.min.copy(t), this.max.copy(e), this
                     }
                     setFromPoints(t) {
                         this.makeEmpty();
                         for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                         return this
                     }
                     setFromCenterAndSize(t, e) {
-                        const n = Ph.copy(e).multiplyScalar(.5);
+                        const n = Xu.copy(e).multiplyScalar(.5);
                         return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     copy(t) {
                         return this.min.copy(t.min), this.max.copy(t.max), this
@@ -14790,34 +15082,34 @@
                     intersectsBox(t) {
                         return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                     }
                     clampPoint(t, e) {
                         return e.copy(t).clamp(this.min, this.max)
                     }
                     distanceToPoint(t) {
-                        return Ph.copy(t).clamp(this.min, this.max).sub(t).length()
+                        return Xu.copy(t).clamp(this.min, this.max).sub(t).length()
                     }
                     intersect(t) {
                         return this.min.max(t.min), this.max.min(t.max), this
                     }
                     union(t) {
                         return this.min.min(t.min), this.max.max(t.max), this
                     }
                     translate(t) {
                         return this.min.add(t), this.max.add(t), this
                     }
                     equals(t) {
                         return t.min.equals(this.min) && t.max.equals(this.max)
                     }
                 }
-                Dh.prototype.isBox2 = !0;
-                const Ih = new Zt,
-                    Nh = new Zt;
-                class Oh {
-                    constructor(t = new Zt, e = new Zt) {
+                qu.prototype.isBox2 = !0;
+                const Yu = new on,
+                    Ju = new on;
+                class Zu {
+                    constructor(t = new on, e = new on) {
                         this.start = t, this.end = e
                     }
                     set(t, e) {
                         return this.start.copy(t), this.end.copy(e), this
                     }
                     copy(t) {
                         return this.start.copy(t.start), this.end.copy(t.end), this
@@ -14834,18 +15126,18 @@
                     distance() {
                         return this.start.distanceTo(this.end)
                     }
                     at(t, e) {
                         return this.delta(e).multiplyScalar(t).add(this.start)
                     }
                     closestPointToPointParameter(t, e) {
-                        Ih.subVectors(t, this.start), Nh.subVectors(this.end, this.start);
-                        const n = Nh.dot(Nh);
-                        let i = Nh.dot(Ih) / n;
-                        return e && (i = _t(i, 0, 1)), i
+                        Yu.subVectors(t, this.start), Ju.subVectors(this.end, this.start);
+                        const n = Ju.dot(Ju);
+                        let i = Ju.dot(Yu) / n;
+                        return e && (i = Ce(i, 0, 1)), i
                     }
                     closestPointToPoint(t, e, n) {
                         const i = this.closestPointToPointParameter(t, e);
                         return this.delta(n).multiplyScalar(i).add(this.start)
                     }
                     applyMatrix4(t) {
                         return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
@@ -14853,304 +15145,304 @@
                     equals(t) {
                         return t.start.equals(this.start) && t.end.equals(this.end)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                const Uh = new Zt,
-                    Bh = new Zt,
-                    Fh = new Ae,
-                    zh = new Ae;
-                class Hh extends io {
+                const Ku = new on,
+                    Qu = new on,
+                    $u = new Fn,
+                    td = new Fn;
+                class ed extends xl {
                     constructor(t) {
-                        const e = Gh(t),
-                            n = new Nn,
+                        const e = nd(t),
+                            n = new Wi,
                             i = [],
                             r = [],
-                            s = new zt(0, 0, 1),
-                            a = new zt(0, 1, 0);
+                            s = new Je(0, 0, 1),
+                            a = new Je(0, 1, 0);
                         for (let t = 0; t < e.length; t++) {
                             const n = e[t];
                             n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
                         }
-                        n.setAttribute("position", new En(i, 3)), n.setAttribute("color", new En(r, 3)), super(n, new Ya({
+                        n.setAttribute("position", new Oi(i, 3)), n.setAttribute("color", new Oi(r, 3)), super(n, new cl({
                             vertexColors: !0,
                             depthTest: !1,
                             depthWrite: !1,
                             toneMapped: !1,
                             transparent: !0
                         })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                     }
                     updateMatrixWorld(t) {
                         const e = this.bones,
                             n = this.geometry,
                             i = n.getAttribute("position");
-                        zh.copy(this.root.matrixWorld).invert();
+                        td.copy(this.root.matrixWorld).invert();
                         for (let t = 0, n = 0; t < e.length; t++) {
                             const r = e[t];
-                            r.parent && r.parent.isBone && (Fh.multiplyMatrices(zh, r.matrixWorld), Bh.setFromMatrixPosition(Fh), i.setXYZ(n, Bh.x, Bh.y, Bh.z), Fh.multiplyMatrices(zh, r.parent.matrixWorld), Bh.setFromMatrixPosition(Fh), i.setXYZ(n + 1, Bh.x, Bh.y, Bh.z), n += 2)
+                            r.parent && r.parent.isBone && ($u.multiplyMatrices(td, r.matrixWorld), Qu.setFromMatrixPosition($u), i.setXYZ(n, Qu.x, Qu.y, Qu.z), $u.multiplyMatrices(td, r.parent.matrixWorld), Qu.setFromMatrixPosition($u), i.setXYZ(n + 1, Qu.x, Qu.y, Qu.z), n += 2)
                         }
                         n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                     }
                 }
 
-                function Gh(t) {
+                function nd(t) {
                     const e = [];
                     t && t.isBone && e.push(t);
-                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, Gh(t.children[n]));
+                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, nd(t.children[n]));
                     return e
                 }
-                const Vh = new Zt,
-                    kh = new zt,
-                    Wh = new zt;
-                class jh extends io {
+                const id = new on,
+                    rd = new Je,
+                    sd = new Je;
+                class ad extends xl {
                     constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
-                        n = new zt(n), i = new zt(i);
+                        n = new Je(n), i = new Je(i);
                         const r = e / 2,
                             s = t / e,
                             a = t / 2,
                             o = [],
                             l = [];
                         for (let t = 0, c = 0, h = -a; t <= e; t++, h += s) {
                             o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
                             const e = t === r ? n : i;
                             e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3
                         }
-                        const c = new Nn;
-                        c.setAttribute("position", new En(o, 3)), c.setAttribute("color", new En(l, 3)), super(c, new Ya({
+                        const c = new Wi;
+                        c.setAttribute("position", new Oi(o, 3)), c.setAttribute("color", new Oi(l, 3)), super(c, new cl({
                             vertexColors: !0,
                             toneMapped: !1
                         })), this.type = "GridHelper"
                     }
                 }
-                const Xh = new Zt,
-                    qh = new Zt,
-                    Yh = new Zt,
-                    Jh = new Zt,
-                    Zh = new si;
+                const od = new on,
+                    ld = new on,
+                    cd = new on,
+                    hd = new on,
+                    ud = new fr;
 
-                function Kh(t, e, n, i, r, s, a) {
-                    Jh.set(r, s, a).unproject(i);
+                function dd(t, e, n, i, r, s, a) {
+                    hd.set(r, s, a).unproject(i);
                     const o = e[t];
                     if (void 0 !== o) {
                         const t = n.getAttribute("position");
-                        for (let e = 0, n = o.length; e < n; e++) t.setXYZ(o[e], Jh.x, Jh.y, Jh.z)
+                        for (let e = 0, n = o.length; e < n; e++) t.setXYZ(o[e], hd.x, hd.y, hd.z)
                     }
                 }
-                const Qh = new $t;
-                class $h extends io {
+                const pd = new hn;
+                class md extends xl {
                     constructor(t, e = 16776960) {
                         const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                             i = new Float32Array(24),
-                            r = new Nn;
-                        r.setIndex(new gn(n, 1)), r.setAttribute("position", new gn(i, 3)), super(r, new Ya({
+                            r = new Wi;
+                        r.setIndex(new Ti(n, 1)), r.setAttribute("position", new Ti(i, 3)), super(r, new cl({
                             color: e,
                             toneMapped: !1
                         })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                     }
                     update(t) {
-                        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Qh.setFromObject(this.object), Qh.isEmpty()) return;
-                        const e = Qh.min,
-                            n = Qh.max,
+                        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && pd.setFromObject(this.object), pd.isEmpty()) return;
+                        const e = pd.min,
+                            n = pd.max,
                             i = this.geometry.attributes.position,
                             r = i.array;
                         r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                     }
                     setFromObject(t) {
                         return this.object = t, this.update(), this
                     }
                     copy(t) {
-                        return io.prototype.copy.call(this, t), this.object = t.object, this
+                        return xl.prototype.copy.call(this, t), this.object = t.object, this
                     }
                 }
-                const tu = new Zt;
-                let eu, nu;
-                class iu extends io {
+                const fd = new on;
+                let gd, vd;
+                class xd extends xl {
                     constructor(t = 1) {
                         const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
-                            n = new Nn;
-                        n.setAttribute("position", new En(e, 3)), n.setAttribute("color", new En([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new Ya({
+                            n = new Wi;
+                        n.setAttribute("position", new Oi(e, 3)), n.setAttribute("color", new Oi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new cl({
                             vertexColors: !0,
                             toneMapped: !1
                         })), this.type = "AxesHelper"
                     }
                     setColors(t, e, n) {
-                        const i = new zt,
+                        const i = new Je,
                             r = this.geometry.attributes.color.array;
                         return i.set(t), i.toArray(r, 0), i.toArray(r, 3), i.set(e), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this
                     }
                     dispose() {
                         this.geometry.dispose(), this.material.dispose()
                     }
                 }
-                const ru = new Float32Array(1),
-                    su = new Int32Array(ru.buffer);
-                Ao.create = function(t, e) {
-                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ao.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
-                }, Yo.prototype.fromPoints = function(t) {
+                const yd = new Float32Array(1),
+                    _d = new Int32Array(yd.buffer);
+                Gl.create = function(t, e) {
+                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Gl.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
+                }, lc.prototype.fromPoints = function(t) {
                     return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
-                }, jh.prototype.setColors = function() {
+                }, ad.prototype.setColors = function() {
                     console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
-                }, Hh.prototype.update = function() {
+                }, ed.prototype.update = function() {
                     console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
-                }, dc.prototype.extractUrlBase = function(t) {
-                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), zc.extractUrlBase(t)
-                }, dc.Handlers = {
+                }, Th.prototype.extractUrlBase = function(t) {
+                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), $h.extractUrlBase(t)
+                }, Th.Handlers = {
                     add: function() {
                         console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                     },
                     get: function() {
                         console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                     }
-                }, Dh.prototype.center = function(t) {
+                }, qu.prototype.center = function(t) {
                     return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
-                }, Dh.prototype.empty = function() {
+                }, qu.prototype.empty = function() {
                     return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, Dh.prototype.isIntersectionBox = function(t) {
+                }, qu.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, Dh.prototype.size = function(t) {
+                }, qu.prototype.size = function(t) {
                     return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
-                }, $t.prototype.center = function(t) {
+                }, hn.prototype.center = function(t) {
                     return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
-                }, $t.prototype.empty = function() {
+                }, hn.prototype.empty = function() {
                     return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, $t.prototype.isIntersectionBox = function(t) {
+                }, hn.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, $t.prototype.isIntersectionSphere = function(t) {
+                }, hn.prototype.isIntersectionSphere = function(t) {
                     return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
-                }, $t.prototype.size = function(t) {
+                }, hn.prototype.size = function(t) {
                     return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
-                }, xe.prototype.empty = function() {
+                }, Ln.prototype.empty = function() {
                     return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, vi.prototype.setFromMatrix = function(t) {
+                }, Ar.prototype.setFromMatrix = function(t) {
                     return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
-                }, Oh.prototype.center = function(t) {
+                }, Zu.prototype.center = function(t) {
                     return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
-                }, Rt.prototype.flattenToArrayOffset = function(t, e) {
+                }, Fe.prototype.flattenToArrayOffset = function(t, e) {
                     return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
-                }, Rt.prototype.multiplyVector3 = function(t) {
+                }, Fe.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
-                }, Rt.prototype.multiplyVector3Array = function() {
+                }, Fe.prototype.multiplyVector3Array = function() {
                     console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
-                }, Rt.prototype.applyToBufferAttribute = function(t) {
+                }, Fe.prototype.applyToBufferAttribute = function(t) {
                     return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
-                }, Rt.prototype.applyToVector3Array = function() {
+                }, Fe.prototype.applyToVector3Array = function() {
                     console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
-                }, Rt.prototype.getInverse = function(t) {
+                }, Fe.prototype.getInverse = function(t) {
                     return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
-                }, Ae.prototype.extractPosition = function(t) {
+                }, Fn.prototype.extractPosition = function(t) {
                     return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
-                }, Ae.prototype.flattenToArrayOffset = function(t, e) {
+                }, Fn.prototype.flattenToArrayOffset = function(t, e) {
                     return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
-                }, Ae.prototype.getPosition = function() {
-                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Zt).setFromMatrixColumn(this, 3)
-                }, Ae.prototype.setRotationFromQuaternion = function(t) {
+                }, Fn.prototype.getPosition = function() {
+                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new on).setFromMatrixColumn(this, 3)
+                }, Fn.prototype.setRotationFromQuaternion = function(t) {
                     return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
-                }, Ae.prototype.multiplyToArray = function() {
+                }, Fn.prototype.multiplyToArray = function() {
                     console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
-                }, Ae.prototype.multiplyVector3 = function(t) {
+                }, Fn.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, Ae.prototype.multiplyVector4 = function(t) {
+                }, Fn.prototype.multiplyVector4 = function(t) {
                     return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, Ae.prototype.multiplyVector3Array = function() {
+                }, Fn.prototype.multiplyVector3Array = function() {
                     console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
-                }, Ae.prototype.rotateAxis = function(t) {
+                }, Fn.prototype.rotateAxis = function(t) {
                     console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
-                }, Ae.prototype.crossVector = function(t) {
+                }, Fn.prototype.crossVector = function(t) {
                     return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, Ae.prototype.translate = function() {
+                }, Fn.prototype.translate = function() {
                     console.error("THREE.Matrix4: .translate() has been removed.")
-                }, Ae.prototype.rotateX = function() {
+                }, Fn.prototype.rotateX = function() {
                     console.error("THREE.Matrix4: .rotateX() has been removed.")
-                }, Ae.prototype.rotateY = function() {
+                }, Fn.prototype.rotateY = function() {
                     console.error("THREE.Matrix4: .rotateY() has been removed.")
-                }, Ae.prototype.rotateZ = function() {
+                }, Fn.prototype.rotateZ = function() {
                     console.error("THREE.Matrix4: .rotateZ() has been removed.")
-                }, Ae.prototype.rotateByAxis = function() {
+                }, Fn.prototype.rotateByAxis = function() {
                     console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
-                }, Ae.prototype.applyToBufferAttribute = function(t) {
+                }, Fn.prototype.applyToBufferAttribute = function(t) {
                     return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, Ae.prototype.applyToVector3Array = function() {
+                }, Fn.prototype.applyToVector3Array = function() {
                     console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
-                }, Ae.prototype.makeFrustum = function(t, e, n, i, r, s) {
+                }, Fn.prototype.makeFrustum = function(t, e, n, i, r, s) {
                     return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, s)
-                }, Ae.prototype.getInverse = function(t) {
+                }, Fn.prototype.getInverse = function(t) {
                     return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
-                }, mi.prototype.isIntersectionLine = function(t) {
+                }, Sr.prototype.isIntersectionLine = function(t) {
                     return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
-                }, Jt.prototype.multiplyVector3 = function(t) {
+                }, an.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
-                }, Jt.prototype.inverse = function() {
+                }, an.prototype.inverse = function() {
                     return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
-                }, Te.prototype.isIntersectionBox = function(t) {
+                }, Bn.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, Te.prototype.isIntersectionPlane = function(t) {
+                }, Bn.prototype.isIntersectionPlane = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
-                }, Te.prototype.isIntersectionSphere = function(t) {
+                }, Bn.prototype.isIntersectionSphere = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
-                }, hn.prototype.area = function() {
+                }, _i.prototype.area = function() {
                     return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
-                }, hn.prototype.barycoordFromPoint = function(t, e) {
+                }, _i.prototype.barycoordFromPoint = function(t, e) {
                     return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
-                }, hn.prototype.midpoint = function(t) {
+                }, _i.prototype.midpoint = function(t) {
                     return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
-                }, hn.prototypenormal = function(t) {
+                }, _i.prototypenormal = function(t) {
                     return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
-                }, hn.prototype.plane = function(t) {
+                }, _i.prototype.plane = function(t) {
                     return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
-                }, hn.barycoordFromPoint = function(t, e, n, i, r) {
-                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), hn.getBarycoord(t, e, n, i, r)
-                }, hn.normal = function(t, e, n, i) {
-                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), hn.getNormal(t, e, n, i)
-                }, Jo.prototype.extractAllPoints = function(t) {
+                }, _i.barycoordFromPoint = function(t, e, n, i, r) {
+                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), _i.getBarycoord(t, e, n, i, r)
+                }, _i.normal = function(t, e, n, i) {
+                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), _i.getNormal(t, e, n, i)
+                }, cc.prototype.extractAllPoints = function(t) {
                     return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
-                }, Jo.prototype.extrude = function(t) {
-                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new wl(this, t)
-                }, Jo.prototype.makeGeometry = function(t) {
-                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ll(this, t)
-                }, At.prototype.fromAttribute = function(t, e, n) {
+                }, cc.prototype.extrude = function(t) {
+                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Bc(this, t)
+                }, cc.prototype.makeGeometry = function(t) {
+                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new kc(this, t)
+                }, Be.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, At.prototype.distanceToManhattan = function(t) {
+                }, Be.prototype.distanceToManhattan = function(t) {
                     return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
-                }, At.prototype.lengthManhattan = function() {
+                }, Be.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, Zt.prototype.setEulerFromRotationMatrix = function() {
+                }, on.prototype.setEulerFromRotationMatrix = function() {
                     console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
-                }, Zt.prototype.setEulerFromQuaternion = function() {
+                }, on.prototype.setEulerFromQuaternion = function() {
                     console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
-                }, Zt.prototype.getPositionFromMatrix = function(t) {
+                }, on.prototype.getPositionFromMatrix = function(t) {
                     return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
-                }, Zt.prototype.getScaleFromMatrix = function(t) {
+                }, on.prototype.getScaleFromMatrix = function(t) {
                     return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
-                }, Zt.prototype.getColumnFromMatrix = function(t, e) {
+                }, on.prototype.getColumnFromMatrix = function(t, e) {
                     return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
-                }, Zt.prototype.applyProjection = function(t) {
+                }, on.prototype.applyProjection = function(t) {
                     return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
-                }, Zt.prototype.fromAttribute = function(t, e, n) {
+                }, on.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, Zt.prototype.distanceToManhattan = function(t) {
+                }, on.prototype.distanceToManhattan = function(t) {
                     return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
-                }, Zt.prototype.lengthManhattan = function() {
+                }, on.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, jt.prototype.fromAttribute = function(t, e, n) {
+                }, en.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, jt.prototype.lengthManhattan = function() {
+                }, en.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, Qe.prototype.getChildByName = function(t) {
+                }, ci.prototype.getChildByName = function(t) {
                     return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
-                }, Qe.prototype.renderDepth = function() {
+                }, ci.prototype.renderDepth = function() {
                     console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
-                }, Qe.prototype.translate = function(t, e) {
+                }, ci.prototype.translate = function(t, e) {
                     return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
-                }, Qe.prototype.getWorldRotation = function() {
+                }, ci.prototype.getWorldRotation = function() {
                     console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
-                }, Qe.prototype.applyMatrix = function(t) {
+                }, ci.prototype.applyMatrix = function(t) {
                     return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
-                }, Object.defineProperties(Qe.prototype, {
+                }, Object.defineProperties(ci.prototype, {
                     eulerOrder: {
                         get: function() {
                             return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                         },
                         set: function(t) {
                             console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                         }
@@ -15159,30 +15451,30 @@
                         get: function() {
                             console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                         },
                         set: function() {
                             console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                         }
                     }
-                }), Qn.prototype.setDrawMode = function() {
+                }), lr.prototype.setDrawMode = function() {
                     console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
-                }, Object.defineProperties(Qn.prototype, {
+                }, Object.defineProperties(lr.prototype, {
                     drawMode: {
                         get: function() {
                             return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                         },
                         set: function() {
                             console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                         }
                     }
-                }), Ua.prototype.initBones = function() {
+                }), Ko.prototype.initBones = function() {
                     console.error("THREE.SkinnedMesh: initBones() has been removed.")
-                }, ai.prototype.setLens = function(t, e) {
+                }, gr.prototype.setLens = function(t, e) {
                     console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
-                }, Object.defineProperties(yc.prototype, {
+                }, Object.defineProperties(Ih.prototype, {
                     onlyShadow: {
                         set: function() {
                             console.warn("THREE.Light: .onlyShadow has been removed.")
                         }
                     },
                     shadowCameraFov: {
                         set: function(t) {
@@ -15240,74 +15532,74 @@
                         }
                     },
                     shadowMapHeight: {
                         set: function(t) {
                             console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                         }
                     }
-                }), Object.defineProperties(gn.prototype, {
+                }), Object.defineProperties(Ti.prototype, {
                     length: {
                         get: function() {
                             return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                         }
                     },
                     dynamic: {
                         get: function() {
-                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === ut
+                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Me
                         },
                         set: function() {
-                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(ut)
+                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Me)
                         }
                     }
-                }), gn.prototype.setDynamic = function(t) {
-                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? ut : ht), this
-                }, gn.prototype.copyIndicesArray = function() {
+                }), Ti.prototype.setDynamic = function(t) {
+                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Me : _e), this
+                }, Ti.prototype.copyIndicesArray = function() {
                     console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
-                }, gn.prototype.setArray = function() {
+                }, Ti.prototype.setArray = function() {
                     console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
-                }, Nn.prototype.addIndex = function(t) {
+                }, Wi.prototype.addIndex = function(t) {
                     console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
-                }, Nn.prototype.addAttribute = function(t, e) {
-                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new gn(arguments[1], arguments[2])))
-                }, Nn.prototype.addDrawCall = function(t, e, n) {
+                }, Wi.prototype.addAttribute = function(t, e) {
+                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Ti(arguments[1], arguments[2])))
+                }, Wi.prototype.addDrawCall = function(t, e, n) {
                     void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
-                }, Nn.prototype.clearDrawCalls = function() {
+                }, Wi.prototype.clearDrawCalls = function() {
                     console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
-                }, Nn.prototype.computeOffsets = function() {
+                }, Wi.prototype.computeOffsets = function() {
                     console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
-                }, Nn.prototype.removeAttribute = function(t) {
+                }, Wi.prototype.removeAttribute = function(t) {
                     return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
-                }, Nn.prototype.applyMatrix = function(t) {
+                }, Wi.prototype.applyMatrix = function(t) {
                     return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
-                }, Object.defineProperties(Nn.prototype, {
+                }, Object.defineProperties(Wi.prototype, {
                     drawcalls: {
                         get: function() {
                             return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                         }
                     },
                     offsets: {
                         get: function() {
                             return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                         }
                     }
-                }), ca.prototype.setDynamic = function(t) {
-                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? ut : ht), this
-                }, ca.prototype.setArray = function() {
+                }), So.prototype.setDynamic = function(t) {
+                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Me : _e), this
+                }, So.prototype.setArray = function() {
                     console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
-                }, wl.prototype.getArrays = function() {
+                }, Bc.prototype.getArrays = function() {
                     console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
-                }, wl.prototype.addShapeList = function() {
+                }, Bc.prototype.addShapeList = function() {
                     console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
-                }, wl.prototype.addShape = function() {
+                }, Bc.prototype.addShape = function() {
                     console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
-                }, la.prototype.dispose = function() {
+                }, wo.prototype.dispose = function() {
                     console.error("THREE.Scene: .dispose() has been removed.")
-                }, Th.prototype.onUpdate = function() {
+                }, Gu.prototype.onUpdate = function() {
                     return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
-                }, Object.defineProperties(dn.prototype, {
+                }, Object.defineProperties(bi.prototype, {
                     wrapAround: {
                         get: function() {
                             console.warn("THREE.Material: .wrapAround has been removed.")
                         },
                         set: function() {
                             console.warn("THREE.Material: .wrapAround has been removed.")
                         }
@@ -15318,15 +15610,15 @@
                         },
                         set: function() {
                             console.warn("THREE.Material: .overdraw has been removed.")
                         }
                     },
                     wrapRGB: {
                         get: function() {
-                            return console.warn("THREE.Material: .wrapRGB has been removed."), new zt
+                            return console.warn("THREE.Material: .wrapRGB has been removed."), new Je
                         }
                     },
                     shading: {
                         get: function() {
                             console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                         },
                         set: function(t) {
@@ -15345,74 +15637,74 @@
                         get: function() {
                             console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                         },
                         set: function() {
                             console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                         }
                     }
-                }), Object.defineProperties(ri.prototype, {
+                }), Object.defineProperties(mr.prototype, {
                     derivatives: {
                         get: function() {
                             return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                         },
                         set: function(t) {
                             console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                         }
                     }
-                }), ra.prototype.clearTarget = function(t, e, n, i) {
+                }), yo.prototype.clearTarget = function(t, e, n, i) {
                     console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
-                }, ra.prototype.animate = function(t) {
+                }, yo.prototype.animate = function(t) {
                     console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
-                }, ra.prototype.getCurrentRenderTarget = function() {
+                }, yo.prototype.getCurrentRenderTarget = function() {
                     return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
-                }, ra.prototype.getMaxAnisotropy = function() {
+                }, yo.prototype.getMaxAnisotropy = function() {
                     return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
-                }, ra.prototype.getPrecision = function() {
+                }, yo.prototype.getPrecision = function() {
                     return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
-                }, ra.prototype.resetGLState = function() {
+                }, yo.prototype.resetGLState = function() {
                     return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
-                }, ra.prototype.supportsFloatTextures = function() {
+                }, yo.prototype.supportsFloatTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
-                }, ra.prototype.supportsHalfFloatTextures = function() {
+                }, yo.prototype.supportsHalfFloatTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
-                }, ra.prototype.supportsStandardDerivatives = function() {
+                }, yo.prototype.supportsStandardDerivatives = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
-                }, ra.prototype.supportsCompressedTextureS3TC = function() {
+                }, yo.prototype.supportsCompressedTextureS3TC = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
-                }, ra.prototype.supportsCompressedTexturePVRTC = function() {
+                }, yo.prototype.supportsCompressedTexturePVRTC = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
-                }, ra.prototype.supportsBlendMinMax = function() {
+                }, yo.prototype.supportsBlendMinMax = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
-                }, ra.prototype.supportsVertexTextures = function() {
+                }, yo.prototype.supportsVertexTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
-                }, ra.prototype.supportsInstancedArrays = function() {
+                }, yo.prototype.supportsInstancedArrays = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
-                }, ra.prototype.enableScissorTest = function(t) {
+                }, yo.prototype.enableScissorTest = function(t) {
                     console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
-                }, ra.prototype.initMaterial = function() {
+                }, yo.prototype.initMaterial = function() {
                     console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
-                }, ra.prototype.addPrePlugin = function() {
+                }, yo.prototype.addPrePlugin = function() {
                     console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
-                }, ra.prototype.addPostPlugin = function() {
+                }, yo.prototype.addPostPlugin = function() {
                     console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
-                }, ra.prototype.updateShadowMap = function() {
+                }, yo.prototype.updateShadowMap = function() {
                     console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
-                }, ra.prototype.setFaceCulling = function() {
+                }, yo.prototype.setFaceCulling = function() {
                     console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
-                }, ra.prototype.allocTextureUnit = function() {
+                }, yo.prototype.allocTextureUnit = function() {
                     console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
-                }, ra.prototype.setTexture = function() {
+                }, yo.prototype.setTexture = function() {
                     console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
-                }, ra.prototype.setTexture2D = function() {
+                }, yo.prototype.setTexture2D = function() {
                     console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
-                }, ra.prototype.setTextureCube = function() {
+                }, yo.prototype.setTextureCube = function() {
                     console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
-                }, ra.prototype.getActiveMipMapLevel = function() {
+                }, yo.prototype.getActiveMipMapLevel = function() {
                     return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
-                }, Object.defineProperties(ra.prototype, {
+                }, Object.defineProperties(yo.prototype, {
                     shadowMapEnabled: {
                         get: function() {
                             return this.shadowMap.enabled
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                         }
@@ -15452,15 +15744,15 @@
                         }
                     },
                     gammaOutput: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                         },
                         set: function(t) {
-                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? lt : ot
+                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? fe : me
                         }
                     },
                     toneMappingWhitePoint: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                         },
                         set: function() {
@@ -15471,15 +15763,15 @@
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                         }
                     }
-                }), Object.defineProperties(qs.prototype, {
+                }), Object.defineProperties(oo.prototype, {
                     cullFace: {
                         get: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                         }
@@ -15496,15 +15788,15 @@
                         get: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                         }
                     }
-                }), Object.defineProperties(Xt.prototype, {
+                }), Object.defineProperties(nn.prototype, {
                     wrapS: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                         }
@@ -15577,112 +15869,112 @@
                         get: function() {
                             return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                         }
                     }
-                }), ah.prototype.load = function(t) {
+                }), _u.prototype.load = function(t) {
                     console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                     const e = this;
-                    return (new Yc).load(t, (function(t) {
+                    return (new lu).load(t, (function(t) {
                         e.setBuffer(t)
                     })), this
-                }, uh.prototype.getData = function() {
+                }, Eu.prototype.getData = function() {
                     return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
-                }, li.prototype.updateCubeMap = function(t, e) {
+                }, xr.prototype.updateCubeMap = function(t, e) {
                     return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
-                }, li.prototype.clear = function(t, e, n, i) {
+                }, xr.prototype.clear = function(t, e, n, i) {
                     return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i)
-                }, Gt.crossOrigin = void 0, Gt.loadTexture = function(t, e, n, i) {
+                }, Ke.crossOrigin = void 0, Ke.loadTexture = function(t, e, n, i) {
                     console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
-                    const r = new xc;
+                    const r = new Dh;
                     r.setCrossOrigin(this.crossOrigin);
                     const s = r.load(t, n, void 0, i);
                     return e && (s.mapping = e), s
-                }, Gt.loadTextureCube = function(t, e, n, i) {
+                }, Ke.loadTextureCube = function(t, e, n, i) {
                     console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
-                    const r = new gc;
+                    const r = new Ch;
                     r.setCrossOrigin(this.crossOrigin);
                     const s = r.load(t, n, void 0, i);
                     return e && (s.mapping = e), s
-                }, Gt.loadCompressedTexture = function() {
+                }, Ke.loadCompressedTexture = function() {
                     console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
-                }, Gt.loadCompressedTextureCube = function() {
+                }, Ke.loadCompressedTextureCube = function() {
                     console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                 };
-                const au = {
+                const Md = {
                     createMultiMaterialObject: function() {
                         console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                     },
                     detach: function() {
                         console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                     },
                     attach: function() {
                         console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                     }
                 };
                 "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                     detail: {
                         revision: n
                     }
-                })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = n), e.ACESFilmicToneMapping = 4, e.AddEquation = i, e.AddOperation = 2, e.AdditiveAnimationBlendMode = at, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AlwaysStencilFunc = 519, e.AmbientLight = Nc, e.AmbientLightProbe = Zc, e.AnimationClip = oc, e.AnimationLoader = class extends dc {
+                })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = n), e.ACESFilmicToneMapping = J, e.AddEquation = x, e.AddOperation = W, e.AdditiveAnimationBlendMode = pe, e.AdditiveBlending = m, e.AlphaFormat = St, e.AlwaysDepth = O, e.AlwaysStencilFunc = 519, e.AmbientLight = Yh, e.AmbientLightProbe = hu, e.AnimationClip = Mh, e.AnimationLoader = class extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new mc(this.manager);
+                            s = new Rh(this.manager);
                         s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                             try {
                                 e(r.parse(JSON.parse(n)))
                             } catch (e) {
                                 i ? i(e) : console.error(e), r.manager.itemError(t)
                             }
                         }), n, i)
                     }
                     parse(t) {
                         const e = [];
                         for (let n = 0; n < t.length; n++) {
-                            const i = oc.parse(t[n]);
+                            const i = Mh.parse(t[n]);
                             e.push(i)
                         }
                         return e
                     }
-                }, e.AnimationMixer = Eh, e.AnimationObjectGroup = wh, e.AnimationUtils = Yl, e.ArcCurve = Lo, e.ArrayCamera = Ks, e.ArrowHelper = class extends Qe {
-                    constructor(t = new Zt(0, 0, 1), e = new Zt(0, 0, 0), n = 1, i = 16776960, r = .2 * n, s = .2 * r) {
-                        super(), this.type = "ArrowHelper", void 0 === eu && (eu = new Nn, eu.setAttribute("position", new En([0, 0, 0, 0, 1, 0], 3)), nu = new xo(0, .5, 1, 5, 1), nu.translate(0, -.5, 0)), this.position.copy(e), this.line = new to(eu, new Ya({
+                }, e.AnimationMixer = Hu, e.AnimationObjectGroup = Fu, e.AnimationUtils = lh, e.ArcCurve = kl, e.ArrayCamera = uo, e.ArrowHelper = class extends ci {
+                    constructor(t = new on(0, 0, 1), e = new on(0, 0, 0), n = 1, i = 16776960, r = .2 * n, s = .2 * r) {
+                        super(), this.type = "ArrowHelper", void 0 === gd && (gd = new Wi, gd.setAttribute("position", new Oi([0, 0, 0, 0, 1, 0], 3)), vd = new Dl(0, .5, 1, 5, 1), vd.translate(0, -.5, 0)), this.position.copy(e), this.line = new fl(gd, new cl({
                             color: i,
                             toneMapped: !1
-                        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Qn(nu, new pn({
+                        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new lr(vd, new wi({
                             color: i,
                             toneMapped: !1
                         })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, s)
                     }
                     setDirection(t) {
                         if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
                         else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                         else {
-                            tu.set(t.z, 0, -t.x).normalize();
+                            fd.set(t.z, 0, -t.x).normalize();
                             const e = Math.acos(t.y);
-                            this.quaternion.setFromAxisAngle(tu, e)
+                            this.quaternion.setFromAxisAngle(fd, e)
                         }
                     }
                     setLength(t, e = .2 * t, n = .2 * e) {
                         this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
                     }
                     setColor(t) {
                         this.line.material.color.set(t), this.cone.material.color.set(t)
                     }
                     copy(t) {
                         return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
                     }
-                }, e.Audio = ah, e.AudioAnalyser = uh, e.AudioContext = qc, e.AudioListener = class extends Qe {
+                }, e.Audio = _u, e.AudioAnalyser = Eu, e.AudioContext = ou, e.AudioListener = class extends ci {
                     constructor() {
-                        super(), this.type = "AudioListener", this.context = qc.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new th
+                        super(), this.type = "AudioListener", this.context = ou.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new mu
                     }
                     getInput() {
                         return this.gain
                     }
                     removeFilter() {
                         return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                     }
@@ -15698,95 +15990,95 @@
                     setMasterVolume(t) {
                         return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                     }
                     updateMatrixWorld(t) {
                         super.updateMatrixWorld(t);
                         const e = this.context.listener,
                             n = this.up;
-                        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(nh, ih, rh), sh.set(0, 0, -1).applyQuaternion(ih), e.positionX) {
+                        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(gu, vu, xu), yu.set(0, 0, -1).applyQuaternion(vu), e.positionX) {
                             const t = this.context.currentTime + this.timeDelta;
-                            e.positionX.linearRampToValueAtTime(nh.x, t), e.positionY.linearRampToValueAtTime(nh.y, t), e.positionZ.linearRampToValueAtTime(nh.z, t), e.forwardX.linearRampToValueAtTime(sh.x, t), e.forwardY.linearRampToValueAtTime(sh.y, t), e.forwardZ.linearRampToValueAtTime(sh.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
-                        } else e.setPosition(nh.x, nh.y, nh.z), e.setOrientation(sh.x, sh.y, sh.z, n.x, n.y, n.z)
+                            e.positionX.linearRampToValueAtTime(gu.x, t), e.positionY.linearRampToValueAtTime(gu.y, t), e.positionZ.linearRampToValueAtTime(gu.z, t), e.forwardX.linearRampToValueAtTime(yu.x, t), e.forwardY.linearRampToValueAtTime(yu.y, t), e.forwardZ.linearRampToValueAtTime(yu.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
+                        } else e.setPosition(gu.x, gu.y, gu.z), e.setOrientation(yu.x, yu.y, yu.z, n.x, n.y, n.z)
                     }
-                }, e.AudioLoader = Yc, e.AxesHelper = iu, e.AxisHelper = function(t) {
-                    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new iu(t)
-                }, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function(t) {
-                    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new vc(t)
-                }, e.Bone = Ba, e.BooleanKeyframeTrack = tc, e.BoundingBoxHelper = function(t, e) {
-                    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new $h(t, e)
-                }, e.Box2 = Dh, e.Box3 = $t, e.Box3Helper = class extends io {
+                }, e.AudioLoader = lu, e.AxesHelper = xd, e.AxisHelper = function(t) {
+                    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new xd(t)
+                }, e.BackSide = h, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function(t) {
+                    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ph(t)
+                }, e.Bone = Qo, e.BooleanKeyframeTrack = mh, e.BoundingBoxHelper = function(t, e) {
+                    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new md(t, e)
+                }, e.Box2 = qu, e.Box3 = hn, e.Box3Helper = class extends xl {
                     constructor(t, e = 16776960) {
                         const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
-                            i = new Nn;
-                        i.setIndex(new gn(n, 1)), i.setAttribute("position", new En([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i, new Ya({
+                            i = new Wi;
+                        i.setIndex(new Ti(n, 1)), i.setAttribute("position", new Oi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i, new cl({
                             color: e,
                             toneMapped: !1
                         })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                     }
                     updateMatrixWorld(t) {
                         const e = this.box;
                         e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t))
                     }
-                }, e.BoxBufferGeometry = ti, e.BoxGeometry = ti, e.BoxHelper = $h, e.BufferAttribute = gn, e.BufferGeometry = Nn, e.BufferGeometryLoader = Gc, e.ByteType = 1010, e.Cache = cc, e.Camera = si, e.CameraHelper = class extends io {
+                }, e.BoxBufferGeometry = hr, e.BoxGeometry = hr, e.BoxHelper = md, e.BufferAttribute = Ti, e.BufferGeometry = Wi, e.BufferGeometryLoader = eu, e.ByteType = mt, e.Cache = wh, e.Camera = fr, e.CameraHelper = class extends xl {
                     constructor(t) {
-                        const e = new Nn,
-                            n = new Ya({
+                        const e = new Wi,
+                            n = new cl({
                                 color: 16777215,
                                 vertexColors: !0,
                                 toneMapped: !1
                             }),
                             i = [],
                             r = [],
                             s = {},
-                            a = new zt(16755200),
-                            o = new zt(16711680),
-                            l = new zt(43775),
-                            c = new zt(16777215),
-                            h = new zt(3355443);
+                            a = new Je(16755200),
+                            o = new Je(16711680),
+                            l = new Je(43775),
+                            c = new Je(16777215),
+                            h = new Je(3355443);
 
                         function u(t, e, n) {
                             d(t, n), d(e, n)
                         }
 
                         function d(t, e) {
                             i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(i.length / 3 - 1)
                         }
-                        u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", o), u("p", "n2", o), u("p", "n3", o), u("p", "n4", o), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new En(i, 3)), e.setAttribute("color", new En(r, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
+                        u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", o), u("p", "n2", o), u("p", "n3", o), u("p", "n4", o), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new Oi(i, 3)), e.setAttribute("color", new Oi(r, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
                     }
                     update() {
                         const t = this.geometry,
                             e = this.pointMap;
-                        Zh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Kh("c", e, t, Zh, 0, 0, -1), Kh("t", e, t, Zh, 0, 0, 1), Kh("n1", e, t, Zh, -1, -1, -1), Kh("n2", e, t, Zh, 1, -1, -1), Kh("n3", e, t, Zh, -1, 1, -1), Kh("n4", e, t, Zh, 1, 1, -1), Kh("f1", e, t, Zh, -1, -1, 1), Kh("f2", e, t, Zh, 1, -1, 1), Kh("f3", e, t, Zh, -1, 1, 1), Kh("f4", e, t, Zh, 1, 1, 1), Kh("u1", e, t, Zh, .7, 1.1, -1), Kh("u2", e, t, Zh, -.7, 1.1, -1), Kh("u3", e, t, Zh, 0, 2, -1), Kh("cf1", e, t, Zh, -1, 0, 1), Kh("cf2", e, t, Zh, 1, 0, 1), Kh("cf3", e, t, Zh, 0, -1, 1), Kh("cf4", e, t, Zh, 0, 1, 1), Kh("cn1", e, t, Zh, -1, 0, -1), Kh("cn2", e, t, Zh, 1, 0, -1), Kh("cn3", e, t, Zh, 0, -1, -1), Kh("cn4", e, t, Zh, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
+                        ud.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), dd("c", e, t, ud, 0, 0, -1), dd("t", e, t, ud, 0, 0, 1), dd("n1", e, t, ud, -1, -1, -1), dd("n2", e, t, ud, 1, -1, -1), dd("n3", e, t, ud, -1, 1, -1), dd("n4", e, t, ud, 1, 1, -1), dd("f1", e, t, ud, -1, -1, 1), dd("f2", e, t, ud, 1, -1, 1), dd("f3", e, t, ud, -1, 1, 1), dd("f4", e, t, ud, 1, 1, 1), dd("u1", e, t, ud, .7, 1.1, -1), dd("u2", e, t, ud, -.7, 1.1, -1), dd("u3", e, t, ud, 0, 2, -1), dd("cf1", e, t, ud, -1, 0, 1), dd("cf2", e, t, ud, 1, 0, 1), dd("cf3", e, t, ud, 0, -1, 1), dd("cf4", e, t, ud, 0, 1, 1), dd("cn1", e, t, ud, -1, 0, -1), dd("cn2", e, t, ud, 1, 0, -1), dd("cn3", e, t, ud, 0, -1, -1), dd("cn4", e, t, ud, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                     }
                     dispose() {
                         this.geometry.dispose(), this.material.dispose()
                     }
                 }, e.CanvasRenderer = function() {
                     console.error("THREE.CanvasRenderer has been removed")
-                }, e.CanvasTexture = go, e.CatmullRomCurve3 = Oo, e.CineonToneMapping = 3, e.CircleBufferGeometry = vo, e.CircleGeometry = vo, e.ClampToEdgeWrapping = d, e.Clock = th, e.Color = zt, e.ColorKeyframeTrack = ec, e.CompressedTexture = fo, e.CompressedTextureLoader = class extends dc {
+                }, e.CanvasTexture = Cl, e.CatmullRomCurve3 = Jl, e.CineonToneMapping = Y, e.CircleBufferGeometry = Pl, e.CircleGeometry = Pl, e.ClampToEdgeWrapping = st, e.Clock = mu, e.Color = Je, e.ColorKeyframeTrack = fh, e.CompressedTexture = Ll, e.CompressedTextureLoader = class extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
                             s = [],
-                            a = new fo,
-                            o = new mc(this.manager);
+                            a = new Ll,
+                            o = new Rh(this.manager);
                         o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials);
                         let l = 0;
 
                         function c(c) {
                             o.load(t[c], (function(t) {
                                 const n = r.parse(t, !0);
                                 s[c] = {
                                     width: n.width,
                                     height: n.height,
                                     format: n.format,
                                     mipmaps: n.mipmaps
-                                }, l += 1, 6 === l && (1 === n.mipmapCount && (a.minFilter = v), a.image = s, a.format = n.format, a.needsUpdate = !0, e && e(a))
+                                }, l += 1, 6 === l && (1 === n.mipmapCount && (a.minFilter = ht), a.image = s, a.format = n.format, a.needsUpdate = !0, e && e(a))
                             }), n, i)
                         }
                         if (Array.isArray(t))
                             for (let e = 0, n = t.length; e < n; ++e) c(e);
                         else o.load(t, (function(t) {
                             const n = r.parse(t, !0);
                             if (n.isCubemap) {
@@ -15795,19 +16087,19 @@
                                     s[e] = {
                                         mipmaps: []
                                     };
                                     for (let t = 0; t < n.mipmapCount; t++) s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), s[e].format = n.format, s[e].width = n.width, s[e].height = n.height
                                 }
                                 a.image = s
                             } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
-                            1 === n.mipmapCount && (a.minFilter = v), a.format = n.format, a.needsUpdate = !0, e && e(a)
+                            1 === n.mipmapCount && (a.minFilter = ht), a.format = n.format, a.needsUpdate = !0, e && e(a)
                         }), n, i);
                         return a
                     }
-                }, e.ConeBufferGeometry = yo, e.ConeGeometry = yo, e.CubeCamera = li, e.CubeReflectionMapping = s, e.CubeRefractionMapping = a, e.CubeTexture = ci, e.CubeTextureLoader = gc, e.CubeUVReflectionMapping = c, e.CubeUVRefractionMapping = h, e.CubicBezierCurve = zo, e.CubicBezierCurve3 = Ho, e.CubicInterpolant = Zl, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = Ao, e.CurvePath = qo, e.CustomBlending = 5, e.CustomToneMapping = 5, e.CylinderBufferGeometry = xo, e.CylinderGeometry = xo, e.Cylindrical = class {
+                }, e.ConeBufferGeometry = Il, e.ConeGeometry = Il, e.CubeCamera = xr, e.CubeReflectionMapping = Q, e.CubeRefractionMapping = $, e.CubeTexture = yr, e.CubeTextureLoader = Ch, e.CubeUVReflectionMapping = nt, e.CubeUVRefractionMapping = it, e.CubicBezierCurve = $l, e.CubicBezierCurve3 = tc, e.CubicInterpolant = hh, e.CullFaceBack = r, e.CullFaceFront = s, e.CullFaceFrontBack = 3, e.CullFaceNone = i, e.Curve = Gl, e.CurvePath = oc, e.CustomBlending = v, e.CustomToneMapping = Z, e.CylinderBufferGeometry = Dl, e.CylinderGeometry = Dl, e.Cylindrical = class {
                     constructor(t = 1, e = 0, n = 0) {
                         return this.radius = t, this.theta = e, this.y = n, this
                     }
                     set(t, e, n) {
                         return this.radius = t, this.theta = e, this.y = n, this
                     }
                     copy(t) {
@@ -15818,133 +16110,133 @@
                     }
                     setFromCartesianCoords(t, e, n) {
                         return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
-                }, e.DataTexture = Fa, e.DataTexture2DArray = er, e.DataTexture3D = or, e.DataTextureLoader = vc, e.DataUtils = class {
+                }, e.DataTexture = $o, e.DataTexture2DArray = ps, e.DataTexture3D = ys, e.DataTextureLoader = Ph, e.DataUtils = class {
                     static toHalfFloat(t) {
-                        t > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), t = 65504), ru[0] = t;
-                        const e = su[0];
+                        t > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), t = 65504), yd[0] = t;
+                        const e = _d[0];
                         let n = e >> 16 & 32768,
                             i = e >> 12 & 2047;
                         const r = e >> 23 & 255;
                         return r < 103 ? n : r > 142 ? (n |= 31744, n |= (255 == r ? 0 : 1) && 8388607 & e, n) : r < 113 ? (i |= 2048, n |= (i >> 114 - r) + (i >> 113 - r & 1), n) : (n |= r - 112 << 10 | i >> 1, n += 1 & i, n)
                     }
-                }, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = uc, e.DepthFormat = A, e.DepthStencilFormat = R, e.DepthTexture = ea, e.DirectionalLight = Ic, e.DirectionalLightHelper = class extends Qe {
+                }, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = Eh, e.DepthFormat = Rt, e.DepthStencilFormat = Lt, e.DepthTexture = go, e.DirectionalLight = qh, e.DirectionalLightHelper = class extends ci {
                     constructor(t, e, n) {
                         super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
-                        let i = new Nn;
-                        i.setAttribute("position", new En([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
-                        const r = new Ya({
+                        let i = new Wi;
+                        i.setAttribute("position", new Oi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
+                        const r = new cl({
                             fog: !1,
                             toneMapped: !1
                         });
-                        this.lightPlane = new to(i, r), this.add(this.lightPlane), i = new Nn, i.setAttribute("position", new En([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new to(i, r), this.add(this.targetLine), this.update()
+                        this.lightPlane = new fl(i, r), this.add(this.lightPlane), i = new Wi, i.setAttribute("position", new Oi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new fl(i, r), this.add(this.targetLine), this.update()
                     }
                     dispose() {
                         this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                     }
                     update() {
-                        Xh.setFromMatrixPosition(this.light.matrixWorld), qh.setFromMatrixPosition(this.light.target.matrixWorld), Yh.subVectors(qh, Xh), this.lightPlane.lookAt(qh), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(qh), this.targetLine.scale.z = Yh.length()
+                        od.setFromMatrixPosition(this.light.matrixWorld), ld.setFromMatrixPosition(this.light.target.matrixWorld), cd.subVectors(ld, od), this.lightPlane.lookAt(ld), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(ld), this.targetLine.scale.z = cd.length()
                     }
-                }, e.DiscreteInterpolant = Ql, e.DodecahedronBufferGeometry = Mo, e.DodecahedronGeometry = Mo, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function(t, e) {
-                    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new gn(t, e).setUsage(ut)
-                }, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = ut, e.DynamicReadUsage = 35049, e.EdgesGeometry = To, e.EdgesHelper = function(t, e) {
-                    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new io(new To(t.geometry), new Ya({
+                }, e.DiscreteInterpolant = dh, e.DodecahedronBufferGeometry = Ol, e.DodecahedronGeometry = Ol, e.DoubleSide = u, e.DstAlphaFactor = L, e.DstColorFactor = P, e.DynamicBufferAttribute = function(t, e) {
+                    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new Ti(t, e).setUsage(Me)
+                }, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = Me, e.DynamicReadUsage = 35049, e.EdgesGeometry = Hl, e.EdgesHelper = function(t, e) {
+                    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new xl(new Hl(t.geometry), new cl({
                         color: void 0 !== e ? e : 16777215
                     }))
-                }, e.EllipseCurve = Ro, e.EqualDepth = 4, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = o, e.EquirectangularRefractionMapping = l, e.Euler = Be, e.EventDispatcher = mt, e.ExtrudeBufferGeometry = wl, e.ExtrudeGeometry = wl, e.FaceColors = 1, e.FileLoader = mc, e.FlatShading = 1, e.Float16BufferAttribute = Sn, e.Float32Attribute = function(t, e) {
-                    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new En(t, e)
-                }, e.Float32BufferAttribute = En, e.Float64Attribute = function(t, e) {
-                    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Tn(t, e)
-                }, e.Float64BufferAttribute = Tn, e.FloatType = w, e.Fog = oa, e.FogExp2 = aa, e.Font = function() {
+                }, e.EllipseCurve = Vl, e.EqualDepth = F, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = tt, e.EquirectangularRefractionMapping = et, e.Euler = Yn, e.EventDispatcher = Se, e.ExtrudeBufferGeometry = Bc, e.ExtrudeGeometry = Bc, e.FaceColors = 1, e.FileLoader = Rh, e.FlatShading = 1, e.Float16BufferAttribute = Ni, e.Float32Attribute = function(t, e) {
+                    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Oi(t, e)
+                }, e.Float32BufferAttribute = Oi, e.Float64Attribute = function(t, e) {
+                    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Ui(t, e)
+                }, e.Float64BufferAttribute = Ui, e.FloatType = yt, e.Fog = bo, e.FogExp2 = Mo, e.Font = function() {
                     console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")
                 }, e.FontLoader = function() {
                     console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")
-                }, e.FramebufferTexture = mo, e.FrontSide = 0, e.Frustum = vi, e.GLBufferAttribute = Rh, e.GLSL1 = "100", e.GLSL3 = dt, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = jh, e.Group = Qs, e.HalfFloatType = S, e.HemisphereLight = _c, e.HemisphereLightHelper = class extends Qe {
+                }, e.FramebufferTexture = Rl, e.FrontSide = c, e.Frustum = Ar, e.GLBufferAttribute = ku, e.GLSL1 = "100", e.GLSL3 = be, e.GreaterDepth = H, e.GreaterEqualDepth = z, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = ad, e.Group = po, e.HalfFloatType = _t, e.HemisphereLight = Nh, e.HemisphereLightHelper = class extends ci {
                     constructor(t, e, n) {
                         super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
-                        const i = new Al(e);
-                        i.rotateY(.5 * Math.PI), this.material = new pn({
+                        const i = new Gc(e);
+                        i.rotateY(.5 * Math.PI), this.material = new wi({
                             wireframe: !0,
                             fog: !1,
                             toneMapped: !1
                         }), void 0 === this.color && (this.material.vertexColors = !0);
                         const r = i.getAttribute("position"),
                             s = new Float32Array(3 * r.count);
-                        i.setAttribute("color", new gn(s, 3)), this.add(new Qn(i, this.material)), this.update()
+                        i.setAttribute("color", new Ti(s, 3)), this.add(new lr(i, this.material)), this.update()
                     }
                     dispose() {
                         this.children[0].geometry.dispose(), this.children[0].material.dispose()
                     }
                     update() {
                         const t = this.children[0];
                         if (void 0 !== this.color) this.material.color.set(this.color);
                         else {
                             const e = t.geometry.getAttribute("color");
-                            kh.copy(this.light.color), Wh.copy(this.light.groundColor);
+                            rd.copy(this.light.color), sd.copy(this.light.groundColor);
                             for (let t = 0, n = e.count; t < n; t++) {
-                                const i = t < n / 2 ? kh : Wh;
+                                const i = t < n / 2 ? rd : sd;
                                 e.setXYZ(t, i.r, i.g, i.b)
                             }
                             e.needsUpdate = !0
                         }
-                        t.lookAt(Vh.setFromMatrixPosition(this.light.matrixWorld).negate())
+                        t.lookAt(id.setFromMatrixPosition(this.light.matrixWorld).negate())
                     }
-                }, e.HemisphereLightProbe = Jc, e.IcosahedronBufferGeometry = El, e.IcosahedronGeometry = El, e.ImageBitmapLoader = jc, e.ImageLoader = fc, e.ImageUtils = Gt, e.ImmediateRenderObject = function() {
+                }, e.HemisphereLightProbe = cu, e.IcosahedronBufferGeometry = zc, e.IcosahedronGeometry = zc, e.ImageBitmapLoader = su, e.ImageLoader = Lh, e.ImageUtils = Ke, e.ImmediateRenderObject = function() {
                     console.error("THREE.ImmediateRenderObject has been removed.")
-                }, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = Va, e.InstancedBufferGeometry = Hc, e.InstancedInterleavedBuffer = Ah, e.InstancedMesh = qa, e.Int16Attribute = function(t, e) {
-                    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new _n(t, e)
-                }, e.Int16BufferAttribute = _n, e.Int32Attribute = function(t, e) {
-                    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new bn(t, e)
-                }, e.Int32BufferAttribute = bn, e.Int8Attribute = function(t, e) {
-                    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new vn(t, e)
-                }, e.Int8BufferAttribute = vn, e.IntType = 1013, e.InterleavedBuffer = ca, e.InterleavedBufferAttribute = ua, e.Interpolant = Jl, e.InterpolateDiscrete = tt, e.InterpolateLinear = et, e.InterpolateSmooth = nt, e.InvertStencilOp = 5386, e.JSONLoader = function() {
+                }, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = il, e.InstancedBufferGeometry = tu, e.InstancedInterleavedBuffer = Vu, e.InstancedMesh = ll, e.Int16Attribute = function(t, e) {
+                    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Ci(t, e)
+                }, e.Int16BufferAttribute = Ci, e.Int32Attribute = function(t, e) {
+                    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Di(t, e)
+                }, e.Int32BufferAttribute = Di, e.Int8Attribute = function(t, e) {
+                    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Ai(t, e)
+                }, e.Int8BufferAttribute = Ai, e.IntType = vt, e.InterleavedBuffer = So, e.InterleavedBufferAttribute = To, e.Interpolant = ch, e.InterpolateDiscrete = oe, e.InterpolateLinear = le, e.InterpolateSmooth = ce, e.InvertStencilOp = 5386, e.JSONLoader = function() {
                     console.error("THREE.JSONLoader has been removed.")
-                }, e.KeepStencilOp = ct, e.KeyframeTrack = $l, e.LOD = Ca, e.LatheBufferGeometry = Tl, e.LatheGeometry = Tl, e.Layers = Fe, e.LensFlare = function() {
+                }, e.KeepStencilOp = ye, e.KeyframeTrack = ph, e.LOD = jo, e.LatheBufferGeometry = Hc, e.LatheGeometry = Hc, e.Layers = Jn, e.LensFlare = function() {
                     console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
-                }, e.LessDepth = 2, e.LessEqualDepth = 3, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = yc, e.LightProbe = Bc, e.Line = to, e.Line3 = Oh, e.LineBasicMaterial = Ya, e.LineCurve = Go, e.LineCurve3 = Vo, e.LineDashedMaterial = Xl, e.LineLoop = ro, e.LinePieces = 1, e.LineSegments = io, e.LineStrip = 0, e.LinearEncoding = ot, e.LinearFilter = v, e.LinearInterpolant = Kl, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = y, e.LinearMipmapNearestFilter = x, e.LinearToneMapping = 1, e.Loader = dc, e.LoaderUtils = zc, e.LoadingManager = hc, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = {
+                }, e.LessDepth = U, e.LessEqualDepth = B, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = Ih, e.LightProbe = Kh, e.Line = fl, e.Line3 = Zu, e.LineBasicMaterial = cl, e.LineCurve = ec, e.LineCurve3 = nc, e.LineDashedMaterial = ah, e.LineLoop = yl, e.LinePieces = 1, e.LineSegments = xl, e.LineStrip = 0, e.LinearEncoding = me, e.LinearFilter = ht, e.LinearInterpolant = uh, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = dt, e.LinearMipmapNearestFilter = ut, e.LinearToneMapping = X, e.Loader = Th, e.LoaderUtils = $h, e.LoadingManager = Sh, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = At, e.LuminanceFormat = Tt, e.MOUSE = {
                     LEFT: 0,
                     MIDDLE: 1,
                     RIGHT: 2,
                     ROTATE: 0,
                     DOLLY: 1,
                     PAN: 2
-                }, e.Material = dn, e.MaterialLoader = Fc, e.Math = Tt, e.MathUtils = Tt, e.Matrix3 = Rt, e.Matrix4 = Ae, e.MaxEquation = 104, e.Mesh = Qn, e.MeshBasicMaterial = pn, e.MeshDepthMaterial = js, e.MeshDistanceMaterial = Xs, e.MeshFaceMaterial = function(t) {
+                }, e.Material = bi, e.MaterialLoader = Qh, e.Math = Ue, e.MathUtils = Ue, e.Matrix3 = Fe, e.Matrix4 = Fn, e.MaxEquation = b, e.Mesh = lr, e.MeshBasicMaterial = wi, e.MeshDepthMaterial = io, e.MeshDistanceMaterial = ro, e.MeshFaceMaterial = function(t) {
                     return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
-                }, e.MeshLambertMaterial = Wl, e.MeshMatcapMaterial = jl, e.MeshNormalMaterial = kl, e.MeshPhongMaterial = Gl, e.MeshPhysicalMaterial = Hl, e.MeshStandardMaterial = zl, e.MeshToonMaterial = Vl, e.MinEquation = 103, e.MirroredRepeatWrapping = p, e.MixOperation = 1, e.MultiMaterial = function(t = []) {
+                }, e.MeshLambertMaterial = rh, e.MeshMatcapMaterial = sh, e.MeshNormalMaterial = ih, e.MeshPhongMaterial = eh, e.MeshPhysicalMaterial = th, e.MeshStandardMaterial = $c, e.MeshToonMaterial = nh, e.MinEquation = M, e.MirroredRepeatWrapping = at, e.MixOperation = k, e.MultiMaterial = function(t = []) {
                     return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                         return t.slice()
                     }, t
-                }, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = m, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = g, e.NearestMipmapNearestFilter = f, e.NeverDepth = 0, e.NeverStencilFunc = 512, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, e.NormalAnimationBlendMode = 2500, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = nc, e.Object3D = Qe, e.ObjectLoader = class extends dc {
+                }, e.MultiplyBlending = g, e.MultiplyOperation = V, e.NearestFilter = ot, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = ct, e.NearestMipmapNearestFilter = lt, e.NeverDepth = N, e.NeverStencilFunc = 512, e.NoBlending = d, e.NoColors = 0, e.NoToneMapping = j, e.NormalAnimationBlendMode = 2500, e.NormalBlending = p, e.NotEqualDepth = G, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = gh, e.Object3D = ci, e.ObjectLoader = class extends Th {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = "" === this.path ? zc.extractUrlBase(t) : this.path;
+                            s = "" === this.path ? $h.extractUrlBase(t) : this.path;
                         this.resourcePath = this.resourcePath || s;
-                        const a = new mc(this.manager);
+                        const a = new Rh(this.manager);
                         a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function(n) {
                             let s = null;
                             try {
                                 s = JSON.parse(n)
                             } catch (e) {
                                 return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                             }
                             const a = s.metadata;
                             void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(s, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                         }), n, i)
                     }
                     async loadAsync(t, e) {
-                        const n = "" === this.path ? zc.extractUrlBase(t) : this.path;
+                        const n = "" === this.path ? $h.extractUrlBase(t) : this.path;
                         this.resourcePath = this.resourcePath || n;
-                        const i = new mc(this.manager);
+                        const i = new Rh(this.manager);
                         i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials);
                         const r = await i.loadAsync(t, e),
                             s = JSON.parse(r),
                             a = s.metadata;
                         if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + t);
                         return await this.parseAsync(s)
                     }
@@ -15980,59 +16272,59 @@
                             l = this.parseSkeletons(t.skeletons, o);
                         return this.bindSkeletons(o, l), o
                     }
                     parseShapes(t) {
                         const e = {};
                         if (void 0 !== t)
                             for (let n = 0, i = t.length; n < i; n++) {
-                                const i = (new Jo).fromJSON(t[n]);
+                                const i = (new cc).fromJSON(t[n]);
                                 e[i.uuid] = i
                             }
                         return e
                     }
                     parseSkeletons(t, e) {
                         const n = {},
                             i = {};
                         if (e.traverse((function(t) {
                                 t.isBone && (i[t.uuid] = t)
                             })), void 0 !== t)
                             for (let e = 0, r = t.length; e < r; e++) {
-                                const r = (new Ga).fromJSON(t[e], i);
+                                const r = (new nl).fromJSON(t[e], i);
                                 n[r.uuid] = r
                             }
                         return n
                     }
                     parseGeometries(t, e) {
                         const n = {};
                         if (void 0 !== t) {
-                            const i = new Gc;
+                            const i = new eu;
                             for (let r = 0, s = t.length; r < s; r++) {
                                 let s;
                                 const a = t[r];
                                 switch (a.type) {
                                     case "BufferGeometry":
                                     case "InstancedBufferGeometry":
                                         s = i.parse(a);
                                         break;
                                     case "Geometry":
                                         console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                                         break;
                                     default:
-                                        a.type in Bl ? s = Bl[a.type].fromJSON(a, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)
+                                        a.type in Kc ? s = Kc[a.type].fromJSON(a, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)
                                 }
                                 s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), n[a.uuid] = s
                             }
                         }
                         return n
                     }
                     parseMaterials(t, e) {
                         const n = {},
                             i = {};
                         if (void 0 !== t) {
-                            const r = new Fc;
+                            const r = new Qh;
                             r.setTextures(e);
                             for (let e = 0, s = t.length; e < s; e++) {
                                 const s = t[e];
                                 if ("MultiMaterial" === s.type) {
                                     const t = [];
                                     for (let e = 0; e < s.materials.length; e++) {
                                         const i = s.materials[e];
@@ -16045,15 +16337,15 @@
                         return i
                     }
                     parseAnimations(t) {
                         const e = {};
                         if (void 0 !== t)
                             for (let n = 0; n < t.length; n++) {
                                 const i = t[n],
-                                    r = oc.parse(i);
+                                    r = Mh.parse(i);
                                 e[r.uuid] = r
                             }
                         return e
                     }
                     parseImages(t, e) {
                         const n = this,
                             i = {};
@@ -16067,30 +16359,30 @@
                                         n.manager.itemEnd(t)
                                     }), void 0, (function() {
                                         n.manager.itemError(t), n.manager.itemEnd(t)
                                     }))
                                 }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e)
                             }
                             return t.data ? {
-                                data: Pt(t.type, t.data),
+                                data: Ge(t.type, t.data),
                                 width: t.width,
                                 height: t.height
                             } : null
                         }
                         if (void 0 !== t && t.length > 0) {
-                            const n = new hc(e);
-                            r = new fc(n), r.setCrossOrigin(this.crossOrigin);
+                            const n = new Sh(e);
+                            r = new Lh(n), r.setCrossOrigin(this.crossOrigin);
                             for (let e = 0, n = t.length; e < n; e++) {
                                 const n = t[e],
                                     r = n.url;
                                 if (Array.isArray(r)) {
                                     i[n.uuid] = [];
                                     for (let t = 0, e = r.length; t < e; t++) {
                                         const e = s(r[t]);
-                                        null !== e && (e instanceof HTMLImageElement ? i[n.uuid].push(e) : i[n.uuid].push(new Fa(e.data, e.width, e.height)))
+                                        null !== e && (e instanceof HTMLImageElement ? i[n.uuid].push(e) : i[n.uuid].push(new $o(e.data, e.width, e.height)))
                                     }
                                 } else {
                                     const t = s(n.url);
                                     null !== t && (i[n.uuid] = t)
                                 }
                             }
                         }
@@ -16103,30 +16395,30 @@
                         async function r(t) {
                             if ("string" == typeof t) {
                                 const n = t,
                                     r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : e.resourcePath + n;
                                 return await i.loadAsync(r)
                             }
                             return t.data ? {
-                                data: Pt(t.type, t.data),
+                                data: Ge(t.type, t.data),
                                 width: t.width,
                                 height: t.height
                             } : null
                         }
                         if (void 0 !== t && t.length > 0) {
-                            i = new fc(this.manager), i.setCrossOrigin(this.crossOrigin);
+                            i = new Lh(this.manager), i.setCrossOrigin(this.crossOrigin);
                             for (let e = 0, i = t.length; e < i; e++) {
                                 const i = t[e],
                                     s = i.url;
                                 if (Array.isArray(s)) {
                                     n[i.uuid] = [];
                                     for (let t = 0, e = s.length; t < e; t++) {
                                         const e = s[t],
                                             a = await r(e);
-                                        null !== a && (a instanceof HTMLImageElement ? n[i.uuid].push(a) : n[i.uuid].push(new Fa(a.data, a.width, a.height)))
+                                        null !== a && (a instanceof HTMLImageElement ? n[i.uuid].push(a) : n[i.uuid].push(new $o(a.data, a.width, a.height)))
                                     }
                                 } else {
                                     const t = await r(i.url);
                                     null !== t && (n[i.uuid] = t)
                                 }
                             }
                         }
@@ -16139,15 +16431,15 @@
                         const i = {};
                         if (void 0 !== t)
                             for (let r = 0, s = t.length; r < s; r++) {
                                 const s = t[r];
                                 let a;
                                 void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                                 const o = e[s.image];
-                                Array.isArray(o) ? (a = new ci(o), 6 === o.length && (a.needsUpdate = !0)) : (a = o && o.data ? new Fa(o.data, o.width, o.height) : new kt(o), o && (a.needsUpdate = !0)), a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, Vc)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], kc), a.wrapT = n(s.wrap[1], kc)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, Wc)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, Wc)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), void 0 !== s.userData && (a.userData = s.userData), i[s.uuid] = a
+                                Array.isArray(o) ? (a = new yr(o), 6 === o.length && (a.needsUpdate = !0)) : (a = o && o.data ? new $o(o.data, o.width, o.height) : new $e(o), o && (a.needsUpdate = !0)), a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, nu)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], iu), a.wrapT = n(s.wrap[1], iu)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, ru)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, ru)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), void 0 !== s.userData && (a.userData = s.userData), i[s.uuid] = a
                             }
                         return i
                     }
                     parseObject(t, e, n, i, r) {
                         let s, a, o;
 
                         function l(t) {
@@ -16169,83 +16461,83 @@
                         }
 
                         function h(t) {
                             return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined texture", t), i[t]
                         }
                         switch (t.type) {
                             case "Scene":
-                                s = new la, void 0 !== t.background && (Number.isInteger(t.background) ? s.background = new zt(t.background) : s.background = h(t.background)), void 0 !== t.environment && (s.environment = h(t.environment)), void 0 !== t.fog && ("Fog" === t.fog.type ? s.fog = new oa(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (s.fog = new aa(t.fog.color, t.fog.density)));
+                                s = new wo, void 0 !== t.background && (Number.isInteger(t.background) ? s.background = new Je(t.background) : s.background = h(t.background)), void 0 !== t.environment && (s.environment = h(t.environment)), void 0 !== t.fog && ("Fog" === t.fog.type ? s.fog = new bo(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (s.fog = new Mo(t.fog.color, t.fog.density)));
                                 break;
                             case "PerspectiveCamera":
-                                s = new ai(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (s.focus = t.focus), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset), void 0 !== t.view && (s.view = Object.assign({}, t.view));
+                                s = new gr(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (s.focus = t.focus), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                                 break;
                             case "OrthographicCamera":
-                                s = new Ci(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.view && (s.view = Object.assign({}, t.view));
+                                s = new Hr(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                                 break;
                             case "AmbientLight":
-                                s = new Nc(t.color, t.intensity);
+                                s = new Yh(t.color, t.intensity);
                                 break;
                             case "DirectionalLight":
-                                s = new Ic(t.color, t.intensity);
+                                s = new qh(t.color, t.intensity);
                                 break;
                             case "PointLight":
-                                s = new Pc(t.color, t.intensity, t.distance, t.decay);
+                                s = new jh(t.color, t.intensity, t.distance, t.decay);
                                 break;
                             case "RectAreaLight":
-                                s = new Oc(t.color, t.intensity, t.width, t.height);
+                                s = new Jh(t.color, t.intensity, t.width, t.height);
                                 break;
                             case "SpotLight":
-                                s = new Tc(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
+                                s = new Hh(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                                 break;
                             case "HemisphereLight":
-                                s = new _c(t.color, t.groundColor, t.intensity);
+                                s = new Nh(t.color, t.groundColor, t.intensity);
                                 break;
                             case "LightProbe":
-                                s = (new Bc).fromJSON(t);
+                                s = (new Kh).fromJSON(t);
                                 break;
                             case "SkinnedMesh":
-                                a = l(t.geometry), o = c(t.material), s = new Ua(a, o), void 0 !== t.bindMode && (s.bindMode = t.bindMode), void 0 !== t.bindMatrix && s.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (s.skeleton = t.skeleton);
+                                a = l(t.geometry), o = c(t.material), s = new Ko(a, o), void 0 !== t.bindMode && (s.bindMode = t.bindMode), void 0 !== t.bindMatrix && s.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (s.skeleton = t.skeleton);
                                 break;
                             case "Mesh":
-                                a = l(t.geometry), o = c(t.material), s = new Qn(a, o);
+                                a = l(t.geometry), o = c(t.material), s = new lr(a, o);
                                 break;
                             case "InstancedMesh":
                                 a = l(t.geometry), o = c(t.material);
                                 const e = t.count,
                                     n = t.instanceMatrix,
                                     i = t.instanceColor;
-                                s = new qa(a, o, e), s.instanceMatrix = new Va(new Float32Array(n.array), 16), void 0 !== i && (s.instanceColor = new Va(new Float32Array(i.array), i.itemSize));
+                                s = new ll(a, o, e), s.instanceMatrix = new il(new Float32Array(n.array), 16), void 0 !== i && (s.instanceColor = new il(new Float32Array(i.array), i.itemSize));
                                 break;
                             case "LOD":
-                                s = new Ca;
+                                s = new jo;
                                 break;
                             case "Line":
-                                s = new to(l(t.geometry), c(t.material));
+                                s = new fl(l(t.geometry), c(t.material));
                                 break;
                             case "LineLoop":
-                                s = new ro(l(t.geometry), c(t.material));
+                                s = new yl(l(t.geometry), c(t.material));
                                 break;
                             case "LineSegments":
-                                s = new io(l(t.geometry), c(t.material));
+                                s = new xl(l(t.geometry), c(t.material));
                                 break;
                             case "PointCloud":
                             case "Points":
-                                s = new ho(l(t.geometry), c(t.material));
+                                s = new El(l(t.geometry), c(t.material));
                                 break;
                             case "Sprite":
-                                s = new Ta(c(t.material));
+                                s = new Go(c(t.material));
                                 break;
                             case "Group":
-                                s = new Qs;
+                                s = new po;
                                 break;
                             case "Bone":
-                                s = new Ba;
+                                s = new Qo;
                                 break;
                             default:
-                                s = new Qe
+                                s = new ci
                         }
                         if (s.uuid = t.uuid, void 0 !== t.name && (s.name = t.name), void 0 !== t.matrix ? (s.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== t.position && s.position.fromArray(t.position), void 0 !== t.rotation && s.rotation.fromArray(t.rotation), void 0 !== t.quaternion && s.quaternion.fromArray(t.quaternion), void 0 !== t.scale && s.scale.fromArray(t.scale)), void 0 !== t.castShadow && (s.castShadow = t.castShadow), void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (s.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (s.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && s.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (s.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.layers && (s.layers.mask = t.layers), void 0 !== t.children) {
                             const a = t.children;
                             for (let t = 0; t < a.length; t++) s.add(this.parseObject(a[t], e, n, i, r))
                         }
                         if (void 0 !== t.animations) {
                             const e = t.animations;
@@ -16272,66 +16564,66 @@
                                 void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(n, t.bindMatrix)
                             }
                         }))
                     }
                     setTexturePath(t) {
                         return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
                     }
-                }, e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = Al, e.OctahedronGeometry = Al, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = Ci, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.PMREMGenerator = Wi, e.ParametricGeometry = function() {
-                    return console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), new Nn
+                }, e.ObjectSpaceNormalMap = xe, e.OctahedronBufferGeometry = Gc, e.OctahedronGeometry = Gc, e.OneFactor = S, e.OneMinusDstAlphaFactor = C, e.OneMinusDstColorFactor = D, e.OneMinusSrcAlphaFactor = R, e.OneMinusSrcColorFactor = T, e.OrthographicCamera = Hr, e.PCFShadowMap = a, e.PCFSoftShadowMap = o, e.PMREMGenerator = ns, e.ParametricGeometry = function() {
+                    return console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), new Wi
                 }, e.Particle = function(t) {
-                    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ta(t)
+                    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Go(t)
                 }, e.ParticleBasicMaterial = function(t) {
-                    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new so(t)
+                    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new _l(t)
                 }, e.ParticleSystem = function(t, e) {
-                    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new ho(t, e)
+                    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new El(t, e)
                 }, e.ParticleSystemMaterial = function(t) {
-                    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new so(t)
-                }, e.Path = Yo, e.PerspectiveCamera = ai, e.Plane = mi, e.PlaneBufferGeometry = _i, e.PlaneGeometry = _i, e.PlaneHelper = class extends to {
+                    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new _l(t)
+                }, e.Path = lc, e.PerspectiveCamera = gr, e.Plane = Sr, e.PlaneBufferGeometry = Cr, e.PlaneGeometry = Cr, e.PlaneHelper = class extends fl {
                     constructor(t, e = 1, n = 16776960) {
                         const i = n,
-                            r = new Nn;
-                        r.setAttribute("position", new En([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), super(r, new Ya({
+                            r = new Wi;
+                        r.setAttribute("position", new Oi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), super(r, new cl({
                             color: i,
                             toneMapped: !1
                         })), this.type = "PlaneHelper", this.plane = t, this.size = e;
-                        const s = new Nn;
-                        s.setAttribute("position", new En([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new Qn(s, new pn({
+                        const s = new Wi;
+                        s.setAttribute("position", new Oi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new lr(s, new wi({
                             color: i,
                             opacity: .2,
                             transparent: !0,
                             depthWrite: !1,
                             toneMapped: !1
                         })))
                     }
                     updateMatrixWorld(t) {
                         let e = -this.plane.constant;
-                        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? 1 : 0, this.lookAt(this.plane.normal), super.updateMatrixWorld(t)
+                        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? h : c, this.lookAt(this.plane.normal), super.updateMatrixWorld(t)
                     }
                 }, e.PointCloud = function(t, e) {
-                    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new ho(t, e)
+                    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new El(t, e)
                 }, e.PointCloudMaterial = function(t) {
-                    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new so(t)
-                }, e.PointLight = Pc, e.PointLightHelper = class extends Qn {
+                    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new _l(t)
+                }, e.PointLight = jh, e.PointLightHelper = class extends lr {
                     constructor(t, e, n) {
-                        super(new Cl(e, 4, 2), new pn({
+                        super(new Wc(e, 4, 2), new wi({
                             wireframe: !0,
                             fog: !1,
                             toneMapped: !1
                         })), this.light = t, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                     }
                     dispose() {
                         this.geometry.dispose(), this.material.dispose()
                     }
                     update() {
                         void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                     }
-                }, e.Points = ho, e.PointsMaterial = so, e.PolarGridHelper = class extends io {
+                }, e.Points = El, e.PointsMaterial = _l, e.PolarGridHelper = class extends xl {
                     constructor(t = 10, e = 16, n = 8, i = 64, r = 4473924, s = 8947848) {
-                        r = new zt(r), s = new zt(s);
+                        r = new Je(r), s = new Je(s);
                         const a = [],
                             o = [];
                         for (let n = 0; n <= e; n++) {
                             const i = n / e * (2 * Math.PI),
                                 l = Math.sin(i) * t,
                                 c = Math.cos(i) * t;
                             a.push(0, 0, 0), a.push(l, 0, c);
@@ -16344,21 +16636,21 @@
                             for (let t = 0; t < i; t++) {
                                 let e = t / i * (2 * Math.PI),
                                     n = Math.sin(e) * c,
                                     r = Math.cos(e) * c;
                                 a.push(n, 0, r), o.push(l.r, l.g, l.b), e = (t + 1) / i * (2 * Math.PI), n = Math.sin(e) * c, r = Math.cos(e) * c, a.push(n, 0, r), o.push(l.r, l.g, l.b)
                             }
                         }
-                        const l = new Nn;
-                        l.setAttribute("position", new En(a, 3)), l.setAttribute("color", new En(o, 3)), super(l, new Ya({
+                        const l = new Wi;
+                        l.setAttribute("position", new Oi(a, 3)), l.setAttribute("color", new Oi(o, 3)), super(l, new cl({
                             vertexColors: !0,
                             toneMapped: !1
                         })), this.type = "PolarGridHelper"
                     }
-                }, e.PolyhedronBufferGeometry = _o, e.PolyhedronGeometry = _o, e.PositionalAudio = class extends ah {
+                }, e.PolyhedronBufferGeometry = Nl, e.PolyhedronGeometry = Nl, e.PositionalAudio = class extends _u {
                     constructor(t) {
                         super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                     }
                     getOutput() {
                         return this.panner
                     }
                     getRefDistance() {
@@ -16386,24 +16678,24 @@
                         return this.panner.maxDistance = t, this
                     }
                     setDirectionalCone(t, e, n) {
                         return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
                     }
                     updateMatrixWorld(t) {
                         if (super.updateMatrixWorld(t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
-                        this.matrixWorld.decompose(oh, lh, ch), hh.set(0, 0, 1).applyQuaternion(lh);
+                        this.matrixWorld.decompose(Mu, bu, wu), Su.set(0, 0, 1).applyQuaternion(bu);
                         const e = this.panner;
                         if (e.positionX) {
                             const t = this.context.currentTime + this.listener.timeDelta;
-                            e.positionX.linearRampToValueAtTime(oh.x, t), e.positionY.linearRampToValueAtTime(oh.y, t), e.positionZ.linearRampToValueAtTime(oh.z, t), e.orientationX.linearRampToValueAtTime(hh.x, t), e.orientationY.linearRampToValueAtTime(hh.y, t), e.orientationZ.linearRampToValueAtTime(hh.z, t)
-                        } else e.setPosition(oh.x, oh.y, oh.z), e.setOrientation(hh.x, hh.y, hh.z)
+                            e.positionX.linearRampToValueAtTime(Mu.x, t), e.positionY.linearRampToValueAtTime(Mu.y, t), e.positionZ.linearRampToValueAtTime(Mu.z, t), e.orientationX.linearRampToValueAtTime(Su.x, t), e.orientationY.linearRampToValueAtTime(Su.y, t), e.orientationZ.linearRampToValueAtTime(Su.z, t)
+                        } else e.setPosition(Mu.x, Mu.y, Mu.z), e.setOrientation(Su.x, Su.y, Su.z)
                     }
-                }, e.PropertyBinding = bh, e.PropertyMixer = dh, e.QuadraticBezierCurve = ko, e.QuadraticBezierCurve3 = Wo, e.Quaternion = Jt, e.QuaternionKeyframeTrack = rc, e.QuaternionLinearInterpolant = ic, e.REVISION = n, e.RGBADepthPacking = 3201, e.RGBAFormat = T, e.RGBAIntegerFormat = 1033, e.RGBA_ASTC_10x10_Format = Z, e.RGBA_ASTC_10x5_Format = q, e.RGBA_ASTC_10x6_Format = Y, e.RGBA_ASTC_10x8_Format = J, e.RGBA_ASTC_12x10_Format = K, e.RGBA_ASTC_12x12_Format = Q, e.RGBA_ASTC_4x4_Format = z, e.RGBA_ASTC_5x4_Format = H, e.RGBA_ASTC_5x5_Format = G, e.RGBA_ASTC_6x5_Format = V, e.RGBA_ASTC_6x6_Format = k, e.RGBA_ASTC_8x5_Format = W, e.RGBA_ASTC_8x6_Format = j, e.RGBA_ASTC_8x8_Format = X, e.RGBA_BPTC_Format = $, e.RGBA_ETC2_EAC_Format = F, e.RGBA_PVRTC_2BPPV1_Format = U, e.RGBA_PVRTC_4BPPV1_Format = O, e.RGBA_S3TC_DXT1_Format = C, e.RGBA_S3TC_DXT3_Format = P, e.RGBA_S3TC_DXT5_Format = D, e.RGB_ETC1_Format = 36196, e.RGB_ETC2_Format = B, e.RGB_PVRTC_2BPPV1_Format = N, e.RGB_PVRTC_4BPPV1_Format = I, e.RGB_S3TC_DXT1_Format = L, e.RGFormat = 1030, e.RGIntegerFormat = 1031, e.RawShaderMaterial = Pi, e.Ray = Te, e.Raycaster = class {
+                }, e.PropertyBinding = Bu, e.PropertyMixer = Tu, e.QuadraticBezierCurve = ic, e.QuadraticBezierCurve3 = rc, e.Quaternion = an, e.QuaternionKeyframeTrack = xh, e.QuaternionLinearInterpolant = vh, e.REVISION = n, e.RGBADepthPacking = ge, e.RGBAFormat = Et, e.RGBAIntegerFormat = Nt, e.RGBA_ASTC_10x10_Format = ie, e.RGBA_ASTC_10x5_Format = te, e.RGBA_ASTC_10x6_Format = ee, e.RGBA_ASTC_10x8_Format = ne, e.RGBA_ASTC_12x10_Format = re, e.RGBA_ASTC_12x12_Format = se, e.RGBA_ASTC_4x4_Format = Xt, e.RGBA_ASTC_5x4_Format = qt, e.RGBA_ASTC_5x5_Format = Yt, e.RGBA_ASTC_6x5_Format = Jt, e.RGBA_ASTC_6x6_Format = Zt, e.RGBA_ASTC_8x5_Format = Kt, e.RGBA_ASTC_8x6_Format = Qt, e.RGBA_ASTC_8x8_Format = $t, e.RGBA_BPTC_Format = ae, e.RGBA_ETC2_EAC_Format = jt, e.RGBA_PVRTC_2BPPV1_Format = Vt, e.RGBA_PVRTC_4BPPV1_Format = Gt, e.RGBA_S3TC_DXT1_Format = Ut, e.RGBA_S3TC_DXT3_Format = Bt, e.RGBA_S3TC_DXT5_Format = Ft, e.RGB_ETC1_Format = kt, e.RGB_ETC2_Format = Wt, e.RGB_PVRTC_2BPPV1_Format = Ht, e.RGB_PVRTC_4BPPV1_Format = zt, e.RGB_S3TC_DXT1_Format = Ot, e.RGFormat = Dt, e.RGIntegerFormat = It, e.RawShaderMaterial = Gr, e.Ray = Bn, e.Raycaster = class {
                     constructor(t, e, n = 0, i = 1 / 0) {
-                        this.ray = new Te(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new Fe, this.params = {
+                        this.ray = new Bn(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new Jn, this.params = {
                             Mesh: {},
                             Line: {
                                 threshold: 1
                             },
                             LOD: {},
                             Points: {
                                 threshold: 1
@@ -16414,26 +16706,26 @@
                     set(t, e) {
                         this.ray.set(t, e)
                     }
                     setFromCamera(t, e) {
                         e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
                     }
                     intersectObject(t, e = !0, n = []) {
-                        return Ch(t, this, n, e), n.sort(Lh), n
+                        return ju(t, this, n, e), n.sort(Wu), n
                     }
                     intersectObjects(t, e = !0, n = []) {
-                        for (let i = 0, r = t.length; i < r; i++) Ch(t[i], this, n, e);
-                        return n.sort(Lh), n
+                        for (let i = 0, r = t.length; i < r; i++) ju(t[i], this, n, e);
+                        return n.sort(Wu), n
                     }
-                }, e.RectAreaLight = Oc, e.RedFormat = 1028, e.RedIntegerFormat = 1029, e.ReinhardToneMapping = 2, e.RepeatWrapping = u, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = 102, e.RingBufferGeometry = Rl, e.RingGeometry = Rl, e.Scene = la, e.SceneUtils = au, e.ShaderChunk = Mi, e.ShaderLib = wi, e.ShaderMaterial = ri, e.ShadowMaterial = Fl, e.Shape = Jo, e.ShapeBufferGeometry = Ll, e.ShapeGeometry = Ll, e.ShapePath = class {
+                }, e.RectAreaLight = Jh, e.RedFormat = Ct, e.RedIntegerFormat = Pt, e.ReinhardToneMapping = q, e.RepeatWrapping = rt, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = _, e.RingBufferGeometry = Vc, e.RingGeometry = Vc, e.Scene = wo, e.SceneUtils = Md, e.ShaderChunk = Pr, e.ShaderLib = Ir, e.ShaderMaterial = mr, e.ShadowMaterial = Qc, e.Shape = cc, e.ShapeBufferGeometry = kc, e.ShapeGeometry = kc, e.ShapePath = class {
                     constructor() {
-                        this.type = "ShapePath", this.color = new zt, this.subPaths = [], this.currentPath = null
+                        this.type = "ShapePath", this.color = new Je, this.subPaths = [], this.currentPath = null
                     }
                     moveTo(t, e) {
-                        return this.currentPath = new Yo, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
+                        return this.currentPath = new lc, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
                     }
                     lineTo(t, e) {
                         return this.currentPath.lineTo(t, e), this
                     }
                     quadraticCurveTo(t, e, n, i) {
                         return this.currentPath.quadraticCurveTo(t, e, n, i), this
                     }
@@ -16444,15 +16736,15 @@
                         return this.currentPath.splineThru(t), this
                     }
                     toShapes(t, e) {
                         function n(t) {
                             const e = [];
                             for (let n = 0, i = t.length; n < i; n++) {
                                 const i = t[n],
-                                    r = new Jo;
+                                    r = new cc;
                                 r.curves = i.curves, e.push(r)
                             }
                             return e
                         }
 
                         function i(t, e) {
                             const n = e.length;
@@ -16475,30 +16767,30 @@
                                 } else {
                                     if (t.y !== n.y) continue;
                                     if (a.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= a.x) return !0
                                 }
                             }
                             return i
                         }
-                        const r = _l.isClockWise,
+                        const r = Nc.isClockWise,
                             s = this.subPaths;
                         if (0 === s.length) return [];
                         if (!0 === e) return n(s);
                         let a, o, l;
                         const c = [];
-                        if (1 === s.length) return o = s[0], l = new Jo, l.curves = o.curves, c.push(l), c;
+                        if (1 === s.length) return o = s[0], l = new cc, l.curves = o.curves, c.push(l), c;
                         let h = !r(s[0].getPoints());
                         h = t ? !h : h;
                         const u = [],
                             d = [];
                         let p, m, f = [],
                             g = 0;
                         d[g] = void 0, f[g] = [];
                         for (let e = 0, n = s.length; e < n; e++) o = s[e], p = o.getPoints(), a = r(p), a = t ? !a : a, a ? (!h && d[g] && g++, d[g] = {
-                            s: new Jo,
+                            s: new cc,
                             p
                         }, d[g].s.curves = o.curves, h && g++, f[g] = []) : f[g].push({
                             h: o,
                             p: p[0]
                         });
                         if (!d[0]) return n(s);
                         if (d.length > 1) {
@@ -16522,15 +16814,15 @@
                         }
                         for (let t = 0, e = d.length; t < e; t++) {
                             l = d[t].s, c.push(l), m = f[t];
                             for (let t = 0, e = m.length; t < e; t++) l.holes.push(m[t].h)
                         }
                         return c
                     }
-                }, e.ShapeUtils = _l, e.ShortType = 1011, e.Skeleton = Ga, e.SkeletonHelper = Hh, e.SkinnedMesh = Ua, e.SmoothShading = 2, e.Sphere = xe, e.SphereBufferGeometry = Cl, e.SphereGeometry = Cl, e.Spherical = class {
+                }, e.ShapeUtils = Nc, e.ShortType = ft, e.Skeleton = nl, e.SkeletonHelper = ed, e.SkinnedMesh = Ko, e.SmoothShading = 2, e.Sphere = Ln, e.SphereBufferGeometry = Wc, e.SphereGeometry = Wc, e.Spherical = class {
                     constructor(t = 1, e = 0, n = 0) {
                         return this.radius = t, this.phi = e, this.theta = n, this
                     }
                     set(t, e, n) {
                         return this.radius = t, this.phi = e, this.theta = n, this
                     }
                     copy(t) {
@@ -16540,138 +16832,230 @@
                         const t = 1e-6;
                         return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
                     }
                     setFromVector3(t) {
                         return this.setFromCartesianCoords(t.x, t.y, t.z)
                     }
                     setFromCartesianCoords(t, e, n) {
-                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(_t(e / this.radius, -1, 1))), this
+                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Ce(e / this.radius, -1, 1))), this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
-                }, e.SphericalHarmonics3 = Uc, e.SplineCurve = jo, e.SpotLight = Tc, e.SpotLightHelper = class extends Qe {
+                }, e.SphericalHarmonics3 = Zh, e.SplineCurve = sc, e.SpotLight = Hh, e.SpotLightHelper = class extends ci {
                     constructor(t, e) {
                         super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
-                        const n = new Nn,
+                        const n = new Wi,
                             i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                         for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
                             const r = t / n * Math.PI * 2,
                                 s = e / n * Math.PI * 2;
                             i.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1)
                         }
-                        n.setAttribute("position", new En(i, 3));
-                        const r = new Ya({
+                        n.setAttribute("position", new Oi(i, 3));
+                        const r = new cl({
                             fog: !1,
                             toneMapped: !1
                         });
-                        this.cone = new io(n, r), this.add(this.cone), this.update()
+                        this.cone = new xl(n, r), this.add(this.cone), this.update()
                     }
                     dispose() {
                         this.cone.geometry.dispose(), this.cone.material.dispose()
                     }
                     update() {
                         this.light.updateMatrixWorld();
                         const t = this.light.distance ? this.light.distance : 1e3,
                             e = t * Math.tan(this.light.angle);
-                        this.cone.scale.set(e, e, t), Uh.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Uh), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
+                        this.cone.scale.set(e, e, t), Ku.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Ku), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                     }
-                }, e.Sprite = Ta, e.SpriteMaterial = da, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StaticCopyUsage = 35046, e.StaticDrawUsage = ht, e.StaticReadUsage = 35045, e.StereoCamera = class {
+                }, e.Sprite = Go, e.SpriteMaterial = Ao, e.SrcAlphaFactor = A, e.SrcAlphaSaturateFactor = I, e.SrcColorFactor = E, e.StaticCopyUsage = 35046, e.StaticDrawUsage = _e, e.StaticReadUsage = 35045, e.StereoCamera = class {
                     constructor() {
-                        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ai, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ai, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
+                        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new gr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new gr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                             focus: null,
                             fov: null,
                             aspect: null,
                             near: null,
                             far: null,
                             zoom: null,
                             eyeSep: null
                         }
                     }
                     update(t) {
                         const e = this._cache;
                         if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
-                            e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep, $c.copy(t.projectionMatrix);
+                            e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep, pu.copy(t.projectionMatrix);
                             const n = e.eyeSep / 2,
                                 i = n * e.near / e.focus,
-                                r = e.near * Math.tan(vt * e.fov * .5) / e.zoom;
+                                r = e.near * Math.tan(Ae * e.fov * .5) / e.zoom;
                             let s, a;
-                            Qc.elements[12] = -n, Kc.elements[12] = n, s = -r * e.aspect + i, a = r * e.aspect + i, $c.elements[0] = 2 * e.near / (a - s), $c.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy($c), s = -r * e.aspect - i, a = r * e.aspect - i, $c.elements[0] = 2 * e.near / (a - s), $c.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy($c)
+                            du.elements[12] = -n, uu.elements[12] = n, s = -r * e.aspect + i, a = r * e.aspect + i, pu.elements[0] = 2 * e.near / (a - s), pu.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(pu), s = -r * e.aspect - i, a = r * e.aspect - i, pu.elements[0] = 2 * e.near / (a - s), pu.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(pu)
                         }
-                        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Qc), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Kc)
+                        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(du), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(uu)
                     }
-                }, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = sc, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TOUCH = {
+                }, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = yh, e.SubtractEquation = y, e.SubtractiveBlending = f, e.TOUCH = {
                     ROTATE: 0,
                     PAN: 1,
                     DOLLY_PAN: 2,
                     DOLLY_ROTATE: 3
-                }, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = Pl, e.TetrahedronGeometry = Pl, e.TextGeometry = function() {
-                    return console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), new Nn
-                }, e.Texture = kt, e.TextureLoader = xc, e.TorusBufferGeometry = Dl, e.TorusGeometry = Dl, e.TorusKnotBufferGeometry = Il, e.TorusKnotGeometry = Il, e.Triangle = hn, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = Nl, e.TubeGeometry = Nl, e.UVMapping = r, e.Uint16Attribute = function(t, e) {
-                    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Mn(t, e)
-                }, e.Uint16BufferAttribute = Mn, e.Uint32Attribute = function(t, e) {
-                    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new wn(t, e)
-                }, e.Uint32BufferAttribute = wn, e.Uint8Attribute = function(t, e) {
-                    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new xn(t, e)
-                }, e.Uint8BufferAttribute = xn, e.Uint8ClampedAttribute = function(t, e) {
-                    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new yn(t, e)
-                }, e.Uint8ClampedBufferAttribute = yn, e.Uniform = Th, e.UniformsLib = bi, e.UniformsUtils = ii, e.UnsignedByteType = _, e.UnsignedInt248Type = E, e.UnsignedIntType = b, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShortType = M, e.VSMShadowMap = 3, e.Vector2 = At, e.Vector3 = Zt, e.Vector4 = jt, e.VectorKeyframeTrack = ac, e.Vertex = function(t, e, n) {
-                    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Zt(t, e, n)
-                }, e.VertexColors = 2, e.VideoTexture = po, e.WebGL1Renderer = sa, e.WebGLCubeRenderTarget = hi, e.WebGLMultipleRenderTargets = qt, e.WebGLMultisampleRenderTarget = Yt, e.WebGLRenderTarget = Xt, e.WebGLRenderTargetCube = function(t, e, n) {
-                    return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new hi(t, n)
-                }, e.WebGLRenderer = ra, e.WebGLUtils = Zs, e.WireframeGeometry = Ol, e.WireframeHelper = function(t, e) {
-                    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new io(new Ol(t.geometry), new Ya({
+                }, e.TangentSpaceNormalMap = ve, e.TetrahedronBufferGeometry = jc, e.TetrahedronGeometry = jc, e.TextGeometry = function() {
+                    return console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), new Wi
+                }, e.Texture = $e, e.TextureLoader = Dh, e.TorusBufferGeometry = Xc, e.TorusGeometry = Xc, e.TorusKnotBufferGeometry = qc, e.TorusKnotGeometry = qc, e.Triangle = _i, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = Yc, e.TubeGeometry = Yc, e.UVMapping = K, e.Uint16Attribute = function(t, e) {
+                    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Pi(t, e)
+                }, e.Uint16BufferAttribute = Pi, e.Uint32Attribute = function(t, e) {
+                    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Ii(t, e)
+                }, e.Uint32BufferAttribute = Ii, e.Uint8Attribute = function(t, e) {
+                    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Ri(t, e)
+                }, e.Uint8BufferAttribute = Ri, e.Uint8ClampedAttribute = function(t, e) {
+                    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Li(t, e)
+                }, e.Uint8ClampedBufferAttribute = Li, e.Uniform = Gu, e.UniformsLib = Dr, e.UniformsUtils = pr, e.UnsignedByteType = pt, e.UnsignedInt248Type = wt, e.UnsignedIntType = xt, e.UnsignedShort4444Type = Mt, e.UnsignedShort5551Type = bt, e.UnsignedShortType = gt, e.VSMShadowMap = l, e.Vector2 = Be, e.Vector3 = on, e.Vector4 = en, e.VectorKeyframeTrack = _h, e.Vertex = function(t, e, n) {
+                    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new on(t, e, n)
+                }, e.VertexColors = 2, e.VideoTexture = Al, e.WebGL1Renderer = _o, e.WebGLCubeRenderTarget = _r, e.WebGLMultipleRenderTargets = rn, e.WebGLMultisampleRenderTarget = sn, e.WebGLRenderTarget = nn, e.WebGLRenderTargetCube = function(t, e, n) {
+                    return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new _r(t, n)
+                }, e.WebGLRenderer = yo, e.WebGLUtils = ho, e.WireframeGeometry = Jc, e.WireframeHelper = function(t, e) {
+                    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new xl(new Jc(t.geometry), new cl({
                         color: void 0 !== e ? e : 16777215
                     }))
-                }, e.WrapAroundEnding = st, e.XHRLoader = function(t) {
-                    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new mc(t)
-                }, e.ZeroCurvatureEnding = it, e.ZeroFactor = 200, e.ZeroSlopeEnding = rt, e.ZeroStencilOp = 0, e._SRGBAFormat = pt, e.sRGBEncoding = lt
+                }, e.WrapAroundEnding = de, e.XHRLoader = function(t) {
+                    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Rh(t)
+                }, e.ZeroCurvatureEnding = he, e.ZeroFactor = w, e.ZeroSlopeEnding = ue, e.ZeroStencilOp = 0, e._SRGBAFormat = we, e.sRGBEncoding = fe
             },
-            296: (t, e, n) => {
+            379: (t, e, n) => {
                 n.r(e), n.d(e, {
-                    MapControls: () => _l,
-                    OrbitControls: () => yl
+                    MapControls: () => ch,
+                    OrbitControls: () => lh
                 });
-                const i = 100,
-                    r = 301,
-                    s = 302,
-                    a = 306,
-                    o = 1e3,
-                    l = 1001,
-                    c = 1002,
-                    h = 1003,
-                    u = 1006,
-                    d = 1008,
-                    p = 1009,
-                    m = 1012,
-                    f = 1014,
-                    g = 1015,
-                    v = 1016,
-                    x = 1020,
-                    y = 1023,
-                    _ = 1026,
-                    M = 1027,
-                    b = 33776,
-                    w = 33777,
-                    S = 33778,
-                    E = 33779,
-                    T = 2300,
-                    A = 2301,
-                    R = 2302,
-                    L = 2400,
-                    C = 2401,
-                    P = 2402,
-                    D = 3e3,
-                    I = 3001,
-                    N = 7680,
-                    O = 35044,
-                    U = 35048,
-                    B = "300 es",
-                    F = 1035;
-                class z {
+                const i = "137",
+                    r = 0,
+                    s = 1,
+                    a = 2,
+                    o = 1,
+                    l = 2,
+                    c = 3,
+                    h = 0,
+                    u = 1,
+                    d = 2,
+                    p = 0,
+                    m = 1,
+                    f = 2,
+                    g = 3,
+                    v = 4,
+                    x = 5,
+                    y = 100,
+                    _ = 101,
+                    M = 102,
+                    b = 103,
+                    w = 104,
+                    S = 200,
+                    E = 201,
+                    T = 202,
+                    A = 203,
+                    R = 204,
+                    L = 205,
+                    C = 206,
+                    P = 207,
+                    D = 208,
+                    I = 209,
+                    N = 210,
+                    O = 0,
+                    U = 1,
+                    B = 2,
+                    F = 3,
+                    z = 4,
+                    H = 5,
+                    G = 6,
+                    V = 7,
+                    k = 0,
+                    W = 1,
+                    j = 2,
+                    X = 0,
+                    q = 1,
+                    Y = 2,
+                    J = 3,
+                    Z = 4,
+                    K = 5,
+                    Q = 301,
+                    $ = 302,
+                    tt = 303,
+                    et = 304,
+                    nt = 306,
+                    it = 307,
+                    rt = 1e3,
+                    st = 1001,
+                    at = 1002,
+                    ot = 1003,
+                    lt = 1004,
+                    ct = 1005,
+                    ht = 1006,
+                    ut = 1007,
+                    dt = 1008,
+                    pt = 1009,
+                    mt = 1010,
+                    ft = 1011,
+                    gt = 1012,
+                    vt = 1013,
+                    xt = 1014,
+                    yt = 1015,
+                    _t = 1016,
+                    Mt = 1017,
+                    bt = 1018,
+                    wt = 1020,
+                    St = 1021,
+                    Et = 1023,
+                    Tt = 1024,
+                    At = 1025,
+                    Rt = 1026,
+                    Lt = 1027,
+                    Ct = 1028,
+                    Pt = 1029,
+                    Dt = 1030,
+                    It = 1031,
+                    Nt = 1033,
+                    Ot = 33776,
+                    Ut = 33777,
+                    Bt = 33778,
+                    Ft = 33779,
+                    zt = 35840,
+                    Ht = 35841,
+                    Gt = 35842,
+                    Vt = 35843,
+                    kt = 36196,
+                    Wt = 37492,
+                    jt = 37496,
+                    Xt = 37808,
+                    qt = 37809,
+                    Yt = 37810,
+                    Jt = 37811,
+                    Zt = 37812,
+                    Kt = 37813,
+                    Qt = 37814,
+                    $t = 37815,
+                    te = 37816,
+                    ee = 37817,
+                    ne = 37818,
+                    ie = 37819,
+                    re = 37820,
+                    se = 37821,
+                    ae = 36492,
+                    oe = 2300,
+                    le = 2301,
+                    ce = 2302,
+                    he = 2400,
+                    ue = 2401,
+                    de = 2402,
+                    pe = 3e3,
+                    me = 3001,
+                    fe = 3201,
+                    ge = 0,
+                    ve = 1,
+                    xe = 7680,
+                    ye = 35044,
+                    _e = 35048,
+                    Me = "300 es",
+                    be = 1035;
+                class we {
                     addEventListener(t, e) {
                         void 0 === this._listeners && (this._listeners = {});
                         const n = this._listeners;
                         void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                     }
                     hasEventListener(t, e) {
                         if (void 0 === this._listeners) return !1;
@@ -16692,43 +17076,43 @@
                             t.target = this;
                             const n = e.slice(0);
                             for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                             t.target = null
                         }
                     }
                 }
-                const H = [];
-                for (let t = 0; t < 256; t++) H[t] = (t < 16 ? "0" : "") + t.toString(16);
-                const G = Math.PI / 180,
-                    V = 180 / Math.PI;
+                const Se = [];
+                for (let t = 0; t < 256; t++) Se[t] = (t < 16 ? "0" : "") + t.toString(16);
+                const Ee = Math.PI / 180,
+                    Te = 180 / Math.PI;
 
-                function k() {
+                function Ae() {
                     const t = 4294967295 * Math.random() | 0,
                         e = 4294967295 * Math.random() | 0,
                         n = 4294967295 * Math.random() | 0,
                         i = 4294967295 * Math.random() | 0;
-                    return (H[255 & t] + H[t >> 8 & 255] + H[t >> 16 & 255] + H[t >> 24 & 255] + "-" + H[255 & e] + H[e >> 8 & 255] + "-" + H[e >> 16 & 15 | 64] + H[e >> 24 & 255] + "-" + H[63 & n | 128] + H[n >> 8 & 255] + "-" + H[n >> 16 & 255] + H[n >> 24 & 255] + H[255 & i] + H[i >> 8 & 255] + H[i >> 16 & 255] + H[i >> 24 & 255]).toUpperCase()
+                    return (Se[255 & t] + Se[t >> 8 & 255] + Se[t >> 16 & 255] + Se[t >> 24 & 255] + "-" + Se[255 & e] + Se[e >> 8 & 255] + "-" + Se[e >> 16 & 15 | 64] + Se[e >> 24 & 255] + "-" + Se[63 & n | 128] + Se[n >> 8 & 255] + "-" + Se[n >> 16 & 255] + Se[n >> 24 & 255] + Se[255 & i] + Se[i >> 8 & 255] + Se[i >> 16 & 255] + Se[i >> 24 & 255]).toUpperCase()
                 }
 
-                function W(t, e, n) {
+                function Re(t, e, n) {
                     return Math.max(e, Math.min(n, t))
                 }
 
-                function j(t, e, n) {
+                function Le(t, e, n) {
                     return (1 - n) * t + n * e
                 }
 
-                function X(t) {
+                function Ce(t) {
                     return 0 == (t & t - 1) && 0 !== t
                 }
 
-                function q(t) {
+                function Pe(t) {
                     return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                 }
-                class Y {
+                class De {
                     constructor(t = 0, e = 0) {
                         this.x = t, this.y = e
                     }
                     get width() {
                         return this.x
                     }
                     set width(t) {
@@ -16913,16 +17297,16 @@
                     }
                     random() {
                         return this.x = Math.random(), this.y = Math.random(), this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y
                     }
                 }
-                Y.prototype.isVector2 = !0;
-                class J {
+                De.prototype.isVector2 = !0;
+                class Ie {
                     constructor() {
                         this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                     }
                     set(t, e, n, i, r, s, a, o, l) {
                         const c = this.elements;
                         return c[0] = t, c[1] = i, c[2] = a, c[3] = e, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this
                     }
@@ -17060,25 +17444,25 @@
                         return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                     }
                     clone() {
                         return (new this.constructor).fromArray(this.elements)
                     }
                 }
 
-                function Z(t) {
+                function Ne(t) {
                     for (let e = t.length - 1; e >= 0; --e)
                         if (t[e] > 65535) return !0;
                     return !1
                 }
 
-                function K(t) {
+                function Oe(t) {
                     return document.createElementNS("http://www.w3.org/1999/xhtml", t)
                 }
-                J.prototype.isMatrix3 = !0, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
-                const Q = {
+                Ie.prototype.isMatrix3 = !0, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
+                const Ue = {
                         aliceblue: 15792383,
                         antiquewhite: 16444375,
                         aqua: 65535,
                         aquamarine: 8388564,
                         azure: 15794175,
                         beige: 16119260,
                         bisque: 16770244,
@@ -17220,37 +17604,37 @@
                         violet: 15631086,
                         wheat: 16113331,
                         white: 16777215,
                         whitesmoke: 16119285,
                         yellow: 16776960,
                         yellowgreen: 10145074
                     },
-                    $ = {
+                    Be = {
                         h: 0,
                         s: 0,
                         l: 0
                     },
-                    tt = {
+                    Fe = {
                         h: 0,
                         s: 0,
                         l: 0
                     };
 
-                function et(t, e, n) {
+                function ze(t, e, n) {
                     return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                 }
 
-                function nt(t) {
+                function He(t) {
                     return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                 }
 
-                function it(t) {
+                function Ge(t) {
                     return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                 }
-                class rt {
+                class Ve {
                     constructor(t, e, n) {
                         return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
                     }
                     set(t) {
                         return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                     }
                     setScalar(t) {
@@ -17259,19 +17643,19 @@
                     setHex(t) {
                         return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                     }
                     setRGB(t, e, n) {
                         return this.r = t, this.g = e, this.b = n, this
                     }
                     setHSL(t, e, n) {
-                        if (t = (t % (i = 1) + i) % i, e = W(e, 0, 1), n = W(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
+                        if (t = (t % (i = 1) + i) % i, e = Re(e, 0, 1), n = Re(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                         else {
                             const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                                 r = 2 * n - i;
-                            this.r = et(r, i, t + 1 / 3), this.g = et(r, i, t), this.b = et(r, i, t - 1 / 3)
+                            this.r = ze(r, i, t + 1 / 3), this.g = ze(r, i, t), this.b = ze(r, i, t - 1 / 3)
                         }
                         var i;
                         return this
                     }
                     setStyle(t) {
                         function e(e) {
                             void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
@@ -17301,28 +17685,28 @@
                                 e = t.length;
                             if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                             if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                         }
                         return t && t.length > 0 ? this.setColorName(t) : this
                     }
                     setColorName(t) {
-                        const e = Q[t.toLowerCase()];
+                        const e = Ue[t.toLowerCase()];
                         return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
                     }
                     clone() {
                         return new this.constructor(this.r, this.g, this.b)
                     }
                     copy(t) {
                         return this.r = t.r, this.g = t.g, this.b = t.b, this
                     }
                     copySRGBToLinear(t) {
-                        return this.r = nt(t.r), this.g = nt(t.g), this.b = nt(t.b), this
+                        return this.r = He(t.r), this.g = He(t.g), this.b = He(t.b), this
                     }
                     copyLinearToSRGB(t) {
-                        return this.r = it(t.r), this.g = it(t.g), this.b = it(t.b), this
+                        return this.r = Ge(t.r), this.g = Ge(t.g), this.b = Ge(t.b), this
                     }
                     convertSRGBToLinear() {
                         return this.copySRGBToLinear(this), this
                     }
                     convertLinearToSRGB() {
                         return this.copyLinearToSRGB(this), this
                     }
@@ -17357,15 +17741,15 @@
                         }
                         return t.h = a, t.s = o, t.l = l, t
                     }
                     getStyle() {
                         return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                     }
                     offsetHSL(t, e, n) {
-                        return this.getHSL($), $.h += t, $.s += e, $.l += n, this.setHSL($.h, $.s, $.l), this
+                        return this.getHSL(Be), Be.h += t, Be.s += e, Be.l += n, this.setHSL(Be.h, Be.s, Be.l), this
                     }
                     add(t) {
                         return this.r += t.r, this.g += t.g, this.b += t.b, this
                     }
                     addColors(t, e) {
                         return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                     }
@@ -17384,18 +17768,18 @@
                     lerp(t, e) {
                         return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                     }
                     lerpColors(t, e, n) {
                         return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
                     }
                     lerpHSL(t, e) {
-                        this.getHSL($), t.getHSL(tt);
-                        const n = j($.h, tt.h, e),
-                            i = j($.s, tt.s, e),
-                            r = j($.l, tt.l, e);
+                        this.getHSL(Be), t.getHSL(Fe);
+                        const n = Le(Be.h, Fe.h, e),
+                            i = Le(Be.s, Fe.s, e),
+                            r = Le(Be.l, Fe.l, e);
                         return this.setHSL(n, i, r), this
                     }
                     equals(t) {
                         return t.r === this.r && t.g === this.g && t.b === this.b
                     }
                     fromArray(t, e = 0) {
                         return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
@@ -17406,58 +17790,58 @@
                     fromBufferAttribute(t, e) {
                         return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                     }
                     toJSON() {
                         return this.getHex()
                     }
                 }
-                let st;
-                rt.NAMES = Q, rt.prototype.isColor = !0, rt.prototype.r = 1, rt.prototype.g = 1, rt.prototype.b = 1;
-                class at {
+                let ke;
+                Ve.NAMES = Ue, Ve.prototype.isColor = !0, Ve.prototype.r = 1, Ve.prototype.g = 1, Ve.prototype.b = 1;
+                class We {
                     static getDataURL(t) {
                         if (/^data:/i.test(t.src)) return t.src;
                         if ("undefined" == typeof HTMLCanvasElement) return t.src;
                         let e;
                         if (t instanceof HTMLCanvasElement) e = t;
                         else {
-                            void 0 === st && (st = K("canvas")), st.width = t.width, st.height = t.height;
-                            const n = st.getContext("2d");
-                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = st
+                            void 0 === ke && (ke = Oe("canvas")), ke.width = t.width, ke.height = t.height;
+                            const n = ke.getContext("2d");
+                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = ke
                         }
                         return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                     }
                     static sRGBToLinear(t) {
                         if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
-                            const e = K("canvas");
+                            const e = Oe("canvas");
                             e.width = t.width, e.height = t.height;
                             const n = e.getContext("2d");
                             n.drawImage(t, 0, 0, t.width, t.height);
                             const i = n.getImageData(0, 0, t.width, t.height),
                                 r = i.data;
-                            for (let t = 0; t < r.length; t++) r[t] = 255 * nt(r[t] / 255);
+                            for (let t = 0; t < r.length; t++) r[t] = 255 * He(r[t] / 255);
                             return n.putImageData(i, 0, 0), e
                         }
                         if (t.data) {
                             const e = t.data.slice(0);
-                            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * nt(e[t] / 255)) : e[t] = nt(e[t]);
+                            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * He(e[t] / 255)) : e[t] = He(e[t]);
                             return {
                                 data: e,
                                 width: t.width,
                                 height: t.height
                             }
                         }
                         return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
                     }
                 }
-                let ot = 0;
-                class lt extends z {
-                    constructor(t = lt.DEFAULT_IMAGE, e = lt.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = 1, c = 3e3) {
+                let je = 0;
+                class Xe extends we {
+                    constructor(t = Xe.DEFAULT_IMAGE, e = Xe.DEFAULT_MAPPING, n = st, i = st, r = ht, s = dt, a = Et, o = pt, l = 1, c = pe) {
                         super(), Object.defineProperty(this, "id", {
-                            value: ot++
-                        }), this.uuid = k(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new Y(0, 0), this.repeat = new Y(1, 1), this.center = new Y(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new J, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
+                            value: je++
+                        }), this.uuid = Ae(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new De(0, 0), this.repeat = new De(1, 1), this.center = new De(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ie, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                     }
                     updateMatrix() {
                         this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
@@ -17489,20 +17873,20 @@
                             anisotropy: this.anisotropy,
                             flipY: this.flipY,
                             premultiplyAlpha: this.premultiplyAlpha,
                             unpackAlignment: this.unpackAlignment
                         };
                         if (void 0 !== this.image) {
                             const i = this.image;
-                            if (void 0 === i.uuid && (i.uuid = k()), !e && void 0 === t.images[i.uuid]) {
+                            if (void 0 === i.uuid && (i.uuid = Ae()), !e && void 0 === t.images[i.uuid]) {
                                 let e;
                                 if (Array.isArray(i)) {
                                     e = [];
-                                    for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(ct(i[t].image)) : e.push(ct(i[t]))
-                                } else e = ct(i);
+                                    for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(qe(i[t].image)) : e.push(qe(i[t]))
+                                } else e = qe(i);
                                 t.images[i.uuid] = {
                                     uuid: i.uuid,
                                     url: e
                                 }
                             }
                             n.image = i.uuid
                         }
@@ -17512,50 +17896,50 @@
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                     transformUv(t) {
                         if (300 !== this.mapping) return t;
                         if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
-                            case o:
+                            case rt:
                                 t.x = t.x - Math.floor(t.x);
                                 break;
-                            case l:
+                            case st:
                                 t.x = t.x < 0 ? 0 : 1;
                                 break;
-                            case c:
+                            case at:
                                 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                         }
                         if (t.y < 0 || t.y > 1) switch (this.wrapT) {
-                            case o:
+                            case rt:
                                 t.y = t.y - Math.floor(t.y);
                                 break;
-                            case l:
+                            case st:
                                 t.y = t.y < 0 ? 0 : 1;
                                 break;
-                            case c:
+                            case at:
                                 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                         }
                         return this.flipY && (t.y = 1 - t.y), t
                     }
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                 }
 
-                function ct(t) {
-                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? at.getDataURL(t) : t.data ? {
+                function qe(t) {
+                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? We.getDataURL(t) : t.data ? {
                         data: Array.prototype.slice.call(t.data),
                         width: t.width,
                         height: t.height,
                         type: t.data.constructor.name
                     } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
                 }
-                lt.DEFAULT_IMAGE = void 0, lt.DEFAULT_MAPPING = 300, lt.prototype.isTexture = !0;
-                class ht {
+                Xe.DEFAULT_IMAGE = void 0, Xe.DEFAULT_MAPPING = 300, Xe.prototype.isTexture = !0;
+                class Ye {
                     constructor(t = 0, e = 0, n = 0, i = 1) {
                         this.x = t, this.y = e, this.z = n, this.w = i
                     }
                     get width() {
                         return this.z
                     }
                     set width(t) {
@@ -17764,22 +18148,22 @@
                     }
                     random() {
                         return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y, yield this.z, yield this.w
                     }
                 }
-                ht.prototype.isVector4 = !0;
-                class ut extends z {
+                Ye.prototype.isVector4 = !0;
+                class Je extends we {
                     constructor(t, e, n = {}) {
-                        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new ht(0, 0, t, e), this.scissorTest = !1, this.viewport = new ht(0, 0, t, e), this.texture = new lt(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
+                        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new Ye(0, 0, t, e), this.scissorTest = !1, this.viewport = new Ye(0, 0, t, e), this.texture = new Xe(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                             width: t,
                             height: e,
                             depth: 1
-                        }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : u, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
+                        }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ht, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
                     }
                     setTexture(t) {
                         t.image = {
                             width: this.width,
                             height: this.height,
                             depth: this.depth
                         }, this.texture = t
@@ -17795,15 +18179,15 @@
                     }
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }
-                ut.prototype.isWebGLRenderTarget = !0, class extends ut {
+                Je.prototype.isWebGLRenderTarget = !0, class extends Je {
                     constructor(t, e, n) {
                         super(t, e);
                         const i = this.texture;
                         this.texture = [];
                         for (let t = 0; t < n; t++) this.texture[t] = i.clone()
                     }
                     setSize(t, e, n = 1) {
@@ -17816,24 +18200,24 @@
                     }
                     copy(t) {
                         this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
                         for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
                         return this
                     }
                 }.prototype.isWebGLMultipleRenderTargets = !0;
-                class dt extends ut {
+                class Ze extends Je {
                     constructor(t, e, n = {}) {
                         super(t, e, n), this.samples = 4, this.ignoreDepthForMultisampleCopy = void 0 === n.ignoreDepth || n.ignoreDepth, this.useRenderToTexture = void 0 !== n.useRenderToTexture && n.useRenderToTexture, this.useRenderbuffer = !1 === this.useRenderToTexture
                     }
                     copy(t) {
                         return super.copy.call(this, t), this.samples = t.samples, this.useRenderToTexture = t.useRenderToTexture, this.useRenderbuffer = t.useRenderbuffer, this
                     }
                 }
-                dt.prototype.isWebGLMultisampleRenderTarget = !0;
-                class pt {
+                Ze.prototype.isWebGLMultisampleRenderTarget = !0;
+                class Ke {
                     constructor(t = 0, e = 0, n = 0, i = 1) {
                         this._x = t, this._y = e, this._z = n, this._w = i
                     }
                     static slerp(t, e, n, i) {
                         return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i)
                     }
                     static slerpFlat(t, e, n, i, r, s, a) {
@@ -17980,15 +18364,15 @@
                         return this._onChangeCallback(), this
                     }
                     setFromUnitVectors(t, e) {
                         let n = t.dot(e) + 1;
                         return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                     }
                     angleTo(t) {
-                        return 2 * Math.acos(Math.abs(W(this.dot(t), -1, 1)))
+                        return 2 * Math.acos(Math.abs(Re(this.dot(t), -1, 1)))
                     }
                     rotateTowards(t, e) {
                         const n = this.angleTo(t);
                         if (0 === n) return this;
                         const i = Math.min(1, e / n);
                         return this.slerp(t, i), this
                     }
@@ -18075,16 +18459,16 @@
                         return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                     }
                     _onChange(t) {
                         return this._onChangeCallback = t, this
                     }
                     _onChangeCallback() {}
                 }
-                pt.prototype.isQuaternion = !0;
-                class mt {
+                Ke.prototype.isQuaternion = !0;
+                class Qe {
                     constructor(t = 0, e = 0, n = 0) {
                         this.x = t, this.y = e, this.z = n
                     }
                     set(t, e, n) {
                         return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
                     }
                     setScalar(t) {
@@ -18160,18 +18544,18 @@
                     multiplyScalar(t) {
                         return this.x *= t, this.y *= t, this.z *= t, this
                     }
                     multiplyVectors(t, e) {
                         return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                     }
                     applyEuler(t) {
-                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(gt.setFromEuler(t))
+                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(tn.setFromEuler(t))
                     }
                     applyAxisAngle(t, e) {
-                        return this.applyQuaternion(gt.setFromAxisAngle(t, e))
+                        return this.applyQuaternion(tn.setFromAxisAngle(t, e))
                     }
                     applyMatrix3(t) {
                         const e = this.x,
                             n = this.y,
                             i = this.z,
                             r = t.elements;
                         return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
@@ -18290,24 +18674,24 @@
                     projectOnVector(t) {
                         const e = t.lengthSq();
                         if (0 === e) return this.set(0, 0, 0);
                         const n = t.dot(this) / e;
                         return this.copy(t).multiplyScalar(n)
                     }
                     projectOnPlane(t) {
-                        return ft.copy(this).projectOnVector(t), this.sub(ft)
+                        return $e.copy(this).projectOnVector(t), this.sub($e)
                     }
                     reflect(t) {
-                        return this.sub(ft.copy(t).multiplyScalar(2 * this.dot(t)))
+                        return this.sub($e.copy(t).multiplyScalar(2 * this.dot(t)))
                     }
                     angleTo(t) {
                         const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                         if (0 === e) return Math.PI / 2;
                         const n = this.dot(t) / e;
-                        return Math.acos(W(n, -1, 1))
+                        return Math.acos(Re(n, -1, 1))
                     }
                     distanceTo(t) {
                         return Math.sqrt(this.distanceToSquared(t))
                     }
                     distanceToSquared(t) {
                         const e = this.x - t.x,
                             n = this.y - t.y,
@@ -18366,19 +18750,19 @@
                             e = Math.random() * Math.PI * 2,
                             n = Math.sqrt(1 - t ** 2);
                         return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
                     }*[Symbol.iterator]() {
                         yield this.x, yield this.y, yield this.z
                     }
                 }
-                mt.prototype.isVector3 = !0;
-                const ft = new mt,
-                    gt = new pt;
-                class vt {
-                    constructor(t = new mt(1 / 0, 1 / 0, 1 / 0), e = new mt(-1 / 0, -1 / 0, -1 / 0)) {
+                Qe.prototype.isVector3 = !0;
+                const $e = new Qe,
+                    tn = new Ke;
+                class en {
+                    constructor(t = new Qe(1 / 0, 1 / 0, 1 / 0), e = new Qe(-1 / 0, -1 / 0, -1 / 0)) {
                         this.min = t, this.max = e
                     }
                     set(t, e) {
                         return this.min.copy(t), this.max.copy(e), this
                     }
                     setFromArray(t) {
                         let e = 1 / 0,
@@ -18412,15 +18796,15 @@
                     }
                     setFromPoints(t) {
                         this.makeEmpty();
                         for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                         return this
                     }
                     setFromCenterAndSize(t, e) {
-                        const n = yt.copy(e).multiplyScalar(.5);
+                        const n = rn.copy(e).multiplyScalar(.5);
                         return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                     }
                     setFromObject(t, e = !1) {
                         return this.makeEmpty(), this.expandByObject(t, e)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
@@ -18451,16 +18835,16 @@
                     }
                     expandByObject(t, e = !1) {
                         t.updateWorldMatrix(!1, !1);
                         const n = t.geometry;
                         if (void 0 !== n)
                             if (e && null != n.attributes && void 0 !== n.attributes.position) {
                                 const e = n.attributes.position;
-                                for (let n = 0, i = e.count; n < i; n++) yt.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(yt)
-                            } else null === n.boundingBox && n.computeBoundingBox(), _t.copy(n.boundingBox), _t.applyMatrix4(t.matrixWorld), this.union(_t);
+                                for (let n = 0, i = e.count; n < i; n++) rn.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(rn)
+                            } else null === n.boundingBox && n.computeBoundingBox(), sn.copy(n.boundingBox), sn.applyMatrix4(t.matrixWorld), this.union(sn);
                         const i = t.children;
                         for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
                         return this
                     }
                     containsPoint(t) {
                         return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                     }
@@ -18470,91 +18854,91 @@
                     getParameter(t, e) {
                         return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                     }
                     intersectsBox(t) {
                         return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                     }
                     intersectsSphere(t) {
-                        return this.clampPoint(t.center, yt), yt.distanceToSquared(t.center) <= t.radius * t.radius
+                        return this.clampPoint(t.center, rn), rn.distanceToSquared(t.center) <= t.radius * t.radius
                     }
                     intersectsPlane(t) {
                         let e, n;
                         return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                     }
                     intersectsTriangle(t) {
                         if (this.isEmpty()) return !1;
-                        this.getCenter(At), Rt.subVectors(this.max, At), Mt.subVectors(t.a, At), bt.subVectors(t.b, At), wt.subVectors(t.c, At), St.subVectors(bt, Mt), Et.subVectors(wt, bt), Tt.subVectors(Mt, wt);
-                        let e = [0, -St.z, St.y, 0, -Et.z, Et.y, 0, -Tt.z, Tt.y, St.z, 0, -St.x, Et.z, 0, -Et.x, Tt.z, 0, -Tt.x, -St.y, St.x, 0, -Et.y, Et.x, 0, -Tt.y, Tt.x, 0];
-                        return !!Pt(e, Mt, bt, wt, Rt) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Pt(e, Mt, bt, wt, Rt) && (Lt.crossVectors(St, Et), e = [Lt.x, Lt.y, Lt.z], Pt(e, Mt, bt, wt, Rt)))
+                        this.getCenter(dn), pn.subVectors(this.max, dn), an.subVectors(t.a, dn), on.subVectors(t.b, dn), ln.subVectors(t.c, dn), cn.subVectors(on, an), hn.subVectors(ln, on), un.subVectors(an, ln);
+                        let e = [0, -cn.z, cn.y, 0, -hn.z, hn.y, 0, -un.z, un.y, cn.z, 0, -cn.x, hn.z, 0, -hn.x, un.z, 0, -un.x, -cn.y, cn.x, 0, -hn.y, hn.x, 0, -un.y, un.x, 0];
+                        return !!gn(e, an, on, ln, pn) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!gn(e, an, on, ln, pn) && (mn.crossVectors(cn, hn), e = [mn.x, mn.y, mn.z], gn(e, an, on, ln, pn)))
                     }
                     clampPoint(t, e) {
                         return e.copy(t).clamp(this.min, this.max)
                     }
                     distanceToPoint(t) {
-                        return yt.copy(t).clamp(this.min, this.max).sub(t).length()
+                        return rn.copy(t).clamp(this.min, this.max).sub(t).length()
                     }
                     getBoundingSphere(t) {
-                        return this.getCenter(t.center), t.radius = .5 * this.getSize(yt).length(), t
+                        return this.getCenter(t.center), t.radius = .5 * this.getSize(rn).length(), t
                     }
                     intersect(t) {
                         return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                     }
                     union(t) {
                         return this.min.min(t.min), this.max.max(t.max), this
                     }
                     applyMatrix4(t) {
-                        return this.isEmpty() || (xt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), xt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), xt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), xt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), xt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), xt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), xt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), xt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(xt)), this
+                        return this.isEmpty() || (nn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), nn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), nn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), nn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), nn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), nn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), nn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), nn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(nn)), this
                     }
                     translate(t) {
                         return this.min.add(t), this.max.add(t), this
                     }
                     equals(t) {
                         return t.min.equals(this.min) && t.max.equals(this.max)
                     }
                 }
-                vt.prototype.isBox3 = !0;
-                const xt = [new mt, new mt, new mt, new mt, new mt, new mt, new mt, new mt],
-                    yt = new mt,
-                    _t = new vt,
-                    Mt = new mt,
-                    bt = new mt,
-                    wt = new mt,
-                    St = new mt,
-                    Et = new mt,
-                    Tt = new mt,
-                    At = new mt,
-                    Rt = new mt,
-                    Lt = new mt,
-                    Ct = new mt;
+                en.prototype.isBox3 = !0;
+                const nn = [new Qe, new Qe, new Qe, new Qe, new Qe, new Qe, new Qe, new Qe],
+                    rn = new Qe,
+                    sn = new en,
+                    an = new Qe,
+                    on = new Qe,
+                    ln = new Qe,
+                    cn = new Qe,
+                    hn = new Qe,
+                    un = new Qe,
+                    dn = new Qe,
+                    pn = new Qe,
+                    mn = new Qe,
+                    fn = new Qe;
 
-                function Pt(t, e, n, i, r) {
+                function gn(t, e, n, i, r) {
                     for (let s = 0, a = t.length - 3; s <= a; s += 3) {
-                        Ct.fromArray(t, s);
-                        const a = r.x * Math.abs(Ct.x) + r.y * Math.abs(Ct.y) + r.z * Math.abs(Ct.z),
-                            o = e.dot(Ct),
-                            l = n.dot(Ct),
-                            c = i.dot(Ct);
+                        fn.fromArray(t, s);
+                        const a = r.x * Math.abs(fn.x) + r.y * Math.abs(fn.y) + r.z * Math.abs(fn.z),
+                            o = e.dot(fn),
+                            l = n.dot(fn),
+                            c = i.dot(fn);
                         if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
                     }
                     return !0
                 }
-                const Dt = new vt,
-                    It = new mt,
-                    Nt = new mt,
-                    Ot = new mt;
-                class Ut {
-                    constructor(t = new mt, e = -1) {
+                const vn = new en,
+                    xn = new Qe,
+                    yn = new Qe,
+                    _n = new Qe;
+                class Mn {
+                    constructor(t = new Qe, e = -1) {
                         this.center = t, this.radius = e
                     }
                     set(t, e) {
                         return this.center.copy(t), this.radius = e, this
                     }
                     setFromPoints(t, e) {
                         const n = this.center;
-                        void 0 !== e ? n.copy(e) : Dt.setFromPoints(t).getCenter(n);
+                        void 0 !== e ? n.copy(e) : vn.setFromPoints(t).getCenter(n);
                         let i = 0;
                         for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                         return this.radius = Math.sqrt(i), this
                     }
                     copy(t) {
                         return this.center.copy(t.center), this.radius = t.radius, this
                     }
@@ -18590,42 +18974,42 @@
                     applyMatrix4(t) {
                         return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                     }
                     translate(t) {
                         return this.center.add(t), this
                     }
                     expandByPoint(t) {
-                        Ot.subVectors(t, this.center);
-                        const e = Ot.lengthSq();
+                        _n.subVectors(t, this.center);
+                        const e = _n.lengthSq();
                         if (e > this.radius * this.radius) {
                             const t = Math.sqrt(e),
                                 n = .5 * (t - this.radius);
-                            this.center.add(Ot.multiplyScalar(n / t)), this.radius += n
+                            this.center.add(_n.multiplyScalar(n / t)), this.radius += n
                         }
                         return this
                     }
                     union(t) {
-                        return !0 === this.center.equals(t.center) ? Nt.set(0, 0, 1).multiplyScalar(t.radius) : Nt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(It.copy(t.center).add(Nt)), this.expandByPoint(It.copy(t.center).sub(Nt)), this
+                        return !0 === this.center.equals(t.center) ? yn.set(0, 0, 1).multiplyScalar(t.radius) : yn.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(xn.copy(t.center).add(yn)), this.expandByPoint(xn.copy(t.center).sub(yn)), this
                     }
                     equals(t) {
                         return t.center.equals(this.center) && t.radius === this.radius
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                const Bt = new mt,
-                    Ft = new mt,
-                    zt = new mt,
-                    Ht = new mt,
-                    Gt = new mt,
-                    Vt = new mt,
-                    kt = new mt;
-                class Wt {
-                    constructor(t = new mt, e = new mt(0, 0, -1)) {
+                const bn = new Qe,
+                    wn = new Qe,
+                    Sn = new Qe,
+                    En = new Qe,
+                    Tn = new Qe,
+                    An = new Qe,
+                    Rn = new Qe;
+                class Ln {
+                    constructor(t = new Qe, e = new Qe(0, 0, -1)) {
                         this.origin = t, this.direction = e
                     }
                     set(t, e) {
                         return this.origin.copy(t), this.direction.copy(e), this
                     }
                     copy(t) {
                         return this.origin.copy(t.origin), this.direction.copy(t.direction), this
@@ -18633,53 +19017,53 @@
                     at(t, e) {
                         return e.copy(this.direction).multiplyScalar(t).add(this.origin)
                     }
                     lookAt(t) {
                         return this.direction.copy(t).sub(this.origin).normalize(), this
                     }
                     recast(t) {
-                        return this.origin.copy(this.at(t, Bt)), this
+                        return this.origin.copy(this.at(t, bn)), this
                     }
                     closestPointToPoint(t, e) {
                         e.subVectors(t, this.origin);
                         const n = e.dot(this.direction);
                         return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                     }
                     distanceToPoint(t) {
                         return Math.sqrt(this.distanceSqToPoint(t))
                     }
                     distanceSqToPoint(t) {
-                        const e = Bt.subVectors(t, this.origin).dot(this.direction);
-                        return e < 0 ? this.origin.distanceToSquared(t) : (Bt.copy(this.direction).multiplyScalar(e).add(this.origin), Bt.distanceToSquared(t))
+                        const e = bn.subVectors(t, this.origin).dot(this.direction);
+                        return e < 0 ? this.origin.distanceToSquared(t) : (bn.copy(this.direction).multiplyScalar(e).add(this.origin), bn.distanceToSquared(t))
                     }
                     distanceSqToSegment(t, e, n, i) {
-                        Ft.copy(t).add(e).multiplyScalar(.5), zt.copy(e).sub(t).normalize(), Ht.copy(this.origin).sub(Ft);
+                        wn.copy(t).add(e).multiplyScalar(.5), Sn.copy(e).sub(t).normalize(), En.copy(this.origin).sub(wn);
                         const r = .5 * t.distanceTo(e),
-                            s = -this.direction.dot(zt),
-                            a = Ht.dot(this.direction),
-                            o = -Ht.dot(zt),
-                            l = Ht.lengthSq(),
+                            s = -this.direction.dot(Sn),
+                            a = En.dot(this.direction),
+                            o = -En.dot(Sn),
+                            l = En.lengthSq(),
                             c = Math.abs(1 - s * s);
                         let h, u, d, p;
                         if (c > 0)
                             if (h = s * o - a, u = s * a - o, p = r * c, h >= 0)
                                 if (u >= -p)
                                     if (u <= p) {
                                         const t = 1 / c;
                                         h *= t, u *= t, d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l
                                     } else u = r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                         else u = -r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                         else u <= -p ? (h = Math.max(0, -(-s * r + a)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
                         else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
-                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(zt).multiplyScalar(u).add(Ft), d
+                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Sn).multiplyScalar(u).add(wn), d
                     }
                     intersectSphere(t, e) {
-                        Bt.subVectors(t.center, this.origin);
-                        const n = Bt.dot(this.direction),
-                            i = Bt.dot(Bt) - n * n,
+                        bn.subVectors(t.center, this.origin);
+                        const n = bn.dot(this.direction),
+                            i = bn.dot(bn) - n * n,
                             r = t.radius * t.radius;
                         if (i > r) return null;
                         const s = Math.sqrt(r - i),
                             a = n - s,
                             o = n + s;
                         return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
                     }
@@ -18705,58 +19089,58 @@
                         const l = 1 / this.direction.x,
                             c = 1 / this.direction.y,
                             h = 1 / this.direction.z,
                             u = this.origin;
                         return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (a = (t.min.z - u.z) * h, o = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, o = (t.min.z - u.z) * h), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                     }
                     intersectsBox(t) {
-                        return null !== this.intersectBox(t, Bt)
+                        return null !== this.intersectBox(t, bn)
                     }
                     intersectTriangle(t, e, n, i, r) {
-                        Gt.subVectors(e, t), Vt.subVectors(n, t), kt.crossVectors(Gt, Vt);
-                        let s, a = this.direction.dot(kt);
+                        Tn.subVectors(e, t), An.subVectors(n, t), Rn.crossVectors(Tn, An);
+                        let s, a = this.direction.dot(Rn);
                         if (a > 0) {
                             if (i) return null;
                             s = 1
                         } else {
                             if (!(a < 0)) return null;
                             s = -1, a = -a
                         }
-                        Ht.subVectors(this.origin, t);
-                        const o = s * this.direction.dot(Vt.crossVectors(Ht, Vt));
+                        En.subVectors(this.origin, t);
+                        const o = s * this.direction.dot(An.crossVectors(En, An));
                         if (o < 0) return null;
-                        const l = s * this.direction.dot(Gt.cross(Ht));
+                        const l = s * this.direction.dot(Tn.cross(En));
                         if (l < 0) return null;
                         if (o + l > a) return null;
-                        const c = -s * Ht.dot(kt);
+                        const c = -s * En.dot(Rn);
                         return c < 0 ? null : this.at(c / a, r)
                     }
                     applyMatrix4(t) {
                         return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                     }
                     equals(t) {
                         return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                class jt {
+                class Cn {
                     constructor() {
                         this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                     }
                     set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
                         const g = this.elements;
                         return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
                     }
                     identity() {
                         return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                     }
                     clone() {
-                        return (new jt).fromArray(this.elements)
+                        return (new Cn).fromArray(this.elements)
                     }
                     copy(t) {
                         const e = this.elements,
                             n = t.elements;
                         return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                     }
                     copyPosition(t) {
@@ -18773,17 +19157,17 @@
                     }
                     makeBasis(t, e, n) {
                         return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                     }
                     extractRotation(t) {
                         const e = this.elements,
                             n = t.elements,
-                            i = 1 / Xt.setFromMatrixColumn(t, 0).length(),
-                            r = 1 / Xt.setFromMatrixColumn(t, 1).length(),
-                            s = 1 / Xt.setFromMatrixColumn(t, 2).length();
+                            i = 1 / Pn.setFromMatrixColumn(t, 0).length(),
+                            r = 1 / Pn.setFromMatrixColumn(t, 1).length(),
+                            s = 1 / Pn.setFromMatrixColumn(t, 2).length();
                         return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                     }
                     makeRotationFromEuler(t) {
                         t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                         const e = this.elements,
                             n = t.x,
                             i = t.y,
@@ -18830,19 +19214,19 @@
                                 i = a * o,
                                 r = a * l;
                             e[0] = o * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = s * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = a * c, e[10] = r * h + t
                         }
                         return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                     }
                     makeRotationFromQuaternion(t) {
-                        return this.compose(Yt, t, Jt)
+                        return this.compose(In, t, Nn)
                     }
                     lookAt(t, e, n) {
                         const i = this.elements;
-                        return Qt.subVectors(t, e), 0 === Qt.lengthSq() && (Qt.z = 1), Qt.normalize(), Zt.crossVectors(n, Qt), 0 === Zt.lengthSq() && (1 === Math.abs(n.z) ? Qt.x += 1e-4 : Qt.z += 1e-4, Qt.normalize(), Zt.crossVectors(n, Qt)), Zt.normalize(), Kt.crossVectors(Qt, Zt), i[0] = Zt.x, i[4] = Kt.x, i[8] = Qt.x, i[1] = Zt.y, i[5] = Kt.y, i[9] = Qt.y, i[2] = Zt.z, i[6] = Kt.z, i[10] = Qt.z, this
+                        return Bn.subVectors(t, e), 0 === Bn.lengthSq() && (Bn.z = 1), Bn.normalize(), On.crossVectors(n, Bn), 0 === On.lengthSq() && (1 === Math.abs(n.z) ? Bn.x += 1e-4 : Bn.z += 1e-4, Bn.normalize(), On.crossVectors(n, Bn)), On.normalize(), Un.crossVectors(Bn, On), i[0] = On.x, i[4] = Un.x, i[8] = Bn.x, i[1] = On.y, i[5] = Un.y, i[9] = Bn.y, i[2] = On.z, i[6] = Un.z, i[10] = Bn.z, this
                     }
                     multiply(t, e) {
                         return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                     }
                     premultiply(t) {
                         return this.multiplyMatrices(t, this)
                     }
@@ -19010,22 +19394,22 @@
                             _ = n.x,
                             M = n.y,
                             b = n.z;
                         return i[0] = (1 - (m + g)) * _, i[1] = (d + y) * _, i[2] = (p - x) * _, i[3] = 0, i[4] = (d - y) * M, i[5] = (1 - (u + g)) * M, i[6] = (f + v) * M, i[7] = 0, i[8] = (p + x) * b, i[9] = (f - v) * b, i[10] = (1 - (u + m)) * b, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                     }
                     decompose(t, e, n) {
                         const i = this.elements;
-                        let r = Xt.set(i[0], i[1], i[2]).length();
-                        const s = Xt.set(i[4], i[5], i[6]).length(),
-                            a = Xt.set(i[8], i[9], i[10]).length();
-                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], qt.copy(this);
+                        let r = Pn.set(i[0], i[1], i[2]).length();
+                        const s = Pn.set(i[4], i[5], i[6]).length(),
+                            a = Pn.set(i[8], i[9], i[10]).length();
+                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Dn.copy(this);
                         const o = 1 / r,
                             l = 1 / s,
                             c = 1 / a;
-                        return qt.elements[0] *= o, qt.elements[1] *= o, qt.elements[2] *= o, qt.elements[4] *= l, qt.elements[5] *= l, qt.elements[6] *= l, qt.elements[8] *= c, qt.elements[9] *= c, qt.elements[10] *= c, e.setFromRotationMatrix(qt), n.x = r, n.y = s, n.z = a, this
+                        return Dn.elements[0] *= o, Dn.elements[1] *= o, Dn.elements[2] *= o, Dn.elements[4] *= l, Dn.elements[5] *= l, Dn.elements[6] *= l, Dn.elements[8] *= c, Dn.elements[9] *= c, Dn.elements[10] *= c, e.setFromRotationMatrix(Dn), n.x = r, n.y = s, n.z = a, this
                     }
                     makePerspective(t, e, n, i, r, s) {
                         void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                         const a = this.elements,
                             o = 2 * r / (e - t),
                             l = 2 * r / (n - i),
                             c = (e + t) / (e - t),
@@ -19056,26 +19440,26 @@
                         return this
                     }
                     toArray(t = [], e = 0) {
                         const n = this.elements;
                         return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                     }
                 }
-                jt.prototype.isMatrix4 = !0;
-                const Xt = new mt,
-                    qt = new jt,
-                    Yt = new mt(0, 0, 0),
-                    Jt = new mt(1, 1, 1),
-                    Zt = new mt,
-                    Kt = new mt,
-                    Qt = new mt,
-                    $t = new jt,
-                    te = new pt;
-                class ee {
-                    constructor(t = 0, e = 0, n = 0, i = ee.DefaultOrder) {
+                Cn.prototype.isMatrix4 = !0;
+                const Pn = new Qe,
+                    Dn = new Cn,
+                    In = new Qe(0, 0, 0),
+                    Nn = new Qe(1, 1, 1),
+                    On = new Qe,
+                    Un = new Qe,
+                    Bn = new Qe,
+                    Fn = new Cn,
+                    zn = new Ke;
+                class Hn {
+                    constructor(t = 0, e = 0, n = 0, i = Hn.DefaultOrder) {
                         this._x = t, this._y = e, this._z = n, this._order = i
                     }
                     get x() {
                         return this._x
                     }
                     set x(t) {
                         this._x = t, this._onChangeCallback()
@@ -19116,64 +19500,64 @@
                             l = i[5],
                             c = i[9],
                             h = i[2],
                             u = i[6],
                             d = i[10];
                         switch (e) {
                             case "XYZ":
-                                this._y = Math.asin(W(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
+                                this._y = Math.asin(Re(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                                 break;
                             case "YXZ":
-                                this._x = Math.asin(-W(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
+                                this._x = Math.asin(-Re(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                                 break;
                             case "ZXY":
-                                this._x = Math.asin(W(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
+                                this._x = Math.asin(Re(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                                 break;
                             case "ZYX":
-                                this._y = Math.asin(-W(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
+                                this._y = Math.asin(-Re(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                                 break;
                             case "YZX":
-                                this._z = Math.asin(W(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
+                                this._z = Math.asin(Re(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                                 break;
                             case "XZY":
-                                this._z = Math.asin(-W(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
+                                this._z = Math.asin(-Re(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                                 break;
                             default:
                                 console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                         }
                         return this._order = e, !0 === n && this._onChangeCallback(), this
                     }
                     setFromQuaternion(t, e, n) {
-                        return $t.makeRotationFromQuaternion(t), this.setFromRotationMatrix($t, e, n)
+                        return Fn.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Fn, e, n)
                     }
                     setFromVector3(t, e = this._order) {
                         return this.set(t.x, t.y, t.z, e)
                     }
                     reorder(t) {
-                        return te.setFromEuler(this), this.setFromQuaternion(te, t)
+                        return zn.setFromEuler(this), this.setFromQuaternion(zn, t)
                     }
                     equals(t) {
                         return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                     }
                     fromArray(t) {
                         return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                     }
                     toArray(t = [], e = 0) {
                         return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                     }
                     toVector3(t) {
-                        return t ? t.set(this._x, this._y, this._z) : new mt(this._x, this._y, this._z)
+                        return t ? t.set(this._x, this._y, this._z) : new Qe(this._x, this._y, this._z)
                     }
                     _onChange(t) {
                         return this._onChangeCallback = t, this
                     }
                     _onChangeCallback() {}
                 }
-                ee.prototype.isEuler = !0, ee.DefaultOrder = "XYZ", ee.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
-                class ne {
+                Hn.prototype.isEuler = !0, Hn.DefaultOrder = "XYZ", Hn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
+                class Gn {
                     constructor() {
                         this.mask = 1
                     }
                     set(t) {
                         this.mask = (1 << t | 0) >>> 0
                     }
                     enable(t) {
@@ -19194,40 +19578,40 @@
                     test(t) {
                         return 0 != (this.mask & t.mask)
                     }
                     isEnabled(t) {
                         return 0 != (this.mask & (1 << t | 0))
                     }
                 }
-                let ie = 0;
-                const re = new mt,
-                    se = new pt,
-                    ae = new jt,
-                    oe = new mt,
-                    le = new mt,
-                    ce = new mt,
-                    he = new pt,
-                    ue = new mt(1, 0, 0),
-                    de = new mt(0, 1, 0),
-                    pe = new mt(0, 0, 1),
-                    me = {
+                let Vn = 0;
+                const kn = new Qe,
+                    Wn = new Ke,
+                    jn = new Cn,
+                    Xn = new Qe,
+                    qn = new Qe,
+                    Yn = new Qe,
+                    Jn = new Ke,
+                    Zn = new Qe(1, 0, 0),
+                    Kn = new Qe(0, 1, 0),
+                    Qn = new Qe(0, 0, 1),
+                    $n = {
                         type: "added"
                     },
-                    fe = {
+                    ti = {
                         type: "removed"
                     };
-                class ge extends z {
+                class ei extends we {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: ie++
-                        }), this.uuid = k(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ge.DefaultUp.clone();
-                        const t = new mt,
-                            e = new ee,
-                            n = new pt,
-                            i = new mt(1, 1, 1);
+                            value: Vn++
+                        }), this.uuid = Ae(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ei.DefaultUp.clone();
+                        const t = new Qe,
+                            e = new Hn,
+                            n = new Ke,
+                            i = new Qe(1, 1, 1);
                         e._onChange((function() {
                             n.setFromEuler(e, !1)
                         })), n._onChange((function() {
                             e.setFromQuaternion(n, void 0, !1)
                         })), Object.defineProperties(this, {
                             position: {
                                 configurable: !0,
@@ -19246,20 +19630,20 @@
                             },
                             scale: {
                                 configurable: !0,
                                 enumerable: !0,
                                 value: i
                             },
                             modelViewMatrix: {
-                                value: new jt
+                                value: new Cn
                             },
                             normalMatrix: {
-                                value: new J
+                                value: new Ie
                             }
-                        }), this.matrix = new jt, this.matrixWorld = new jt, this.matrixAutoUpdate = ge.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ne, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
+                        }), this.matrix = new Cn, this.matrixWorld = new Cn, this.matrixAutoUpdate = ei.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Gn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                     }
                     onBeforeRender() {}
                     onAfterRender() {}
                     applyMatrix4(t) {
                         this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                     }
                     applyQuaternion(t) {
@@ -19274,79 +19658,79 @@
                     setRotationFromMatrix(t) {
                         this.quaternion.setFromRotationMatrix(t)
                     }
                     setRotationFromQuaternion(t) {
                         this.quaternion.copy(t)
                     }
                     rotateOnAxis(t, e) {
-                        return se.setFromAxisAngle(t, e), this.quaternion.multiply(se), this
+                        return Wn.setFromAxisAngle(t, e), this.quaternion.multiply(Wn), this
                     }
                     rotateOnWorldAxis(t, e) {
-                        return se.setFromAxisAngle(t, e), this.quaternion.premultiply(se), this
+                        return Wn.setFromAxisAngle(t, e), this.quaternion.premultiply(Wn), this
                     }
                     rotateX(t) {
-                        return this.rotateOnAxis(ue, t)
+                        return this.rotateOnAxis(Zn, t)
                     }
                     rotateY(t) {
-                        return this.rotateOnAxis(de, t)
+                        return this.rotateOnAxis(Kn, t)
                     }
                     rotateZ(t) {
-                        return this.rotateOnAxis(pe, t)
+                        return this.rotateOnAxis(Qn, t)
                     }
                     translateOnAxis(t, e) {
-                        return re.copy(t).applyQuaternion(this.quaternion), this.position.add(re.multiplyScalar(e)), this
+                        return kn.copy(t).applyQuaternion(this.quaternion), this.position.add(kn.multiplyScalar(e)), this
                     }
                     translateX(t) {
-                        return this.translateOnAxis(ue, t)
+                        return this.translateOnAxis(Zn, t)
                     }
                     translateY(t) {
-                        return this.translateOnAxis(de, t)
+                        return this.translateOnAxis(Kn, t)
                     }
                     translateZ(t) {
-                        return this.translateOnAxis(pe, t)
+                        return this.translateOnAxis(Qn, t)
                     }
                     localToWorld(t) {
                         return t.applyMatrix4(this.matrixWorld)
                     }
                     worldToLocal(t) {
-                        return t.applyMatrix4(ae.copy(this.matrixWorld).invert())
+                        return t.applyMatrix4(jn.copy(this.matrixWorld).invert())
                     }
                     lookAt(t, e, n) {
-                        t.isVector3 ? oe.copy(t) : oe.set(t, e, n);
+                        t.isVector3 ? Xn.copy(t) : Xn.set(t, e, n);
                         const i = this.parent;
-                        this.updateWorldMatrix(!0, !1), le.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ae.lookAt(le, oe, this.up) : ae.lookAt(oe, le, this.up), this.quaternion.setFromRotationMatrix(ae), i && (ae.extractRotation(i.matrixWorld), se.setFromRotationMatrix(ae), this.quaternion.premultiply(se.invert()))
+                        this.updateWorldMatrix(!0, !1), qn.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? jn.lookAt(qn, Xn, this.up) : jn.lookAt(Xn, qn, this.up), this.quaternion.setFromRotationMatrix(jn), i && (jn.extractRotation(i.matrixWorld), Wn.setFromRotationMatrix(jn), this.quaternion.premultiply(Wn.invert()))
                     }
                     add(t) {
                         if (arguments.length > 1) {
                             for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                             return this
                         }
-                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(me)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
+                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent($n)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                     }
                     remove(t) {
                         if (arguments.length > 1) {
                             for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                             return this
                         }
                         const e = this.children.indexOf(t);
-                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(fe)), this
+                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(ti)), this
                     }
                     removeFromParent() {
                         const t = this.parent;
                         return null !== t && t.remove(this), this
                     }
                     clear() {
                         for (let t = 0; t < this.children.length; t++) {
                             const e = this.children[t];
-                            e.parent = null, e.dispatchEvent(fe)
+                            e.parent = null, e.dispatchEvent(ti)
                         }
                         return this.children.length = 0, this
                     }
                     attach(t) {
-                        return this.updateWorldMatrix(!0, !1), ae.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), ae.multiply(t.parent.matrixWorld)), t.applyMatrix4(ae), this.add(t), t.updateWorldMatrix(!1, !0), this
+                        return this.updateWorldMatrix(!0, !1), jn.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), jn.multiply(t.parent.matrixWorld)), t.applyMatrix4(jn), this.add(t), t.updateWorldMatrix(!1, !0), this
                     }
                     getObjectById(t) {
                         return this.getObjectByProperty("id", t)
                     }
                     getObjectByName(t) {
                         return this.getObjectByProperty("name", t)
                     }
@@ -19357,18 +19741,18 @@
                             if (void 0 !== i) return i
                         }
                     }
                     getWorldPosition(t) {
                         return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                     }
                     getWorldQuaternion(t) {
-                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(le, t, ce), t
+                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(qn, t, Yn), t
                     }
                     getWorldScale(t) {
-                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(le, he, t), t
+                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(qn, Jn, t), t
                     }
                     getWorldDirection(t) {
                         this.updateWorldMatrix(!0, !1);
                         const e = this.matrixWorld.elements;
                         return t.set(e[8], e[9], e[10]).normalize()
                     }
                     raycast() {}
@@ -19482,56 +19866,56 @@
                             for (let e = 0; e < t.children.length; e++) {
                                 const n = t.children[e];
                                 this.add(n.clone())
                             }
                         return this
                     }
                 }
-                ge.DefaultUp = new mt(0, 1, 0), ge.DefaultMatrixAutoUpdate = !0, ge.prototype.isObject3D = !0;
-                const ve = new mt,
-                    xe = new mt,
-                    ye = new mt,
-                    _e = new mt,
-                    Me = new mt,
-                    be = new mt,
-                    we = new mt,
-                    Se = new mt,
-                    Ee = new mt,
-                    Te = new mt;
-                class Ae {
-                    constructor(t = new mt, e = new mt, n = new mt) {
+                ei.DefaultUp = new Qe(0, 1, 0), ei.DefaultMatrixAutoUpdate = !0, ei.prototype.isObject3D = !0;
+                const ni = new Qe,
+                    ii = new Qe,
+                    ri = new Qe,
+                    si = new Qe,
+                    ai = new Qe,
+                    oi = new Qe,
+                    li = new Qe,
+                    ci = new Qe,
+                    hi = new Qe,
+                    ui = new Qe;
+                class di {
+                    constructor(t = new Qe, e = new Qe, n = new Qe) {
                         this.a = t, this.b = e, this.c = n
                     }
                     static getNormal(t, e, n, i) {
-                        i.subVectors(n, e), ve.subVectors(t, e), i.cross(ve);
+                        i.subVectors(n, e), ni.subVectors(t, e), i.cross(ni);
                         const r = i.lengthSq();
                         return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                     }
                     static getBarycoord(t, e, n, i, r) {
-                        ve.subVectors(i, e), xe.subVectors(n, e), ye.subVectors(t, e);
-                        const s = ve.dot(ve),
-                            a = ve.dot(xe),
-                            o = ve.dot(ye),
-                            l = xe.dot(xe),
-                            c = xe.dot(ye),
+                        ni.subVectors(i, e), ii.subVectors(n, e), ri.subVectors(t, e);
+                        const s = ni.dot(ni),
+                            a = ni.dot(ii),
+                            o = ni.dot(ri),
+                            l = ii.dot(ii),
+                            c = ii.dot(ri),
                             h = s * l - a * a;
                         if (0 === h) return r.set(-2, -1, -1);
                         const u = 1 / h,
                             d = (l * o - a * c) * u,
                             p = (s * c - a * o) * u;
                         return r.set(1 - d - p, p, d)
                     }
                     static containsPoint(t, e, n, i) {
-                        return this.getBarycoord(t, e, n, i, _e), _e.x >= 0 && _e.y >= 0 && _e.x + _e.y <= 1
+                        return this.getBarycoord(t, e, n, i, si), si.x >= 0 && si.y >= 0 && si.x + si.y <= 1
                     }
                     static getUV(t, e, n, i, r, s, a, o) {
-                        return this.getBarycoord(t, e, n, i, _e), o.set(0, 0), o.addScaledVector(r, _e.x), o.addScaledVector(s, _e.y), o.addScaledVector(a, _e.z), o
+                        return this.getBarycoord(t, e, n, i, si), o.set(0, 0), o.addScaledVector(r, si.x), o.addScaledVector(s, si.y), o.addScaledVector(a, si.z), o
                     }
                     static isFrontFacing(t, e, n, i) {
-                        return ve.subVectors(n, e), xe.subVectors(t, e), ve.cross(xe).dot(i) < 0
+                        return ni.subVectors(n, e), ii.subVectors(t, e), ni.cross(ii).dot(i) < 0
                     }
                     set(t, e, n) {
                         return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                     }
                     setFromPointsAndIndices(t, e, n, i) {
                         return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                     }
@@ -19541,76 +19925,76 @@
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     copy(t) {
                         return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                     }
                     getArea() {
-                        return ve.subVectors(this.c, this.b), xe.subVectors(this.a, this.b), .5 * ve.cross(xe).length()
+                        return ni.subVectors(this.c, this.b), ii.subVectors(this.a, this.b), .5 * ni.cross(ii).length()
                     }
                     getMidpoint(t) {
                         return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                     }
                     getNormal(t) {
-                        return Ae.getNormal(this.a, this.b, this.c, t)
+                        return di.getNormal(this.a, this.b, this.c, t)
                     }
                     getPlane(t) {
                         return t.setFromCoplanarPoints(this.a, this.b, this.c)
                     }
                     getBarycoord(t, e) {
-                        return Ae.getBarycoord(t, this.a, this.b, this.c, e)
+                        return di.getBarycoord(t, this.a, this.b, this.c, e)
                     }
                     getUV(t, e, n, i, r) {
-                        return Ae.getUV(t, this.a, this.b, this.c, e, n, i, r)
+                        return di.getUV(t, this.a, this.b, this.c, e, n, i, r)
                     }
                     containsPoint(t) {
-                        return Ae.containsPoint(t, this.a, this.b, this.c)
+                        return di.containsPoint(t, this.a, this.b, this.c)
                     }
                     isFrontFacing(t) {
-                        return Ae.isFrontFacing(this.a, this.b, this.c, t)
+                        return di.isFrontFacing(this.a, this.b, this.c, t)
                     }
                     intersectsBox(t) {
                         return t.intersectsTriangle(this)
                     }
                     closestPointToPoint(t, e) {
                         const n = this.a,
                             i = this.b,
                             r = this.c;
                         let s, a;
-                        Me.subVectors(i, n), be.subVectors(r, n), Se.subVectors(t, n);
-                        const o = Me.dot(Se),
-                            l = be.dot(Se);
+                        ai.subVectors(i, n), oi.subVectors(r, n), ci.subVectors(t, n);
+                        const o = ai.dot(ci),
+                            l = oi.dot(ci);
                         if (o <= 0 && l <= 0) return e.copy(n);
-                        Ee.subVectors(t, i);
-                        const c = Me.dot(Ee),
-                            h = be.dot(Ee);
+                        hi.subVectors(t, i);
+                        const c = ai.dot(hi),
+                            h = oi.dot(hi);
                         if (c >= 0 && h <= c) return e.copy(i);
                         const u = o * h - c * l;
-                        if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector(Me, s);
-                        Te.subVectors(t, r);
-                        const d = Me.dot(Te),
-                            p = be.dot(Te);
+                        if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector(ai, s);
+                        ui.subVectors(t, r);
+                        const d = ai.dot(ui),
+                            p = oi.dot(ui);
                         if (p >= 0 && d <= p) return e.copy(r);
                         const m = d * l - o * p;
-                        if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(be, a);
+                        if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(oi, a);
                         const f = c * p - d * h;
-                        if (f <= 0 && h - c >= 0 && d - p >= 0) return we.subVectors(r, i), a = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(we, a);
+                        if (f <= 0 && h - c >= 0 && d - p >= 0) return li.subVectors(r, i), a = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(li, a);
                         const g = 1 / (f + m + u);
-                        return s = m * g, a = u * g, e.copy(n).addScaledVector(Me, s).addScaledVector(be, a)
+                        return s = m * g, a = u * g, e.copy(n).addScaledVector(ai, s).addScaledVector(oi, a)
                     }
                     equals(t) {
                         return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                     }
                 }
-                let Re = 0;
-                class Le extends z {
+                let pi = 0;
+                class mi extends we {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: Re++
-                        }), this.uuid = k(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = i, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = N, this.stencilZFail = N, this.stencilZPass = N, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.alphaWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
+                            value: pi++
+                        }), this.uuid = Ae(), this.name = "", this.type = "Material", this.fog = !0, this.blending = m, this.side = h, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = R, this.blendDst = L, this.blendEquation = y, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = F, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = xe, this.stencilZFail = xe, this.stencilZPass = xe, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.alphaWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                     }
                     get alphaTest() {
                         return this._alphaTest
                     }
                     set alphaTest(t) {
                         this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
                     }
@@ -19654,15 +20038,15 @@
                             const e = [];
                             for (const n in t) {
                                 const i = t[n];
                                 delete i.metadata, e.push(i)
                             }
                             return e
                         }
-                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.alphaWrite = this.alphaWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
+                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== m && (n.blending = this.blending), this.side !== h && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.alphaWrite = this.alphaWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                             const e = i(t.textures),
                                 r = i(t.images);
                             e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                         }
                         return n
                     }
                     clone() {
@@ -19684,30 +20068,30 @@
                             type: "dispose"
                         })
                     }
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                 }
-                Le.prototype.isMaterial = !0;
-                class Ce extends Le {
+                mi.prototype.isMaterial = !0;
+                class fi extends mi {
                     constructor(t) {
-                        super(), this.type = "MeshBasicMaterial", this.color = new rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        super(), this.type = "MeshBasicMaterial", this.color = new Ve(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = k, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }
-                Ce.prototype.isMeshBasicMaterial = !0;
-                const Pe = new mt,
-                    De = new Y;
-                class Ie {
+                fi.prototype.isMeshBasicMaterial = !0;
+                const gi = new Qe,
+                    vi = new De;
+                class xi {
                     constructor(t, e, n) {
                         if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
-                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = O, this.updateRange = {
+                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = ye, this.updateRange = {
                             offset: 0,
                             count: -1
                         }, this.version = 0
                     }
                     onUploadCallback() {}
                     set needsUpdate(t) {
                         !0 === t && this.version++
@@ -19727,62 +20111,62 @@
                         return this.array.set(t), this
                     }
                     copyColorsArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new rt), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Ve), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                         }
                         return this
                     }
                     copyVector2sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Y), e[n++] = r.x, e[n++] = r.y
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new De), e[n++] = r.x, e[n++] = r.y
                         }
                         return this
                     }
                     copyVector3sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new mt), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Qe), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                         }
                         return this
                     }
                     copyVector4sArray(t) {
                         const e = this.array;
                         let n = 0;
                         for (let i = 0, r = t.length; i < r; i++) {
                             let r = t[i];
-                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new ht), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
+                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new Ye), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                         }
                         return this
                     }
                     applyMatrix3(t) {
                         if (2 === this.itemSize)
-                            for (let e = 0, n = this.count; e < n; e++) De.fromBufferAttribute(this, e), De.applyMatrix3(t), this.setXY(e, De.x, De.y);
+                            for (let e = 0, n = this.count; e < n; e++) vi.fromBufferAttribute(this, e), vi.applyMatrix3(t), this.setXY(e, vi.x, vi.y);
                         else if (3 === this.itemSize)
-                            for (let e = 0, n = this.count; e < n; e++) Pe.fromBufferAttribute(this, e), Pe.applyMatrix3(t), this.setXYZ(e, Pe.x, Pe.y, Pe.z);
+                            for (let e = 0, n = this.count; e < n; e++) gi.fromBufferAttribute(this, e), gi.applyMatrix3(t), this.setXYZ(e, gi.x, gi.y, gi.z);
                         return this
                     }
                     applyMatrix4(t) {
-                        for (let e = 0, n = this.count; e < n; e++) Pe.x = this.getX(e), Pe.y = this.getY(e), Pe.z = this.getZ(e), Pe.applyMatrix4(t), this.setXYZ(e, Pe.x, Pe.y, Pe.z);
+                        for (let e = 0, n = this.count; e < n; e++) gi.x = this.getX(e), gi.y = this.getY(e), gi.z = this.getZ(e), gi.applyMatrix4(t), this.setXYZ(e, gi.x, gi.y, gi.z);
                         return this
                     }
                     applyNormalMatrix(t) {
-                        for (let e = 0, n = this.count; e < n; e++) Pe.x = this.getX(e), Pe.y = this.getY(e), Pe.z = this.getZ(e), Pe.applyNormalMatrix(t), this.setXYZ(e, Pe.x, Pe.y, Pe.z);
+                        for (let e = 0, n = this.count; e < n; e++) gi.x = this.getX(e), gi.y = this.getY(e), gi.z = this.getZ(e), gi.applyNormalMatrix(t), this.setXYZ(e, gi.x, gi.y, gi.z);
                         return this
                     }
                     transformDirection(t) {
-                        for (let e = 0, n = this.count; e < n; e++) Pe.x = this.getX(e), Pe.y = this.getY(e), Pe.z = this.getZ(e), Pe.transformDirection(t), this.setXYZ(e, Pe.x, Pe.y, Pe.z);
+                        for (let e = 0, n = this.count; e < n; e++) gi.x = this.getX(e), gi.y = this.getY(e), gi.z = this.getZ(e), gi.transformDirection(t), this.setXYZ(e, gi.x, gi.y, gi.z);
                         return this
                     }
                     set(t, e = 0) {
                         return this.array.set(t, e), this
                     }
                     getX(t) {
                         return this.array[t * this.itemSize]
@@ -19826,58 +20210,58 @@
                     toJSON() {
                         const t = {
                             itemSize: this.itemSize,
                             type: this.array.constructor.name,
                             array: Array.prototype.slice.call(this.array),
                             normalized: this.normalized
                         };
-                        return "" !== this.name && (t.name = this.name), this.usage !== O && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
+                        return "" !== this.name && (t.name = this.name), this.usage !== ye && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
                     }
                 }
-                Ie.prototype.isBufferAttribute = !0;
-                class Ne extends Ie {
+                xi.prototype.isBufferAttribute = !0;
+                class yi extends xi {
                     constructor(t, e, n) {
                         super(new Uint16Array(t), e, n)
                     }
                 }
-                class Oe extends Ie {
+                class _i extends xi {
                     constructor(t, e, n) {
                         super(new Uint32Array(t), e, n)
                     }
-                }(class extends Ie {
+                }(class extends xi {
                     constructor(t, e, n) {
                         super(new Uint16Array(t), e, n)
                     }
                 }).prototype.isFloat16BufferAttribute = !0;
-                class Ue extends Ie {
+                class Mi extends xi {
                     constructor(t, e, n) {
                         super(new Float32Array(t), e, n)
                     }
                 }
-                let Be = 0;
-                const Fe = new jt,
-                    ze = new ge,
-                    He = new mt,
-                    Ge = new vt,
-                    Ve = new vt,
-                    ke = new mt;
-                class We extends z {
+                let bi = 0;
+                const wi = new Cn,
+                    Si = new ei,
+                    Ei = new Qe,
+                    Ti = new en,
+                    Ai = new en,
+                    Ri = new Qe;
+                class Li extends we {
                     constructor() {
                         super(), Object.defineProperty(this, "id", {
-                            value: Be++
-                        }), this.uuid = k(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
+                            value: bi++
+                        }), this.uuid = Ae(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                             start: 0,
                             count: 1 / 0
                         }, this.userData = {}
                     }
                     getIndex() {
                         return this.index
                     }
                     setIndex(t) {
-                        return Array.isArray(t) ? this.index = new(Z(t) ? Oe : Ne)(t, 1) : this.index = t, this
+                        return Array.isArray(t) ? this.index = new(Ne(t) ? _i : yi)(t, 1) : this.index = t, this
                     }
                     getAttribute(t) {
                         return this.attributes[t]
                     }
                     setAttribute(t, e) {
                         return this.attributes[t] = e, this
                     }
@@ -19901,112 +20285,112 @@
                         this.drawRange.start = t, this.drawRange.count = e
                     }
                     applyMatrix4(t) {
                         const e = this.attributes.position;
                         void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                         const n = this.attributes.normal;
                         if (void 0 !== n) {
-                            const e = (new J).getNormalMatrix(t);
+                            const e = (new Ie).getNormalMatrix(t);
                             n.applyNormalMatrix(e), n.needsUpdate = !0
                         }
                         const i = this.attributes.tangent;
                         return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                     }
                     applyQuaternion(t) {
-                        return Fe.makeRotationFromQuaternion(t), this.applyMatrix4(Fe), this
+                        return wi.makeRotationFromQuaternion(t), this.applyMatrix4(wi), this
                     }
                     rotateX(t) {
-                        return Fe.makeRotationX(t), this.applyMatrix4(Fe), this
+                        return wi.makeRotationX(t), this.applyMatrix4(wi), this
                     }
                     rotateY(t) {
-                        return Fe.makeRotationY(t), this.applyMatrix4(Fe), this
+                        return wi.makeRotationY(t), this.applyMatrix4(wi), this
                     }
                     rotateZ(t) {
-                        return Fe.makeRotationZ(t), this.applyMatrix4(Fe), this
+                        return wi.makeRotationZ(t), this.applyMatrix4(wi), this
                     }
                     translate(t, e, n) {
-                        return Fe.makeTranslation(t, e, n), this.applyMatrix4(Fe), this
+                        return wi.makeTranslation(t, e, n), this.applyMatrix4(wi), this
                     }
                     scale(t, e, n) {
-                        return Fe.makeScale(t, e, n), this.applyMatrix4(Fe), this
+                        return wi.makeScale(t, e, n), this.applyMatrix4(wi), this
                     }
                     lookAt(t) {
-                        return ze.lookAt(t), ze.updateMatrix(), this.applyMatrix4(ze.matrix), this
+                        return Si.lookAt(t), Si.updateMatrix(), this.applyMatrix4(Si.matrix), this
                     }
                     center() {
-                        return this.computeBoundingBox(), this.boundingBox.getCenter(He).negate(), this.translate(He.x, He.y, He.z), this
+                        return this.computeBoundingBox(), this.boundingBox.getCenter(Ei).negate(), this.translate(Ei.x, Ei.y, Ei.z), this
                     }
                     setFromPoints(t) {
                         const e = [];
                         for (let n = 0, i = t.length; n < i; n++) {
                             const i = t[n];
                             e.push(i.x, i.y, i.z || 0)
                         }
-                        return this.setAttribute("position", new Ue(e, 3)), this
+                        return this.setAttribute("position", new Mi(e, 3)), this
                     }
                     computeBoundingBox() {
-                        null === this.boundingBox && (this.boundingBox = new vt);
+                        null === this.boundingBox && (this.boundingBox = new en);
                         const t = this.attributes.position,
                             e = this.morphAttributes.position;
-                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new mt(-1 / 0, -1 / 0, -1 / 0), new mt(1 / 0, 1 / 0, 1 / 0));
+                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Qe(-1 / 0, -1 / 0, -1 / 0), new Qe(1 / 0, 1 / 0, 1 / 0));
                         if (void 0 !== t) {
                             if (this.boundingBox.setFromBufferAttribute(t), e)
                                 for (let t = 0, n = e.length; t < n; t++) {
                                     const n = e[t];
-                                    Ge.setFromBufferAttribute(n), this.morphTargetsRelative ? (ke.addVectors(this.boundingBox.min, Ge.min), this.boundingBox.expandByPoint(ke), ke.addVectors(this.boundingBox.max, Ge.max), this.boundingBox.expandByPoint(ke)) : (this.boundingBox.expandByPoint(Ge.min), this.boundingBox.expandByPoint(Ge.max))
+                                    Ti.setFromBufferAttribute(n), this.morphTargetsRelative ? (Ri.addVectors(this.boundingBox.min, Ti.min), this.boundingBox.expandByPoint(Ri), Ri.addVectors(this.boundingBox.max, Ti.max), this.boundingBox.expandByPoint(Ri)) : (this.boundingBox.expandByPoint(Ti.min), this.boundingBox.expandByPoint(Ti.max))
                                 }
                         } else this.boundingBox.makeEmpty();
                         (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                     }
                     computeBoundingSphere() {
-                        null === this.boundingSphere && (this.boundingSphere = new Ut);
+                        null === this.boundingSphere && (this.boundingSphere = new Mn);
                         const t = this.attributes.position,
                             e = this.morphAttributes.position;
-                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new mt, 1 / 0);
+                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Qe, 1 / 0);
                         if (t) {
                             const n = this.boundingSphere.center;
-                            if (Ge.setFromBufferAttribute(t), e)
+                            if (Ti.setFromBufferAttribute(t), e)
                                 for (let t = 0, n = e.length; t < n; t++) {
                                     const n = e[t];
-                                    Ve.setFromBufferAttribute(n), this.morphTargetsRelative ? (ke.addVectors(Ge.min, Ve.min), Ge.expandByPoint(ke), ke.addVectors(Ge.max, Ve.max), Ge.expandByPoint(ke)) : (Ge.expandByPoint(Ve.min), Ge.expandByPoint(Ve.max))
+                                    Ai.setFromBufferAttribute(n), this.morphTargetsRelative ? (Ri.addVectors(Ti.min, Ai.min), Ti.expandByPoint(Ri), Ri.addVectors(Ti.max, Ai.max), Ti.expandByPoint(Ri)) : (Ti.expandByPoint(Ai.min), Ti.expandByPoint(Ai.max))
                                 }
-                            Ge.getCenter(n);
+                            Ti.getCenter(n);
                             let i = 0;
-                            for (let e = 0, r = t.count; e < r; e++) ke.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(ke));
+                            for (let e = 0, r = t.count; e < r; e++) Ri.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Ri));
                             if (e)
                                 for (let r = 0, s = e.length; r < s; r++) {
                                     const s = e[r],
                                         a = this.morphTargetsRelative;
-                                    for (let e = 0, r = s.count; e < r; e++) ke.fromBufferAttribute(s, e), a && (He.fromBufferAttribute(t, e), ke.add(He)), i = Math.max(i, n.distanceToSquared(ke))
+                                    for (let e = 0, r = s.count; e < r; e++) Ri.fromBufferAttribute(s, e), a && (Ei.fromBufferAttribute(t, e), Ri.add(Ei)), i = Math.max(i, n.distanceToSquared(Ri))
                                 }
                             this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                         }
                     }
                     computeTangents() {
                         const t = this.index,
                             e = this.attributes;
                         if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                         const n = t.array,
                             i = e.position.array,
                             r = e.normal.array,
                             s = e.uv.array,
                             a = i.length / 3;
-                        void 0 === e.tangent && this.setAttribute("tangent", new Ie(new Float32Array(4 * a), 4));
+                        void 0 === e.tangent && this.setAttribute("tangent", new xi(new Float32Array(4 * a), 4));
                         const o = e.tangent.array,
                             l = [],
                             c = [];
-                        for (let t = 0; t < a; t++) l[t] = new mt, c[t] = new mt;
-                        const h = new mt,
-                            u = new mt,
-                            d = new mt,
-                            p = new Y,
-                            m = new Y,
-                            f = new Y,
-                            g = new mt,
-                            v = new mt;
+                        for (let t = 0; t < a; t++) l[t] = new Qe, c[t] = new Qe;
+                        const h = new Qe,
+                            u = new Qe,
+                            d = new Qe,
+                            p = new De,
+                            m = new De,
+                            f = new De,
+                            g = new Qe,
+                            v = new Qe;
 
                         function x(t, e, n) {
                             h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * n), u.sub(h), d.sub(h), m.sub(p), f.sub(p);
                             const r = 1 / (m.x * f.y - f.x * m.y);
                             isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                         }
                         let y = this.groups;
@@ -20015,18 +20399,18 @@
                             count: n.length
                         }]);
                         for (let t = 0, e = y.length; t < e; ++t) {
                             const e = y[t],
                                 i = e.start;
                             for (let t = i, r = i + e.count; t < r; t += 3) x(n[t + 0], n[t + 1], n[t + 2])
                         }
-                        const _ = new mt,
-                            M = new mt,
-                            b = new mt,
-                            w = new mt;
+                        const _ = new Qe,
+                            M = new Qe,
+                            b = new Qe,
+                            w = new Qe;
 
                         function S(t) {
                             b.fromArray(r, 3 * t), w.copy(b);
                             const e = l[t];
                             _.copy(e), _.sub(b.multiplyScalar(b.dot(e))).normalize(), M.crossVectors(w, e);
                             const n = M.dot(c[t]) < 0 ? -1 : 1;
                             o[4 * t] = _.x, o[4 * t + 1] = _.y, o[4 * t + 2] = _.z, o[4 * t + 3] = n
@@ -20038,25 +20422,25 @@
                         }
                     }
                     computeVertexNormals() {
                         const t = this.index,
                             e = this.getAttribute("position");
                         if (void 0 !== e) {
                             let n = this.getAttribute("normal");
-                            if (void 0 === n) n = new Ie(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
+                            if (void 0 === n) n = new xi(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                             else
                                 for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
-                            const i = new mt,
-                                r = new mt,
-                                s = new mt,
-                                a = new mt,
-                                o = new mt,
-                                l = new mt,
-                                c = new mt,
-                                h = new mt;
+                            const i = new Qe,
+                                r = new Qe,
+                                s = new Qe,
+                                a = new Qe,
+                                o = new Qe,
+                                l = new Qe,
+                                c = new Qe,
+                                h = new Qe;
                             if (t)
                                 for (let u = 0, d = t.count; u < d; u += 3) {
                                     const d = t.getX(u + 0),
                                         p = t.getX(u + 1),
                                         m = t.getX(u + 2);
                                     i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(m, l.x, l.y, l.z)
                                 } else
@@ -20077,32 +20461,32 @@
                                 l = Math.min(a.length, r.length - o);
                             for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t]
                         }
                         return this
                     }
                     normalizeNormals() {
                         const t = this.attributes.normal;
-                        for (let e = 0, n = t.count; e < n; e++) ke.fromBufferAttribute(t, e), ke.normalize(), t.setXYZ(e, ke.x, ke.y, ke.z)
+                        for (let e = 0, n = t.count; e < n; e++) Ri.fromBufferAttribute(t, e), Ri.normalize(), t.setXYZ(e, Ri.x, Ri.y, Ri.z)
                     }
                     toNonIndexed() {
                         function t(t, e) {
                             const n = t.array,
                                 i = t.itemSize,
                                 r = t.normalized,
                                 s = new n.constructor(e.length * i);
                             let a = 0,
                                 o = 0;
                             for (let r = 0, l = e.length; r < l; r++) {
                                 a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                                 for (let t = 0; t < i; t++) s[o++] = n[a++]
                             }
-                            return new Ie(s, i, r)
+                            return new xi(s, i, r)
                         }
                         if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
-                        const e = new We,
+                        const e = new Li,
                             n = this.index.array,
                             i = this.attributes;
                         for (const r in i) {
                             const s = t(i[r], n);
                             e.setAttribute(r, s)
                         }
                         const r = this.morphAttributes;
@@ -20203,34 +20587,34 @@
                     }
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }
-                We.prototype.isBufferGeometry = !0;
-                const je = new jt,
-                    Xe = new Wt,
-                    qe = new Ut,
-                    Ye = new mt,
-                    Je = new mt,
-                    Ze = new mt,
-                    Ke = new mt,
-                    Qe = new mt,
-                    $e = new mt,
-                    tn = new mt,
-                    en = new mt,
-                    nn = new mt,
-                    rn = new Y,
-                    sn = new Y,
-                    an = new Y,
-                    on = new mt,
-                    ln = new mt;
-                class cn extends ge {
-                    constructor(t = new We, e = new Ce) {
+                Li.prototype.isBufferGeometry = !0;
+                const Ci = new Cn,
+                    Pi = new Ln,
+                    Di = new Mn,
+                    Ii = new Qe,
+                    Ni = new Qe,
+                    Oi = new Qe,
+                    Ui = new Qe,
+                    Bi = new Qe,
+                    Fi = new Qe,
+                    zi = new Qe,
+                    Hi = new Qe,
+                    Gi = new Qe,
+                    Vi = new De,
+                    ki = new De,
+                    Wi = new De,
+                    ji = new Qe,
+                    Xi = new Qe;
+                class qi extends ei {
+                    constructor(t = new Li, e = new fi) {
                         super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                     }
                     updateMorphTargets() {
                         const t = this.geometry;
@@ -20253,16 +20637,16 @@
                         }
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.material,
                             r = this.matrixWorld;
                         if (void 0 === i) return;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), qe.copy(n.boundingSphere), qe.applyMatrix4(r), !1 === t.ray.intersectsSphere(qe)) return;
-                        if (je.copy(r).invert(), Xe.copy(t.ray).applyMatrix4(je), null !== n.boundingBox && !1 === Xe.intersectsBox(n.boundingBox)) return;
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), Di.copy(n.boundingSphere), Di.applyMatrix4(r), !1 === t.ray.intersectsSphere(Di)) return;
+                        if (Ci.copy(r).invert(), Pi.copy(t.ray).applyMatrix4(Ci), null !== n.boundingBox && !1 === Pi.intersectsBox(n.boundingBox)) return;
                         let s;
                         if (n.isBufferGeometry) {
                             const r = n.index,
                                 a = n.attributes.position,
                                 o = n.morphAttributes.position,
                                 l = n.morphTargetsRelative,
                                 c = n.attributes.uv,
@@ -20274,73 +20658,73 @@
                                     for (let n = 0, p = u.length; n < p; n++) {
                                         const p = u[n],
                                             m = i[p.materialIndex];
                                         for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                                             const i = r.getX(n),
                                                 u = r.getX(n + 1),
                                                 d = r.getX(n + 2);
-                                            s = hn(this, m, t, Xe, a, o, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
+                                            s = Yi(this, m, t, Pi, a, o, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                         }
                                     } else
                                         for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                                             const u = r.getX(n),
                                                 d = r.getX(n + 1),
                                                 p = r.getX(n + 2);
-                                            s = hn(this, i, t, Xe, a, o, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
+                                            s = Yi(this, i, t, Pi, a, o, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                         } else if (void 0 !== a)
                                             if (Array.isArray(i))
                                                 for (let n = 0, r = u.length; n < r; n++) {
                                                     const r = u[n],
                                                         p = i[r.materialIndex];
-                                                    for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) s = hn(this, p, t, Xe, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
+                                                    for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) s = Yi(this, p, t, Pi, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                                 } else
-                                                    for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) s = hn(this, i, t, Xe, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
+                                                    for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) s = Yi(this, i, t, Pi, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                         } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                     }
                 }
 
-                function hn(t, e, n, i, r, s, a, o, l, c, h, u) {
-                    Ye.fromBufferAttribute(r, c), Je.fromBufferAttribute(r, h), Ze.fromBufferAttribute(r, u);
-                    const d = t.morphTargetInfluences;
-                    if (s && d) {
-                        tn.set(0, 0, 0), en.set(0, 0, 0), nn.set(0, 0, 0);
+                function Yi(t, e, n, i, r, s, a, o, l, c, h, p) {
+                    Ii.fromBufferAttribute(r, c), Ni.fromBufferAttribute(r, h), Oi.fromBufferAttribute(r, p);
+                    const m = t.morphTargetInfluences;
+                    if (s && m) {
+                        zi.set(0, 0, 0), Hi.set(0, 0, 0), Gi.set(0, 0, 0);
                         for (let t = 0, e = s.length; t < e; t++) {
-                            const e = d[t],
+                            const e = m[t],
                                 n = s[t];
-                            0 !== e && (Ke.fromBufferAttribute(n, c), Qe.fromBufferAttribute(n, h), $e.fromBufferAttribute(n, u), a ? (tn.addScaledVector(Ke, e), en.addScaledVector(Qe, e), nn.addScaledVector($e, e)) : (tn.addScaledVector(Ke.sub(Ye), e), en.addScaledVector(Qe.sub(Je), e), nn.addScaledVector($e.sub(Ze), e)))
+                            0 !== e && (Ui.fromBufferAttribute(n, c), Bi.fromBufferAttribute(n, h), Fi.fromBufferAttribute(n, p), a ? (zi.addScaledVector(Ui, e), Hi.addScaledVector(Bi, e), Gi.addScaledVector(Fi, e)) : (zi.addScaledVector(Ui.sub(Ii), e), Hi.addScaledVector(Bi.sub(Ni), e), Gi.addScaledVector(Fi.sub(Oi), e)))
                         }
-                        Ye.add(tn), Je.add(en), Ze.add(nn)
+                        Ii.add(zi), Ni.add(Hi), Oi.add(Gi)
                     }
-                    t.isSkinnedMesh && (t.boneTransform(c, Ye), t.boneTransform(h, Je), t.boneTransform(u, Ze));
-                    const p = function(t, e, n, i, r, s, a, o) {
+                    t.isSkinnedMesh && (t.boneTransform(c, Ii), t.boneTransform(h, Ni), t.boneTransform(p, Oi));
+                    const f = function(t, e, n, i, r, s, a, o) {
                         let l;
-                        if (l = 1 === e.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, 2 !== e.side, o), null === l) return null;
-                        ln.copy(o), ln.applyMatrix4(t.matrixWorld);
-                        const c = n.ray.origin.distanceTo(ln);
+                        if (l = e.side === u ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, e.side !== d, o), null === l) return null;
+                        Xi.copy(o), Xi.applyMatrix4(t.matrixWorld);
+                        const c = n.ray.origin.distanceTo(Xi);
                         return c < n.near || c > n.far ? null : {
                             distance: c,
-                            point: ln.clone(),
+                            point: Xi.clone(),
                             object: t
                         }
-                    }(t, e, n, i, Ye, Je, Ze, on);
-                    if (p) {
-                        o && (rn.fromBufferAttribute(o, c), sn.fromBufferAttribute(o, h), an.fromBufferAttribute(o, u), p.uv = Ae.getUV(on, Ye, Je, Ze, rn, sn, an, new Y)), l && (rn.fromBufferAttribute(l, c), sn.fromBufferAttribute(l, h), an.fromBufferAttribute(l, u), p.uv2 = Ae.getUV(on, Ye, Je, Ze, rn, sn, an, new Y));
+                    }(t, e, n, i, Ii, Ni, Oi, ji);
+                    if (f) {
+                        o && (Vi.fromBufferAttribute(o, c), ki.fromBufferAttribute(o, h), Wi.fromBufferAttribute(o, p), f.uv = di.getUV(ji, Ii, Ni, Oi, Vi, ki, Wi, new De)), l && (Vi.fromBufferAttribute(l, c), ki.fromBufferAttribute(l, h), Wi.fromBufferAttribute(l, p), f.uv2 = di.getUV(ji, Ii, Ni, Oi, Vi, ki, Wi, new De));
                         const t = {
                             a: c,
                             b: h,
-                            c: u,
-                            normal: new mt,
+                            c: p,
+                            normal: new Qe,
                             materialIndex: 0
                         };
-                        Ae.getNormal(Ye, Je, Ze, t.normal), p.face = t
+                        di.getNormal(Ii, Ni, Oi, t.normal), f.face = t
                     }
-                    return p
+                    return f
                 }
-                cn.prototype.isMesh = !0;
-                class un extends We {
+                qi.prototype.isMesh = !0;
+                class Ji extends Li {
                     constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                         super(), this.type = "BoxGeometry", this.parameters = {
                             width: t,
                             height: e,
                             depth: n,
                             widthSegments: i,
                             heightSegments: r,
@@ -20361,15 +20745,15 @@
                                 _ = s / 2,
                                 M = p / 2,
                                 b = m / 2,
                                 w = f + 1,
                                 S = g + 1;
                             let E = 0,
                                 T = 0;
-                            const A = new mt;
+                            const A = new Qe;
                             for (let s = 0; s < S; s++) {
                                 const a = s * y - M;
                                 for (let o = 0; o < w; o++) {
                                     const u = o * x - _;
                                     A[t] = u * i, A[e] = a * r, A[n] = b, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(o / f), h.push(1 - s / g), E += 1
                                 }
                             }
@@ -20379,60 +20763,60 @@
                                         i = u + e + w * (t + 1),
                                         r = u + (e + 1) + w * (t + 1),
                                         s = u + (e + 1) + w * t;
                                     o.push(n, i, s), o.push(i, r, s), T += 6
                                 }
                             a.addGroup(d, T, v), d += T, u += E
                         }
-                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Ue(l, 3)), this.setAttribute("normal", new Ue(c, 3)), this.setAttribute("uv", new Ue(h, 2))
+                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Mi(l, 3)), this.setAttribute("normal", new Mi(c, 3)), this.setAttribute("uv", new Mi(h, 2))
                     }
                     static fromJSON(t) {
-                        return new un(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
+                        return new Ji(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
                     }
                 }
 
-                function dn(t) {
+                function Zi(t) {
                     const e = {};
                     for (const n in t) {
                         e[n] = {};
                         for (const i in t[n]) {
                             const r = t[n][i];
                             r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                         }
                     }
                     return e
                 }
 
-                function pn(t) {
+                function Ki(t) {
                     const e = {};
                     for (let n = 0; n < t.length; n++) {
-                        const i = dn(t[n]);
+                        const i = Zi(t[n]);
                         for (const t in i) e[t] = i[t]
                     }
                     return e
                 }
-                const mn = {
-                    clone: dn,
-                    merge: pn
+                const Qi = {
+                    clone: Zi,
+                    merge: Ki
                 };
-                class fn extends Le {
+                class $i extends mi {
                     constructor(t) {
                         super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                             derivatives: !1,
                             fragDepth: !1,
                             drawBuffers: !1,
                             shaderTextureLOD: !1
                         }, this.defaultAttributeValues = {
                             color: [1, 1, 1],
                             uv: [0, 0],
                             uv2: [0, 0]
                         }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
                     }
                     copy(t) {
-                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = dn(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
+                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Zi(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         e.glslVersion = this.glslVersion, e.uniforms = {};
                         for (const n in this.uniforms) {
                             const i = this.uniforms[n].value;
                             i && i.isTexture ? e.uniforms[n] = {
@@ -20462,18 +20846,18 @@
                         }
                         Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                         const n = {};
                         for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                         return Object.keys(n).length > 0 && (e.extensions = n), e
                     }
                 }
-                fn.prototype.isShaderMaterial = !0;
-                class gn extends ge {
+                $i.prototype.isShaderMaterial = !0;
+                class tr extends ei {
                     constructor() {
-                        super(), this.type = "Camera", this.matrixWorldInverse = new jt, this.projectionMatrix = new jt, this.projectionMatrixInverse = new jt
+                        super(), this.type = "Camera", this.matrixWorldInverse = new Cn, this.projectionMatrix = new Cn, this.projectionMatrixInverse = new Cn
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                     }
                     getWorldDirection(t) {
                         this.updateWorldMatrix(!0, !1);
                         const e = this.matrixWorld.elements;
@@ -20485,32 +20869,32 @@
                     updateWorldMatrix(t, e) {
                         super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                gn.prototype.isCamera = !0;
-                class vn extends gn {
+                tr.prototype.isCamera = !0;
+                class er extends tr {
                     constructor(t = 50, e = 1, n = .1, i = 2e3) {
                         super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                     }
                     setFocalLength(t) {
                         const e = .5 * this.getFilmHeight() / t;
-                        this.fov = 2 * V * Math.atan(e), this.updateProjectionMatrix()
+                        this.fov = 2 * Te * Math.atan(e), this.updateProjectionMatrix()
                     }
                     getFocalLength() {
-                        const t = Math.tan(.5 * G * this.fov);
+                        const t = Math.tan(.5 * Ee * this.fov);
                         return .5 * this.getFilmHeight() / t
                     }
                     getEffectiveFOV() {
-                        return 2 * V * Math.atan(Math.tan(.5 * G * this.fov) / this.zoom)
+                        return 2 * Te * Math.atan(Math.tan(.5 * Ee * this.fov) / this.zoom)
                     }
                     getFilmWidth() {
                         return this.filmGauge * Math.min(this.aspect, 1)
                     }
                     getFilmHeight() {
                         return this.filmGauge / Math.max(this.aspect, 1)
                     }
@@ -20526,15 +20910,15 @@
                         }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                     }
                     clearViewOffset() {
                         null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                     }
                     updateProjectionMatrix() {
                         const t = this.near;
-                        let e = t * Math.tan(.5 * G * this.fov) / this.zoom,
+                        let e = t * Math.tan(.5 * Ee * this.fov) / this.zoom,
                             n = 2 * e,
                             i = this.aspect * n,
                             r = -.5 * i;
                         const s = this.view;
                         if (null !== this.view && this.view.enabled) {
                             const t = s.fullWidth,
                                 a = s.fullHeight;
@@ -20544,108 +20928,108 @@
                         0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                     }
                 }
-                vn.prototype.isPerspectiveCamera = !0;
-                const xn = 90;
-                class yn extends ge {
+                er.prototype.isPerspectiveCamera = !0;
+                const nr = 90;
+                class ir extends ei {
                     constructor(t, e, n) {
                         if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                         this.renderTarget = n;
-                        const i = new vn(xn, 1, t, e);
-                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new mt(1, 0, 0)), this.add(i);
-                        const r = new vn(xn, 1, t, e);
-                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new mt(-1, 0, 0)), this.add(r);
-                        const s = new vn(xn, 1, t, e);
-                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new mt(0, 1, 0)), this.add(s);
-                        const a = new vn(xn, 1, t, e);
-                        a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new mt(0, -1, 0)), this.add(a);
-                        const o = new vn(xn, 1, t, e);
-                        o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new mt(0, 0, 1)), this.add(o);
-                        const l = new vn(xn, 1, t, e);
-                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new mt(0, 0, -1)), this.add(l)
+                        const i = new er(nr, 1, t, e);
+                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Qe(1, 0, 0)), this.add(i);
+                        const r = new er(nr, 1, t, e);
+                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Qe(-1, 0, 0)), this.add(r);
+                        const s = new er(nr, 1, t, e);
+                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Qe(0, 1, 0)), this.add(s);
+                        const a = new er(nr, 1, t, e);
+                        a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new Qe(0, -1, 0)), this.add(a);
+                        const o = new er(nr, 1, t, e);
+                        o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Qe(0, 0, 1)), this.add(o);
+                        const l = new er(nr, 1, t, e);
+                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Qe(0, 0, -1)), this.add(l)
                     }
                     update(t, e) {
                         null === this.parent && this.updateMatrixWorld();
                         const n = this.renderTarget,
                             [i, r, s, a, o, l] = this.children,
                             c = t.xr.enabled,
                             h = t.getRenderTarget();
                         t.xr.enabled = !1;
                         const u = n.texture.generateMipmaps;
                         n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, a), t.setRenderTarget(n, 4), t.render(e, o), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c, n.texture.needsPMREMUpdate = !0
                     }
                 }
-                class _n extends lt {
-                    constructor(t, e, n, i, s, a, o, l, c, h) {
-                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : r, n, i, s, a, o, l, c, h), this.flipY = !1
+                class rr extends Xe {
+                    constructor(t, e, n, i, r, s, a, o, l, c) {
+                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : Q, n, i, r, s, a, o, l, c), this.flipY = !1
                     }
                     get images() {
                         return this.image
                     }
                     set images(t) {
                         this.image = t
                     }
                 }
-                _n.prototype.isCubeTexture = !0;
-                class Mn extends ut {
+                rr.prototype.isCubeTexture = !0;
+                class sr extends Je {
                     constructor(t, e, n) {
-                        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new _n(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : u
+                        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new rr(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : ht
                     }
                     fromEquirectangularTexture(t, e) {
-                        this.texture.type = e.type, this.texture.format = y, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
+                        this.texture.type = e.type, this.texture.format = Et, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                         const n = {
                                 tEquirect: {
                                     value: null
                                 }
                             },
                             i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                             r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
-                            s = new un(5, 5, 5),
-                            a = new fn({
+                            s = new Ji(5, 5, 5),
+                            a = new $i({
                                 name: "CubemapFromEquirect",
-                                uniforms: dn(n),
+                                uniforms: Zi(n),
                                 vertexShader: i,
                                 fragmentShader: r,
-                                side: 1,
-                                blending: 0
+                                side: u,
+                                blending: p
                             });
                         a.uniforms.tEquirect.value = e;
-                        const o = new cn(s, a),
+                        const o = new qi(s, a),
                             l = e.minFilter;
-                        return e.minFilter === d && (e.minFilter = u), new yn(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
+                        return e.minFilter === dt && (e.minFilter = ht), new ir(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
                     }
                     clear(t, e, n, i) {
                         const r = t.getRenderTarget();
                         for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                         t.setRenderTarget(r)
                     }
                 }
-                Mn.prototype.isWebGLCubeRenderTarget = !0;
-                const bn = new mt,
-                    wn = new mt,
-                    Sn = new J;
-                class En {
-                    constructor(t = new mt(1, 0, 0), e = 0) {
+                sr.prototype.isWebGLCubeRenderTarget = !0;
+                const ar = new Qe,
+                    or = new Qe,
+                    lr = new Ie;
+                class cr {
+                    constructor(t = new Qe(1, 0, 0), e = 0) {
                         this.normal = t, this.constant = e
                     }
                     set(t, e) {
                         return this.normal.copy(t), this.constant = e, this
                     }
                     setComponents(t, e, n, i) {
                         return this.normal.set(t, e, n), this.constant = i, this
                     }
                     setFromNormalAndCoplanarPoint(t, e) {
                         return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                     }
                     setFromCoplanarPoints(t, e, n) {
-                        const i = bn.subVectors(n, e).cross(wn.subVectors(t, e)).normalize();
+                        const i = ar.subVectors(n, e).cross(or.subVectors(t, e)).normalize();
                         return this.setFromNormalAndCoplanarPoint(i, t), this
                     }
                     copy(t) {
                         return this.normal.copy(t.normal), this.constant = t.constant, this
                     }
                     normalize() {
                         const t = 1 / this.normal.length();
@@ -20660,15 +21044,15 @@
                     distanceToSphere(t) {
                         return this.distanceToPoint(t.center) - t.radius
                     }
                     projectPoint(t, e) {
                         return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                     }
                     intersectLine(t, e) {
-                        const n = t.delta(bn),
+                        const n = t.delta(ar),
                             i = this.normal.dot(n);
                         if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                         const r = -(t.start.dot(this.normal) + this.constant) / i;
                         return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
                     }
                     intersectsLine(t) {
                         const e = this.distanceToPoint(t.start),
@@ -20681,34 +21065,34 @@
                     intersectsSphere(t) {
                         return t.intersectsPlane(this)
                     }
                     coplanarPoint(t) {
                         return t.copy(this.normal).multiplyScalar(-this.constant)
                     }
                     applyMatrix4(t, e) {
-                        const n = e || Sn.getNormalMatrix(t),
-                            i = this.coplanarPoint(bn).applyMatrix4(t),
+                        const n = e || lr.getNormalMatrix(t),
+                            i = this.coplanarPoint(ar).applyMatrix4(t),
                             r = this.normal.applyMatrix3(n).normalize();
                         return this.constant = -i.dot(r), this
                     }
                     translate(t) {
                         return this.constant -= t.dot(this.normal), this
                     }
                     equals(t) {
                         return t.normal.equals(this.normal) && t.constant === this.constant
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                En.prototype.isPlane = !0;
-                const Tn = new Ut,
-                    An = new mt;
-                class Rn {
-                    constructor(t = new En, e = new En, n = new En, i = new En, r = new En, s = new En) {
+                cr.prototype.isPlane = !0;
+                const hr = new Mn,
+                    ur = new Qe;
+                class dr {
+                    constructor(t = new cr, e = new cr, n = new cr, i = new cr, r = new cr, s = new cr) {
                         this.planes = [t, e, n, i, r, s]
                     }
                     set(t, e, n, i, r, s) {
                         const a = this.planes;
                         return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this
                     }
                     copy(t) {
@@ -20735,47 +21119,47 @@
                             g = n[13],
                             v = n[14],
                             x = n[15];
                         return e[0].setComponents(a - i, h - o, m - u, x - f).normalize(), e[1].setComponents(a + i, h + o, m + u, x + f).normalize(), e[2].setComponents(a + r, h + l, m + d, x + g).normalize(), e[3].setComponents(a - r, h - l, m - d, x - g).normalize(), e[4].setComponents(a - s, h - c, m - p, x - v).normalize(), e[5].setComponents(a + s, h + c, m + p, x + v).normalize(), this
                     }
                     intersectsObject(t) {
                         const e = t.geometry;
-                        return null === e.boundingSphere && e.computeBoundingSphere(), Tn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Tn)
+                        return null === e.boundingSphere && e.computeBoundingSphere(), hr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(hr)
                     }
                     intersectsSprite(t) {
-                        return Tn.center.set(0, 0, 0), Tn.radius = .7071067811865476, Tn.applyMatrix4(t.matrixWorld), this.intersectsSphere(Tn)
+                        return hr.center.set(0, 0, 0), hr.radius = .7071067811865476, hr.applyMatrix4(t.matrixWorld), this.intersectsSphere(hr)
                     }
                     intersectsSphere(t) {
                         const e = this.planes,
                             n = t.center,
                             i = -t.radius;
                         for (let t = 0; t < 6; t++)
                             if (e[t].distanceToPoint(n) < i) return !1;
                         return !0
                     }
                     intersectsBox(t) {
                         const e = this.planes;
                         for (let n = 0; n < 6; n++) {
                             const i = e[n];
-                            if (An.x = i.normal.x > 0 ? t.max.x : t.min.x, An.y = i.normal.y > 0 ? t.max.y : t.min.y, An.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(An) < 0) return !1
+                            if (ur.x = i.normal.x > 0 ? t.max.x : t.min.x, ur.y = i.normal.y > 0 ? t.max.y : t.min.y, ur.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(ur) < 0) return !1
                         }
                         return !0
                     }
                     containsPoint(t) {
                         const e = this.planes;
                         for (let n = 0; n < 6; n++)
                             if (e[n].distanceToPoint(t) < 0) return !1;
                         return !0
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
 
-                function Ln() {
+                function pr() {
                     let t = null,
                         e = !1,
                         n = null,
                         i = null;
 
                     function r(e, s) {
                         n(e, s), i = t.requestAnimationFrame(r)
@@ -20792,15 +21176,15 @@
                         },
                         setContext: function(e) {
                             t = e
                         }
                     }
                 }
 
-                function Cn(t, e) {
+                function mr(t, e) {
                     const n = e.isWebGL2,
                         i = new WeakMap;
                     return {
                         get: function(t) {
                             return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                         },
                         remove: function(e) {
@@ -20836,15 +21220,15 @@
                                 const s = i.array,
                                     a = i.updateRange;
                                 t.bindBuffer(r, e), -1 === a.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1)
                             }(s.buffer, e, r), s.version = e.version)
                         }
                     }
                 }
-                class Pn extends We {
+                class fr extends Li {
                     constructor(t = 1, e = 1, n = 1, i = 1) {
                         super(), this.type = "PlaneGeometry", this.parameters = {
                             width: t,
                             height: e,
                             widthSegments: n,
                             heightSegments: i
                         };
@@ -20871,21 +21255,21 @@
                             for (let e = 0; e < a; e++) {
                                 const n = e + l * t,
                                     i = e + l * (t + 1),
                                     r = e + 1 + l * (t + 1),
                                     s = e + 1 + l * t;
                                 d.push(n, i, s), d.push(i, r, s)
                             }
-                        this.setIndex(d), this.setAttribute("position", new Ue(p, 3)), this.setAttribute("normal", new Ue(m, 3)), this.setAttribute("uv", new Ue(f, 2))
+                        this.setIndex(d), this.setAttribute("position", new Mi(p, 3)), this.setAttribute("normal", new Mi(m, 3)), this.setAttribute("uv", new Mi(f, 2))
                     }
                     static fromJSON(t) {
-                        return new Pn(t.width, t.height, t.widthSegments, t.heightSegments)
+                        return new fr(t.width, t.height, t.widthSegments, t.heightSegments)
                     }
                 }
-                const Dn = {
+                const gr = {
                         alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                         alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                         alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                         alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                         aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                         aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                         begin_vertex: "vec3 transformed = vec3( position );",
@@ -21013,30 +21397,30 @@
                         points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                         points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                         shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                         shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                         sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                         sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
                     },
-                    In = {
+                    vr = {
                         common: {
                             diffuse: {
-                                value: new rt(16777215)
+                                value: new Ve(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             map: {
                                 value: null
                             },
                             uvTransform: {
-                                value: new J
+                                value: new Ie
                             },
                             uv2Transform: {
-                                value: new J
+                                value: new Ie
                             },
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             }
@@ -21093,15 +21477,15 @@
                             }
                         },
                         normalmap: {
                             normalMap: {
                                 value: null
                             },
                             normalScale: {
-                                value: new Y(1, 1)
+                                value: new De(1, 1)
                             }
                         },
                         displacementmap: {
                             displacementMap: {
                                 value: null
                             },
                             displacementScale: {
@@ -21133,15 +21517,15 @@
                             fogNear: {
                                 value: 1
                             },
                             fogFar: {
                                 value: 2e3
                             },
                             fogColor: {
-                                value: new rt(16777215)
+                                value: new Ve(16777215)
                             }
                         },
                         lights: {
                             ambientLightColor: {
                                 value: []
                             },
                             lightProbe: {
@@ -21244,15 +21628,15 @@
                             },
                             ltc_2: {
                                 value: null
                             }
                         },
                         points: {
                             diffuse: {
-                                value: new rt(16777215)
+                                value: new Ve(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             size: {
                                 value: 1
                             },
@@ -21265,271 +21649,271 @@
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             },
                             uvTransform: {
-                                value: new J
+                                value: new Ie
                             }
                         },
                         sprite: {
                             diffuse: {
-                                value: new rt(16777215)
+                                value: new Ve(16777215)
                             },
                             opacity: {
                                 value: 1
                             },
                             center: {
-                                value: new Y(.5, .5)
+                                value: new De(.5, .5)
                             },
                             rotation: {
                                 value: 0
                             },
                             map: {
                                 value: null
                             },
                             alphaMap: {
                                 value: null
                             },
                             alphaTest: {
                                 value: 0
                             },
                             uvTransform: {
-                                value: new J
+                                value: new Ie
                             }
                         }
                     },
-                    Nn = {
+                    xr = {
                         basic: {
-                            uniforms: pn([In.common, In.specularmap, In.envmap, In.aomap, In.lightmap, In.fog]),
-                            vertexShader: Dn.meshbasic_vert,
-                            fragmentShader: Dn.meshbasic_frag
+                            uniforms: Ki([vr.common, vr.specularmap, vr.envmap, vr.aomap, vr.lightmap, vr.fog]),
+                            vertexShader: gr.meshbasic_vert,
+                            fragmentShader: gr.meshbasic_frag
                         },
                         lambert: {
-                            uniforms: pn([In.common, In.specularmap, In.envmap, In.aomap, In.lightmap, In.emissivemap, In.fog, In.lights, {
+                            uniforms: Ki([vr.common, vr.specularmap, vr.envmap, vr.aomap, vr.lightmap, vr.emissivemap, vr.fog, vr.lights, {
                                 emissive: {
-                                    value: new rt(0)
+                                    value: new Ve(0)
                                 }
                             }]),
-                            vertexShader: Dn.meshlambert_vert,
-                            fragmentShader: Dn.meshlambert_frag
+                            vertexShader: gr.meshlambert_vert,
+                            fragmentShader: gr.meshlambert_frag
                         },
                         phong: {
-                            uniforms: pn([In.common, In.specularmap, In.envmap, In.aomap, In.lightmap, In.emissivemap, In.bumpmap, In.normalmap, In.displacementmap, In.fog, In.lights, {
+                            uniforms: Ki([vr.common, vr.specularmap, vr.envmap, vr.aomap, vr.lightmap, vr.emissivemap, vr.bumpmap, vr.normalmap, vr.displacementmap, vr.fog, vr.lights, {
                                 emissive: {
-                                    value: new rt(0)
+                                    value: new Ve(0)
                                 },
                                 specular: {
-                                    value: new rt(1118481)
+                                    value: new Ve(1118481)
                                 },
                                 shininess: {
                                     value: 30
                                 }
                             }]),
-                            vertexShader: Dn.meshphong_vert,
-                            fragmentShader: Dn.meshphong_frag
+                            vertexShader: gr.meshphong_vert,
+                            fragmentShader: gr.meshphong_frag
                         },
                         standard: {
-                            uniforms: pn([In.common, In.envmap, In.aomap, In.lightmap, In.emissivemap, In.bumpmap, In.normalmap, In.displacementmap, In.roughnessmap, In.metalnessmap, In.fog, In.lights, {
+                            uniforms: Ki([vr.common, vr.envmap, vr.aomap, vr.lightmap, vr.emissivemap, vr.bumpmap, vr.normalmap, vr.displacementmap, vr.roughnessmap, vr.metalnessmap, vr.fog, vr.lights, {
                                 emissive: {
-                                    value: new rt(0)
+                                    value: new Ve(0)
                                 },
                                 roughness: {
                                     value: 1
                                 },
                                 metalness: {
                                     value: 0
                                 },
                                 envMapIntensity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Dn.meshphysical_vert,
-                            fragmentShader: Dn.meshphysical_frag
+                            vertexShader: gr.meshphysical_vert,
+                            fragmentShader: gr.meshphysical_frag
                         },
                         toon: {
-                            uniforms: pn([In.common, In.aomap, In.lightmap, In.emissivemap, In.bumpmap, In.normalmap, In.displacementmap, In.gradientmap, In.fog, In.lights, {
+                            uniforms: Ki([vr.common, vr.aomap, vr.lightmap, vr.emissivemap, vr.bumpmap, vr.normalmap, vr.displacementmap, vr.gradientmap, vr.fog, vr.lights, {
                                 emissive: {
-                                    value: new rt(0)
+                                    value: new Ve(0)
                                 }
                             }]),
-                            vertexShader: Dn.meshtoon_vert,
-                            fragmentShader: Dn.meshtoon_frag
+                            vertexShader: gr.meshtoon_vert,
+                            fragmentShader: gr.meshtoon_frag
                         },
                         matcap: {
-                            uniforms: pn([In.common, In.bumpmap, In.normalmap, In.displacementmap, In.fog, {
+                            uniforms: Ki([vr.common, vr.bumpmap, vr.normalmap, vr.displacementmap, vr.fog, {
                                 matcap: {
                                     value: null
                                 }
                             }]),
-                            vertexShader: Dn.meshmatcap_vert,
-                            fragmentShader: Dn.meshmatcap_frag
+                            vertexShader: gr.meshmatcap_vert,
+                            fragmentShader: gr.meshmatcap_frag
                         },
                         points: {
-                            uniforms: pn([In.points, In.fog]),
-                            vertexShader: Dn.points_vert,
-                            fragmentShader: Dn.points_frag
+                            uniforms: Ki([vr.points, vr.fog]),
+                            vertexShader: gr.points_vert,
+                            fragmentShader: gr.points_frag
                         },
                         dashed: {
-                            uniforms: pn([In.common, In.fog, {
+                            uniforms: Ki([vr.common, vr.fog, {
                                 scale: {
                                     value: 1
                                 },
                                 dashSize: {
                                     value: 1
                                 },
                                 totalSize: {
                                     value: 2
                                 }
                             }]),
-                            vertexShader: Dn.linedashed_vert,
-                            fragmentShader: Dn.linedashed_frag
+                            vertexShader: gr.linedashed_vert,
+                            fragmentShader: gr.linedashed_frag
                         },
                         depth: {
-                            uniforms: pn([In.common, In.displacementmap]),
-                            vertexShader: Dn.depth_vert,
-                            fragmentShader: Dn.depth_frag
+                            uniforms: Ki([vr.common, vr.displacementmap]),
+                            vertexShader: gr.depth_vert,
+                            fragmentShader: gr.depth_frag
                         },
                         normal: {
-                            uniforms: pn([In.common, In.bumpmap, In.normalmap, In.displacementmap, {
+                            uniforms: Ki([vr.common, vr.bumpmap, vr.normalmap, vr.displacementmap, {
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Dn.meshnormal_vert,
-                            fragmentShader: Dn.meshnormal_frag
+                            vertexShader: gr.meshnormal_vert,
+                            fragmentShader: gr.meshnormal_frag
                         },
                         sprite: {
-                            uniforms: pn([In.sprite, In.fog]),
-                            vertexShader: Dn.sprite_vert,
-                            fragmentShader: Dn.sprite_frag
+                            uniforms: Ki([vr.sprite, vr.fog]),
+                            vertexShader: gr.sprite_vert,
+                            fragmentShader: gr.sprite_frag
                         },
                         background: {
                             uniforms: {
                                 uvTransform: {
-                                    value: new J
+                                    value: new Ie
                                 },
                                 t2D: {
                                     value: null
                                 }
                             },
-                            vertexShader: Dn.background_vert,
-                            fragmentShader: Dn.background_frag
+                            vertexShader: gr.background_vert,
+                            fragmentShader: gr.background_frag
                         },
                         cube: {
-                            uniforms: pn([In.envmap, {
+                            uniforms: Ki([vr.envmap, {
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Dn.cube_vert,
-                            fragmentShader: Dn.cube_frag
+                            vertexShader: gr.cube_vert,
+                            fragmentShader: gr.cube_frag
                         },
                         equirect: {
                             uniforms: {
                                 tEquirect: {
                                     value: null
                                 }
                             },
-                            vertexShader: Dn.equirect_vert,
-                            fragmentShader: Dn.equirect_frag
+                            vertexShader: gr.equirect_vert,
+                            fragmentShader: gr.equirect_frag
                         },
                         distanceRGBA: {
-                            uniforms: pn([In.common, In.displacementmap, {
+                            uniforms: Ki([vr.common, vr.displacementmap, {
                                 referencePosition: {
-                                    value: new mt
+                                    value: new Qe
                                 },
                                 nearDistance: {
                                     value: 1
                                 },
                                 farDistance: {
                                     value: 1e3
                                 }
                             }]),
-                            vertexShader: Dn.distanceRGBA_vert,
-                            fragmentShader: Dn.distanceRGBA_frag
+                            vertexShader: gr.distanceRGBA_vert,
+                            fragmentShader: gr.distanceRGBA_frag
                         },
                         shadow: {
-                            uniforms: pn([In.lights, In.fog, {
+                            uniforms: Ki([vr.lights, vr.fog, {
                                 color: {
-                                    value: new rt(0)
+                                    value: new Ve(0)
                                 },
                                 opacity: {
                                     value: 1
                                 }
                             }]),
-                            vertexShader: Dn.shadow_vert,
-                            fragmentShader: Dn.shadow_frag
+                            vertexShader: gr.shadow_vert,
+                            fragmentShader: gr.shadow_frag
                         }
                     };
 
-                function On(t, e, n, i, r, s) {
-                    const o = new rt(0);
-                    let l, c, h = !0 === r ? 0 : 1,
-                        u = null,
-                        d = 0,
-                        p = null;
+                function yr(t, e, n, i, r, s) {
+                    const a = new Ve(0);
+                    let o, l, c = !0 === r ? 0 : 1,
+                        d = null,
+                        p = 0,
+                        m = null;
 
-                    function m(t, e) {
+                    function f(t, e) {
                         n.buffers.color.setClear(t.r, t.g, t.b, e, s)
                     }
                     return {
                         getClearColor: function() {
-                            return o
+                            return a
                         },
                         setClearColor: function(t, e = 1) {
-                            o.set(t), h = e, m(o, h)
+                            a.set(t), c = e, f(a, c)
                         },
                         getClearAlpha: function() {
-                            return h
+                            return c
                         },
                         setClearAlpha: function(t) {
-                            h = t, m(o, h)
+                            c = t, f(a, c)
                         },
                         render: function(n, r) {
                             let s = !1,
-                                f = !0 === r.isScene ? r.background : null;
-                            f && f.isTexture && (f = e.get(f));
-                            const g = t.xr,
-                                v = g.getSession && g.getSession();
-                            v && "additive" === v.environmentBlendMode && (f = null), null === f ? m(o, h) : f && f.isColor && (m(f, 1), s = !0), (t.autoClear || s) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.mapping === a) ? (void 0 === c && (c = new cn(new un(1, 1, 1), new fn({
+                                g = !0 === r.isScene ? r.background : null;
+                            g && g.isTexture && (g = e.get(g));
+                            const v = t.xr,
+                                x = v.getSession && v.getSession();
+                            x && "additive" === x.environmentBlendMode && (g = null), null === g ? f(a, c) : g && g.isColor && (f(g, 1), s = !0), (t.autoClear || s) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.mapping === nt) ? (void 0 === l && (l = new qi(new Ji(1, 1, 1), new $i({
                                 name: "BackgroundCubeMaterial",
-                                uniforms: dn(Nn.cube.uniforms),
-                                vertexShader: Nn.cube.vertexShader,
-                                fragmentShader: Nn.cube.fragmentShader,
-                                side: 1,
+                                uniforms: Zi(xr.cube.uniforms),
+                                vertexShader: xr.cube.vertexShader,
+                                fragmentShader: xr.cube.fragmentShader,
+                                side: u,
                                 depthTest: !1,
                                 depthWrite: !1,
                                 fog: !1
-                            })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(t, e, n) {
+                            })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(t, e, n) {
                                 this.matrixWorld.copyPosition(n.matrixWorld)
-                            }, Object.defineProperty(c.material, "envMap", {
+                            }, Object.defineProperty(l.material, "envMap", {
                                 get: function() {
                                     return this.uniforms.envMap.value
                                 }
-                            }), i.update(c)), c.material.uniforms.envMap.value = f, c.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, u === f && d === f.version && p === t.toneMapping || (c.material.needsUpdate = !0, u = f, d = f.version, p = t.toneMapping), n.unshift(c, c.geometry, c.material, 0, 0, null)) : f && f.isTexture && (void 0 === l && (l = new cn(new Pn(2, 2), new fn({
+                            }), i.update(l)), l.material.uniforms.envMap.value = g, l.material.uniforms.flipEnvMap.value = g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1, d === g && p === g.version && m === t.toneMapping || (l.material.needsUpdate = !0, d = g, p = g.version, m = t.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null)) : g && g.isTexture && (void 0 === o && (o = new qi(new fr(2, 2), new $i({
                                 name: "BackgroundMaterial",
-                                uniforms: dn(Nn.background.uniforms),
-                                vertexShader: Nn.background.vertexShader,
-                                fragmentShader: Nn.background.fragmentShader,
-                                side: 0,
+                                uniforms: Zi(xr.background.uniforms),
+                                vertexShader: xr.background.vertexShader,
+                                fragmentShader: xr.background.fragmentShader,
+                                side: h,
                                 depthTest: !1,
                                 depthWrite: !1,
                                 fog: !1
-                            })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
+                            })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                                 get: function() {
                                     return this.uniforms.t2D.value
                                 }
-                            }), i.update(l)), l.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), l.material.uniforms.uvTransform.value.copy(f.matrix), u === f && d === f.version && p === t.toneMapping || (l.material.needsUpdate = !0, u = f, d = f.version, p = t.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null))
+                            }), i.update(o)), o.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), o.material.uniforms.uvTransform.value.copy(g.matrix), d === g && p === g.version && m === t.toneMapping || (o.material.needsUpdate = !0, d = g, p = g.version, m = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                         }
                     }
                 }
 
-                function Un(t, e, n, i) {
+                function _r(t, e, n, i) {
                     const r = t.getParameter(34921),
                         s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                         a = i.isWebGL2 || null !== s,
                         o = {},
                         l = d(null);
                     let c = l;
 
@@ -21726,15 +22110,15 @@
                         },
                         initAttributes: p,
                         enableAttribute: m,
                         disableUnusedAttributes: g
                     }
                 }
 
-                function Bn(t, e, n, i) {
+                function Mr(t, e, n, i) {
                     const r = i.isWebGL2;
                     let s;
                     this.setMode = function(t) {
                         s = t
                     }, this.render = function(e, i) {
                         t.drawArrays(s, e, i), n.update(i, s, 1)
                     }, this.renderInstances = function(i, a, o) {
@@ -21742,15 +22126,15 @@
                         let l, c;
                         if (r) l = t, c = "drawArraysInstanced";
                         else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                         l[c](s, i, a, o), n.update(a, s, o)
                     }
                 }
 
-                function Fn(t, e, n) {
+                function br(t, e, n) {
                     let i;
 
                     function r(e) {
                         if ("highp" === e) {
                             if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                             e = "mediump"
                         }
@@ -21797,22 +22181,22 @@
                         vertexTextures: x,
                         floatFragmentTextures: y,
                         floatVertexTextures: x && y,
                         maxSamples: s ? t.getParameter(36183) : 0
                     }
                 }
 
-                function zn(t) {
+                function wr(t) {
                     const e = this;
                     let n = null,
                         i = 0,
                         r = !1,
                         s = !1;
-                    const a = new En,
-                        o = new J,
+                    const a = new cr,
+                        o = new Ie,
                         l = {
                             value: null,
                             needsUpdate: !1
                         };
 
                     function c() {
                         l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
@@ -21852,74 +22236,74 @@
                             l.value = r, r = h(u, a, e, o);
                             for (let t = 0; t !== e; ++t) r[t] = n[t];
                             m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                         }
                     }
                 }
 
-                function Hn(t) {
+                function Sr(t) {
                     let e = new WeakMap;
 
                     function n(t, e) {
-                        return 303 === e ? t.mapping = r : 304 === e && (t.mapping = s), t
+                        return e === tt ? t.mapping = Q : e === et && (t.mapping = $), t
                     }
 
                     function i(t) {
                         const n = t.target;
                         n.removeEventListener("dispose", i);
                         const r = e.get(n);
                         void 0 !== r && (e.delete(n), r.dispose())
                     }
                     return {
                         get: function(r) {
                             if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                                 const s = r.mapping;
-                                if (303 === s || 304 === s) {
+                                if (s === tt || s === et) {
                                     if (e.has(r)) return n(e.get(r).texture, r.mapping); {
                                         const s = r.image;
                                         if (s && s.height > 0) {
-                                            const a = new Mn(s.height / 2);
+                                            const a = new sr(s.height / 2);
                                             return a.fromEquirectangularTexture(t, r), e.set(r, a), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                         }
                                         return null
                                     }
                                 }
                             }
                             return r
                         },
                         dispose: function() {
                             e = new WeakMap
                         }
                     }
                 }
-                Nn.physical = {
-                    uniforms: pn([Nn.standard.uniforms, {
+                xr.physical = {
+                    uniforms: Ki([xr.standard.uniforms, {
                         clearcoat: {
                             value: 0
                         },
                         clearcoatMap: {
                             value: null
                         },
                         clearcoatRoughness: {
                             value: 0
                         },
                         clearcoatRoughnessMap: {
                             value: null
                         },
                         clearcoatNormalScale: {
-                            value: new Y(1, 1)
+                            value: new De(1, 1)
                         },
                         clearcoatNormalMap: {
                             value: null
                         },
                         sheen: {
                             value: 0
                         },
                         sheenColor: {
-                            value: new rt(0)
+                            value: new Ve(0)
                         },
                         sheenColorMap: {
                             value: null
                         },
                         sheenRoughness: {
                             value: 1
                         },
@@ -21929,48 +22313,48 @@
                         transmission: {
                             value: 0
                         },
                         transmissionMap: {
                             value: null
                         },
                         transmissionSamplerSize: {
-                            value: new Y
+                            value: new De
                         },
                         transmissionSamplerMap: {
                             value: null
                         },
                         thickness: {
                             value: 0
                         },
                         thicknessMap: {
                             value: null
                         },
                         attenuationDistance: {
                             value: 0
                         },
                         attenuationColor: {
-                            value: new rt(0)
+                            value: new Ve(0)
                         },
                         specularIntensity: {
                             value: 1
                         },
                         specularIntensityMap: {
                             value: null
                         },
                         specularColor: {
-                            value: new rt(1, 1, 1)
+                            value: new Ve(1, 1, 1)
                         },
                         specularColorMap: {
                             value: null
                         }
                     }]),
-                    vertexShader: Dn.meshphysical_vert,
-                    fragmentShader: Dn.meshphysical_frag
+                    vertexShader: gr.meshphysical_vert,
+                    fragmentShader: gr.meshphysical_frag
                 };
-                class Gn extends gn {
+                class Er extends tr {
                     constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) {
                         super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
                     }
                     copy(t, e) {
                         return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                     }
                     setViewOffset(t, e, n, i, r, s) {
@@ -22004,41 +22388,43 @@
                         this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                     }
                 }
-                Gn.prototype.isOrthographicCamera = !0;
-                class Vn extends fn {
+                Er.prototype.isOrthographicCamera = !0;
+                class Tr extends $i {
                     constructor(t) {
                         super(t), this.type = "RawShaderMaterial"
                     }
                 }
-                Vn.prototype.isRawShaderMaterial = !0;
-                const kn = Math.pow(2, 8),
-                    Wn = [.125, .215, .35, .446, .526, .582],
-                    jn = 5 + Wn.length,
-                    Xn = new Gn,
+                Tr.prototype.isRawShaderMaterial = !0;
+                const Ar = 4,
+                    Rr = 8,
+                    Lr = Math.pow(2, Rr),
+                    Cr = [.125, .215, .35, .446, .526, .582],
+                    Pr = Rr - Ar + 1 + Cr.length,
+                    Dr = new Er,
                     {
-                        _lodPlanes: qn,
-                        _sizeLods: Yn,
-                        _sigmas: Jn
-                    } = ni(),
-                    Zn = new rt;
-                let Kn = null;
-                const Qn = (1 + Math.sqrt(5)) / 2,
-                    $n = 1 / Qn,
-                    ti = [new mt(1, 1, 1), new mt(-1, 1, 1), new mt(1, 1, -1), new mt(-1, 1, -1), new mt(0, Qn, $n), new mt(0, Qn, -$n), new mt($n, 0, Qn), new mt(-$n, 0, Qn), new mt(Qn, $n, 0), new mt(-Qn, $n, 0)];
-                class ei {
+                        _lodPlanes: Ir,
+                        _sizeLods: Nr,
+                        _sigmas: Or
+                    } = Vr(),
+                    Ur = new Ve;
+                let Br = null;
+                const Fr = (1 + Math.sqrt(5)) / 2,
+                    zr = 1 / Fr,
+                    Hr = [new Qe(1, 1, 1), new Qe(-1, 1, 1), new Qe(1, 1, -1), new Qe(-1, 1, -1), new Qe(0, Fr, zr), new Qe(0, Fr, -zr), new Qe(zr, 0, Fr), new Qe(-zr, 0, Fr), new Qe(Fr, zr, 0), new Qe(-Fr, zr, 0)];
+                class Gr {
                     constructor(t) {
                         this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
                             const e = new Float32Array(20),
-                                n = new mt(0, 1, 0);
-                            return new Vn({
+                                n = new Qe(0, 1, 0);
+                            return new Tr({
                                 name: "SphericalGaussianBlur",
                                 defines: {
                                     n: 20
                                 },
                                 uniforms: {
                                     envMap: {
                                         value: null
@@ -22060,149 +22446,149 @@
                                     },
                                     poleAxis: {
                                         value: n
                                     }
                                 },
                                 vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                 fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
-                                blending: 0,
+                                blending: p,
                                 depthTest: !1,
                                 depthWrite: !1
                             })
                         }(), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                     }
                     fromScene(t, e = 0, n = .1, i = 100) {
-                        Kn = this._renderer.getRenderTarget();
+                        Br = this._renderer.getRenderTarget();
                         const r = this._allocateTargets();
                         return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
                     }
                     fromEquirectangular(t, e = null) {
                         return this._fromTexture(t, e)
                     }
                     fromCubemap(t, e = null) {
                         return this._fromTexture(t, e)
                     }
                     compileCubemapShader() {
-                        null === this._cubemapShader && (this._cubemapShader = ai(), this._compileMaterial(this._cubemapShader))
+                        null === this._cubemapShader && (this._cubemapShader = Xr(), this._compileMaterial(this._cubemapShader))
                     }
                     compileEquirectangularShader() {
-                        null === this._equirectShader && (this._equirectShader = si(), this._compileMaterial(this._equirectShader))
+                        null === this._equirectShader && (this._equirectShader = jr(), this._compileMaterial(this._equirectShader))
                     }
                     dispose() {
                         this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
-                        for (let t = 0; t < qn.length; t++) qn[t].dispose()
+                        for (let t = 0; t < Ir.length; t++) Ir[t].dispose()
                     }
                     _cleanup(t) {
-                        this._renderer.setRenderTarget(Kn), t.scissorTest = !1, ri(t, 0, 0, t.width, t.height)
+                        this._renderer.setRenderTarget(Br), t.scissorTest = !1, Wr(t, 0, 0, t.width, t.height)
                     }
                     _fromTexture(t, e) {
-                        Kn = this._renderer.getRenderTarget();
+                        Br = this._renderer.getRenderTarget();
                         const n = e || this._allocateTargets(t);
                         return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
                     }
                     _allocateTargets(t) {
                         const e = {
-                                magFilter: u,
-                                minFilter: u,
+                                magFilter: ht,
+                                minFilter: ht,
                                 generateMipmaps: !1,
-                                type: v,
-                                format: y,
-                                encoding: D,
+                                type: _t,
+                                format: Et,
+                                encoding: pe,
                                 depthBuffer: !1
                             },
-                            n = ii(e);
-                        return n.depthBuffer = !t, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = ii(e)), n
+                            n = kr(e);
+                        return n.depthBuffer = !t, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = kr(e)), n
                     }
                     _compileMaterial(t) {
-                        const e = new cn(qn[0], t);
-                        this._renderer.compile(e, Xn)
+                        const e = new qi(Ir[0], t);
+                        this._renderer.compile(e, Dr)
                     }
                     _sceneToCubeUV(t, e, n, i) {
-                        const r = new vn(90, 1, e, n),
+                        const r = new er(90, 1, e, n),
                             s = [1, -1, 1, 1, 1, 1],
                             a = [1, 1, 1, -1, -1, -1],
                             o = this._renderer,
                             l = o.autoClear,
                             c = o.toneMapping;
-                        o.getClearColor(Zn), o.toneMapping = 0, o.autoClear = !1;
-                        const h = new Ce({
+                        o.getClearColor(Ur), o.toneMapping = X, o.autoClear = !1;
+                        const h = new fi({
                                 name: "PMREM.Background",
-                                side: 1,
+                                side: u,
                                 depthWrite: !1,
                                 depthTest: !1
                             }),
-                            u = new cn(new un, h);
-                        let d = !1;
-                        const p = t.background;
-                        p ? p.isColor && (h.color.copy(p), t.background = null, d = !0) : (h.color.copy(Zn), d = !0);
+                            d = new qi(new Ji, h);
+                        let p = !1;
+                        const m = t.background;
+                        m ? m.isColor && (h.color.copy(m), t.background = null, p = !0) : (h.color.copy(Ur), p = !0);
                         for (let e = 0; e < 6; e++) {
                             const n = e % 3;
-                            0 === n ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])), ri(i, n * kn, e > 2 ? kn : 0, kn, kn), o.setRenderTarget(i), d && o.render(u, r), o.render(t, r)
+                            0 === n ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])), Wr(i, n * Lr, e > 2 ? Lr : 0, Lr, Lr), o.setRenderTarget(i), p && o.render(d, r), o.render(t, r)
                         }
-                        u.geometry.dispose(), u.material.dispose(), o.toneMapping = c, o.autoClear = l, t.background = p
+                        d.geometry.dispose(), d.material.dispose(), o.toneMapping = c, o.autoClear = l, t.background = m
                     }
                     _textureToCubeUV(t, e) {
                         const n = this._renderer,
-                            i = t.mapping === r || t.mapping === s;
-                        i ? (null === this._cubemapShader && (this._cubemapShader = ai()), this._cubemapShader.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = si());
-                        const a = i ? this._cubemapShader : this._equirectShader,
-                            o = new cn(qn[0], a),
-                            l = a.uniforms;
-                        l.envMap.value = t, i || l.texelSize.value.set(1 / t.image.width, 1 / t.image.height), ri(e, 0, 0, 3 * kn, 2 * kn), n.setRenderTarget(e), n.render(o, Xn)
+                            i = t.mapping === Q || t.mapping === $;
+                        i ? (null === this._cubemapShader && (this._cubemapShader = Xr()), this._cubemapShader.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = jr());
+                        const r = i ? this._cubemapShader : this._equirectShader,
+                            s = new qi(Ir[0], r),
+                            a = r.uniforms;
+                        a.envMap.value = t, i || a.texelSize.value.set(1 / t.image.width, 1 / t.image.height), Wr(e, 0, 0, 3 * Lr, 2 * Lr), n.setRenderTarget(e), n.render(s, Dr)
                     }
                     _applyPMREM(t) {
                         const e = this._renderer,
                             n = e.autoClear;
                         e.autoClear = !1;
-                        for (let e = 1; e < jn; e++) {
-                            const n = Math.sqrt(Jn[e] * Jn[e] - Jn[e - 1] * Jn[e - 1]),
-                                i = ti[(e - 1) % ti.length];
+                        for (let e = 1; e < Pr; e++) {
+                            const n = Math.sqrt(Or[e] * Or[e] - Or[e - 1] * Or[e - 1]),
+                                i = Hr[(e - 1) % Hr.length];
                             this._blur(t, e - 1, e, n, i)
                         }
                         e.autoClear = n
                     }
                     _blur(t, e, n, i, r) {
                         const s = this._pingPongRenderTarget;
                         this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r)
                     }
                     _halfBlur(t, e, n, i, r, s, a) {
                         const o = this._renderer,
                             l = this._blurMaterial;
                         "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
-                        const c = new cn(qn[i], l),
+                        const c = new qi(Ir[i], l),
                             h = l.uniforms,
-                            u = Yn[n] - 1,
+                            u = Nr[n] - 1,
                             d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                             p = r / d,
                             m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                         m > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
                         const f = [];
                         let g = 0;
                         for (let t = 0; t < 20; ++t) {
                             const e = t / p,
                                 n = Math.exp(-e * e / 2);
                             f.push(n), 0 === t ? g += n : t < m && (g += 2 * n)
                         }
                         for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
-                        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = 8 - n;
-                        const v = Yn[i];
-                        ri(e, 3 * Math.max(0, kn - 2 * v), (0 === i ? 0 : 2 * kn) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), o.setRenderTarget(e), o.render(c, Xn)
+                        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = Rr - n;
+                        const v = Nr[i];
+                        Wr(e, 3 * Math.max(0, Lr - 2 * v), (0 === i ? 0 : 2 * Lr) + 2 * v * (i > Rr - Ar ? i - Rr + Ar : 0), 3 * v, 2 * v), o.setRenderTarget(e), o.render(c, Dr)
                     }
                 }
 
-                function ni() {
+                function Vr() {
                     const t = [],
                         e = [],
                         n = [];
-                    let i = 8;
-                    for (let r = 0; r < jn; r++) {
+                    let i = Rr;
+                    for (let r = 0; r < Pr; r++) {
                         const s = Math.pow(2, i);
                         e.push(s);
                         let a = 1 / s;
-                        r > 4 ? a = Wn[r - 8 + 4 - 1] : 0 === r && (a = 0), n.push(a);
+                        r > Rr - Ar ? a = Cr[r - Rr + Ar - 1] : 0 === r && (a = 0), n.push(a);
                         const o = 1 / (s - 1),
                             l = -o / 2,
                             c = 1 + o / 2,
                             h = [l, l, c, l, c, c, l, l, c, c, l, c],
                             u = 6,
                             d = 6,
                             p = 3,
@@ -22215,118 +22601,118 @@
                             const e = t % 3 * 2 / 3 - 1,
                                 n = t > 2 ? 0 : -1,
                                 i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                             g.set(i, p * d * t), v.set(h, m * d * t);
                             const r = [t, t, t, t, t, t];
                             x.set(r, f * d * t)
                         }
-                        const y = new We;
-                        y.setAttribute("position", new Ie(g, p)), y.setAttribute("uv", new Ie(v, m)), y.setAttribute("faceIndex", new Ie(x, f)), t.push(y), i > 4 && i--
+                        const y = new Li;
+                        y.setAttribute("position", new xi(g, p)), y.setAttribute("uv", new xi(v, m)), y.setAttribute("faceIndex", new xi(x, f)), t.push(y), i > Ar && i--
                     }
                     return {
                         _lodPlanes: t,
                         _sizeLods: e,
                         _sigmas: n
                     }
                 }
 
-                function ii(t) {
-                    const e = new ut(3 * kn, 3 * kn, t);
-                    return e.texture.mapping = a, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
+                function kr(t) {
+                    const e = new Je(3 * Lr, 3 * Lr, t);
+                    return e.texture.mapping = nt, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
                 }
 
-                function ri(t, e, n, i, r) {
+                function Wr(t, e, n, i, r) {
                     t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
                 }
 
-                function si() {
-                    const t = new Y(1, 1);
-                    return new Vn({
+                function jr() {
+                    const t = new De(1, 1);
+                    return new Tr({
                         name: "EquirectangularToCubeUV",
                         uniforms: {
                             envMap: {
                                 value: null
                             },
                             texelSize: {
                                 value: t
                             }
                         },
                         vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                         fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",
-                        blending: 0,
+                        blending: p,
                         depthTest: !1,
                         depthWrite: !1
                     })
                 }
 
-                function ai() {
-                    return new Vn({
+                function Xr() {
+                    return new Tr({
                         name: "CubemapToCubeUV",
                         uniforms: {
                             envMap: {
                                 value: null
                             },
                             flipEnvMap: {
                                 value: -1
                             }
                         },
                         vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                         fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
-                        blending: 0,
+                        blending: p,
                         depthTest: !1,
                         depthWrite: !1
                     })
                 }
 
-                function oi(t) {
+                function qr(t) {
                     let e = new WeakMap,
                         n = null;
 
                     function i(t) {
                         const n = t.target;
                         n.removeEventListener("dispose", i);
                         const r = e.get(n);
                         void 0 !== r && (e.delete(n), r.dispose())
                     }
                     return {
-                        get: function(a) {
-                            if (a && a.isTexture) {
-                                const o = a.mapping,
-                                    l = 303 === o || 304 === o,
-                                    c = o === r || o === s;
-                                if (l || c) {
-                                    if (a.isRenderTargetTexture && !0 === a.needsPMREMUpdate) {
-                                        a.needsPMREMUpdate = !1;
-                                        let i = e.get(a);
-                                        return null === n && (n = new ei(t)), i = l ? n.fromEquirectangular(a, i) : n.fromCubemap(a, i), e.set(a, i), i.texture
-                                    }
-                                    if (e.has(a)) return e.get(a).texture; {
-                                        const r = a.image;
-                                        if (l && r && r.height > 0 || c && r && function(t) {
+                        get: function(r) {
+                            if (r && r.isTexture) {
+                                const s = r.mapping,
+                                    a = s === tt || s === et,
+                                    o = s === Q || s === $;
+                                if (a || o) {
+                                    if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
+                                        r.needsPMREMUpdate = !1;
+                                        let i = e.get(r);
+                                        return null === n && (n = new Gr(t)), i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture
+                                    }
+                                    if (e.has(r)) return e.get(r).texture; {
+                                        const s = r.image;
+                                        if (a && s && s.height > 0 || o && s && function(t) {
                                                 let e = 0;
                                                 for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                                 return 6 === e
-                                            }(r)) {
-                                            null === n && (n = new ei(t));
-                                            const r = l ? n.fromEquirectangular(a) : n.fromCubemap(a);
-                                            return e.set(a, r), a.addEventListener("dispose", i), r.texture
+                                            }(s)) {
+                                            null === n && (n = new Gr(t));
+                                            const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
+                                            return e.set(r, s), r.addEventListener("dispose", i), s.texture
                                         }
                                         return null
                                     }
                                 }
                             }
-                            return a
+                            return r
                         },
                         dispose: function() {
                             e = new WeakMap, null !== n && (n.dispose(), n = null)
                         }
                     }
                 }
 
-                function li(t) {
+                function Yr(t) {
                     const e = {};
 
                     function n(n) {
                         if (void 0 !== e[n]) return e[n];
                         let i;
                         switch (n) {
                             case "WEBGL_depth_texture":
@@ -22356,15 +22742,15 @@
                         get: function(t) {
                             const e = n(t);
                             return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                         }
                     }
                 }
 
-                function ci(t, e, n, i) {
+                function Jr(t, e, n, i) {
                     const r = {},
                         s = new WeakMap;
 
                     function a(t) {
                         const o = t.target;
                         null !== o.index && e.remove(o.index);
                         for (const t in o.attributes) e.remove(o.attributes[t]);
@@ -22393,15 +22779,15 @@
                             for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                                 const t = e + 0,
                                     i = e + 1,
                                     r = e + 2;
                                 n.push(t, i, i, r, r, t)
                             }
                         }
-                        const o = new(Z(n) ? Oe : Ne)(n, 1);
+                        const o = new(Ne(n) ? _i : yi)(n, 1);
                         o.version = a;
                         const l = s.get(t);
                         l && e.remove(l), s.set(t, o)
                     }
                     return {
                         get: function(t, e) {
                             return !0 === r[e.id] || (e.addEventListener("dispose", a), r[e.id] = !0, n.memory.geometries++), e
@@ -22422,15 +22808,15 @@
                                 null !== n && e.version < n.version && o(t)
                             } else o(t);
                             return s.get(t)
                         }
                     }
                 }
 
-                function hi(t, e, n, i) {
+                function Zr(t, e, n, i) {
                     const r = i.isWebGL2;
                     let s, a, o;
                     this.setMode = function(t) {
                         s = t
                     }, this.setIndex = function(t) {
                         a = t.type, o = t.bytesPerElement
                     }, this.render = function(e, i) {
@@ -22440,15 +22826,15 @@
                         let h, u;
                         if (r) h = t, u = "drawElementsInstanced";
                         else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                         h[u](s, l, a, i * o, c), n.update(l, s, c)
                     }
                 }
 
-                function ui(t) {
+                function Kr(t) {
                     const e = {
                         frame: 0,
                         calls: 0,
                         triangles: 0,
                         points: 0,
                         lines: 0
                     };
@@ -22482,121 +22868,121 @@
                                     break;
                                 default:
                                     console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                             }
                         }
                     }
                 }
-                class di extends lt {
+                class Qr extends Xe {
                     constructor(t = null, e = 1, n = 1, i = 1) {
                         super(null), this.image = {
                             data: t,
                             width: e,
                             height: n,
                             depth: i
-                        }, this.magFilter = h, this.minFilter = h, this.wrapR = l, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
+                        }, this.magFilter = ot, this.minFilter = ot, this.wrapR = st, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }
 
-                function pi(t, e) {
+                function $r(t, e) {
                     return t[0] - e[0]
                 }
 
-                function mi(t, e) {
+                function ts(t, e) {
                     return Math.abs(e[1]) - Math.abs(t[1])
                 }
 
-                function fi(t, e) {
+                function es(t, e) {
                     let n = 1;
                     const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
                     i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), t.divideScalar(n)
                 }
 
-                function gi(t, e, n) {
+                function ns(t, e, n) {
                     const i = {},
                         r = new Float32Array(8),
                         s = new WeakMap,
-                        a = new mt,
+                        a = new Qe,
                         o = [];
                     for (let t = 0; t < 8; t++) o[t] = [t, 0];
                     return {
                         update: function(l, c, h, u) {
                             const d = l.morphTargetInfluences;
                             if (!0 === e.isWebGL2) {
                                 const p = c.morphAttributes.position.length;
                                 let m = s.get(c);
                                 if (void 0 === m || m.count !== p) {
                                     void 0 !== m && m.texture.dispose();
-                                    const x = void 0 !== c.morphAttributes.normal,
-                                        _ = c.morphAttributes.position,
-                                        M = c.morphAttributes.normal || [],
-                                        b = !0 === x ? 2 : 1;
-                                    let w = c.attributes.position.count * b,
-                                        S = 1;
-                                    w > e.maxTextureSize && (S = Math.ceil(w / e.maxTextureSize), w = e.maxTextureSize);
-                                    const E = new Float32Array(w * S * 4 * p),
-                                        T = new di(E, w, S, p);
-                                    T.format = y, T.type = g, T.needsUpdate = !0;
-                                    const A = 4 * b;
-                                    for (let L = 0; L < p; L++) {
-                                        const C = _[L],
-                                            P = M[L],
-                                            D = w * S * 4 * L;
-                                        for (let I = 0; I < C.count; I++) {
-                                            a.fromBufferAttribute(C, I), !0 === C.normalized && fi(a, C);
-                                            const N = I * A;
-                                            E[D + N + 0] = a.x, E[D + N + 1] = a.y, E[D + N + 2] = a.z, E[D + N + 3] = 0, !0 === x && (a.fromBufferAttribute(P, I), !0 === P.normalized && fi(a, P), E[D + N + 4] = a.x, E[D + N + 5] = a.y, E[D + N + 6] = a.z, E[D + N + 7] = 0)
+                                    const v = void 0 !== c.morphAttributes.normal,
+                                        x = c.morphAttributes.position,
+                                        y = c.morphAttributes.normal || [],
+                                        _ = !0 === v ? 2 : 1;
+                                    let M = c.attributes.position.count * _,
+                                        b = 1;
+                                    M > e.maxTextureSize && (b = Math.ceil(M / e.maxTextureSize), M = e.maxTextureSize);
+                                    const w = new Float32Array(M * b * 4 * p),
+                                        S = new Qr(w, M, b, p);
+                                    S.format = Et, S.type = yt, S.needsUpdate = !0;
+                                    const E = 4 * _;
+                                    for (let A = 0; A < p; A++) {
+                                        const R = x[A],
+                                            L = y[A],
+                                            C = M * b * 4 * A;
+                                        for (let P = 0; P < R.count; P++) {
+                                            a.fromBufferAttribute(R, P), !0 === R.normalized && es(a, R);
+                                            const D = P * E;
+                                            w[C + D + 0] = a.x, w[C + D + 1] = a.y, w[C + D + 2] = a.z, w[C + D + 3] = 0, !0 === v && (a.fromBufferAttribute(L, P), !0 === L.normalized && es(a, L), w[C + D + 4] = a.x, w[C + D + 5] = a.y, w[C + D + 6] = a.z, w[C + D + 7] = 0)
                                         }
                                     }
 
-                                    function R() {
-                                        T.dispose(), s.delete(c), c.removeEventListener("dispose", R)
+                                    function T() {
+                                        S.dispose(), s.delete(c), c.removeEventListener("dispose", T)
                                     }
                                     m = {
                                         count: p,
-                                        texture: T,
-                                        size: new Y(w, S)
-                                    }, s.set(c, m), c.addEventListener("dispose", R)
+                                        texture: S,
+                                        size: new De(M, b)
+                                    }, s.set(c, m), c.addEventListener("dispose", T)
                                 }
                                 let f = 0;
-                                for (let O = 0; O < d.length; O++) f += d[O];
-                                const v = c.morphTargetsRelative ? 1 : 1 - f;
-                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", v), u.getUniforms().setValue(t, "morphTargetInfluences", d), u.getUniforms().setValue(t, "morphTargetsTexture", m.texture, n), u.getUniforms().setValue(t, "morphTargetsTextureSize", m.size)
+                                for (let I = 0; I < d.length; I++) f += d[I];
+                                const g = c.morphTargetsRelative ? 1 : 1 - f;
+                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", g), u.getUniforms().setValue(t, "morphTargetInfluences", d), u.getUniforms().setValue(t, "morphTargetsTexture", m.texture, n), u.getUniforms().setValue(t, "morphTargetsTextureSize", m.size)
                             } else {
-                                const U = void 0 === d ? 0 : d.length;
-                                let B = i[c.id];
-                                if (void 0 === B || B.length !== U) {
-                                    B = [];
-                                    for (let V = 0; V < U; V++) B[V] = [V, 0];
-                                    i[c.id] = B
+                                const N = void 0 === d ? 0 : d.length;
+                                let O = i[c.id];
+                                if (void 0 === O || O.length !== N) {
+                                    O = [];
+                                    for (let H = 0; H < N; H++) O[H] = [H, 0];
+                                    i[c.id] = O
                                 }
-                                for (let k = 0; k < U; k++) {
-                                    const W = B[k];
-                                    W[0] = k, W[1] = d[k]
+                                for (let G = 0; G < N; G++) {
+                                    const V = O[G];
+                                    V[0] = G, V[1] = d[G]
                                 }
-                                B.sort(mi);
-                                for (let j = 0; j < 8; j++) j < U && B[j][1] ? (o[j][0] = B[j][0], o[j][1] = B[j][1]) : (o[j][0] = Number.MAX_SAFE_INTEGER, o[j][1] = 0);
-                                o.sort(pi);
-                                const F = c.morphAttributes.position,
-                                    z = c.morphAttributes.normal;
-                                let H = 0;
-                                for (let X = 0; X < 8; X++) {
-                                    const q = o[X],
-                                        J = q[0],
-                                        Z = q[1];
-                                    J !== Number.MAX_SAFE_INTEGER && Z ? (F && c.getAttribute("morphTarget" + X) !== F[J] && c.setAttribute("morphTarget" + X, F[J]), z && c.getAttribute("morphNormal" + X) !== z[J] && c.setAttribute("morphNormal" + X, z[J]), r[X] = Z, H += Z) : (F && !0 === c.hasAttribute("morphTarget" + X) && c.deleteAttribute("morphTarget" + X), z && !0 === c.hasAttribute("morphNormal" + X) && c.deleteAttribute("morphNormal" + X), r[X] = 0)
+                                O.sort(ts);
+                                for (let k = 0; k < 8; k++) k < N && O[k][1] ? (o[k][0] = O[k][0], o[k][1] = O[k][1]) : (o[k][0] = Number.MAX_SAFE_INTEGER, o[k][1] = 0);
+                                o.sort($r);
+                                const U = c.morphAttributes.position,
+                                    B = c.morphAttributes.normal;
+                                let F = 0;
+                                for (let W = 0; W < 8; W++) {
+                                    const j = o[W],
+                                        X = j[0],
+                                        q = j[1];
+                                    X !== Number.MAX_SAFE_INTEGER && q ? (U && c.getAttribute("morphTarget" + W) !== U[X] && c.setAttribute("morphTarget" + W, U[X]), B && c.getAttribute("morphNormal" + W) !== B[X] && c.setAttribute("morphNormal" + W, B[X]), r[W] = q, F += q) : (U && !0 === c.hasAttribute("morphTarget" + W) && c.deleteAttribute("morphTarget" + W), B && !0 === c.hasAttribute("morphNormal" + W) && c.deleteAttribute("morphNormal" + W), r[W] = 0)
                                 }
-                                const G = c.morphTargetsRelative ? 1 : 1 - H;
-                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", G), u.getUniforms().setValue(t, "morphTargetInfluences", r)
+                                const z = c.morphTargetsRelative ? 1 : 1 - F;
+                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", z), u.getUniforms().setValue(t, "morphTargetInfluences", r)
                             }
                         }
                     }
                 }
 
-                function vi(t, e, n, i) {
+                function is(t, e, n, i) {
                     let r = new WeakMap;
 
                     function s(t) {
                         const e = t.target;
                         e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                     }
                     return {
@@ -22607,670 +22993,670 @@
                             return r.get(l) !== a && (e.update(l), r.set(l, a)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
                         },
                         dispose: function() {
                             r = new WeakMap
                         }
                     }
                 }
-                di.prototype.isDataTexture2DArray = !0;
-                class xi extends lt {
+                Qr.prototype.isDataTexture2DArray = !0;
+                class rs extends Xe {
                     constructor(t = null, e = 1, n = 1, i = 1) {
                         super(null), this.image = {
                             data: t,
                             width: e,
                             height: n,
                             depth: i
-                        }, this.magFilter = h, this.minFilter = h, this.wrapR = l, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
+                        }, this.magFilter = ot, this.minFilter = ot, this.wrapR = st, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }
-                xi.prototype.isDataTexture3D = !0;
-                const yi = new lt,
-                    _i = new di,
-                    Mi = new xi,
-                    bi = new _n,
-                    wi = [],
-                    Si = [],
-                    Ei = new Float32Array(16),
-                    Ti = new Float32Array(9),
-                    Ai = new Float32Array(4);
+                rs.prototype.isDataTexture3D = !0;
+                const ss = new Xe,
+                    as = new Qr,
+                    os = new rs,
+                    ls = new rr,
+                    cs = [],
+                    hs = [],
+                    us = new Float32Array(16),
+                    ds = new Float32Array(9),
+                    ps = new Float32Array(4);
 
-                function Ri(t, e, n) {
+                function ms(t, e, n) {
                     const i = t[0];
                     if (i <= 0 || i > 0) return t;
                     const r = e * n;
-                    let s = wi[r];
-                    if (void 0 === s && (s = new Float32Array(r), wi[r] = s), 0 !== e) {
+                    let s = cs[r];
+                    if (void 0 === s && (s = new Float32Array(r), cs[r] = s), 0 !== e) {
                         i.toArray(s, 0);
                         for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r)
                     }
                     return s
                 }
 
-                function Li(t, e) {
+                function fs(t, e) {
                     if (t.length !== e.length) return !1;
                     for (let n = 0, i = t.length; n < i; n++)
                         if (t[n] !== e[n]) return !1;
                     return !0
                 }
 
-                function Ci(t, e) {
+                function gs(t, e) {
                     for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
                 }
 
-                function Pi(t, e) {
-                    let n = Si[e];
-                    void 0 === n && (n = new Int32Array(e), Si[e] = n);
+                function vs(t, e) {
+                    let n = hs[e];
+                    void 0 === n && (n = new Int32Array(e), hs[e] = n);
                     for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                     return n
                 }
 
-                function Di(t, e) {
+                function xs(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
                 }
 
-                function Ii(t, e) {
+                function ys(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                     else {
-                        if (Li(n, e)) return;
-                        t.uniform2fv(this.addr, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniform2fv(this.addr, e), gs(n, e)
                     }
                 }
 
-                function Ni(t, e) {
+                function _s(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                     else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                     else {
-                        if (Li(n, e)) return;
-                        t.uniform3fv(this.addr, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniform3fv(this.addr, e), gs(n, e)
                     }
                 }
 
-                function Oi(t, e) {
+                function Ms(t, e) {
                     const n = this.cache;
                     if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                     else {
-                        if (Li(n, e)) return;
-                        t.uniform4fv(this.addr, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniform4fv(this.addr, e), gs(n, e)
                     }
                 }
 
-                function Ui(t, e) {
+                function bs(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (Li(n, e)) return;
-                        t.uniformMatrix2fv(this.addr, !1, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniformMatrix2fv(this.addr, !1, e), gs(n, e)
                     } else {
-                        if (Li(n, i)) return;
-                        Ai.set(i), t.uniformMatrix2fv(this.addr, !1, Ai), Ci(n, i)
+                        if (fs(n, i)) return;
+                        ps.set(i), t.uniformMatrix2fv(this.addr, !1, ps), gs(n, i)
                     }
                 }
 
-                function Bi(t, e) {
+                function ws(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (Li(n, e)) return;
-                        t.uniformMatrix3fv(this.addr, !1, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniformMatrix3fv(this.addr, !1, e), gs(n, e)
                     } else {
-                        if (Li(n, i)) return;
-                        Ti.set(i), t.uniformMatrix3fv(this.addr, !1, Ti), Ci(n, i)
+                        if (fs(n, i)) return;
+                        ds.set(i), t.uniformMatrix3fv(this.addr, !1, ds), gs(n, i)
                     }
                 }
 
-                function Fi(t, e) {
+                function Ss(t, e) {
                     const n = this.cache,
                         i = e.elements;
                     if (void 0 === i) {
-                        if (Li(n, e)) return;
-                        t.uniformMatrix4fv(this.addr, !1, e), Ci(n, e)
+                        if (fs(n, e)) return;
+                        t.uniformMatrix4fv(this.addr, !1, e), gs(n, e)
                     } else {
-                        if (Li(n, i)) return;
-                        Ei.set(i), t.uniformMatrix4fv(this.addr, !1, Ei), Ci(n, i)
+                        if (fs(n, i)) return;
+                        us.set(i), t.uniformMatrix4fv(this.addr, !1, us), gs(n, i)
                     }
                 }
 
-                function zi(t, e) {
+                function Es(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
                 }
 
-                function Hi(t, e) {
+                function Ts(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform2iv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform2iv(this.addr, e), gs(n, e))
                 }
 
-                function Gi(t, e) {
+                function As(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform3iv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform3iv(this.addr, e), gs(n, e))
                 }
 
-                function Vi(t, e) {
+                function Rs(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform4iv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform4iv(this.addr, e), gs(n, e))
                 }
 
-                function ki(t, e) {
+                function Ls(t, e) {
                     const n = this.cache;
                     n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
                 }
 
-                function Wi(t, e) {
+                function Cs(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform2uiv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform2uiv(this.addr, e), gs(n, e))
                 }
 
-                function ji(t, e) {
+                function Ps(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform3uiv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform3uiv(this.addr, e), gs(n, e))
                 }
 
-                function Xi(t, e) {
+                function Ds(t, e) {
                     const n = this.cache;
-                    Li(n, e) || (t.uniform4uiv(this.addr, e), Ci(n, e))
+                    fs(n, e) || (t.uniform4uiv(this.addr, e), gs(n, e))
                 }
 
-                function qi(t, e, n) {
+                function Is(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || yi, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || ss, r)
                 }
 
-                function Yi(t, e, n) {
+                function Ns(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Mi, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || os, r)
                 }
 
-                function Ji(t, e, n) {
+                function Os(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || bi, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || ls, r)
                 }
 
-                function Zi(t, e, n) {
+                function Us(t, e, n) {
                     const i = this.cache,
                         r = n.allocateTextureUnit();
-                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || _i, r)
+                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || as, r)
                 }
 
-                function Ki(t, e) {
+                function Bs(t, e) {
                     t.uniform1fv(this.addr, e)
                 }
 
-                function Qi(t, e) {
-                    const n = Ri(e, this.size, 2);
+                function Fs(t, e) {
+                    const n = ms(e, this.size, 2);
                     t.uniform2fv(this.addr, n)
                 }
 
-                function $i(t, e) {
-                    const n = Ri(e, this.size, 3);
+                function zs(t, e) {
+                    const n = ms(e, this.size, 3);
                     t.uniform3fv(this.addr, n)
                 }
 
-                function tr(t, e) {
-                    const n = Ri(e, this.size, 4);
+                function Hs(t, e) {
+                    const n = ms(e, this.size, 4);
                     t.uniform4fv(this.addr, n)
                 }
 
-                function er(t, e) {
-                    const n = Ri(e, this.size, 4);
+                function Gs(t, e) {
+                    const n = ms(e, this.size, 4);
                     t.uniformMatrix2fv(this.addr, !1, n)
                 }
 
-                function nr(t, e) {
-                    const n = Ri(e, this.size, 9);
+                function Vs(t, e) {
+                    const n = ms(e, this.size, 9);
                     t.uniformMatrix3fv(this.addr, !1, n)
                 }
 
-                function ir(t, e) {
-                    const n = Ri(e, this.size, 16);
+                function ks(t, e) {
+                    const n = ms(e, this.size, 16);
                     t.uniformMatrix4fv(this.addr, !1, n)
                 }
 
-                function rr(t, e) {
+                function Ws(t, e) {
                     t.uniform1iv(this.addr, e)
                 }
 
-                function sr(t, e) {
+                function js(t, e) {
                     t.uniform2iv(this.addr, e)
                 }
 
-                function ar(t, e) {
+                function Xs(t, e) {
                     t.uniform3iv(this.addr, e)
                 }
 
-                function or(t, e) {
+                function qs(t, e) {
                     t.uniform4iv(this.addr, e)
                 }
 
-                function lr(t, e) {
+                function Ys(t, e) {
                     t.uniform1uiv(this.addr, e)
                 }
 
-                function cr(t, e) {
+                function Js(t, e) {
                     t.uniform2uiv(this.addr, e)
                 }
 
-                function hr(t, e) {
+                function Zs(t, e) {
                     t.uniform3uiv(this.addr, e)
                 }
 
-                function ur(t, e) {
+                function Ks(t, e) {
                     t.uniform4uiv(this.addr, e)
                 }
 
-                function dr(t, e, n) {
+                function Qs(t, e, n) {
                     const i = e.length,
-                        r = Pi(n, i);
+                        r = vs(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || yi, r[t])
+                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || ss, r[t])
                 }
 
-                function pr(t, e, n) {
+                function $s(t, e, n) {
                     const i = e.length,
-                        r = Pi(n, i);
+                        r = vs(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || Mi, r[t])
+                    for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || os, r[t])
                 }
 
-                function mr(t, e, n) {
+                function ta(t, e, n) {
                     const i = e.length,
-                        r = Pi(n, i);
+                        r = vs(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || bi, r[t])
+                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || ls, r[t])
                 }
 
-                function fr(t, e, n) {
+                function ea(t, e, n) {
                     const i = e.length,
-                        r = Pi(n, i);
+                        r = vs(n, i);
                     t.uniform1iv(this.addr, r);
-                    for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || _i, r[t])
+                    for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || as, r[t])
                 }
 
-                function gr(t, e, n) {
+                function na(t, e, n) {
                     this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                         switch (t) {
                             case 5126:
-                                return Di;
+                                return xs;
                             case 35664:
-                                return Ii;
+                                return ys;
                             case 35665:
-                                return Ni;
+                                return _s;
                             case 35666:
-                                return Oi;
+                                return Ms;
                             case 35674:
-                                return Ui;
+                                return bs;
                             case 35675:
-                                return Bi;
+                                return ws;
                             case 35676:
-                                return Fi;
+                                return Ss;
                             case 5124:
                             case 35670:
-                                return zi;
+                                return Es;
                             case 35667:
                             case 35671:
-                                return Hi;
+                                return Ts;
                             case 35668:
                             case 35672:
-                                return Gi;
+                                return As;
                             case 35669:
                             case 35673:
-                                return Vi;
+                                return Rs;
                             case 5125:
-                                return ki;
+                                return Ls;
                             case 36294:
-                                return Wi;
+                                return Cs;
                             case 36295:
-                                return ji;
+                                return Ps;
                             case 36296:
-                                return Xi;
+                                return Ds;
                             case 35678:
                             case 36198:
                             case 36298:
                             case 36306:
                             case 35682:
-                                return qi;
+                                return Is;
                             case 35679:
                             case 36299:
                             case 36307:
-                                return Yi;
+                                return Ns;
                             case 35680:
                             case 36300:
                             case 36308:
                             case 36293:
-                                return Ji;
+                                return Os;
                             case 36289:
                             case 36303:
                             case 36311:
                             case 36292:
-                                return Zi
+                                return Us
                         }
                     }(e.type)
                 }
 
-                function vr(t, e, n) {
+                function ia(t, e, n) {
                     this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                         switch (t) {
                             case 5126:
-                                return Ki;
+                                return Bs;
                             case 35664:
-                                return Qi;
+                                return Fs;
                             case 35665:
-                                return $i;
+                                return zs;
                             case 35666:
-                                return tr;
+                                return Hs;
                             case 35674:
-                                return er;
+                                return Gs;
                             case 35675:
-                                return nr;
+                                return Vs;
                             case 35676:
-                                return ir;
+                                return ks;
                             case 5124:
                             case 35670:
-                                return rr;
+                                return Ws;
                             case 35667:
                             case 35671:
-                                return sr;
+                                return js;
                             case 35668:
                             case 35672:
-                                return ar;
+                                return Xs;
                             case 35669:
                             case 35673:
-                                return or;
+                                return qs;
                             case 5125:
-                                return lr;
+                                return Ys;
                             case 36294:
-                                return cr;
+                                return Js;
                             case 36295:
-                                return hr;
+                                return Zs;
                             case 36296:
-                                return ur;
+                                return Ks;
                             case 35678:
                             case 36198:
                             case 36298:
                             case 36306:
                             case 35682:
-                                return dr;
+                                return Qs;
                             case 35679:
                             case 36299:
                             case 36307:
-                                return pr;
+                                return $s;
                             case 35680:
                             case 36300:
                             case 36308:
                             case 36293:
-                                return mr;
+                                return ta;
                             case 36289:
                             case 36303:
                             case 36311:
                             case 36292:
-                                return fr
+                                return ea
                         }
                     }(e.type)
                 }
 
-                function xr(t) {
+                function ra(t) {
                     this.id = t, this.seq = [], this.map = {}
                 }
-                vr.prototype.updateCache = function(t) {
+                ia.prototype.updateCache = function(t) {
                     const e = this.cache;
-                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Ci(e, t)
-                }, xr.prototype.setValue = function(t, e, n) {
+                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), gs(e, t)
+                }, ra.prototype.setValue = function(t, e, n) {
                     const i = this.seq;
                     for (let r = 0, s = i.length; r !== s; ++r) {
                         const s = i[r];
                         s.setValue(t, e[s.id], n)
                     }
                 };
-                const yr = /(\w+)(\])?(\[|\.)?/g;
+                const sa = /(\w+)(\])?(\[|\.)?/g;
 
-                function _r(t, e) {
+                function aa(t, e) {
                     t.seq.push(e), t.map[e.id] = e
                 }
 
-                function Mr(t, e, n) {
+                function oa(t, e, n) {
                     const i = t.name,
                         r = i.length;
-                    for (yr.lastIndex = 0;;) {
-                        const s = yr.exec(i),
-                            a = yr.lastIndex;
+                    for (sa.lastIndex = 0;;) {
+                        const s = sa.exec(i),
+                            a = sa.lastIndex;
                         let o = s[1];
                         const l = "]" === s[2],
                             c = s[3];
                         if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === r) {
-                            _r(n, void 0 === c ? new gr(o, t, e) : new vr(o, t, e));
+                            aa(n, void 0 === c ? new na(o, t, e) : new ia(o, t, e));
                             break
                         } {
                             let t = n.map[o];
-                            void 0 === t && (t = new xr(o), _r(n, t)), n = t
+                            void 0 === t && (t = new ra(o), aa(n, t)), n = t
                         }
                     }
                 }
 
-                function br(t, e) {
+                function la(t, e) {
                     this.seq = [], this.map = {};
                     const n = t.getProgramParameter(e, 35718);
                     for (let i = 0; i < n; ++i) {
                         const n = t.getActiveUniform(e, i);
-                        Mr(n, t.getUniformLocation(e, n.name), this)
+                        oa(n, t.getUniformLocation(e, n.name), this)
                     }
                 }
 
-                function wr(t, e, n) {
+                function ca(t, e, n) {
                     const i = t.createShader(e);
                     return t.shaderSource(i, n), t.compileShader(i), i
                 }
-                br.prototype.setValue = function(t, e, n, i) {
+                la.prototype.setValue = function(t, e, n, i) {
                     const r = this.map[e];
                     void 0 !== r && r.setValue(t, n, i)
-                }, br.prototype.setOptional = function(t, e, n) {
+                }, la.prototype.setOptional = function(t, e, n) {
                     const i = e[n];
                     void 0 !== i && this.setValue(t, n, i)
-                }, br.upload = function(t, e, n, i) {
+                }, la.upload = function(t, e, n, i) {
                     for (let r = 0, s = e.length; r !== s; ++r) {
                         const s = e[r],
                             a = n[s.id];
                         !1 !== a.needsUpdate && s.setValue(t, a.value, i)
                     }
-                }, br.seqWithValue = function(t, e) {
+                }, la.seqWithValue = function(t, e) {
                     const n = [];
                     for (let i = 0, r = t.length; i !== r; ++i) {
                         const r = t[i];
                         r.id in e && n.push(r)
                     }
                     return n
                 };
-                let Sr = 0;
+                let ha = 0;
 
-                function Er(t, e, n) {
+                function ua(t, e, n) {
                     const i = t.getShaderParameter(e, 35713),
                         r = t.getShaderInfoLog(e).trim();
                     return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function(t) {
                         const e = t.split("\n");
                         for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                         return e.join("\n")
                     }(t.getShaderSource(e))
                 }
 
-                function Tr(t, e) {
+                function da(t, e) {
                     const n = function(t) {
                         switch (t) {
-                            case D:
+                            case pe:
                                 return ["Linear", "( value )"];
-                            case I:
+                            case me:
                                 return ["sRGB", "( value )"];
                             default:
                                 return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                         }
                     }(e);
                     return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                 }
 
-                function Ar(t, e) {
+                function pa(t, e) {
                     let n;
                     switch (e) {
-                        case 1:
+                        case q:
                             n = "Linear";
                             break;
-                        case 2:
+                        case Y:
                             n = "Reinhard";
                             break;
-                        case 3:
+                        case J:
                             n = "OptimizedCineon";
                             break;
-                        case 4:
+                        case Z:
                             n = "ACESFilmic";
                             break;
-                        case 5:
+                        case K:
                             n = "Custom";
                             break;
                         default:
                             console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                     }
                     return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                 }
 
-                function Rr(t) {
+                function ma(t) {
                     return "" !== t
                 }
 
-                function Lr(t, e) {
+                function fa(t, e) {
                     return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
                 }
 
-                function Cr(t, e) {
+                function ga(t, e) {
                     return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
                 }
-                const Pr = /^[ \t]*#include +<([\w\d./]+)>/gm;
+                const va = /^[ \t]*#include +<([\w\d./]+)>/gm;
 
-                function Dr(t) {
-                    return t.replace(Pr, Ir)
+                function xa(t) {
+                    return t.replace(va, ya)
                 }
 
-                function Ir(t, e) {
-                    const n = Dn[e];
+                function ya(t, e) {
+                    const n = gr[e];
                     if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
-                    return Dr(n)
+                    return xa(n)
                 }
-                const Nr = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
-                    Or = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
+                const _a = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
+                    Ma = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
 
-                function Ur(t) {
-                    return t.replace(Or, Fr).replace(Nr, Br)
+                function ba(t) {
+                    return t.replace(Ma, Sa).replace(_a, wa)
                 }
 
-                function Br(t, e, n, i) {
-                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Fr(0, e, n, i)
+                function wa(t, e, n, i) {
+                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Sa(0, e, n, i)
                 }
 
-                function Fr(t, e, n, i) {
+                function Sa(t, e, n, i) {
                     let r = "";
                     for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
                     return r
                 }
 
-                function zr(t) {
+                function Ea(t) {
                     let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                     return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
                 }
 
-                function Hr(t, e, n, i) {
-                    const o = t.getContext(),
-                        l = n.defines;
-                    let c = n.vertexShader,
+                function Ta(t, e, n, i) {
+                    const r = t.getContext(),
+                        s = n.defines;
+                    let a = n.vertexShader,
                         h = n.fragmentShader;
                     const u = function(t) {
                             let e = "SHADOWMAP_TYPE_BASIC";
-                            return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
+                            return t.shadowMapType === o ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === l ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === c && (e = "SHADOWMAP_TYPE_VSM"), e
                         }(n),
                         d = function(t) {
                             let e = "ENVMAP_TYPE_CUBE";
                             if (t.envMap) switch (t.envMapMode) {
-                                case r:
-                                case s:
+                                case Q:
+                                case $:
                                     e = "ENVMAP_TYPE_CUBE";
                                     break;
-                                case a:
-                                case 307:
+                                case nt:
+                                case it:
                                     e = "ENVMAP_TYPE_CUBE_UV"
                             }
                             return e
                         }(n),
                         p = function(t) {
                             let e = "ENVMAP_MODE_REFLECTION";
                             if (t.envMap) switch (t.envMapMode) {
-                                case s:
-                                case 307:
+                                case $:
+                                case it:
                                     e = "ENVMAP_MODE_REFRACTION"
                             }
                             return e
                         }(n),
                         m = function(t) {
                             let e = "ENVMAP_BLENDING_NONE";
                             if (t.envMap) switch (t.combine) {
-                                case 0:
+                                case k:
                                     e = "ENVMAP_BLENDING_MULTIPLY";
                                     break;
-                                case 1:
+                                case W:
                                     e = "ENVMAP_BLENDING_MIX";
                                     break;
-                                case 2:
+                                case j:
                                     e = "ENVMAP_BLENDING_ADD"
                             }
                             return e
                         }(n),
                         f = n.isWebGL2 ? "" : function(t) {
-                            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Rr).join("\n")
+                            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ma).join("\n")
                         }(n),
                         g = function(t) {
                             const e = [];
                             for (const n in t) {
                                 const i = t[n];
                                 !1 !== i && e.push("#define " + n + " " + i)
                             }
                             return e.join("\n")
-                        }(l),
-                        v = o.createProgram();
+                        }(s),
+                        v = r.createProgram();
                     let x, y, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
-                    n.isRawShaderMaterial ? (x = [g].filter(Rr).join("\n"), x.length > 0 && (x += "\n"), y = [f, g].filter(Rr).join("\n"), y.length > 0 && (y += "\n")) : (x = [zr(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Rr).join("\n"), y = [f, zr(n), "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Dn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Ar("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.alphaWrite ? "" : "#define OPAQUE", Dn.encodings_pars_fragment, Tr("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Rr).join("\n")), c = Dr(c), c = Lr(c, n), c = Cr(c, n), h = Dr(h), h = Lr(h, n), h = Cr(h, n), c = Ur(c), h = Ur(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, y = ["#define varying in", n.glslVersion === B ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === B ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
+                    n.isRawShaderMaterial ? (x = [g].filter(ma).join("\n"), x.length > 0 && (x += "\n"), y = [f, g].filter(ma).join("\n"), y.length > 0 && (y += "\n")) : (x = [Ea(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ma).join("\n"), y = [f, Ea(n), "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== X ? "#define TONE_MAPPING" : "", n.toneMapping !== X ? gr.tonemapping_pars_fragment : "", n.toneMapping !== X ? pa("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.alphaWrite ? "" : "#define OPAQUE", gr.encodings_pars_fragment, da("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ma).join("\n")), a = xa(a), a = fa(a, n), a = ga(a, n), h = xa(h), h = fa(h, n), h = ga(h, n), a = ba(a), h = ba(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, y = ["#define varying in", n.glslVersion === Me ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Me ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
                     const M = _ + y + h,
-                        b = wr(o, 35633, _ + x + c),
-                        w = wr(o, 35632, M);
-                    if (o.attachShader(v, b), o.attachShader(v, w), void 0 !== n.index0AttributeName ? o.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && o.bindAttribLocation(v, 0, "position"), o.linkProgram(v), t.debug.checkShaderErrors) {
-                        const t = o.getProgramInfoLog(v).trim(),
-                            e = o.getShaderInfoLog(b).trim(),
-                            n = o.getShaderInfoLog(w).trim();
+                        b = ca(r, 35633, _ + x + a),
+                        w = ca(r, 35632, M);
+                    if (r.attachShader(v, b), r.attachShader(v, w), void 0 !== n.index0AttributeName ? r.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(v, 0, "position"), r.linkProgram(v), t.debug.checkShaderErrors) {
+                        const t = r.getProgramInfoLog(v).trim(),
+                            e = r.getShaderInfoLog(b).trim(),
+                            n = r.getShaderInfoLog(w).trim();
                         let i = !0,
-                            r = !0;
-                        if (!1 === o.getProgramParameter(v, 35714)) {
+                            s = !0;
+                        if (!1 === r.getProgramParameter(v, 35714)) {
                             i = !1;
-                            const e = Er(o, b, "vertex"),
-                                n = Er(o, w, "fragment");
-                            console.error("THREE.WebGLProgram: Shader Error " + o.getError() + " - VALIDATE_STATUS " + o.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
-                        } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (r = !1);
-                        r && (this.diagnostics = {
+                            const e = ua(r, b, "vertex"),
+                                n = ua(r, w, "fragment");
+                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
+                        } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (s = !1);
+                        s && (this.diagnostics = {
                             runnable: i,
                             programLog: t,
                             vertexShader: {
                                 log: e,
                                 prefix: x
                             },
                             fragmentShader: {
                                 log: n,
                                 prefix: y
                             }
                         })
                     }
                     let S, E;
-                    return o.deleteShader(b), o.deleteShader(w), this.getUniforms = function() {
-                        return void 0 === S && (S = new br(o, v)), S
+                    return r.deleteShader(b), r.deleteShader(w), this.getUniforms = function() {
+                        return void 0 === S && (S = new la(r, v)), S
                     }, this.getAttributes = function() {
                         return void 0 === E && (E = function(t, e) {
                             const n = {},
                                 i = t.getProgramParameter(e, 35721);
                             for (let r = 0; r < i; r++) {
                                 const i = t.getActiveAttrib(e, r),
                                     s = i.name;
@@ -23278,21 +23664,21 @@
                                 35674 === i.type && (a = 2), 35675 === i.type && (a = 3), 35676 === i.type && (a = 4), n[s] = {
                                     type: i.type,
                                     location: t.getAttribLocation(e, s),
                                     locationSize: a
                                 }
                             }
                             return n
-                        }(o, v)), E
+                        }(r, v)), E
                     }, this.destroy = function() {
-                        i.releaseStatesOfProgram(this), o.deleteProgram(v), this.program = void 0
-                    }, this.name = n.shaderName, this.id = Sr++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = b, this.fragmentShader = w, this
+                        i.releaseStatesOfProgram(this), r.deleteProgram(v), this.program = void 0
+                    }, this.name = n.shaderName, this.id = ha++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = b, this.fragmentShader = w, this
                 }
-                let Gr = 0;
-                class Vr {
+                let Aa = 0;
+                class Ra {
                     constructor() {
                         this.shaderCache = new Map, this.materialCache = new Map
                     }
                     update(t) {
                         const e = t.vertexShader,
                             n = t.fragmentShader,
                             i = this._getShaderStage(e),
@@ -23317,37 +23703,37 @@
                     _getShaderCacheForMaterial(t) {
                         const e = this.materialCache;
                         return !1 === e.has(t) && e.set(t, new Set), e.get(t)
                     }
                     _getShaderStage(t) {
                         const e = this.shaderCache;
                         if (!1 === e.has(t)) {
-                            const n = new kr;
+                            const n = new La;
                             e.set(t, n)
                         }
                         return e.get(t)
                     }
                 }
-                class kr {
+                class La {
                     constructor() {
-                        this.id = Gr++, this.usedTimes = 0
+                        this.id = Aa++, this.usedTimes = 0
                     }
                 }
 
-                function Wr(t, e, n, i, r, s, o) {
-                    const l = new ne,
-                        c = new Vr,
-                        h = [],
-                        u = r.isWebGL2,
-                        d = r.logarithmicDepthBuffer,
-                        p = r.floatVertexTextures,
-                        m = r.maxVertexUniforms,
-                        f = r.vertexTextures;
-                    let g = r.precision;
-                    const v = {
+                function Ca(t, e, n, i, r, s, a) {
+                    const o = new Gn,
+                        l = new Ra,
+                        c = [],
+                        h = r.isWebGL2,
+                        p = r.logarithmicDepthBuffer,
+                        m = r.floatVertexTextures,
+                        f = r.maxVertexUniforms,
+                        g = r.vertexTextures;
+                    let v = r.precision;
+                    const x = {
                         MeshDepthMaterial: "depth",
                         MeshDistanceMaterial: "distanceRGBA",
                         MeshNormalMaterial: "normal",
                         MeshBasicMaterial: "basic",
                         MeshLambertMaterial: "lambert",
                         MeshPhongMaterial: "phong",
                         MeshToonMaterial: "toon",
@@ -23357,180 +23743,180 @@
                         LineBasicMaterial: "basic",
                         LineDashedMaterial: "dashed",
                         PointsMaterial: "points",
                         ShadowMaterial: "shadow",
                         SpriteMaterial: "sprite"
                     };
                     return {
-                        getParameters: function(s, l, h, x, y) {
-                            const _ = x.fog,
-                                M = s.isMeshStandardMaterial ? x.environment : null,
-                                b = (s.isMeshStandardMaterial ? n : e).get(s.envMap || M),
-                                w = v[s.type],
-                                S = y.isSkinnedMesh ? function(t) {
+                        getParameters: function(s, o, c, y, _) {
+                            const M = y.fog,
+                                b = s.isMeshStandardMaterial ? y.environment : null,
+                                w = (s.isMeshStandardMaterial ? n : e).get(s.envMap || b),
+                                S = x[s.type],
+                                E = _.isSkinnedMesh ? function(t) {
                                     const e = t.skeleton.bones;
-                                    if (p) return 1024; {
-                                        const t = m,
+                                    if (m) return 1024; {
+                                        const t = f,
                                             n = Math.floor((t - 20) / 4),
                                             i = Math.min(n, e.length);
                                         return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                                     }
-                                }(y) : 0;
-                            let E, T, A, R;
-                            if (null !== s.precision && (g = r.getMaxPrecision(s.precision), g !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", g, "instead.")), w) {
-                                const t = Nn[w];
-                                E = t.vertexShader, T = t.fragmentShader
-                            } else E = s.vertexShader, T = s.fragmentShader, c.update(s), A = c.getVertexShaderID(s), R = c.getFragmentShaderID(s);
-                            const L = t.getRenderTarget(),
-                                C = s.alphaTest > 0,
-                                P = s.clearcoat > 0;
+                                }(_) : 0;
+                            let T, A, R, L;
+                            if (null !== s.precision && (v = r.getMaxPrecision(s.precision), v !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", v, "instead.")), S) {
+                                const t = xr[S];
+                                T = t.vertexShader, A = t.fragmentShader
+                            } else T = s.vertexShader, A = s.fragmentShader, l.update(s), R = l.getVertexShaderID(s), L = l.getFragmentShaderID(s);
+                            const C = t.getRenderTarget(),
+                                P = s.alphaTest > 0,
+                                D = s.clearcoat > 0;
                             return {
-                                isWebGL2: u,
-                                shaderID: w,
+                                isWebGL2: h,
+                                shaderID: S,
                                 shaderName: s.type,
-                                vertexShader: E,
-                                fragmentShader: T,
+                                vertexShader: T,
+                                fragmentShader: A,
                                 defines: s.defines,
-                                customVertexShaderID: A,
-                                customFragmentShaderID: R,
+                                customVertexShaderID: R,
+                                customFragmentShaderID: L,
                                 isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                                 glslVersion: s.glslVersion,
-                                precision: g,
-                                instancing: !0 === y.isInstancedMesh,
-                                instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor,
-                                supportsVertexTextures: f,
-                                outputEncoding: null === L ? t.outputEncoding : !0 === L.isXRRenderTarget ? L.texture.encoding : D,
+                                precision: v,
+                                instancing: !0 === _.isInstancedMesh,
+                                instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
+                                supportsVertexTextures: g,
+                                outputEncoding: null === C ? t.outputEncoding : !0 === C.isXRRenderTarget ? C.texture.encoding : pe,
                                 map: !!s.map,
                                 matcap: !!s.matcap,
-                                envMap: !!b,
-                                envMapMode: b && b.mapping,
-                                envMapCubeUV: !!b && (b.mapping === a || 307 === b.mapping),
+                                envMap: !!w,
+                                envMapMode: w && w.mapping,
+                                envMapCubeUV: !!w && (w.mapping === nt || w.mapping === it),
                                 lightMap: !!s.lightMap,
                                 aoMap: !!s.aoMap,
                                 emissiveMap: !!s.emissiveMap,
                                 bumpMap: !!s.bumpMap,
                                 normalMap: !!s.normalMap,
-                                objectSpaceNormalMap: 1 === s.normalMapType,
-                                tangentSpaceNormalMap: 0 === s.normalMapType,
-                                decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === I,
-                                clearcoat: P,
-                                clearcoatMap: P && !!s.clearcoatMap,
-                                clearcoatRoughnessMap: P && !!s.clearcoatRoughnessMap,
-                                clearcoatNormalMap: P && !!s.clearcoatNormalMap,
+                                objectSpaceNormalMap: s.normalMapType === ve,
+                                tangentSpaceNormalMap: s.normalMapType === ge,
+                                decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === me,
+                                clearcoat: D,
+                                clearcoatMap: D && !!s.clearcoatMap,
+                                clearcoatRoughnessMap: D && !!s.clearcoatRoughnessMap,
+                                clearcoatNormalMap: D && !!s.clearcoatNormalMap,
                                 displacementMap: !!s.displacementMap,
                                 roughnessMap: !!s.roughnessMap,
                                 metalnessMap: !!s.metalnessMap,
                                 specularMap: !!s.specularMap,
                                 specularIntensityMap: !!s.specularIntensityMap,
                                 specularColorMap: !!s.specularColorMap,
                                 alphaMap: !!s.alphaMap,
-                                alphaTest: C,
+                                alphaTest: P,
                                 alphaWrite: s.alphaWrite || s.transparent,
                                 gradientMap: !!s.gradientMap,
                                 sheen: s.sheen > 0,
                                 sheenColorMap: !!s.sheenColorMap,
                                 sheenRoughnessMap: !!s.sheenRoughnessMap,
                                 transmission: s.transmission > 0,
                                 transmissionMap: !!s.transmissionMap,
                                 thicknessMap: !!s.thicknessMap,
                                 combine: s.combine,
-                                vertexTangents: !!s.normalMap && !!y.geometry && !!y.geometry.attributes.tangent,
+                                vertexTangents: !!s.normalMap && !!_.geometry && !!_.geometry.attributes.tangent,
                                 vertexColors: s.vertexColors,
-                                vertexAlphas: !0 === s.vertexColors && !!y.geometry && !!y.geometry.attributes.color && 4 === y.geometry.attributes.color.itemSize,
+                                vertexAlphas: !0 === s.vertexColors && !!_.geometry && !!_.geometry.attributes.color && 4 === _.geometry.attributes.color.itemSize,
                                 vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
                                 uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
-                                fog: !!_,
+                                fog: !!M,
                                 useFog: s.fog,
-                                fogExp2: _ && _.isFogExp2,
+                                fogExp2: M && M.isFogExp2,
                                 flatShading: !!s.flatShading,
                                 sizeAttenuation: s.sizeAttenuation,
-                                logarithmicDepthBuffer: d,
-                                skinning: !0 === y.isSkinnedMesh && S > 0,
-                                maxBones: S,
-                                useVertexTexture: p,
-                                morphTargets: !!y.geometry && !!y.geometry.morphAttributes.position,
-                                morphNormals: !!y.geometry && !!y.geometry.morphAttributes.normal,
-                                morphTargetsCount: y.geometry && y.geometry.morphAttributes.position ? y.geometry.morphAttributes.position.length : 0,
-                                numDirLights: l.directional.length,
-                                numPointLights: l.point.length,
-                                numSpotLights: l.spot.length,
-                                numRectAreaLights: l.rectArea.length,
-                                numHemiLights: l.hemi.length,
-                                numDirLightShadows: l.directionalShadowMap.length,
-                                numPointLightShadows: l.pointShadowMap.length,
-                                numSpotLightShadows: l.spotShadowMap.length,
-                                numClippingPlanes: o.numPlanes,
-                                numClipIntersection: o.numIntersection,
+                                logarithmicDepthBuffer: p,
+                                skinning: !0 === _.isSkinnedMesh && E > 0,
+                                maxBones: E,
+                                useVertexTexture: m,
+                                morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position,
+                                morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
+                                morphTargetsCount: _.geometry && _.geometry.morphAttributes.position ? _.geometry.morphAttributes.position.length : 0,
+                                numDirLights: o.directional.length,
+                                numPointLights: o.point.length,
+                                numSpotLights: o.spot.length,
+                                numRectAreaLights: o.rectArea.length,
+                                numHemiLights: o.hemi.length,
+                                numDirLightShadows: o.directionalShadowMap.length,
+                                numPointLightShadows: o.pointShadowMap.length,
+                                numSpotLightShadows: o.spotShadowMap.length,
+                                numClippingPlanes: a.numPlanes,
+                                numClipIntersection: a.numIntersection,
                                 dithering: s.dithering,
-                                shadowMapEnabled: t.shadowMap.enabled && h.length > 0,
+                                shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                                 shadowMapType: t.shadowMap.type,
-                                toneMapping: s.toneMapped ? t.toneMapping : 0,
+                                toneMapping: s.toneMapped ? t.toneMapping : X,
                                 physicallyCorrectLights: t.physicallyCorrectLights,
                                 premultipliedAlpha: s.premultipliedAlpha,
-                                doubleSided: 2 === s.side,
-                                flipSided: 1 === s.side,
+                                doubleSided: s.side === d,
+                                flipSided: s.side === u,
                                 depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                                 index0AttributeName: s.index0AttributeName,
                                 extensionDerivatives: s.extensions && s.extensions.derivatives,
                                 extensionFragDepth: s.extensions && s.extensions.fragDepth,
                                 extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                                 extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
-                                rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
-                                rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
-                                rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
+                                rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
+                                rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
+                                rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
                                 customProgramCacheKey: s.customProgramCacheKey()
                             }
                         },
                         getProgramCacheKey: function(e) {
                             const n = [];
                             if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
                                 for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                             return !1 === e.isRawShaderMaterial && (function(t, e) {
                                 t.push(e.precision), t.push(e.outputEncoding), t.push(e.envMapMode), t.push(e.combine), t.push(e.vertexUvs), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.maxBones), t.push(e.morphTargetsCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.alphaWrite)
                             }(n, e), function(t, e) {
-                                l.disableAll(), e.isWebGL2 && l.enable(0), e.supportsVertexTextures && l.enable(1), e.instancing && l.enable(2), e.instancingColor && l.enable(3), e.map && l.enable(4), e.matcap && l.enable(5), e.envMap && l.enable(6), e.envMapCubeUV && l.enable(7), e.lightMap && l.enable(8), e.aoMap && l.enable(9), e.emissiveMap && l.enable(10), e.bumpMap && l.enable(11), e.normalMap && l.enable(12), e.objectSpaceNormalMap && l.enable(13), e.tangentSpaceNormalMap && l.enable(14), e.clearcoat && l.enable(15), e.clearcoatMap && l.enable(16), e.clearcoatRoughnessMap && l.enable(17), e.clearcoatNormalMap && l.enable(18), e.displacementMap && l.enable(19), e.specularMap && l.enable(20), e.roughnessMap && l.enable(21), e.metalnessMap && l.enable(22), e.gradientMap && l.enable(23), e.alphaMap && l.enable(24), e.alphaTest && l.enable(25), e.vertexColors && l.enable(26), e.vertexAlphas && l.enable(27), e.vertexUvs && l.enable(28), e.vertexTangents && l.enable(29), e.uvsVertexOnly && l.enable(30), e.fog && l.enable(31), t.push(l.mask), l.disableAll(), e.useFog && l.enable(0), e.flatShading && l.enable(1), e.logarithmicDepthBuffer && l.enable(2), e.skinning && l.enable(3), e.useVertexTexture && l.enable(4), e.morphTargets && l.enable(5), e.morphNormals && l.enable(6), e.premultipliedAlpha && l.enable(7), e.shadowMapEnabled && l.enable(8), e.physicallyCorrectLights && l.enable(9), e.doubleSided && l.enable(10), e.flipSided && l.enable(11), e.depthPacking && l.enable(12), e.dithering && l.enable(13), e.specularIntensityMap && l.enable(14), e.specularColorMap && l.enable(15), e.transmission && l.enable(16), e.transmissionMap && l.enable(17), e.thicknessMap && l.enable(18), e.sheen && l.enable(19), e.sheenColorMap && l.enable(20), e.sheenRoughnessMap && l.enable(21), e.decodeVideoTexture && l.enable(22), t.push(l.mask)
+                                o.disableAll(), e.isWebGL2 && o.enable(0), e.supportsVertexTextures && o.enable(1), e.instancing && o.enable(2), e.instancingColor && o.enable(3), e.map && o.enable(4), e.matcap && o.enable(5), e.envMap && o.enable(6), e.envMapCubeUV && o.enable(7), e.lightMap && o.enable(8), e.aoMap && o.enable(9), e.emissiveMap && o.enable(10), e.bumpMap && o.enable(11), e.normalMap && o.enable(12), e.objectSpaceNormalMap && o.enable(13), e.tangentSpaceNormalMap && o.enable(14), e.clearcoat && o.enable(15), e.clearcoatMap && o.enable(16), e.clearcoatRoughnessMap && o.enable(17), e.clearcoatNormalMap && o.enable(18), e.displacementMap && o.enable(19), e.specularMap && o.enable(20), e.roughnessMap && o.enable(21), e.metalnessMap && o.enable(22), e.gradientMap && o.enable(23), e.alphaMap && o.enable(24), e.alphaTest && o.enable(25), e.vertexColors && o.enable(26), e.vertexAlphas && o.enable(27), e.vertexUvs && o.enable(28), e.vertexTangents && o.enable(29), e.uvsVertexOnly && o.enable(30), e.fog && o.enable(31), t.push(o.mask), o.disableAll(), e.useFog && o.enable(0), e.flatShading && o.enable(1), e.logarithmicDepthBuffer && o.enable(2), e.skinning && o.enable(3), e.useVertexTexture && o.enable(4), e.morphTargets && o.enable(5), e.morphNormals && o.enable(6), e.premultipliedAlpha && o.enable(7), e.shadowMapEnabled && o.enable(8), e.physicallyCorrectLights && o.enable(9), e.doubleSided && o.enable(10), e.flipSided && o.enable(11), e.depthPacking && o.enable(12), e.dithering && o.enable(13), e.specularIntensityMap && o.enable(14), e.specularColorMap && o.enable(15), e.transmission && o.enable(16), e.transmissionMap && o.enable(17), e.thicknessMap && o.enable(18), e.sheen && o.enable(19), e.sheenColorMap && o.enable(20), e.sheenRoughnessMap && o.enable(21), e.decodeVideoTexture && o.enable(22), t.push(o.mask)
                             }(n, e), n.push(t.outputEncoding)), n.push(e.customProgramCacheKey), n.join()
                         },
                         getUniforms: function(t) {
-                            const e = v[t.type];
+                            const e = x[t.type];
                             let n;
                             if (e) {
-                                const t = Nn[e];
-                                n = mn.clone(t.uniforms)
+                                const t = xr[e];
+                                n = Qi.clone(t.uniforms)
                             } else n = t.uniforms;
                             return n
                         },
                         acquireProgram: function(e, n) {
                             let i;
-                            for (let t = 0, e = h.length; t < e; t++) {
-                                const e = h[t];
+                            for (let t = 0, e = c.length; t < e; t++) {
+                                const e = c[t];
                                 if (e.cacheKey === n) {
                                     i = e, ++i.usedTimes;
                                     break
                                 }
                             }
-                            return void 0 === i && (i = new Hr(t, n, e, s), h.push(i)), i
+                            return void 0 === i && (i = new Ta(t, n, e, s), c.push(i)), i
                         },
                         releaseProgram: function(t) {
                             if (0 == --t.usedTimes) {
-                                const e = h.indexOf(t);
-                                h[e] = h[h.length - 1], h.pop(), t.destroy()
+                                const e = c.indexOf(t);
+                                c[e] = c[c.length - 1], c.pop(), t.destroy()
                             }
                         },
                         releaseShaderCache: function(t) {
-                            c.remove(t)
+                            l.remove(t)
                         },
-                        programs: h,
+                        programs: c,
                         dispose: function() {
-                            c.dispose()
+                            l.dispose()
                         }
                     }
                 }
 
-                function jr() {
+                function Pa() {
                     let t = new WeakMap;
                     return {
                         get: function(e) {
                             let n = t.get(e);
                             return void 0 === n && (n = {}, t.set(e, n)), n
                         },
                         remove: function(e) {
@@ -23541,23 +23927,23 @@
                         },
                         dispose: function() {
                             t = new WeakMap
                         }
                     }
                 }
 
-                function Xr(t, e) {
+                function Da(t, e) {
                     return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                 }
 
-                function qr(t, e) {
+                function Ia(t, e) {
                     return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                 }
 
-                function Yr() {
+                function Na() {
                     const t = [];
                     let e = 0;
                     const n = [],
                         i = [],
                         r = [];
 
                     function s(n, i, r, s, a, o) {
@@ -23592,113 +23978,113 @@
                             for (let n = e, i = t.length; n < i; n++) {
                                 const e = t[n];
                                 if (null === e.id) break;
                                 e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                             }
                         },
                         sort: function(t, e) {
-                            n.length > 1 && n.sort(t || Xr), i.length > 1 && i.sort(e || qr), r.length > 1 && r.sort(e || qr)
+                            n.length > 1 && n.sort(t || Da), i.length > 1 && i.sort(e || Ia), r.length > 1 && r.sort(e || Ia)
                         }
                     }
                 }
 
-                function Jr() {
+                function Oa() {
                     let t = new WeakMap;
                     return {
                         get: function(e, n) {
                             let i;
-                            return !1 === t.has(e) ? (i = new Yr, t.set(e, [i])) : n >= t.get(e).length ? (i = new Yr, t.get(e).push(i)) : i = t.get(e)[n], i
+                            return !1 === t.has(e) ? (i = new Na, t.set(e, [i])) : n >= t.get(e).length ? (i = new Na, t.get(e).push(i)) : i = t.get(e)[n], i
                         },
                         dispose: function() {
                             t = new WeakMap
                         }
                     }
                 }
 
-                function Zr() {
+                function Ua() {
                     const t = {};
                     return {
                         get: function(e) {
                             if (void 0 !== t[e.id]) return t[e.id];
                             let n;
                             switch (e.type) {
                                 case "DirectionalLight":
                                     n = {
-                                        direction: new mt,
-                                        color: new rt
+                                        direction: new Qe,
+                                        color: new Ve
                                     };
                                     break;
                                 case "SpotLight":
                                     n = {
-                                        position: new mt,
-                                        direction: new mt,
-                                        color: new rt,
+                                        position: new Qe,
+                                        direction: new Qe,
+                                        color: new Ve,
                                         distance: 0,
                                         coneCos: 0,
                                         penumbraCos: 0,
                                         decay: 0
                                     };
                                     break;
                                 case "PointLight":
                                     n = {
-                                        position: new mt,
-                                        color: new rt,
+                                        position: new Qe,
+                                        color: new Ve,
                                         distance: 0,
                                         decay: 0
                                     };
                                     break;
                                 case "HemisphereLight":
                                     n = {
-                                        direction: new mt,
-                                        skyColor: new rt,
-                                        groundColor: new rt
+                                        direction: new Qe,
+                                        skyColor: new Ve,
+                                        groundColor: new Ve
                                     };
                                     break;
                                 case "RectAreaLight":
                                     n = {
-                                        color: new rt,
-                                        position: new mt,
-                                        halfWidth: new mt,
-                                        halfHeight: new mt
+                                        color: new Ve,
+                                        position: new Qe,
+                                        halfWidth: new Qe,
+                                        halfHeight: new Qe
                                     }
                             }
                             return t[e.id] = n, n
                         }
                     }
                 }
-                let Kr = 0;
+                let Ba = 0;
 
-                function Qr(t, e) {
+                function Fa(t, e) {
                     return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
                 }
 
-                function $r(t, e) {
-                    const n = new Zr,
+                function za(t, e) {
+                    const n = new Ua,
                         i = function() {
                             const t = {};
                             return {
                                 get: function(e) {
                                     if (void 0 !== t[e.id]) return t[e.id];
                                     let n;
                                     switch (e.type) {
                                         case "DirectionalLight":
                                         case "SpotLight":
                                             n = {
                                                 shadowBias: 0,
                                                 shadowNormalBias: 0,
                                                 shadowRadius: 1,
-                                                shadowMapSize: new Y
+                                                shadowMapSize: new De
                                             };
                                             break;
                                         case "PointLight":
                                             n = {
                                                 shadowBias: 0,
                                                 shadowNormalBias: 0,
                                                 shadowRadius: 1,
-                                                shadowMapSize: new Y,
+                                                shadowMapSize: new De,
                                                 shadowCameraNear: 1,
                                                 shadowCameraFar: 1e3
                                             }
                                     }
                                     return t[e.id] = n, n
                                 }
                             }
@@ -23730,33 +24116,33 @@
                             rectAreaLTC2: null,
                             point: [],
                             pointShadow: [],
                             pointShadowMap: [],
                             pointShadowMatrix: [],
                             hemi: []
                         };
-                    for (let t = 0; t < 9; t++) r.probe.push(new mt);
-                    const s = new mt,
-                        a = new jt,
-                        o = new jt;
+                    for (let t = 0; t < 9; t++) r.probe.push(new Qe);
+                    const s = new Qe,
+                        a = new Cn,
+                        o = new Cn;
                     return {
                         setup: function(s, a) {
                             let o = 0,
                                 l = 0,
                                 c = 0;
                             for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                             let h = 0,
                                 u = 0,
                                 d = 0,
                                 p = 0,
                                 m = 0,
                                 f = 0,
                                 g = 0,
                                 v = 0;
-                            s.sort(Qr);
+                            s.sort(Fa);
                             const x = !0 !== a ? Math.PI : 1;
                             for (let t = 0, e = s.length; t < e; t++) {
                                 const e = s[t],
                                     a = e.color,
                                     y = e.intensity,
                                     _ = e.distance,
                                     M = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
@@ -23791,17 +24177,17 @@
                                     }
                                     r.point[u] = t, u++
                                 } else if (e.isHemisphereLight) {
                                     const t = n.get(e);
                                     t.skyColor.copy(e.color).multiplyScalar(y * x), t.groundColor.copy(e.groundColor).multiplyScalar(y * x), r.hemi[m] = t, m++
                                 }
                             }
-                            p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = In.LTC_FLOAT_1, r.rectAreaLTC2 = In.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = In.LTC_HALF_1, r.rectAreaLTC2 = In.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
+                            p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = vr.LTC_FLOAT_1, r.rectAreaLTC2 = vr.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = vr.LTC_HALF_1, r.rectAreaLTC2 = vr.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
                             const y = r.hash;
-                            y.directionalLength === h && y.pointLength === u && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === m && y.numDirectionalShadows === f && y.numPointShadows === g && y.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, y.directionalLength = h, y.pointLength = u, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = m, y.numDirectionalShadows = f, y.numPointShadows = g, y.numSpotShadows = v, r.version = Kr++)
+                            y.directionalLength === h && y.pointLength === u && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === m && y.numDirectionalShadows === f && y.numPointShadows === g && y.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, y.directionalLength = h, y.pointLength = u, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = m, y.numDirectionalShadows = f, y.numPointShadows = g, y.numSpotShadows = v, r.version = Ba++)
                         },
                         setupView: function(t, e) {
                             let n = 0,
                                 i = 0,
                                 l = 0,
                                 c = 0,
                                 h = 0;
@@ -23826,16 +24212,16 @@
                                 }
                             }
                         },
                         state: r
                     }
                 }
 
-                function ts(t, e) {
-                    const n = new $r(t, e),
+                function Ha(t, e) {
+                    const n = new za(t, e),
                         i = [],
                         r = [];
                     return {
                         init: function() {
                             i.length = 0, r.length = 0
                         },
                         state: {
@@ -23854,182 +24240,185 @@
                         },
                         pushShadow: function(t) {
                             r.push(t)
                         }
                     }
                 }
 
-                function es(t, e) {
+                function Ga(t, e) {
                     let n = new WeakMap;
                     return {
                         get: function(i, r = 0) {
                             let s;
-                            return !1 === n.has(i) ? (s = new ts(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new ts(t, e), n.get(i).push(s)) : s = n.get(i)[r], s
+                            return !1 === n.has(i) ? (s = new Ha(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new Ha(t, e), n.get(i).push(s)) : s = n.get(i)[r], s
                         },
                         dispose: function() {
                             n = new WeakMap
                         }
                     }
                 }
-                class ns extends Le {
+                class Va extends mi {
                     constructor(t) {
                         super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                     }
                 }
-                ns.prototype.isMeshDepthMaterial = !0;
-                class is extends Le {
+                Va.prototype.isMeshDepthMaterial = !0;
+                class ka extends mi {
                     constructor(t) {
-                        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new mt, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
+                        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Qe, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                     }
                 }
+                ka.prototype.isMeshDistanceMaterial = !0;
+                const Wa = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
+                    ja = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
 
-                function rs(t, e, n) {
-                    let i = new Rn;
-                    const r = new Y,
-                        s = new Y,
-                        a = new ht,
-                        o = new ns({
-                            depthPacking: 3201
+                function Xa(t, e, n) {
+                    let i = new dr;
+                    const r = new De,
+                        s = new De,
+                        a = new Ye,
+                        l = new Va({
+                            depthPacking: fe
                         }),
-                        l = new is,
-                        c = {},
-                        d = n.maxTextureSize,
-                        p = {
-                            0: 1,
-                            1: 0,
-                            2: 2
+                        m = new ka,
+                        f = {},
+                        g = n.maxTextureSize,
+                        v = {
+                            0: u,
+                            1: h,
+                            2: d
                         },
-                        m = new fn({
+                        x = new $i({
                             defines: {
                                 VSM_SAMPLES: 8
                             },
                             uniforms: {
                                 shadow_pass: {
                                     value: null
                                 },
                                 resolution: {
-                                    value: new Y
+                                    value: new De
                                 },
                                 radius: {
                                     value: 4
                                 }
                             },
-                            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
-                            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
+                            vertexShader: Wa,
+                            fragmentShader: ja
                         }),
-                        f = m.clone();
-                    f.defines.HORIZONTAL_PASS = 1;
-                    const g = new We;
-                    g.setAttribute("position", new Ie(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
-                    const v = new cn(g, m),
-                        x = this;
-
-                    function _(n, i) {
-                        const r = e.update(v);
-                        m.defines.VSM_SAMPLES !== n.blurSamples && (m.defines.VSM_SAMPLES = n.blurSamples, f.defines.VSM_SAMPLES = n.blurSamples, m.needsUpdate = !0, f.needsUpdate = !0), m.uniforms.shadow_pass.value = n.map.texture, m.uniforms.resolution.value = n.mapSize, m.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, m, v, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, f, v, null)
-                    }
-
-                    function M(e, n, i, r, s, a, h) {
-                        let u = null;
-                        const d = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
-                        if (u = void 0 !== d ? d : !0 === r.isPointLight ? l : o, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
-                            const t = u.uuid,
+                        y = x.clone();
+                    y.defines.HORIZONTAL_PASS = 1;
+                    const _ = new Li;
+                    _.setAttribute("position", new xi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
+                    const M = new qi(_, x),
+                        b = this;
+
+                    function w(n, i) {
+                        const r = e.update(M);
+                        x.defines.VSM_SAMPLES !== n.blurSamples && (x.defines.VSM_SAMPLES = n.blurSamples, y.defines.VSM_SAMPLES = n.blurSamples, x.needsUpdate = !0, y.needsUpdate = !0), x.uniforms.shadow_pass.value = n.map.texture, x.uniforms.resolution.value = n.mapSize, x.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, x, M, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, y, M, null)
+                    }
+
+                    function S(e, n, i, r, s, a, o) {
+                        let h = null;
+                        const u = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
+                        if (h = void 0 !== u ? u : !0 === r.isPointLight ? m : l, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
+                            const t = h.uuid,
                                 e = i.uuid;
-                            let n = c[t];
-                            void 0 === n && (n = {}, c[t] = n);
+                            let n = f[t];
+                            void 0 === n && (n = {}, f[t] = n);
                             let r = n[e];
-                            void 0 === r && (r = u.clone(), n[e] = r), u = r
+                            void 0 === r && (r = h.clone(), n[e] = r), h = r
                         }
-                        return u.visible = i.visible, u.wireframe = i.wireframe, u.side = 3 === h ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : p[i.side], u.alphaMap = i.alphaMap, u.alphaTest = i.alphaTest, u.clipShadows = i.clipShadows, u.clippingPlanes = i.clippingPlanes, u.clipIntersection = i.clipIntersection, u.displacementMap = i.displacementMap, u.displacementScale = i.displacementScale, u.displacementBias = i.displacementBias, u.wireframeLinewidth = i.wireframeLinewidth, u.linewidth = i.linewidth, !0 === r.isPointLight && !0 === u.isMeshDistanceMaterial && (u.referencePosition.setFromMatrixPosition(r.matrixWorld), u.nearDistance = s, u.farDistance = a), u
+                        return h.visible = i.visible, h.wireframe = i.wireframe, h.side = o === c ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : v[i.side], h.alphaMap = i.alphaMap, h.alphaTest = i.alphaTest, h.clipShadows = i.clipShadows, h.clippingPlanes = i.clippingPlanes, h.clipIntersection = i.clipIntersection, h.displacementMap = i.displacementMap, h.displacementScale = i.displacementScale, h.displacementBias = i.displacementBias, h.wireframeLinewidth = i.wireframeLinewidth, h.linewidth = i.linewidth, !0 === r.isPointLight && !0 === h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(r.matrixWorld), h.nearDistance = s, h.farDistance = a), h
                     }
 
-                    function b(n, r, s, a, o) {
+                    function E(n, r, s, a, o) {
                         if (!1 === n.visible) return;
-                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
+                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && o === c) && (!n.frustumCulled || i.intersectsObject(n))) {
                             n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                             const i = e.update(n),
                                 r = n.material;
                             if (Array.isArray(r)) {
                                 const e = i.groups;
                                 for (let l = 0, c = e.length; l < c; l++) {
                                     const c = e[l],
                                         h = r[c.materialIndex];
                                     if (h && h.visible) {
-                                        const e = M(n, 0, h, a, s.near, s.far, o);
+                                        const e = S(n, 0, h, a, s.near, s.far, o);
                                         t.renderBufferDirect(s, null, i, e, n, c)
                                     }
                                 }
                             } else if (r.visible) {
-                                const e = M(n, 0, r, a, s.near, s.far, o);
+                                const e = S(n, 0, r, a, s.near, s.far, o);
                                 t.renderBufferDirect(s, null, i, e, n, null)
                             }
                         }
                         const l = n.children;
-                        for (let t = 0, e = l.length; t < e; t++) b(l[t], r, s, a, o)
+                        for (let t = 0, e = l.length; t < e; t++) E(l[t], r, s, a, o)
                     }
-                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, n, o) {
-                        if (!1 === x.enabled) return;
-                        if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
+                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = o, this.render = function(e, n, o) {
+                        if (!1 === b.enabled) return;
+                        if (!1 === b.autoUpdate && !1 === b.needsUpdate) return;
                         if (0 === e.length) return;
                         const l = t.getRenderTarget(),
-                            c = t.getActiveCubeFace(),
-                            p = t.getActiveMipmapLevel(),
-                            m = t.state;
-                        m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), m.setScissorTest(!1);
-                        for (let l = 0, c = e.length; l < c; l++) {
-                            const c = e[l],
-                                p = c.shadow;
-                            if (void 0 === p) {
-                                console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
+                            h = t.getActiveCubeFace(),
+                            u = t.getActiveMipmapLevel(),
+                            d = t.state;
+                        d.setBlending(p), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
+                        for (let l = 0, h = e.length; l < h; l++) {
+                            const h = e[l],
+                                u = h.shadow;
+                            if (void 0 === u) {
+                                console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
                                 continue
                             }
-                            if (!1 === p.autoUpdate && !1 === p.needsUpdate) continue;
-                            r.copy(p.mapSize);
-                            const f = p.getFrameExtents();
-                            if (r.multiply(f), s.copy(p.mapSize), (r.x > d || r.y > d) && (r.x > d && (s.x = Math.floor(d / f.x), r.x = s.x * f.x, p.mapSize.x = s.x), r.y > d && (s.y = Math.floor(d / f.y), r.y = s.y * f.y, p.mapSize.y = s.y)), null === p.map && !p.isPointLightShadow && 3 === this.type) {
+                            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
+                            r.copy(u.mapSize);
+                            const p = u.getFrameExtents();
+                            if (r.multiply(p), s.copy(u.mapSize), (r.x > g || r.y > g) && (r.x > g && (s.x = Math.floor(g / p.x), r.x = s.x * p.x, u.mapSize.x = s.x), r.y > g && (s.y = Math.floor(g / p.y), r.y = s.y * p.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && this.type === c) {
                                 const t = {
-                                    minFilter: u,
-                                    magFilter: u,
-                                    format: y
+                                    minFilter: ht,
+                                    magFilter: ht,
+                                    format: Et
                                 };
-                                p.map = new ut(r.x, r.y, t), p.map.texture.name = c.name + ".shadowMap", p.mapPass = new ut(r.x, r.y, t), p.camera.updateProjectionMatrix()
+                                u.map = new Je(r.x, r.y, t), u.map.texture.name = h.name + ".shadowMap", u.mapPass = new Je(r.x, r.y, t), u.camera.updateProjectionMatrix()
                             }
-                            if (null === p.map) {
+                            if (null === u.map) {
                                 const t = {
-                                    minFilter: h,
-                                    magFilter: h,
-                                    format: y
+                                    minFilter: ot,
+                                    magFilter: ot,
+                                    format: Et
                                 };
-                                p.map = new ut(r.x, r.y, t), p.map.texture.name = c.name + ".shadowMap", p.camera.updateProjectionMatrix()
+                                u.map = new Je(r.x, r.y, t), u.map.texture.name = h.name + ".shadowMap", u.camera.updateProjectionMatrix()
                             }
-                            t.setRenderTarget(p.map), t.clear();
-                            const g = p.getViewportCount();
-                            for (let t = 0; t < g; t++) {
-                                const e = p.getViewport(t);
-                                a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), m.viewport(a), p.updateMatrices(c, t), i = p.getFrustum(), b(n, o, p.camera, c, this.type)
+                            t.setRenderTarget(u.map), t.clear();
+                            const m = u.getViewportCount();
+                            for (let t = 0; t < m; t++) {
+                                const e = u.getViewport(t);
+                                a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(a), u.updateMatrices(h, t), i = u.getFrustum(), E(n, o, u.camera, h, this.type)
                             }
-                            p.isPointLightShadow || 3 !== this.type || _(p, o), p.needsUpdate = !1
+                            u.isPointLightShadow || this.type !== c || w(u, o), u.needsUpdate = !1
                         }
-                        x.needsUpdate = !1, t.setRenderTarget(l, c, p)
+                        b.needsUpdate = !1, t.setRenderTarget(l, h, u)
                     }
                 }
 
-                function ss(t, e, n) {
-                    const r = n.isWebGL2,
-                        s = new function() {
+                function qa(t, e, n) {
+                    const i = n.isWebGL2,
+                        o = new function() {
                             let e = !1;
-                            const n = new ht;
+                            const n = new Ye;
                             let i = null;
-                            const r = new ht(0, 0, 0, 0);
+                            const r = new Ye(0, 0, 0, 0);
                             return {
                                 setMask: function(n) {
                                     i === n || e || (t.colorMask(n, n, n, n), i = n)
                                 },
                                 setLocked: function(t) {
                                     e = t
                                 },
@@ -24037,53 +24426,55 @@
                                     !0 === o && (e *= a, i *= a, s *= a), n.set(e, i, s, a), !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n))
                                 },
                                 reset: function() {
                                     e = !1, i = null, r.set(-1, 0, 0, 0)
                                 }
                             }
                         },
-                        a = new function() {
+                        l = new function() {
                             let e = !1,
                                 n = null,
                                 i = null,
                                 r = null;
                             return {
                                 setTest: function(t) {
-                                    t ? z(2929) : H(2929)
+                                    t ? yt(2929) : _t(2929)
                                 },
                                 setMask: function(i) {
                                     n === i || e || (t.depthMask(i), n = i)
                                 },
                                 setFunc: function(e) {
                                     if (i !== e) {
                                         if (e) switch (e) {
-                                            case 0:
+                                            case O:
                                                 t.depthFunc(512);
                                                 break;
-                                            case 1:
+                                            case U:
                                                 t.depthFunc(519);
                                                 break;
-                                            case 2:
+                                            case B:
                                                 t.depthFunc(513);
                                                 break;
-                                            case 3:
-                                            default:
+                                            case F:
                                                 t.depthFunc(515);
                                                 break;
-                                            case 4:
+                                            case z:
                                                 t.depthFunc(514);
                                                 break;
-                                            case 5:
+                                            case H:
                                                 t.depthFunc(518);
                                                 break;
-                                            case 6:
+                                            case G:
                                                 t.depthFunc(516);
                                                 break;
-                                            case 7:
-                                                t.depthFunc(517)
+                                            case V:
+                                                t.depthFunc(517);
+                                                break;
+                                            default:
+                                                t.depthFunc(515)
                                         } else t.depthFunc(515);
                                         i = e
                                     }
                                 },
                                 setLocked: function(t) {
                                     e = t
                                 },
@@ -24091,27 +24482,27 @@
                                     r !== e && (t.clearDepth(e), r = e)
                                 },
                                 reset: function() {
                                     e = !1, n = null, i = null, r = null
                                 }
                             }
                         },
-                        o = new function() {
+                        c = new function() {
                             let e = !1,
                                 n = null,
                                 i = null,
                                 r = null,
                                 s = null,
                                 a = null,
                                 o = null,
                                 l = null,
                                 c = null;
                             return {
                                 setTest: function(t) {
-                                    e || (t ? z(2960) : H(2960))
+                                    e || (t ? yt(2960) : _t(2960))
                                 },
                                 setMask: function(i) {
                                     n === i || e || (t.stencilMask(i), n = i)
                                 },
                                 setFunc: function(e, n, a) {
                                     i === e && r === n && s === a || (t.stencilFunc(e, n, a), i = e, r = n, s = a)
                                 },
@@ -24125,196 +24516,196 @@
                                     c !== e && (t.clearStencil(e), c = e)
                                 },
                                 reset: function() {
                                     e = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null
                                 }
                             }
                         };
-                    let l = {},
-                        c = {},
-                        h = new WeakMap,
-                        u = [],
-                        d = null,
-                        p = !1,
-                        m = null,
-                        f = null,
-                        g = null,
-                        v = null,
-                        x = null,
-                        y = null,
-                        _ = null,
-                        M = !1,
-                        b = null,
-                        w = null,
-                        S = null,
-                        E = null,
-                        T = null;
-                    const A = t.getParameter(35661);
-                    let R = !1,
-                        L = 0;
-                    const C = t.getParameter(7938); - 1 !== C.indexOf("WebGL") ? (L = parseFloat(/^WebGL (\d)/.exec(C)[1]), R = L >= 1) : -1 !== C.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL ES (\d)/.exec(C)[1]), R = L >= 2);
-                    let P = null,
-                        D = {};
-                    const I = t.getParameter(3088),
-                        N = t.getParameter(2978),
-                        O = (new ht).fromArray(I),
-                        U = (new ht).fromArray(N);
+                    let h = {},
+                        k = {},
+                        W = new WeakMap,
+                        j = [],
+                        X = null,
+                        q = !1,
+                        Y = null,
+                        J = null,
+                        Z = null,
+                        K = null,
+                        Q = null,
+                        $ = null,
+                        tt = null,
+                        et = !1,
+                        nt = null,
+                        it = null,
+                        rt = null,
+                        st = null,
+                        at = null;
+                    const ot = t.getParameter(35661);
+                    let lt = !1,
+                        ct = 0;
+                    const ht = t.getParameter(7938); - 1 !== ht.indexOf("WebGL") ? (ct = parseFloat(/^WebGL (\d)/.exec(ht)[1]), lt = ct >= 1) : -1 !== ht.indexOf("OpenGL ES") && (ct = parseFloat(/^OpenGL ES (\d)/.exec(ht)[1]), lt = ct >= 2);
+                    let ut = null,
+                        dt = {};
+                    const pt = t.getParameter(3088),
+                        mt = t.getParameter(2978),
+                        ft = (new Ye).fromArray(pt),
+                        gt = (new Ye).fromArray(mt);
 
-                    function B(e, n, i) {
+                    function vt(e, n, i) {
                         const r = new Uint8Array(4),
                             s = t.createTexture();
                         t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                         for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                         return s
                     }
-                    const F = {};
+                    const xt = {};
 
-                    function z(e) {
-                        !0 !== l[e] && (t.enable(e), l[e] = !0)
+                    function yt(e) {
+                        !0 !== h[e] && (t.enable(e), h[e] = !0)
                     }
 
-                    function H(e) {
-                        !1 !== l[e] && (t.disable(e), l[e] = !1)
+                    function _t(e) {
+                        !1 !== h[e] && (t.disable(e), h[e] = !1)
                     }
-                    F[3553] = B(3553, 3553, 1), F[34067] = B(34067, 34069, 6), s.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), z(2929), a.setFunc(3), W(!1), j(1), z(2884), k(0);
-                    const G = {
-                        [i]: 32774,
-                        101: 32778,
-                        102: 32779
+                    xt[3553] = vt(3553, 3553, 1), xt[34067] = vt(34067, 34069, 6), o.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), yt(2929), l.setFunc(F), St(!1), Et(s), yt(2884), wt(p);
+                    const Mt = {
+                        [y]: 32774,
+                        [_]: 32778,
+                        [M]: 32779
                     };
-                    if (r) G[103] = 32775, G[104] = 32776;
+                    if (i) Mt[b] = 32775, Mt[w] = 32776;
                     else {
                         const t = e.get("EXT_blend_minmax");
-                        null !== t && (G[103] = t.MIN_EXT, G[104] = t.MAX_EXT)
+                        null !== t && (Mt[b] = t.MIN_EXT, Mt[w] = t.MAX_EXT)
                     }
-                    const V = {
-                        200: 0,
-                        201: 1,
-                        202: 768,
-                        204: 770,
-                        210: 776,
-                        208: 774,
-                        206: 772,
-                        203: 769,
-                        205: 771,
-                        209: 775,
-                        207: 773
+                    const bt = {
+                        [S]: 0,
+                        [E]: 1,
+                        [T]: 768,
+                        [R]: 770,
+                        [N]: 776,
+                        [D]: 774,
+                        [C]: 772,
+                        [A]: 769,
+                        [L]: 771,
+                        [I]: 775,
+                        [P]: 773
                     };
 
-                    function k(e, n, r, s, a, o, l, c) {
-                        if (0 !== e) {
-                            if (!1 === p && (z(3042), p = !0), 5 === e) a = a || n, o = o || r, l = l || s, n === f && a === x || (t.blendEquationSeparate(G[n], G[a]), f = n, x = a), r === g && s === v && o === y && l === _ || (t.blendFuncSeparate(V[r], V[s], V[o], V[l]), g = r, v = s, y = o, _ = l), m = e, M = null;
-                            else if (e !== m || c !== M) {
-                                if (f === i && x === i || (t.blendEquation(32774), f = i, x = i), c) switch (e) {
-                                    case 1:
+                    function wt(e, n, i, r, s, a, o, l) {
+                        if (e !== p) {
+                            if (!1 === q && (yt(3042), q = !0), e === x) s = s || n, a = a || i, o = o || r, n === J && s === Q || (t.blendEquationSeparate(Mt[n], Mt[s]), J = n, Q = s), i === Z && r === K && a === $ && o === tt || (t.blendFuncSeparate(bt[i], bt[r], bt[a], bt[o]), Z = i, K = r, $ = a, tt = o), Y = e, et = null;
+                            else if (e !== Y || l !== et) {
+                                if (J === y && Q === y || (t.blendEquation(32774), J = y, Q = y), l) switch (e) {
+                                    case m:
                                         t.blendFuncSeparate(1, 771, 1, 771);
                                         break;
-                                    case 2:
+                                    case f:
                                         t.blendFunc(1, 1);
                                         break;
-                                    case 3:
+                                    case g:
                                         t.blendFuncSeparate(0, 769, 0, 1);
                                         break;
-                                    case 4:
+                                    case v:
                                         t.blendFuncSeparate(0, 768, 0, 770);
                                         break;
                                     default:
                                         console.error("THREE.WebGLState: Invalid blending: ", e)
                                 } else switch (e) {
-                                    case 1:
+                                    case m:
                                         t.blendFuncSeparate(770, 771, 1, 771);
                                         break;
-                                    case 2:
+                                    case f:
                                         t.blendFunc(770, 1);
                                         break;
-                                    case 3:
+                                    case g:
                                         t.blendFuncSeparate(0, 769, 0, 1);
                                         break;
-                                    case 4:
+                                    case v:
                                         t.blendFunc(0, 768);
                                         break;
                                     default:
                                         console.error("THREE.WebGLState: Invalid blending: ", e)
                                 }
-                                g = null, v = null, y = null, _ = null, m = e, M = c
+                                Z = null, K = null, $ = null, tt = null, Y = e, et = l
                             }
-                        } else !0 === p && (H(3042), p = !1)
+                        } else !0 === q && (_t(3042), q = !1)
                     }
 
-                    function W(e) {
-                        b !== e && (e ? t.frontFace(2304) : t.frontFace(2305), b = e)
+                    function St(e) {
+                        nt !== e && (e ? t.frontFace(2304) : t.frontFace(2305), nt = e)
                     }
 
-                    function j(e) {
-                        0 !== e ? (z(2884), e !== w && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : H(2884), w = e
+                    function Et(e) {
+                        e !== r ? (yt(2884), e !== it && (e === s ? t.cullFace(1029) : e === a ? t.cullFace(1028) : t.cullFace(1032))) : _t(2884), it = e
                     }
 
-                    function X(e, n, i) {
-                        e ? (z(32823), E === n && T === i || (t.polygonOffset(n, i), E = n, T = i)) : H(32823)
+                    function Tt(e, n, i) {
+                        e ? (yt(32823), st === n && at === i || (t.polygonOffset(n, i), st = n, at = i)) : _t(32823)
                     }
 
-                    function q(e) {
-                        void 0 === e && (e = 33984 + A - 1), P !== e && (t.activeTexture(e), P = e)
+                    function At(e) {
+                        void 0 === e && (e = 33984 + ot - 1), ut !== e && (t.activeTexture(e), ut = e)
                     }
                     return {
                         buffers: {
-                            color: s,
-                            depth: a,
-                            stencil: o
+                            color: o,
+                            depth: l,
+                            stencil: c
                         },
-                        enable: z,
-                        disable: H,
+                        enable: yt,
+                        disable: _t,
                         bindFramebuffer: function(e, n) {
-                            return c[e] !== n && (t.bindFramebuffer(e, n), c[e] = n, r && (36009 === e && (c[36160] = n), 36160 === e && (c[36009] = n)), !0)
+                            return k[e] !== n && (t.bindFramebuffer(e, n), k[e] = n, i && (36009 === e && (k[36160] = n), 36160 === e && (k[36009] = n)), !0)
                         },
                         drawBuffers: function(i, r) {
-                            let s = u,
+                            let s = j,
                                 a = !1;
                             if (i)
-                                if (s = h.get(r), void 0 === s && (s = [], h.set(r, s)), i.isWebGLMultipleRenderTargets) {
+                                if (s = W.get(r), void 0 === s && (s = [], W.set(r, s)), i.isWebGLMultipleRenderTargets) {
                                     const t = i.texture;
                                     if (s.length !== t.length || 36064 !== s[0]) {
                                         for (let e = 0, n = t.length; e < n; e++) s[e] = 36064 + e;
                                         s.length = t.length, a = !0
                                     }
                                 } else 36064 !== s[0] && (s[0] = 36064, a = !0);
                             else 1029 !== s[0] && (s[0] = 1029, a = !0);
                             a && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                         },
                         useProgram: function(e) {
-                            return d !== e && (t.useProgram(e), d = e, !0)
+                            return X !== e && (t.useProgram(e), X = e, !0)
                         },
-                        setBlending: k,
+                        setBlending: wt,
                         setMaterial: function(t, e) {
-                            2 === t.side ? H(2884) : z(2884);
-                            let n = 1 === t.side;
-                            e && (n = !n), W(n), 1 === t.blending && !1 === t.transparent ? k(0) : k(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), a.setFunc(t.depthFunc), a.setTest(t.depthTest), a.setMask(t.depthWrite), s.setMask(t.colorWrite);
+                            t.side === d ? _t(2884) : yt(2884);
+                            let n = t.side === u;
+                            e && (n = !n), St(n), t.blending === m && !1 === t.transparent ? wt(p) : wt(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), l.setFunc(t.depthFunc), l.setTest(t.depthTest), l.setMask(t.depthWrite), o.setMask(t.colorWrite);
                             const i = t.stencilWrite;
-                            o.setTest(i), i && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), X(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? z(32926) : H(32926)
+                            c.setTest(i), i && (c.setMask(t.stencilWriteMask), c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Tt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? yt(32926) : _t(32926)
                         },
-                        setFlipSided: W,
-                        setCullFace: j,
+                        setFlipSided: St,
+                        setCullFace: Et,
                         setLineWidth: function(e) {
-                            e !== S && (R && t.lineWidth(e), S = e)
+                            e !== rt && (lt && t.lineWidth(e), rt = e)
                         },
-                        setPolygonOffset: X,
+                        setPolygonOffset: Tt,
                         setScissorTest: function(t) {
-                            t ? z(3089) : H(3089)
+                            t ? yt(3089) : _t(3089)
                         },
-                        activeTexture: q,
+                        activeTexture: At,
                         bindTexture: function(e, n) {
-                            null === P && q();
-                            let i = D[P];
+                            null === ut && At();
+                            let i = dt[ut];
                             void 0 === i && (i = {
                                 type: void 0,
                                 texture: void 0
-                            }, D[P] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || F[e]), i.type = e, i.texture = n)
+                            }, dt[ut] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || xt[e]), i.type = e, i.texture = n)
                         },
                         unbindTexture: function() {
-                            const e = D[P];
+                            const e = dt[ut];
                             void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                         },
                         compressedTexImage2D: function() {
                             try {
                                 t.compressedTexImage2D.apply(t, arguments)
                             } catch (t) {
                                 console.error("THREE.WebGLState:", t)
@@ -24366,100 +24757,100 @@
                             try {
                                 t.compressedTexSubImage2D.apply(t, arguments)
                             } catch (t) {
                                 console.error("THREE.WebGLState:", t)
                             }
                         },
                         scissor: function(e) {
-                            !1 === O.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), O.copy(e))
+                            !1 === ft.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ft.copy(e))
                         },
                         viewport: function(e) {
-                            !1 === U.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), U.copy(e))
+                            !1 === gt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), gt.copy(e))
                         },
                         reset: function() {
-                            t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === r && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), l = {}, P = null, D = {}, c = {}, h = new WeakMap, u = [], d = null, p = !1, m = null, f = null, g = null, v = null, x = null, y = null, _ = null, M = !1, b = null, w = null, S = null, E = null, T = null, O.set(0, 0, t.canvas.width, t.canvas.height), U.set(0, 0, t.canvas.width, t.canvas.height), s.reset(), a.reset(), o.reset()
+                            t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), h = {}, ut = null, dt = {}, k = {}, W = new WeakMap, j = [], X = null, q = !1, Y = null, J = null, Z = null, K = null, Q = null, $ = null, tt = null, et = !1, nt = null, it = null, rt = null, st = null, at = null, ft.set(0, 0, t.canvas.width, t.canvas.height), gt.set(0, 0, t.canvas.width, t.canvas.height), o.reset(), l.reset(), c.reset()
                         }
                     }
                 }
 
-                function as(t, e, n, i, r, s, a) {
-                    const b = r.isWebGL2,
-                        w = r.maxTextures,
-                        S = r.maxCubemapSize,
-                        E = r.maxTextureSize,
-                        T = r.maxSamples,
-                        A = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
-                        R = new WeakMap;
-                    let L, C = !1;
+                function Ya(t, e, n, i, r, s, a) {
+                    const o = r.isWebGL2,
+                        l = r.maxTextures,
+                        c = r.maxCubemapSize,
+                        h = r.maxTextureSize,
+                        u = r.maxSamples,
+                        d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
+                        p = new WeakMap;
+                    let m, f = !1;
                     try {
-                        C = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
+                        f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                     } catch (t) {}
 
-                    function P(t, e) {
-                        return C ? new OffscreenCanvas(t, e) : K("canvas")
+                    function g(t, e) {
+                        return f ? new OffscreenCanvas(t, e) : Oe("canvas")
                     }
 
-                    function N(t, e, n, i) {
+                    function v(t, e, n, i) {
                         let r = 1;
                         if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                             if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
-                                const i = e ? q : Math.floor,
+                                const i = e ? Pe : Math.floor,
                                     s = i(r * t.width),
                                     a = i(r * t.height);
-                                void 0 === L && (L = P(s, a));
-                                const o = n ? P(s, a) : L;
+                                void 0 === m && (m = g(s, a));
+                                const o = n ? g(s, a) : m;
                                 return o.width = s, o.height = a, o.getContext("2d").drawImage(t, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."), o
                             }
                             return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                         }
                         return t
                     }
 
-                    function O(t) {
-                        return X(t.width) && X(t.height)
+                    function x(t) {
+                        return Ce(t.width) && Ce(t.height)
                     }
 
-                    function U(t, e) {
-                        return t.generateMipmaps && e && t.minFilter !== h && t.minFilter !== u
+                    function y(t, e) {
+                        return t.generateMipmaps && e && t.minFilter !== ot && t.minFilter !== ht
                     }
 
-                    function B(e) {
+                    function _(e) {
                         t.generateMipmap(e)
                     }
 
-                    function z(n, i, r, s, a = !1) {
-                        if (!1 === b) return i;
+                    function M(n, i, r, s, a = !1) {
+                        if (!1 === o) return i;
                         if (null !== n) {
                             if (void 0 !== t[n]) return t[n];
                             console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                         }
-                        let o = i;
-                        return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 33319 === i && (5126 === r && (o = 33328), 5131 === r && (o = 33327), 5121 === r && (o = 33323)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = s === I && !1 === a ? 35907 : 32856), 32819 === r && (o = 32854), 32820 === r && (o = 32855)), 33325 !== o && 33326 !== o && 33327 !== o && 33328 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o
+                        let l = i;
+                        return 6403 === i && (5126 === r && (l = 33326), 5131 === r && (l = 33325), 5121 === r && (l = 33321)), 33319 === i && (5126 === r && (l = 33328), 5131 === r && (l = 33327), 5121 === r && (l = 33323)), 6408 === i && (5126 === r && (l = 34836), 5131 === r && (l = 34842), 5121 === r && (l = s === me && !1 === a ? 35907 : 32856), 32819 === r && (l = 32854), 32820 === r && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || e.get("EXT_color_buffer_float"), l
                     }
 
-                    function H(t, e, n) {
-                        return !0 === U(t, n) || t.isFramebufferTexture && t.minFilter !== h && t.minFilter !== u ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
+                    function b(t, e, n) {
+                        return !0 === y(t, n) || t.isFramebufferTexture && t.minFilter !== ot && t.minFilter !== ht ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
                     }
 
-                    function G(t) {
-                        return t === h || 1004 === t || 1005 === t ? 9728 : 9729
+                    function w(t) {
+                        return t === ot || t === lt || t === ct ? 9728 : 9729
                     }
 
-                    function V(e) {
+                    function S(e) {
                         const n = e.target;
-                        n.removeEventListener("dispose", V),
+                        n.removeEventListener("dispose", S),
                             function(e) {
                                 const n = i.get(e);
                                 void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e))
-                            }(n), n.isVideoTexture && R.delete(n), a.memory.textures--
+                            }(n), n.isVideoTexture && p.delete(n), a.memory.textures--
                     }
 
-                    function k(e) {
+                    function E(e) {
                         const n = e.target;
-                        n.removeEventListener("dispose", k),
+                        n.removeEventListener("dispose", E),
                             function(e) {
                                 const n = e.texture,
                                     r = i.get(e),
                                     s = i.get(n);
                                 if (e) {
                                     if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), a.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                         for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
@@ -24469,408 +24860,407 @@
                                             const r = i.get(n[e]);
                                             r.__webglTexture && (t.deleteTexture(r.__webglTexture), a.memory.textures--), i.remove(n[e])
                                         }
                                     i.remove(n), i.remove(e)
                                 }
                             }(n)
                     }
-                    let W = 0;
+                    let T = 0;
 
-                    function j(t, e) {
+                    function A(t, e) {
                         const r = i.get(t);
                         if (t.isVideoTexture && function(t) {
                                 const e = a.render.frame;
-                                R.get(t) !== e && (R.set(t, e), t.update())
+                                p.get(t) !== e && (p.set(t, e), t.update())
                             }(t), t.version > 0 && r.__version !== t.version) {
                             const n = t.image;
                             if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                             else {
-                                if (!1 !== n.complete) return void tt(r, t, e);
+                                if (!1 !== n.complete) return void I(r, t, e);
                                 console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                             }
                         }
                         n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
                     }
 
-                    function Y(e, r) {
+                    function R(e, r) {
                         const a = i.get(e);
                         e.version > 0 && a.__version !== e.version ? function(e, i, r) {
                             if (6 !== i.image.length) return;
-                            $(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
+                            D(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                             const a = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
-                                o = i.image[0] && i.image[0].isDataTexture,
-                                l = [];
-                            for (let t = 0; t < 6; t++) l[t] = a || o ? o ? i.image[t].image : i.image[t] : N(i.image[t], !1, !0, S), l[t] = st(i, l[t]);
-                            const c = l[0],
-                                h = O(c) || b,
-                                u = s.convert(i.format, i.encoding),
-                                d = s.convert(i.type),
-                                p = z(i.internalFormat, u, d, i.encoding),
-                                m = b && !0 !== i.isVideoTexture,
-                                f = void 0 === e.__version;
-                            let g, v = H(i, c, h);
-                            if (Q(34067, i, h), a) {
-                                m && f && n.texStorage2D(34067, v, p, c.width, c.height);
+                                l = i.image[0] && i.image[0].isDataTexture,
+                                h = [];
+                            for (let t = 0; t < 6; t++) h[t] = a || l ? l ? i.image[t].image : i.image[t] : v(i.image[t], !1, !0, c), h[t] = F(i, h[t]);
+                            const u = h[0],
+                                d = x(u) || o,
+                                p = s.convert(i.format, i.encoding),
+                                m = s.convert(i.type),
+                                f = M(i.internalFormat, p, m, i.encoding),
+                                g = o && !0 !== i.isVideoTexture,
+                                w = void 0 === e.__version;
+                            let S, E = b(i, u, d);
+                            if (P(34067, i, d), a) {
+                                g && w && n.texStorage2D(34067, E, f, u.width, u.height);
                                 for (let t = 0; t < 6; t++) {
-                                    g = l[t].mipmaps;
-                                    for (let e = 0; e < g.length; e++) {
-                                        const r = g[e];
-                                        i.format !== y ? null !== u ? m ? n.compressedTexSubImage2D(34069 + t, e, 0, 0, r.width, r.height, u, r.data) : n.compressedTexImage2D(34069 + t, e, p, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : m ? n.texSubImage2D(34069 + t, e, 0, 0, r.width, r.height, u, d, r.data) : n.texImage2D(34069 + t, e, p, r.width, r.height, 0, u, d, r.data)
+                                    S = h[t].mipmaps;
+                                    for (let e = 0; e < S.length; e++) {
+                                        const r = S[e];
+                                        i.format !== Et ? null !== p ? g ? n.compressedTexSubImage2D(34069 + t, e, 0, 0, r.width, r.height, p, r.data) : n.compressedTexImage2D(34069 + t, e, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(34069 + t, e, 0, 0, r.width, r.height, p, m, r.data) : n.texImage2D(34069 + t, e, f, r.width, r.height, 0, p, m, r.data)
                                     }
                                 }
                             } else {
-                                g = i.mipmaps, m && f && (g.length > 0 && v++, n.texStorage2D(34067, v, p, l[0].width, l[0].height));
+                                S = i.mipmaps, g && w && (S.length > 0 && E++, n.texStorage2D(34067, E, f, h[0].width, h[0].height));
                                 for (let t = 0; t < 6; t++)
-                                    if (o) {
-                                        m ? n.texSubImage2D(34069 + t, 0, 0, 0, l[t].width, l[t].height, u, d, l[t].data) : n.texImage2D(34069 + t, 0, p, l[t].width, l[t].height, 0, u, d, l[t].data);
-                                        for (let e = 0; e < g.length; e++) {
-                                            const i = g[e].image[t].image;
-                                            m ? n.texSubImage2D(34069 + t, e + 1, 0, 0, i.width, i.height, u, d, i.data) : n.texImage2D(34069 + t, e + 1, p, i.width, i.height, 0, u, d, i.data)
+                                    if (l) {
+                                        g ? n.texSubImage2D(34069 + t, 0, 0, 0, h[t].width, h[t].height, p, m, h[t].data) : n.texImage2D(34069 + t, 0, f, h[t].width, h[t].height, 0, p, m, h[t].data);
+                                        for (let e = 0; e < S.length; e++) {
+                                            const i = S[e].image[t].image;
+                                            g ? n.texSubImage2D(34069 + t, e + 1, 0, 0, i.width, i.height, p, m, i.data) : n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, p, m, i.data)
                                         }
                                     } else {
-                                        m ? n.texSubImage2D(34069 + t, 0, 0, 0, u, d, l[t]) : n.texImage2D(34069 + t, 0, p, u, d, l[t]);
-                                        for (let e = 0; e < g.length; e++) {
-                                            const i = g[e];
-                                            m ? n.texSubImage2D(34069 + t, e + 1, 0, 0, u, d, i.image[t]) : n.texImage2D(34069 + t, e + 1, p, u, d, i.image[t])
+                                        g ? n.texSubImage2D(34069 + t, 0, 0, 0, p, m, h[t]) : n.texImage2D(34069 + t, 0, f, p, m, h[t]);
+                                        for (let e = 0; e < S.length; e++) {
+                                            const i = S[e];
+                                            g ? n.texSubImage2D(34069 + t, e + 1, 0, 0, p, m, i.image[t]) : n.texImage2D(34069 + t, e + 1, f, p, m, i.image[t])
                                         }
                                     }
                             }
-                            U(i, h) && B(34067), e.__version = i.version, i.onUpdate && i.onUpdate(i)
+                            y(i, d) && _(34067), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                         }(a, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture))
                     }
-                    const J = {
-                            [o]: 10497,
-                            [l]: 33071,
-                            [c]: 33648
-                        },
-                        Z = {
-                            [h]: 9728,
-                            1004: 9984,
-                            1005: 9986,
-                            [u]: 9729,
-                            1007: 9985,
-                            [d]: 9987
+                    const L = {
+                            [rt]: 10497,
+                            [st]: 33071,
+                            [at]: 33648
+                        },
+                        C = {
+                            [ot]: 9728,
+                            [lt]: 9984,
+                            [ct]: 9986,
+                            [ht]: 9729,
+                            [ut]: 9985,
+                            [dt]: 9987
                         };
 
-                    function Q(n, s, a) {
-                        if (a ? (t.texParameteri(n, 10242, J[s.wrapS]), t.texParameteri(n, 10243, J[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, J[s.wrapR]), t.texParameteri(n, 10240, Z[s.magFilter]), t.texParameteri(n, 10241, Z[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === l && s.wrapT === l || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, G(s.magFilter)), t.texParameteri(n, 10241, G(s.minFilter)), s.minFilter !== h && s.minFilter !== u && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
+                    function P(n, s, a) {
+                        if (a ? (t.texParameteri(n, 10242, L[s.wrapS]), t.texParameteri(n, 10243, L[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, L[s.wrapR]), t.texParameteri(n, 10240, C[s.magFilter]), t.texParameteri(n, 10241, C[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === st && s.wrapT === st || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, w(s.magFilter)), t.texParameteri(n, 10241, w(s.minFilter)), s.minFilter !== ot && s.minFilter !== ht && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                             const a = e.get("EXT_texture_filter_anisotropic");
-                            if (s.type === g && !1 === e.has("OES_texture_float_linear")) return;
-                            if (!1 === b && s.type === v && !1 === e.has("OES_texture_half_float_linear")) return;
+                            if (s.type === yt && !1 === e.has("OES_texture_float_linear")) return;
+                            if (!1 === o && s.type === _t && !1 === e.has("OES_texture_half_float_linear")) return;
                             (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                         }
                     }
 
-                    function $(e, n) {
-                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", V), e.__webglTexture = t.createTexture(), a.memory.textures++)
+                    function D(e, n) {
+                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", S), e.__webglTexture = t.createTexture(), a.memory.textures++)
                     }
 
-                    function tt(e, i, r) {
+                    function I(e, i, r) {
                         let a = 3553;
-                        i.isDataTexture2DArray && (a = 35866), i.isDataTexture3D && (a = 32879), $(e, i), n.activeTexture(33984 + r), n.bindTexture(a, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
-                        const o = function(t) {
-                            return !b && (t.wrapS !== l || t.wrapT !== l || t.minFilter !== h && t.minFilter !== u)
-                        }(i) && !1 === O(i.image);
-                        let c = N(i.image, o, !1, E);
-                        c = st(i, c);
-                        const d = O(c) || b,
-                            p = s.convert(i.format, i.encoding);
-                        let v, w = s.convert(i.type),
-                            S = z(i.internalFormat, p, w, i.encoding, i.isVideoTexture);
-                        Q(a, i, d);
-                        const T = i.mipmaps,
-                            A = b && !0 !== i.isVideoTexture,
-                            R = void 0 === e.__version,
-                            L = H(i, c, d);
-                        if (i.isDepthTexture) S = 6402, b ? S = i.type === g ? 36012 : i.type === f ? 33190 : i.type === x ? 35056 : 33189 : i.type === g && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === _ && 6402 === S && i.type !== m && i.type !== f && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = m, w = s.convert(i.type)), i.format === M && 6402 === S && (S = 34041, i.type !== x && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = x, w = s.convert(i.type))), A && R ? n.texStorage2D(3553, 1, S, c.width, c.height) : n.texImage2D(3553, 0, S, c.width, c.height, 0, p, w, null);
+                        i.isDataTexture2DArray && (a = 35866), i.isDataTexture3D && (a = 32879), D(e, i), n.activeTexture(33984 + r), n.bindTexture(a, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
+                        const l = function(t) {
+                            return !o && (t.wrapS !== st || t.wrapT !== st || t.minFilter !== ot && t.minFilter !== ht)
+                        }(i) && !1 === x(i.image);
+                        let c = v(i.image, l, !1, h);
+                        c = F(i, c);
+                        const u = x(c) || o,
+                            d = s.convert(i.format, i.encoding);
+                        let p, m = s.convert(i.type),
+                            f = M(i.internalFormat, d, m, i.encoding, i.isVideoTexture);
+                        P(a, i, u);
+                        const g = i.mipmaps,
+                            w = o && !0 !== i.isVideoTexture,
+                            S = void 0 === e.__version,
+                            E = b(i, c, u);
+                        if (i.isDepthTexture) f = 6402, o ? f = i.type === yt ? 36012 : i.type === xt ? 33190 : i.type === wt ? 35056 : 33189 : i.type === yt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Rt && 6402 === f && i.type !== gt && i.type !== xt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = gt, m = s.convert(i.type)), i.format === Lt && 6402 === f && (f = 34041, i.type !== wt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = wt, m = s.convert(i.type))), w && S ? n.texStorage2D(3553, 1, f, c.width, c.height) : n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null);
                         else if (i.isDataTexture)
-                            if (T.length > 0 && d) {
-                                A && R && n.texStorage2D(3553, L, S, T[0].width, T[0].height);
-                                for (let t = 0, e = T.length; t < e; t++) v = T[t], A ? n.texSubImage2D(3553, 0, 0, 0, v.width, v.height, p, w, v.data) : n.texImage2D(3553, t, S, v.width, v.height, 0, p, w, v.data);
+                            if (g.length > 0 && u) {
+                                w && S && n.texStorage2D(3553, E, f, g[0].width, g[0].height);
+                                for (let t = 0, e = g.length; t < e; t++) p = g[t], w ? n.texSubImage2D(3553, 0, 0, 0, p.width, p.height, d, m, p.data) : n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                                 i.generateMipmaps = !1
-                            } else A ? (R && n.texStorage2D(3553, L, S, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, c.width, c.height, p, w, c.data)) : n.texImage2D(3553, 0, S, c.width, c.height, 0, p, w, c.data);
+                            } else w ? (S && n.texStorage2D(3553, E, f, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, c.width, c.height, d, m, c.data)) : n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, c.data);
                         else if (i.isCompressedTexture) {
-                            A && R && n.texStorage2D(3553, L, S, T[0].width, T[0].height);
-                            for (let t = 0, e = T.length; t < e; t++) v = T[t], i.format !== y ? null !== p ? A ? n.compressedTexSubImage2D(3553, t, 0, 0, v.width, v.height, p, v.data) : n.compressedTexImage2D(3553, t, S, v.width, v.height, 0, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : A ? n.texSubImage2D(3553, t, 0, 0, v.width, v.height, p, w, v.data) : n.texImage2D(3553, t, S, v.width, v.height, 0, p, w, v.data)
-                        } else if (i.isDataTexture2DArray) A ? (R && n.texStorage3D(35866, L, S, c.width, c.height, c.depth), n.texSubImage3D(35866, 0, 0, 0, 0, c.width, c.height, c.depth, p, w, c.data)) : n.texImage3D(35866, 0, S, c.width, c.height, c.depth, 0, p, w, c.data);
-                        else if (i.isDataTexture3D) A ? (R && n.texStorage3D(32879, L, S, c.width, c.height, c.depth), n.texSubImage3D(32879, 0, 0, 0, 0, c.width, c.height, c.depth, p, w, c.data)) : n.texImage3D(32879, 0, S, c.width, c.height, c.depth, 0, p, w, c.data);
-                        else if (i.isFramebufferTexture) A && R ? n.texStorage2D(3553, L, S, c.width, c.height) : n.texImage2D(3553, 0, S, c.width, c.height, 0, p, w, null);
-                        else if (T.length > 0 && d) {
-                            A && R && n.texStorage2D(3553, L, S, T[0].width, T[0].height);
-                            for (let t = 0, e = T.length; t < e; t++) v = T[t], A ? n.texSubImage2D(3553, t, 0, 0, p, w, v) : n.texImage2D(3553, t, S, p, w, v);
+                            w && S && n.texStorage2D(3553, E, f, g[0].width, g[0].height);
+                            for (let t = 0, e = g.length; t < e; t++) p = g[t], i.format !== Et ? null !== d ? w ? n.compressedTexSubImage2D(3553, t, 0, 0, p.width, p.height, d, p.data) : n.compressedTexImage2D(3553, t, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : w ? n.texSubImage2D(3553, t, 0, 0, p.width, p.height, d, m, p.data) : n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data)
+                        } else if (i.isDataTexture2DArray) w ? (S && n.texStorage3D(35866, E, f, c.width, c.height, c.depth), n.texSubImage3D(35866, 0, 0, 0, 0, c.width, c.height, c.depth, d, m, c.data)) : n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, d, m, c.data);
+                        else if (i.isDataTexture3D) w ? (S && n.texStorage3D(32879, E, f, c.width, c.height, c.depth), n.texSubImage3D(32879, 0, 0, 0, 0, c.width, c.height, c.depth, d, m, c.data)) : n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, d, m, c.data);
+                        else if (i.isFramebufferTexture) w && S ? n.texStorage2D(3553, E, f, c.width, c.height) : n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null);
+                        else if (g.length > 0 && u) {
+                            w && S && n.texStorage2D(3553, E, f, g[0].width, g[0].height);
+                            for (let t = 0, e = g.length; t < e; t++) p = g[t], w ? n.texSubImage2D(3553, t, 0, 0, d, m, p) : n.texImage2D(3553, t, f, d, m, p);
                             i.generateMipmaps = !1
-                        } else A ? (R && n.texStorage2D(3553, L, S, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, p, w, c)) : n.texImage2D(3553, 0, S, p, w, c);
-                        U(i, d) && B(a), e.__version = i.version, i.onUpdate && i.onUpdate(i)
+                        } else w ? (S && n.texStorage2D(3553, E, f, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, d, m, c)) : n.texImage2D(3553, 0, f, d, m, c);
+                        y(i, u) && _(a), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                     }
 
-                    function et(e, r, a, o, l) {
+                    function N(e, r, a, o, l) {
                         const c = s.convert(a.format, a.encoding),
                             h = s.convert(a.type),
-                            u = z(a.internalFormat, c, h, a.encoding);
-                        i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(36160, e), r.useRenderToTexture ? A.framebufferTexture2DMultisampleEXT(36160, o, l, i.get(a).__webglTexture, 0, rt(r)) : t.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(36160, null)
+                            u = M(a.internalFormat, c, h, a.encoding);
+                        i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(36160, e), r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, o, l, i.get(a).__webglTexture, 0, B(r)) : t.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(36160, null)
                     }
 
-                    function nt(e, n, i) {
+                    function O(e, n, i) {
                         if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                             let r = 33189;
                             if (i || n.useRenderToTexture) {
                                 const e = n.depthTexture;
-                                e && e.isDepthTexture && (e.type === g ? r = 36012 : e.type === f && (r = 33190));
-                                const i = rt(n);
-                                n.useRenderToTexture ? A.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
+                                e && e.isDepthTexture && (e.type === yt ? r = 36012 : e.type === xt && (r = 33190));
+                                const i = B(n);
+                                n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                             } else t.renderbufferStorage(36161, r, n.width, n.height);
                             t.framebufferRenderbuffer(36160, 36096, 36161, e)
                         } else if (n.depthBuffer && n.stencilBuffer) {
-                            const r = rt(n);
-                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : n.useRenderToTexture ? A.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)
+                            const r = B(n);
+                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)
                         } else {
                             const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                                 r = s.convert(e.format, e.encoding),
                                 a = s.convert(e.type),
-                                o = z(e.internalFormat, r, a, e.encoding),
-                                l = rt(n);
-                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, l, o, n.width, n.height) : n.useRenderToTexture ? A.renderbufferStorageMultisampleEXT(36161, l, o, n.width, n.height) : t.renderbufferStorage(36161, o, n.width, n.height)
+                                o = M(e.internalFormat, r, a, e.encoding),
+                                l = B(n);
+                            i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, l, o, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, l, o, n.width, n.height) : t.renderbufferStorage(36161, o, n.width, n.height)
                         }
                         t.bindRenderbuffer(36161, null)
                     }
 
-                    function it(e) {
+                    function U(e) {
                         const r = i.get(e),
                             s = !0 === e.isWebGLCubeRenderTarget;
                         if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                             if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                             ! function(e, r) {
                                 if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                 if (n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
-                                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), j(r.depthTexture, 0);
+                                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), A(r.depthTexture, 0);
                                 const s = i.get(r.depthTexture).__webglTexture,
-                                    a = rt(r);
-                                if (r.depthTexture.format === _) r.useRenderToTexture ? A.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : t.framebufferTexture2D(36160, 36096, 3553, s, 0);
+                                    a = B(r);
+                                if (r.depthTexture.format === Rt) r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                                 else {
-                                    if (r.depthTexture.format !== M) throw new Error("Unknown depthTexture format");
-                                    r.useRenderToTexture ? A.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : t.framebufferTexture2D(36160, 33306, 3553, s, 0)
+                                    if (r.depthTexture.format !== Lt) throw new Error("Unknown depthTexture format");
+                                    r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                                 }
                             }(r.__webglFramebuffer, e)
                         } else if (s) {
                             r.__webglDepthbuffer = [];
-                            for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), nt(r.__webglDepthbuffer[i], e, !1)
-                        } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), nt(r.__webglDepthbuffer, e, !1);
+                            for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), O(r.__webglDepthbuffer[i], e, !1)
+                        } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), O(r.__webglDepthbuffer, e, !1);
                         n.bindFramebuffer(36160, null)
                     }
 
-                    function rt(t) {
-                        return b && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(T, t.samples) : 0
+                    function B(t) {
+                        return o && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(u, t.samples) : 0
                     }
 
-                    function st(t, n) {
+                    function F(t, n) {
                         const i = t.encoding,
                             r = t.format,
                             s = t.type;
-                        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === F || i !== D && (i === I ? !1 === b ? !0 === e.has("EXT_sRGB") && r === y ? (t.format = F, t.minFilter = u, t.generateMipmaps = !1) : n = at.sRGBToLinear(n) : r === y && s === p || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n
+                        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === be || i !== pe && (i === me ? !1 === o ? !0 === e.has("EXT_sRGB") && r === Et ? (t.format = be, t.minFilter = ht, t.generateMipmaps = !1) : n = We.sRGBToLinear(n) : r === Et && s === pt || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n
                     }
-                    let ot = !1,
-                        lt = !1;
+                    let z = !1,
+                        H = !1;
                     this.allocateTextureUnit = function() {
-                        const t = W;
-                        return t >= w && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + w), W += 1, t
+                        const t = T;
+                        return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), T += 1, t
                     }, this.resetTextureUnits = function() {
-                        W = 0
-                    }, this.setTexture2D = j, this.setTexture2DArray = function(t, e) {
+                        T = 0
+                    }, this.setTexture2D = A, this.setTexture2DArray = function(t, e) {
                         const r = i.get(t);
-                        t.version > 0 && r.__version !== t.version ? tt(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
+                        t.version > 0 && r.__version !== t.version ? I(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
                     }, this.setTexture3D = function(t, e) {
                         const r = i.get(t);
-                        t.version > 0 && r.__version !== t.version ? tt(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
-                    }, this.setTextureCube = Y, this.rebindTextures = function(t, e, n) {
+                        t.version > 0 && r.__version !== t.version ? I(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
+                    }, this.setTextureCube = R, this.rebindTextures = function(t, e, n) {
                         const r = i.get(t);
-                        void 0 !== e && et(r.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && it(t)
+                        void 0 !== e && N(r.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && U(t)
                     }, this.setupRenderTarget = function(e) {
-                        const o = e.texture,
-                            l = i.get(e),
-                            c = i.get(o);
-                        e.addEventListener("dispose", k), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = t.createTexture()), c.__version = o.version, a.memory.textures++);
-                        const h = !0 === e.isWebGLCubeRenderTarget,
-                            u = !0 === e.isWebGLMultipleRenderTargets,
-                            d = o.isDataTexture3D || o.isDataTexture2DArray,
-                            p = O(e) || b;
-                        if (h) {
-                            l.__webglFramebuffer = [];
-                            for (let e = 0; e < 6; e++) l.__webglFramebuffer[e] = t.createFramebuffer()
-                        } else if (l.__webglFramebuffer = t.createFramebuffer(), u)
+                        const l = e.texture,
+                            c = i.get(e),
+                            h = i.get(l);
+                        e.addEventListener("dispose", E), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()), h.__version = l.version, a.memory.textures++);
+                        const u = !0 === e.isWebGLCubeRenderTarget,
+                            d = !0 === e.isWebGLMultipleRenderTargets,
+                            p = l.isDataTexture3D || l.isDataTexture2DArray,
+                            m = x(e) || o;
+                        if (u) {
+                            c.__webglFramebuffer = [];
+                            for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
+                        } else if (c.__webglFramebuffer = t.createFramebuffer(), d)
                             if (r.drawBuffers) {
                                 const n = e.texture;
                                 for (let e = 0, r = n.length; e < r; e++) {
                                     const r = i.get(n[e]);
                                     void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), a.memory.textures++)
                                 }
                             } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                         else if (e.useRenderbuffer)
-                            if (b) {
-                                l.__webglMultisampledFramebuffer = t.createFramebuffer(), l.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
-                                const i = s.convert(o.format, o.encoding),
-                                    r = s.convert(o.type),
-                                    a = z(o.internalFormat, i, r, o.encoding),
-                                    c = rt(e);
-                                t.renderbufferStorageMultisample(36161, c, a, e.width, e.height), n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (l.__webglDepthRenderbuffer = t.createRenderbuffer(), nt(l.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
+                            if (o) {
+                                c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
+                                const i = s.convert(l.format, l.encoding),
+                                    r = s.convert(l.type),
+                                    a = M(l.internalFormat, i, r, l.encoding),
+                                    o = B(e);
+                                t.renderbufferStorageMultisample(36161, o, a, e.width, e.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), O(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                             } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
-                        if (h) {
-                            n.bindTexture(34067, c.__webglTexture), Q(34067, o, p);
-                            for (let t = 0; t < 6; t++) et(l.__webglFramebuffer[t], e, o, 36064, 34069 + t);
-                            U(o, p) && B(34067), n.unbindTexture()
-                        } else if (u) {
+                        if (u) {
+                            n.bindTexture(34067, h.__webglTexture), P(34067, l, m);
+                            for (let t = 0; t < 6; t++) N(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
+                            y(l, m) && _(34067), n.unbindTexture()
+                        } else if (d) {
                             const t = e.texture;
                             for (let r = 0, s = t.length; r < s; r++) {
                                 const s = t[r],
                                     a = i.get(s);
-                                n.bindTexture(3553, a.__webglTexture), Q(3553, s, p), et(l.__webglFramebuffer, e, s, 36064 + r, 3553), U(s, p) && B(3553)
+                                n.bindTexture(3553, a.__webglTexture), P(3553, s, m), N(c.__webglFramebuffer, e, s, 36064 + r, 3553), y(s, m) && _(3553)
                             }
                             n.unbindTexture()
                         } else {
                             let t = 3553;
-                            d && (b ? t = o.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(t, c.__webglTexture), Q(t, o, p), et(l.__webglFramebuffer, e, o, 36064, t), U(o, p) && B(t), n.unbindTexture()
+                            p && (o ? t = l.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(t, h.__webglTexture), P(t, l, m), N(c.__webglFramebuffer, e, l, 36064, t), y(l, m) && _(t), n.unbindTexture()
                         }
-                        e.depthBuffer && it(e)
+                        e.depthBuffer && U(e)
                     }, this.updateRenderTargetMipmap = function(t) {
-                        const e = O(t) || b,
+                        const e = x(t) || o,
                             r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                         for (let s = 0, a = r.length; s < a; s++) {
                             const a = r[s];
-                            if (U(a, e)) {
+                            if (y(a, e)) {
                                 const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                     r = i.get(a).__webglTexture;
-                                n.bindTexture(e, r), B(e), n.unbindTexture()
+                                n.bindTexture(e, r), _(e), n.unbindTexture()
                             }
                         }
                     }, this.updateMultisampleRenderTarget = function(e) {
                         if (e.useRenderbuffer)
-                            if (b) {
+                            if (o) {
                                 const r = e.width,
                                     s = e.height;
                                 let a = 16384;
                                 const o = [36064],
                                     l = e.stencilBuffer ? 33306 : 36096;
                                 e.depthBuffer && o.push(l), e.ignoreDepthForMultisampleCopy || (e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024));
                                 const c = i.get(e);
                                 n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, c.__webglFramebuffer), e.ignoreDepthForMultisampleCopy && (t.invalidateFramebuffer(36008, [l]), t.invalidateFramebuffer(36009, [l])), t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728), t.invalidateFramebuffer(36008, o), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
                             } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
-                    }, this.setupDepthRenderbuffer = it, this.setupFrameBufferTexture = et, this.safeSetTexture2D = function(t, e) {
-                        t && t.isWebGLRenderTarget && (!1 === ot && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), ot = !0), t = t.texture), j(t, e)
+                    }, this.setupDepthRenderbuffer = U, this.setupFrameBufferTexture = N, this.safeSetTexture2D = function(t, e) {
+                        t && t.isWebGLRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), z = !0), t = t.texture), A(t, e)
                     }, this.safeSetTextureCube = function(t, e) {
-                        t && t.isWebGLCubeRenderTarget && (!1 === lt && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), lt = !0), t = t.texture), Y(t, e)
+                        t && t.isWebGLCubeRenderTarget && (!1 === H && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), H = !0), t = t.texture), R(t, e)
                     }
                 }
 
-                function os(t, e, n) {
+                function Ja(t, e, n) {
                     const i = n.isWebGL2;
                     return {
                         convert: function(t, n = null) {
                             let r;
-                            if (t === p) return 5121;
-                            if (1017 === t) return 32819;
-                            if (1018 === t) return 32820;
-                            if (1010 === t) return 5120;
-                            if (1011 === t) return 5122;
-                            if (t === m) return 5123;
-                            if (1013 === t) return 5124;
-                            if (t === f) return 5125;
-                            if (t === g) return 5126;
-                            if (t === v) return i ? 5131 : (r = e.get("OES_texture_half_float"), null !== r ? r.HALF_FLOAT_OES : null);
-                            if (1021 === t) return 6406;
-                            if (t === y) return 6408;
-                            if (1024 === t) return 6409;
-                            if (1025 === t) return 6410;
-                            if (t === _) return 6402;
-                            if (t === M) return 34041;
-                            if (1028 === t) return 6403;
-                            if (t === F) return r = e.get("EXT_sRGB"), null !== r ? r.SRGB_ALPHA_EXT : null;
-                            if (1029 === t) return 36244;
-                            if (1030 === t) return 33319;
-                            if (1031 === t) return 33320;
-                            if (1033 === t) return 36249;
-                            if (t === b || t === w || t === S || t === E)
-                                if (n === I) {
+                            if (t === pt) return 5121;
+                            if (t === Mt) return 32819;
+                            if (t === bt) return 32820;
+                            if (t === mt) return 5120;
+                            if (t === ft) return 5122;
+                            if (t === gt) return 5123;
+                            if (t === vt) return 5124;
+                            if (t === xt) return 5125;
+                            if (t === yt) return 5126;
+                            if (t === _t) return i ? 5131 : (r = e.get("OES_texture_half_float"), null !== r ? r.HALF_FLOAT_OES : null);
+                            if (t === St) return 6406;
+                            if (t === Et) return 6408;
+                            if (t === Tt) return 6409;
+                            if (t === At) return 6410;
+                            if (t === Rt) return 6402;
+                            if (t === Lt) return 34041;
+                            if (t === Ct) return 6403;
+                            if (t === be) return r = e.get("EXT_sRGB"), null !== r ? r.SRGB_ALPHA_EXT : null;
+                            if (t === Pt) return 36244;
+                            if (t === Dt) return 33319;
+                            if (t === It) return 33320;
+                            if (t === Nt) return 36249;
+                            if (t === Ot || t === Ut || t === Bt || t === Ft)
+                                if (n === me) {
                                     if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === r) return null;
-                                    if (t === b) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
-                                    if (t === w) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
-                                    if (t === S) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
-                                    if (t === E) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
+                                    if (t === Ot) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
+                                    if (t === Ut) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
+                                    if (t === Bt) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
+                                    if (t === Ft) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                 } else {
                                     if (r = e.get("WEBGL_compressed_texture_s3tc"), null === r) return null;
-                                    if (t === b) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
-                                    if (t === w) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
-                                    if (t === S) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
-                                    if (t === E) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
-                                } if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
+                                    if (t === Ot) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
+                                    if (t === Ut) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
+                                    if (t === Bt) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
+                                    if (t === Ft) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
+                                } if (t === zt || t === Ht || t === Gt || t === Vt) {
                                 if (r = e.get("WEBGL_compressed_texture_pvrtc"), null === r) return null;
-                                if (35840 === t) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
-                                if (35841 === t) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
-                                if (35842 === t) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
-                                if (35843 === t) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
+                                if (t === zt) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
+                                if (t === Ht) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
+                                if (t === Gt) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
+                                if (t === Vt) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                             }
-                            if (36196 === t) return r = e.get("WEBGL_compressed_texture_etc1"), null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
-                            if (37492 === t || 37496 === t) {
+                            if (t === kt) return r = e.get("WEBGL_compressed_texture_etc1"), null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
+                            if (t === Wt || t === jt) {
                                 if (r = e.get("WEBGL_compressed_texture_etc"), null === r) return null;
-                                if (37492 === t) return n === I ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
-                                if (37496 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
+                                if (t === Wt) return n === me ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
+                                if (t === jt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                             }
-                            if (37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) {
+                            if (t === Xt || t === qt || t === Yt || t === Jt || t === Zt || t === Kt || t === Qt || t === $t || t === te || t === ee || t === ne || t === ie || t === re || t === se) {
                                 if (r = e.get("WEBGL_compressed_texture_astc"), null === r) return null;
-                                if (37808 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
-                                if (37809 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
-                                if (37810 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
-                                if (37811 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
-                                if (37812 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
-                                if (37813 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
-                                if (37814 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
-                                if (37815 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
-                                if (37816 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
-                                if (37817 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
-                                if (37818 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
-                                if (37819 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
-                                if (37820 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
-                                if (37821 === t) return n === I ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
+                                if (t === Xt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
+                                if (t === qt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
+                                if (t === Yt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
+                                if (t === Jt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
+                                if (t === Zt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
+                                if (t === Kt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
+                                if (t === Qt) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
+                                if (t === $t) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
+                                if (t === te) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
+                                if (t === ee) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
+                                if (t === ne) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
+                                if (t === ie) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
+                                if (t === re) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
+                                if (t === se) return n === me ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                             }
-                            if (36492 === t) {
+                            if (t === ae) {
                                 if (r = e.get("EXT_texture_compression_bptc"), null === r) return null;
-                                if (36492 === t) return n === I ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT
+                                if (t === ae) return n === me ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT
                             }
-                            return t === x ? i ? 34042 : (r = e.get("WEBGL_depth_texture"), null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0
+                            return t === wt ? i ? 34042 : (r = e.get("WEBGL_depth_texture"), null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                         }
                     }
                 }
-                is.prototype.isMeshDistanceMaterial = !0;
-                class ls extends vn {
+                class Za extends er {
                     constructor(t = []) {
                         super(), this.cameras = t
                     }
                 }
-                ls.prototype.isArrayCamera = !0;
-                class cs extends ge {
+                Za.prototype.isArrayCamera = !0;
+                class Ka extends ei {
                     constructor() {
                         super(), this.type = "Group"
                     }
                 }
-                cs.prototype.isGroup = !0;
-                const hs = {
+                Ka.prototype.isGroup = !0;
+                const Qa = {
                     type: "move"
                 };
-                class us {
+                class $a {
                     constructor() {
                         this._targetRay = null, this._grip = null, this._hand = null
                     }
                     getHandSpace() {
-                        return null === this._hand && (this._hand = new cs, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
+                        return null === this._hand && (this._hand = new Ka, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                             pinching: !1
                         }), this._hand
                     }
                     getTargetRaySpace() {
-                        return null === this._targetRay && (this._targetRay = new cs, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new mt, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new mt), this._targetRay
+                        return null === this._targetRay && (this._targetRay = new Ka, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Qe, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Qe), this._targetRay
                     }
                     getGripSpace() {
-                        return null === this._grip && (this._grip = new cs, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new mt, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new mt), this._grip
+                        return null === this._grip && (this._grip = new Ka, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Qe, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Qe), this._grip
                     }
                     dispatchEvent(t) {
                         return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                     }
                     disconnect(t) {
                         return this.dispatchEvent({
                             type: "disconnected",
@@ -24881,20 +25271,20 @@
                         let i = null,
                             r = null,
                             s = null;
                         const a = this._targetRay,
                             o = this._grip,
                             l = this._hand;
                         if (t && "visible-blurred" !== e.session.visibilityState)
-                            if (null !== a && (i = e.getPose(t.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(hs))), l && t.hand) {
+                            if (null !== a && (i = e.getPose(t.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Qa))), l && t.hand) {
                                 s = !0;
                                 for (const i of t.hand.values()) {
                                     const t = e.getJointPose(i, n);
                                     if (void 0 === l.joints[i.jointName]) {
-                                        const t = new cs;
+                                        const t = new Ka;
                                         t.matrixAutoUpdate = !1, t.visible = !1, l.joints[i.jointName] = t, l.add(t)
                                     }
                                     const r = l.joints[i.jointName];
                                     null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
                                 }
                                 const i = l.joints["index-finger-tip"],
                                     r = l.joints["thumb-tip"],
@@ -24910,187 +25300,187 @@
                                     handedness: t.handedness,
                                     target: this
                                 }))
                             } else null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                         return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
                     }
                 }
-                class ds extends lt {
+                class to extends Xe {
                     constructor(t, e, n, i, r, s, a, o, l, c) {
-                        if ((c = void 0 !== c ? c : _) !== _ && c !== M) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
-                        void 0 === n && c === _ && (n = m), void 0 === n && c === M && (n = x), super(null, i, r, s, a, o, c, n, l), this.image = {
+                        if ((c = void 0 !== c ? c : Rt) !== Rt && c !== Lt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
+                        void 0 === n && c === Rt && (n = gt), void 0 === n && c === Lt && (n = wt), super(null, i, r, s, a, o, c, n, l), this.image = {
                             width: t,
                             height: e
-                        }, this.magFilter = void 0 !== a ? a : h, this.minFilter = void 0 !== o ? o : h, this.flipY = !1, this.generateMipmaps = !1
+                        }, this.magFilter = void 0 !== a ? a : ot, this.minFilter = void 0 !== o ? o : ot, this.flipY = !1, this.generateMipmaps = !1
                     }
                 }
-                ds.prototype.isDepthTexture = !0;
-                class ps extends z {
+                to.prototype.isDepthTexture = !0;
+                class eo extends we {
                     constructor(t, e) {
                         super();
                         const n = this;
                         let i = null,
                             r = 1,
                             s = null,
                             a = "local-floor";
                         const o = t.extensions.has("WEBGL_multisampled_render_to_texture");
                         let l = null,
                             c = null,
                             h = null,
                             u = null,
                             d = !1,
-                            f = null;
-                        const g = e.getContextAttributes();
-                        let v = null,
-                            b = null;
-                        const w = [],
-                            S = new Map,
-                            E = new vn;
-                        E.layers.enable(1), E.viewport = new ht;
-                        const T = new vn;
-                        T.layers.enable(2), T.viewport = new ht;
-                        const A = [E, T],
-                            R = new ls;
-                        R.layers.enable(1), R.layers.enable(2);
-                        let L = null,
-                            C = null;
+                            p = null;
+                        const m = e.getContextAttributes();
+                        let f = null,
+                            g = null;
+                        const v = [],
+                            x = new Map,
+                            y = new er;
+                        y.layers.enable(1), y.viewport = new Ye;
+                        const _ = new er;
+                        _.layers.enable(2), _.viewport = new Ye;
+                        const M = [y, _],
+                            b = new Za;
+                        b.layers.enable(1), b.layers.enable(2);
+                        let w = null,
+                            S = null;
 
-                        function P(t) {
-                            const e = S.get(t.inputSource);
+                        function E(t) {
+                            const e = x.get(t.inputSource);
                             e && e.dispatchEvent({
                                 type: t.type,
                                 data: t.inputSource
                             })
                         }
 
-                        function D() {
-                            S.forEach((function(t, e) {
+                        function T() {
+                            x.forEach((function(t, e) {
                                 t.disconnect(e)
-                            })), S.clear(), L = null, C = null, t.setRenderTarget(v), u = null, h = null, c = null, i = null, b = null, z.stop(), n.isPresenting = !1, n.dispatchEvent({
+                            })), x.clear(), w = null, S = null, t.setRenderTarget(f), u = null, h = null, c = null, i = null, g = null, D.stop(), n.isPresenting = !1, n.dispatchEvent({
                                 type: "sessionend"
                             })
                         }
 
-                        function N(t) {
+                        function A(t) {
                             const e = i.inputSources;
-                            for (let t = 0; t < w.length; t++) S.set(e[t], w[t]);
+                            for (let t = 0; t < v.length; t++) x.set(e[t], v[t]);
                             for (let e = 0; e < t.removed.length; e++) {
                                 const n = t.removed[e],
-                                    i = S.get(n);
+                                    i = x.get(n);
                                 i && (i.dispatchEvent({
                                     type: "disconnected",
                                     data: n
-                                }), S.delete(n))
+                                }), x.delete(n))
                             }
                             for (let e = 0; e < t.added.length; e++) {
                                 const n = t.added[e],
-                                    i = S.get(n);
+                                    i = x.get(n);
                                 i && i.dispatchEvent({
                                     type: "connected",
                                     data: n
                                 })
                             }
                         }
                         this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
-                            let e = w[t];
-                            return void 0 === e && (e = new us, w[t] = e), e.getTargetRaySpace()
+                            let e = v[t];
+                            return void 0 === e && (e = new $a, v[t] = e), e.getTargetRaySpace()
                         }, this.getControllerGrip = function(t) {
-                            let e = w[t];
-                            return void 0 === e && (e = new us, w[t] = e), e.getGripSpace()
+                            let e = v[t];
+                            return void 0 === e && (e = new $a, v[t] = e), e.getGripSpace()
                         }, this.getHand = function(t) {
-                            let e = w[t];
-                            return void 0 === e && (e = new us, w[t] = e), e.getHandSpace()
+                            let e = v[t];
+                            return void 0 === e && (e = new $a, v[t] = e), e.getHandSpace()
                         }, this.setFramebufferScaleFactor = function(t) {
                             r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                         }, this.setReferenceSpaceType = function(t) {
                             a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                         }, this.getReferenceSpace = function() {
                             return s
                         }, this.getBaseLayer = function() {
                             return null !== h ? h : u
                         }, this.getBinding = function() {
                             return c
                         }, this.getFrame = function() {
-                            return f
+                            return p
                         }, this.getSession = function() {
                             return i
                         }, this.setSession = async function(l) {
                             if (i = l, null !== i) {
-                                if (v = t.getRenderTarget(), i.addEventListener("select", P), i.addEventListener("selectstart", P), i.addEventListener("selectend", P), i.addEventListener("squeeze", P), i.addEventListener("squeezestart", P), i.addEventListener("squeezeend", P), i.addEventListener("end", D), i.addEventListener("inputsourceschange", N), !0 !== g.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
+                                if (f = t.getRenderTarget(), i.addEventListener("select", E), i.addEventListener("selectstart", E), i.addEventListener("selectend", E), i.addEventListener("squeeze", E), i.addEventListener("squeezestart", E), i.addEventListener("squeezeend", E), i.addEventListener("end", T), i.addEventListener("inputsourceschange", A), !0 !== m.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                                     const n = {
-                                        antialias: void 0 !== i.renderState.layers || g.antialias,
-                                        alpha: g.alpha,
-                                        depth: g.depth,
-                                        stencil: g.stencil,
+                                        antialias: void 0 !== i.renderState.layers || m.antialias,
+                                        alpha: m.alpha,
+                                        depth: m.depth,
+                                        stencil: m.stencil,
                                         framebufferScaleFactor: r
                                     };
                                     u = new XRWebGLLayer(i, e, n), i.updateRenderState({
                                         baseLayer: u
-                                    }), b = new ut(u.framebufferWidth, u.framebufferHeight, {
-                                        format: y,
-                                        type: p,
+                                    }), g = new Je(u.framebufferWidth, u.framebufferHeight, {
+                                        format: Et,
+                                        type: pt,
                                         encoding: t.outputEncoding
                                     })
                                 } else {
-                                    d = g.antialias;
+                                    d = m.antialias;
                                     let n = null,
                                         s = null,
                                         a = null;
-                                    g.depth && (a = g.stencil ? 35056 : 33190, n = g.stencil ? M : _, s = g.stencil ? x : m);
+                                    m.depth && (a = m.stencil ? 35056 : 33190, n = m.stencil ? Lt : Rt, s = m.stencil ? wt : gt);
                                     const l = {
-                                        colorFormat: t.outputEncoding === I ? 35907 : 32856,
+                                        colorFormat: t.outputEncoding === me ? 35907 : 32856,
                                         depthFormat: a,
                                         scaleFactor: r
                                     };
                                     c = new XRWebGLBinding(i, e), h = c.createProjectionLayer(l), i.updateRenderState({
                                         layers: [h]
-                                    }), b = d ? new dt(h.textureWidth, h.textureHeight, {
-                                        format: y,
-                                        type: p,
-                                        depthTexture: new ds(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
-                                        stencilBuffer: g.stencil,
+                                    }), g = d ? new Ze(h.textureWidth, h.textureHeight, {
+                                        format: Et,
+                                        type: pt,
+                                        depthTexture: new to(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
+                                        stencilBuffer: m.stencil,
                                         ignoreDepth: h.ignoreDepthValues,
                                         useRenderToTexture: o,
                                         encoding: t.outputEncoding
-                                    }) : new ut(h.textureWidth, h.textureHeight, {
-                                        format: y,
-                                        type: p,
-                                        depthTexture: new ds(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
-                                        stencilBuffer: g.stencil,
+                                    }) : new Je(h.textureWidth, h.textureHeight, {
+                                        format: Et,
+                                        type: pt,
+                                        depthTexture: new to(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
+                                        stencilBuffer: m.stencil,
                                         ignoreDepth: h.ignoreDepthValues,
                                         encoding: t.outputEncoding
                                     })
                                 }
-                                b.isXRRenderTarget = !0, this.setFoveation(1), s = await i.requestReferenceSpace(a), z.setContext(i), z.start(), n.isPresenting = !0, n.dispatchEvent({
+                                g.isXRRenderTarget = !0, this.setFoveation(1), s = await i.requestReferenceSpace(a), D.setContext(i), D.start(), n.isPresenting = !0, n.dispatchEvent({
                                     type: "sessionstart"
                                 })
                             }
                         };
-                        const O = new mt,
-                            U = new mt;
+                        const R = new Qe,
+                            L = new Qe;
 
-                        function B(t, e) {
+                        function C(t, e) {
                             null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                         }
                         this.updateCamera = function(t) {
                             if (null === i) return;
-                            R.near = T.near = E.near = t.near, R.far = T.far = E.far = t.far, L === R.near && C === R.far || (i.updateRenderState({
-                                depthNear: R.near,
-                                depthFar: R.far
-                            }), L = R.near, C = R.far);
+                            b.near = _.near = y.near = t.near, b.far = _.far = y.far = t.far, w === b.near && S === b.far || (i.updateRenderState({
+                                depthNear: b.near,
+                                depthFar: b.far
+                            }), w = b.near, S = b.far);
                             const e = t.parent,
-                                n = R.cameras;
-                            B(R, e);
-                            for (let t = 0; t < n.length; t++) B(n[t], e);
-                            R.matrixWorld.decompose(R.position, R.quaternion, R.scale), t.position.copy(R.position), t.quaternion.copy(R.quaternion), t.scale.copy(R.scale), t.matrix.copy(R.matrix), t.matrixWorld.copy(R.matrixWorld);
+                                n = b.cameras;
+                            C(b, e);
+                            for (let t = 0; t < n.length; t++) C(n[t], e);
+                            b.matrixWorld.decompose(b.position, b.quaternion, b.scale), t.position.copy(b.position), t.quaternion.copy(b.quaternion), t.scale.copy(b.scale), t.matrix.copy(b.matrix), t.matrixWorld.copy(b.matrixWorld);
                             const r = t.children;
                             for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
                             2 === n.length ? function(t, e, n) {
-                                O.setFromMatrixPosition(e.matrixWorld), U.setFromMatrixPosition(n.matrixWorld);
-                                const i = O.distanceTo(U),
+                                R.setFromMatrixPosition(e.matrixWorld), L.setFromMatrixPosition(n.matrixWorld);
+                                const i = R.distanceTo(L),
                                     r = e.projectionMatrix.elements,
                                     s = n.projectionMatrix.elements,
                                     a = r[14] / (r[10] - 1),
                                     o = r[14] / (r[10] + 1),
                                     l = (r[9] + 1) / r[5],
                                     c = (r[9] - 1) / r[5],
                                     h = (r[8] - 1) / r[0],
@@ -25103,87 +25493,87 @@
                                 const g = a + m,
                                     v = o + m,
                                     x = d - f,
                                     y = p + (i - f),
                                     _ = l * o / v * g,
                                     M = c * o / v * g;
                                 t.projectionMatrix.makePerspective(x, y, _, M, g, v)
-                            }(R, E, T) : R.projectionMatrix.copy(E.projectionMatrix)
+                            }(b, y, _) : b.projectionMatrix.copy(y.projectionMatrix)
                         }, this.getCamera = function() {
-                            return R
+                            return b
                         }, this.getFoveation = function() {
                             return null !== h ? h.fixedFoveation : null !== u ? u.fixedFoveation : void 0
                         }, this.setFoveation = function(t) {
                             null !== h && (h.fixedFoveation = t), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = t)
                         };
-                        let F = null;
-                        const z = new Ln;
-                        z.setAnimationLoop((function(e, n) {
-                            if (l = n.getViewerPose(s), f = n, null !== l) {
+                        let P = null;
+                        const D = new pr;
+                        D.setAnimationLoop((function(e, n) {
+                            if (l = n.getViewerPose(s), p = n, null !== l) {
                                 const e = l.views;
-                                null !== u && (t.setRenderTargetFramebuffer(b, u.framebuffer), t.setRenderTarget(b));
+                                null !== u && (t.setRenderTargetFramebuffer(g, u.framebuffer), t.setRenderTarget(g));
                                 let n = !1;
-                                e.length !== R.cameras.length && (R.cameras.length = 0, n = !0);
+                                e.length !== b.cameras.length && (b.cameras.length = 0, n = !0);
                                 for (let i = 0; i < e.length; i++) {
                                     const r = e[i];
                                     let s = null;
                                     if (null !== u) s = u.getViewport(r);
                                     else {
                                         const e = c.getViewSubImage(h, r);
-                                        s = e.viewport, 0 === i && (t.setRenderTargetTextures(b, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(b))
+                                        s = e.viewport, 0 === i && (t.setRenderTargetTextures(g, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(g))
                                     }
-                                    const a = A[i];
-                                    a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && R.matrix.copy(a.matrix), !0 === n && R.cameras.push(a)
+                                    const a = M[i];
+                                    a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && b.matrix.copy(a.matrix), !0 === n && b.cameras.push(a)
                                 }
                             }
                             const r = i.inputSources;
-                            for (let t = 0; t < w.length; t++) {
-                                const e = w[t],
+                            for (let t = 0; t < v.length; t++) {
+                                const e = v[t],
                                     i = r[t];
                                 e.update(i, n, s)
                             }
-                            F && F(e, n), f = null
+                            P && P(e, n), p = null
                         })), this.setAnimationLoop = function(t) {
-                            F = t
+                            P = t
                         }, this.dispose = function() {}
                     }
                 }
 
-                function ms(t) {
+                function no(t) {
                     function e(e, n) {
                         e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
                         const i = t.get(n).envMap;
                         let r, s;
                         i && (e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.ior.value = n.ior, e.refractionRatio.value = n.refractionRatio), n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
                     }
 
                     function n(e, n) {
-                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
+                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === u && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === u && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
                     }
                     return {
                         refreshFogUniforms: function(t, e) {
                             t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                         },
                         refreshMaterialUniforms: function(t, i, r, s, a) {
                             i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) {
                                 e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                             }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) {
-                                e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === u && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === u && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) {
-                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === u && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === u && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function(t, e, i) {
-                                n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
+                                n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === u && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                             }(t, i, a) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) {
-                                e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === u && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === u && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) {
                                 e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) {
                                 e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                             }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) {
-                                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
+                                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === u && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === u && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                             }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                             }(t, i), i.isLineDashedMaterial && function(t, e) {
                                 t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                             }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                                 let r;
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
@@ -25191,559 +25581,559 @@
                                 let n;
                                 t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                             }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                         }
                     }
                 }
 
-                function fs(t = {}) {
+                function io(t = {}) {
                     const e = void 0 !== t.canvas ? t.canvas : function() {
-                            const t = K("canvas");
+                            const t = Oe("canvas");
                             return t.style.display = "block", t
                         }(),
                         n = void 0 !== t.context ? t.context : null,
-                        i = void 0 !== t.alpha && t.alpha,
-                        r = void 0 === t.depth || t.depth,
-                        s = void 0 === t.stencil || t.stencil,
-                        a = void 0 !== t.antialias && t.antialias,
-                        o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
+                        r = void 0 !== t.alpha && t.alpha,
+                        s = void 0 === t.depth || t.depth,
+                        a = void 0 === t.stencil || t.stencil,
+                        o = void 0 !== t.antialias && t.antialias,
+                        l = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                         c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
-                        u = void 0 !== t.powerPreference ? t.powerPreference : "default",
+                        p = void 0 !== t.powerPreference ? t.powerPreference : "default",
                         m = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                     let f = null,
-                        x = null;
-                    const _ = [],
-                        M = [];
+                        g = null;
+                    const v = [],
+                        x = [];
                     this.domElement = e, this.debug = {
                         checkShaderErrors: !0
-                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = D, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
-                    const b = this;
-                    let w = !1,
-                        S = 0,
-                        E = 0,
-                        T = null,
-                        A = -1,
-                        R = null;
-                    const L = new ht,
-                        C = new ht;
-                    let P = null,
-                        I = e.width,
-                        N = e.height,
-                        O = 1,
-                        U = null,
-                        B = null;
-                    const F = new ht(0, 0, I, N),
-                        z = new ht(0, 0, I, N);
-                    let H = !1;
-                    const G = new Rn;
-                    let V = !1,
-                        k = !1,
-                        W = null;
-                    const j = new jt,
-                        X = new mt,
-                        q = {
+                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = pe, this.physicallyCorrectLights = !1, this.toneMapping = X, this.toneMappingExposure = 1;
+                    const y = this;
+                    let _ = !1,
+                        M = 0,
+                        b = 0,
+                        w = null,
+                        S = -1,
+                        E = null;
+                    const T = new Ye,
+                        A = new Ye;
+                    let R = null,
+                        L = e.width,
+                        C = e.height,
+                        P = 1,
+                        D = null,
+                        I = null;
+                    const N = new Ye(0, 0, L, C),
+                        O = new Ye(0, 0, L, C);
+                    let U = !1;
+                    const B = new dr;
+                    let F = !1,
+                        z = !1,
+                        H = null;
+                    const G = new Cn,
+                        V = new Qe,
+                        k = {
                             background: null,
                             fog: null,
                             environment: null,
                             overrideMaterial: null,
                             isScene: !0
                         };
 
-                    function Y() {
-                        return null === T ? O : 1
+                    function W() {
+                        return null === w ? P : 1
                     }
-                    let J, Z, Q, $, tt, et, nt, it, rt, st, at, ot, lt, ct, pt, ft, gt, vt, xt, yt, _t, Mt, bt, wt = n;
+                    let j, q, Y, J, Z, K, Q, $, tt, et, nt, it, rt, at, lt, ct, ht, ut, mt, ft, gt, vt, xt, Mt = n;
 
-                    function St(t, n) {
+                    function bt(t, n) {
                         for (let i = 0; i < t.length; i++) {
                             const r = t[i],
                                 s = e.getContext(r, n);
                             if (null !== s) return s
                         }
                         return null
                     }
                     try {
                         const t = {
                             alpha: !0,
-                            depth: r,
-                            stencil: s,
-                            antialias: a,
-                            premultipliedAlpha: o,
+                            depth: s,
+                            stencil: a,
+                            antialias: o,
+                            premultipliedAlpha: l,
                             preserveDrawingBuffer: c,
-                            powerPreference: u,
+                            powerPreference: p,
                             failIfMajorPerformanceCaveat: m
                         };
-                        if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r137"), e.addEventListener("webglcontextlost", At, !1), e.addEventListener("webglcontextrestored", Rt, !1), null === wt) {
+                        if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${i}`), e.addEventListener("webglcontextlost", Tt, !1), e.addEventListener("webglcontextrestored", At, !1), null === Mt) {
                             const e = ["webgl2", "webgl", "experimental-webgl"];
-                            if (!0 === b.isWebGL1Renderer && e.shift(), wt = St(e, t), null === wt) throw St(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
+                            if (!0 === y.isWebGL1Renderer && e.shift(), Mt = bt(e, t), null === Mt) throw bt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                         }
-                        void 0 === wt.getShaderPrecisionFormat && (wt.getShaderPrecisionFormat = function() {
+                        void 0 === Mt.getShaderPrecisionFormat && (Mt.getShaderPrecisionFormat = function() {
                             return {
                                 rangeMin: 1,
                                 rangeMax: 1,
                                 precision: 1
                             }
                         })
                     } catch (t) {
                         throw console.error("THREE.WebGLRenderer: " + t.message), t
                     }
 
-                    function Et() {
-                        J = new li(wt), Z = new Fn(wt, J, t), J.init(Z), Mt = new os(wt, J, Z), Q = new ss(wt, J, Z), $ = new ui(wt), tt = new jr, et = new as(wt, J, Q, tt, Z, Mt, $), nt = new Hn(b), it = new oi(b), rt = new Cn(wt, Z), bt = new Un(wt, J, rt, Z), st = new ci(wt, rt, $, bt), at = new vi(wt, st, rt, $), xt = new gi(wt, Z, et), ft = new zn(tt), ot = new Wr(b, nt, it, J, Z, bt, ft), lt = new ms(tt), ct = new Jr, pt = new es(J, Z), vt = new On(b, nt, Q, at, i, o), gt = new rs(b, at, Z), yt = new Bn(wt, J, $, Z), _t = new hi(wt, J, $, Z), $.programs = ot.programs, b.capabilities = Z, b.extensions = J, b.properties = tt, b.renderLists = ct, b.shadowMap = gt, b.state = Q, b.info = $
+                    function wt() {
+                        j = new Yr(Mt), q = new br(Mt, j, t), j.init(q), vt = new Ja(Mt, j, q), Y = new qa(Mt, j, q), J = new Kr(Mt), Z = new Pa, K = new Ya(Mt, j, Y, Z, q, vt, J), Q = new Sr(y), $ = new qr(y), tt = new mr(Mt, q), xt = new _r(Mt, j, tt, q), et = new Jr(Mt, tt, J, xt), nt = new is(Mt, et, tt, J), mt = new ns(Mt, q, K), ct = new wr(Z), it = new Ca(y, Q, $, j, q, xt, ct), rt = new no(Z), at = new Oa, lt = new Ga(j, q), ut = new yr(y, Q, Y, nt, r, l), ht = new Xa(y, nt, q), ft = new Mr(Mt, j, J, q), gt = new Zr(Mt, j, J, q), J.programs = it.programs, y.capabilities = q, y.extensions = j, y.properties = Z, y.renderLists = at, y.shadowMap = ht, y.state = Y, y.info = J
                     }
-                    Et();
-                    const Tt = new ps(b, wt);
+                    wt();
+                    const St = new eo(y, Mt);
 
-                    function At(t) {
-                        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), w = !0
+                    function Tt(t) {
+                        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0
                     }
 
-                    function Rt() {
-                        console.log("THREE.WebGLRenderer: Context Restored."), w = !1;
-                        const t = $.autoReset,
-                            e = gt.enabled,
-                            n = gt.autoUpdate,
-                            i = gt.needsUpdate,
-                            r = gt.type;
-                        Et(), $.autoReset = t, gt.enabled = e, gt.autoUpdate = n, gt.needsUpdate = i, gt.type = r
+                    function At() {
+                        console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
+                        const t = J.autoReset,
+                            e = ht.enabled,
+                            n = ht.autoUpdate,
+                            i = ht.needsUpdate,
+                            r = ht.type;
+                        wt(), J.autoReset = t, ht.enabled = e, ht.autoUpdate = n, ht.needsUpdate = i, ht.type = r
                     }
 
-                    function Lt(t) {
+                    function Rt(t) {
                         const e = t.target;
-                        e.removeEventListener("dispose", Lt),
+                        e.removeEventListener("dispose", Rt),
                             function(t) {
                                 (function(t) {
-                                    const e = tt.get(t).programs;
+                                    const e = Z.get(t).programs;
                                     void 0 !== e && (e.forEach((function(t) {
-                                        ot.releaseProgram(t)
-                                    })), t.isShaderMaterial && ot.releaseShaderCache(t))
-                                })(t), tt.remove(t)
+                                        it.releaseProgram(t)
+                                    })), t.isShaderMaterial && it.releaseShaderCache(t))
+                                })(t), Z.remove(t)
                             }(e)
                     }
-                    this.xr = Tt, this.getContext = function() {
-                        return wt
+                    this.xr = St, this.getContext = function() {
+                        return Mt
                     }, this.getContextAttributes = function() {
-                        return wt.getContextAttributes()
+                        return Mt.getContextAttributes()
                     }, this.forceContextLoss = function() {
-                        const t = J.get("WEBGL_lose_context");
+                        const t = j.get("WEBGL_lose_context");
                         t && t.loseContext()
                     }, this.forceContextRestore = function() {
-                        const t = J.get("WEBGL_lose_context");
+                        const t = j.get("WEBGL_lose_context");
                         t && t.restoreContext()
                     }, this.getPixelRatio = function() {
-                        return O
+                        return P
                     }, this.setPixelRatio = function(t) {
-                        void 0 !== t && (O = t, this.setSize(I, N, !1))
+                        void 0 !== t && (P = t, this.setSize(L, C, !1))
                     }, this.getSize = function(t) {
-                        return t.set(I, N)
+                        return t.set(L, C)
                     }, this.setSize = function(t, n, i) {
-                        Tt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I = t, N = n, e.width = Math.floor(t * O), e.height = Math.floor(n * O), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
+                        St.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (L = t, C = n, e.width = Math.floor(t * P), e.height = Math.floor(n * P), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                     }, this.getDrawingBufferSize = function(t) {
-                        return t.set(I * O, N * O).floor()
+                        return t.set(L * P, C * P).floor()
                     }, this.setDrawingBufferSize = function(t, n, i) {
-                        I = t, N = n, O = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
+                        L = t, C = n, P = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
                     }, this.getCurrentViewport = function(t) {
-                        return t.copy(L)
+                        return t.copy(T)
                     }, this.getViewport = function(t) {
-                        return t.copy(F)
+                        return t.copy(N)
                     }, this.setViewport = function(t, e, n, i) {
-                        t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i), Q.viewport(L.copy(F).multiplyScalar(O).floor())
+                        t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i), Y.viewport(T.copy(N).multiplyScalar(P).floor())
                     }, this.getScissor = function(t) {
-                        return t.copy(z)
+                        return t.copy(O)
                     }, this.setScissor = function(t, e, n, i) {
-                        t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, n, i), Q.scissor(C.copy(z).multiplyScalar(O).floor())
+                        t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i), Y.scissor(A.copy(O).multiplyScalar(P).floor())
                     }, this.getScissorTest = function() {
-                        return H
+                        return U
                     }, this.setScissorTest = function(t) {
-                        Q.setScissorTest(H = t)
+                        Y.setScissorTest(U = t)
                     }, this.setOpaqueSort = function(t) {
-                        U = t
+                        D = t
                     }, this.setTransparentSort = function(t) {
-                        B = t
+                        I = t
                     }, this.getClearColor = function(t) {
-                        return t.copy(vt.getClearColor())
+                        return t.copy(ut.getClearColor())
                     }, this.setClearColor = function() {
-                        vt.setClearColor.apply(vt, arguments)
+                        ut.setClearColor.apply(ut, arguments)
                     }, this.getClearAlpha = function() {
-                        return vt.getClearAlpha()
+                        return ut.getClearAlpha()
                     }, this.setClearAlpha = function() {
-                        vt.setClearAlpha.apply(vt, arguments)
+                        ut.setClearAlpha.apply(ut, arguments)
                     }, this.clear = function(t, e, n) {
                         let i = 0;
-                        (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), wt.clear(i)
+                        (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), Mt.clear(i)
                     }, this.clearColor = function() {
                         this.clear(!0, !1, !1)
                     }, this.clearDepth = function() {
                         this.clear(!1, !0, !1)
                     }, this.clearStencil = function() {
                         this.clear(!1, !1, !0)
                     }, this.dispose = function() {
-                        e.removeEventListener("webglcontextlost", At, !1), e.removeEventListener("webglcontextrestored", Rt, !1), ct.dispose(), pt.dispose(), tt.dispose(), nt.dispose(), it.dispose(), at.dispose(), bt.dispose(), ot.dispose(), Tt.dispose(), Tt.removeEventListener("sessionstart", Pt), Tt.removeEventListener("sessionend", Dt), W && (W.dispose(), W = null), It.stop()
+                        e.removeEventListener("webglcontextlost", Tt, !1), e.removeEventListener("webglcontextrestored", At, !1), at.dispose(), lt.dispose(), Z.dispose(), Q.dispose(), $.dispose(), nt.dispose(), xt.dispose(), it.dispose(), St.dispose(), St.removeEventListener("sessionstart", Ct), St.removeEventListener("sessionend", Pt), H && (H.dispose(), H = null), Dt.stop()
                     }, this.renderBufferDirect = function(t, e, n, i, r, s) {
-                        null === e && (e = q);
+                        null === e && (e = k);
                         const a = r.isMesh && r.matrixWorld.determinant() < 0,
                             o = function(t, e, n, i, r) {
-                                !0 !== e.isScene && (e = q), et.resetTextureUnits();
+                                !0 !== e.isScene && (e = k), K.resetTextureUnits();
                                 const s = e.fog,
                                     a = i.isMeshStandardMaterial ? e.environment : null,
-                                    o = null === T ? b.outputEncoding : !0 === T.isXRRenderTarget ? T.texture.encoding : D,
-                                    l = (i.isMeshStandardMaterial ? it : nt).get(i.envMap || a),
+                                    o = null === w ? y.outputEncoding : !0 === w.isXRRenderTarget ? w.texture.encoding : pe,
+                                    l = (i.isMeshStandardMaterial ? $ : Q).get(i.envMap || a),
                                     c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                     h = !!i.normalMap && !!n.attributes.tangent,
                                     u = !!n.morphAttributes.position,
                                     d = !!n.morphAttributes.normal,
                                     p = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
-                                    m = i.toneMapped ? b.toneMapping : 0,
-                                    f = tt.get(i),
-                                    g = x.state.lights;
-                                if (!0 === V && (!0 === k || t !== R)) {
-                                    const e = t === R && i.id === A;
-                                    ft.setState(i, t, e)
-                                }
-                                let v = !1;
-                                i.version === f.__version ? f.needsLights && f.lightsStateVersion !== g.state.version || f.outputEncoding !== o || r.isInstancedMesh && !1 === f.instancing ? v = !0 : r.isInstancedMesh || !0 !== f.instancing ? r.isSkinnedMesh && !1 === f.skinning ? v = !0 : r.isSkinnedMesh || !0 !== f.skinning ? f.envMap !== l || i.fog && f.fog !== s ? v = !0 : void 0 === f.numClippingPlanes || f.numClippingPlanes === ft.numPlanes && f.numIntersection === ft.numIntersection ? (f.vertexAlphas !== c || f.vertexTangents !== h || f.morphTargets !== u || f.morphNormals !== d || f.toneMapping !== m || !0 === Z.isWebGL2 && f.morphTargetsCount !== p) && (v = !0) : v = !0 : v = !0 : v = !0 : (v = !0, f.__version = i.version);
-                                let y = f.currentProgram;
-                                !0 === v && (y = Ft(i, e, r));
-                                let _ = !1,
-                                    M = !1,
-                                    w = !1;
-                                const S = y.getUniforms(),
-                                    E = f.uniforms;
-                                if (Q.useProgram(y.program) && (_ = !0, M = !0, w = !0), i.id !== A && (A = i.id, M = !0), _ || R !== t) {
-                                    if (S.setValue(wt, "projectionMatrix", t.projectionMatrix), Z.logarithmicDepthBuffer && S.setValue(wt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), R !== t && (R = t, M = !0, w = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
-                                        const e = S.map.cameraPosition;
-                                        void 0 !== e && e.setValue(wt, X.setFromMatrixPosition(t.matrixWorld))
-                                    }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && S.setValue(wt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && S.setValue(wt, "viewMatrix", t.matrixWorldInverse)
+                                    m = i.toneMapped ? y.toneMapping : X,
+                                    f = Z.get(i),
+                                    v = g.state.lights;
+                                if (!0 === F && (!0 === z || t !== E)) {
+                                    const e = t === E && i.id === S;
+                                    ct.setState(i, t, e)
+                                }
+                                let x = !1;
+                                i.version === f.__version ? f.needsLights && f.lightsStateVersion !== v.state.version || f.outputEncoding !== o || r.isInstancedMesh && !1 === f.instancing ? x = !0 : r.isInstancedMesh || !0 !== f.instancing ? r.isSkinnedMesh && !1 === f.skinning ? x = !0 : r.isSkinnedMesh || !0 !== f.skinning ? f.envMap !== l || i.fog && f.fog !== s ? x = !0 : void 0 === f.numClippingPlanes || f.numClippingPlanes === ct.numPlanes && f.numIntersection === ct.numIntersection ? (f.vertexAlphas !== c || f.vertexTangents !== h || f.morphTargets !== u || f.morphNormals !== d || f.toneMapping !== m || !0 === q.isWebGL2 && f.morphTargetsCount !== p) && (x = !0) : x = !0 : x = !0 : x = !0 : (x = !0, f.__version = i.version);
+                                let _ = f.currentProgram;
+                                !0 === x && (_ = Bt(i, e, r));
+                                let M = !1,
+                                    b = !1,
+                                    T = !1;
+                                const A = _.getUniforms(),
+                                    R = f.uniforms;
+                                if (Y.useProgram(_.program) && (M = !0, b = !0, T = !0), i.id !== S && (S = i.id, b = !0), M || E !== t) {
+                                    if (A.setValue(Mt, "projectionMatrix", t.projectionMatrix), q.logarithmicDepthBuffer && A.setValue(Mt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), E !== t && (E = t, b = !0, T = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
+                                        const e = A.map.cameraPosition;
+                                        void 0 !== e && e.setValue(Mt, V.setFromMatrixPosition(t.matrixWorld))
+                                    }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && A.setValue(Mt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && A.setValue(Mt, "viewMatrix", t.matrixWorldInverse)
                                 }
                                 if (r.isSkinnedMesh) {
-                                    S.setOptional(wt, r, "bindMatrix"), S.setOptional(wt, r, "bindMatrixInverse");
+                                    A.setOptional(Mt, r, "bindMatrix"), A.setOptional(Mt, r, "bindMatrixInverse");
                                     const t = r.skeleton;
-                                    t && (Z.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), S.setValue(wt, "boneTexture", t.boneTexture, et), S.setValue(wt, "boneTextureSize", t.boneTextureSize)) : S.setOptional(wt, t, "boneMatrices"))
+                                    t && (q.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), A.setValue(Mt, "boneTexture", t.boneTexture, K), A.setValue(Mt, "boneTextureSize", t.boneTextureSize)) : A.setOptional(Mt, t, "boneMatrices"))
                                 }
-                                var L, C;
-                                return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || xt.update(r, n, i, y), (M || f.receiveShadow !== r.receiveShadow) && (f.receiveShadow = r.receiveShadow, S.setValue(wt, "receiveShadow", r.receiveShadow)), M && (S.setValue(wt, "toneMappingExposure", b.toneMappingExposure), f.needsLights && (C = w, (L = E).ambientLightColor.needsUpdate = C, L.lightProbe.needsUpdate = C, L.directionalLights.needsUpdate = C, L.directionalLightShadows.needsUpdate = C, L.pointLights.needsUpdate = C, L.pointLightShadows.needsUpdate = C, L.spotLights.needsUpdate = C, L.spotLightShadows.needsUpdate = C, L.rectAreaLights.needsUpdate = C, L.hemisphereLights.needsUpdate = C), s && i.fog && lt.refreshFogUniforms(E, s), lt.refreshMaterialUniforms(E, i, O, N, W), br.upload(wt, f.uniformsList, E, et)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (br.upload(wt, f.uniformsList, E, et), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && S.setValue(wt, "center", r.center), S.setValue(wt, "modelViewMatrix", r.modelViewMatrix), S.setValue(wt, "normalMatrix", r.normalMatrix), S.setValue(wt, "modelMatrix", r.matrixWorld), y
+                                var L, D;
+                                return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || mt.update(r, n, i, _), (b || f.receiveShadow !== r.receiveShadow) && (f.receiveShadow = r.receiveShadow, A.setValue(Mt, "receiveShadow", r.receiveShadow)), b && (A.setValue(Mt, "toneMappingExposure", y.toneMappingExposure), f.needsLights && (D = T, (L = R).ambientLightColor.needsUpdate = D, L.lightProbe.needsUpdate = D, L.directionalLights.needsUpdate = D, L.directionalLightShadows.needsUpdate = D, L.pointLights.needsUpdate = D, L.pointLightShadows.needsUpdate = D, L.spotLights.needsUpdate = D, L.spotLightShadows.needsUpdate = D, L.rectAreaLights.needsUpdate = D, L.hemisphereLights.needsUpdate = D), s && i.fog && rt.refreshFogUniforms(R, s), rt.refreshMaterialUniforms(R, i, P, C, H), la.upload(Mt, f.uniformsList, R, K)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (la.upload(Mt, f.uniformsList, R, K), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && A.setValue(Mt, "center", r.center), A.setValue(Mt, "modelViewMatrix", r.modelViewMatrix), A.setValue(Mt, "normalMatrix", r.normalMatrix), A.setValue(Mt, "modelMatrix", r.matrixWorld), _
                             }(t, e, n, i, r);
-                        Q.setMaterial(i, a);
+                        Y.setMaterial(i, a);
                         let l = n.index;
                         const c = n.attributes.position;
                         if (null === l) {
                             if (void 0 === c || 0 === c.count) return
                         } else if (0 === l.count) return;
                         let h, u = 1;
-                        !0 === i.wireframe && (l = st.getWireframeAttribute(n), u = 2), bt.setup(r, i, o, n, l);
-                        let d = yt;
-                        null !== l && (h = rt.get(l), d = _t, d.setIndex(h));
+                        !0 === i.wireframe && (l = et.getWireframeAttribute(n), u = 2), xt.setup(r, i, o, n, l);
+                        let d = ft;
+                        null !== l && (h = tt.get(l), d = gt, d.setIndex(h));
                         const p = null !== l ? l.count : c.count,
                             m = n.drawRange.start * u,
                             f = n.drawRange.count * u,
-                            g = null !== s ? s.start * u : 0,
-                            v = null !== s ? s.count * u : 1 / 0,
-                            y = Math.max(m, g),
-                            _ = Math.min(p, m + f, g + v) - 1,
-                            M = Math.max(0, _ - y + 1);
-                        if (0 !== M) {
-                            if (r.isMesh) !0 === i.wireframe ? (Q.setLineWidth(i.wireframeLinewidth * Y()), d.setMode(1)) : d.setMode(4);
+                            v = null !== s ? s.start * u : 0,
+                            x = null !== s ? s.count * u : 1 / 0,
+                            _ = Math.max(m, v),
+                            M = Math.min(p, m + f, v + x) - 1,
+                            b = Math.max(0, M - _ + 1);
+                        if (0 !== b) {
+                            if (r.isMesh) !0 === i.wireframe ? (Y.setLineWidth(i.wireframeLinewidth * W()), d.setMode(1)) : d.setMode(4);
                             else if (r.isLine) {
                                 let t = i.linewidth;
-                                void 0 === t && (t = 1), Q.setLineWidth(t * Y()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
+                                void 0 === t && (t = 1), Y.setLineWidth(t * W()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                             } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
-                            if (r.isInstancedMesh) d.renderInstances(y, M, r.count);
+                            if (r.isInstancedMesh) d.renderInstances(_, b, r.count);
                             else if (n.isInstancedBufferGeometry) {
                                 const t = Math.min(n.instanceCount, n._maxInstanceCount);
-                                d.renderInstances(y, M, t)
-                            } else d.render(y, M)
+                                d.renderInstances(_, b, t)
+                            } else d.render(_, b)
                         }
                     }, this.compile = function(t, e) {
-                        x = pt.get(t), x.init(), M.push(x), t.traverseVisible((function(t) {
-                            t.isLight && t.layers.test(e.layers) && (x.pushLight(t), t.castShadow && x.pushShadow(t))
-                        })), x.setupLights(b.physicallyCorrectLights), t.traverse((function(e) {
+                        g = lt.get(t), g.init(), x.push(g), t.traverseVisible((function(t) {
+                            t.isLight && t.layers.test(e.layers) && (g.pushLight(t), t.castShadow && g.pushShadow(t))
+                        })), g.setupLights(y.physicallyCorrectLights), t.traverse((function(e) {
                             const n = e.material;
                             if (n)
                                 if (Array.isArray(n))
-                                    for (let i = 0; i < n.length; i++) Ft(n[i], t, e);
-                                else Ft(n, t, e)
-                        })), M.pop(), x = null
+                                    for (let i = 0; i < n.length; i++) Bt(n[i], t, e);
+                                else Bt(n, t, e)
+                        })), x.pop(), g = null
                     };
-                    let Ct = null;
+                    let Lt = null;
 
-                    function Pt() {
-                        It.stop()
+                    function Ct() {
+                        Dt.stop()
                     }
 
-                    function Dt() {
-                        It.start()
+                    function Pt() {
+                        Dt.start()
                     }
-                    const It = new Ln;
+                    const Dt = new pr;
 
-                    function Nt(t, e, n, i) {
+                    function It(t, e, n, i) {
                         if (!1 === t.visible) return;
                         if (t.layers.test(e.layers))
                             if (t.isGroup) n = t.renderOrder;
                             else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
-                        else if (t.isLight) x.pushLight(t), t.castShadow && x.pushShadow(t);
+                        else if (t.isLight) g.pushLight(t), t.castShadow && g.pushShadow(t);
                         else if (t.isSprite) {
-                            if (!t.frustumCulled || G.intersectsSprite(t)) {
-                                i && X.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
-                                const e = at.update(t),
+                            if (!t.frustumCulled || B.intersectsSprite(t)) {
+                                i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
+                                const e = nt.update(t),
                                     r = t.material;
-                                r.visible && f.push(t, e, r, n, X.z, null)
+                                r.visible && f.push(t, e, r, n, V.z, null)
                             }
-                        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== $.render.frame && (t.skeleton.update(), t.skeleton.frame = $.render.frame), !t.frustumCulled || G.intersectsObject(t))) {
-                            i && X.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
-                            const e = at.update(t),
+                        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== J.render.frame && (t.skeleton.update(), t.skeleton.frame = J.render.frame), !t.frustumCulled || B.intersectsObject(t))) {
+                            i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
+                            const e = nt.update(t),
                                 r = t.material;
                             if (Array.isArray(r)) {
                                 const i = e.groups;
                                 for (let s = 0, a = i.length; s < a; s++) {
                                     const a = i[s],
                                         o = r[a.materialIndex];
-                                    o && o.visible && f.push(t, e, o, n, X.z, a)
+                                    o && o.visible && f.push(t, e, o, n, V.z, a)
                                 }
-                            } else r.visible && f.push(t, e, r, n, X.z, null)
+                            } else r.visible && f.push(t, e, r, n, V.z, null)
                         }
                         const r = t.children;
-                        for (let t = 0, s = r.length; t < s; t++) Nt(r[t], e, n, i)
+                        for (let t = 0, s = r.length; t < s; t++) It(r[t], e, n, i)
                     }
 
-                    function Ot(t, e, n, i) {
+                    function Nt(t, e, n, i) {
                         const r = t.opaque,
                             s = t.transmissive,
-                            o = t.transparent;
-                        x.setupLightsView(n), s.length > 0 && function(t, e, n) {
-                            if (null === W) {
-                                const t = !0 === a && !0 === Z.isWebGL2;
-                                W = new(t ? dt : ut)(1024, 1024, {
+                            a = t.transparent;
+                        g.setupLightsView(n), s.length > 0 && function(t, e, n) {
+                            if (null === H) {
+                                const t = !0 === o && !0 === q.isWebGL2;
+                                H = new(t ? Ze : Je)(1024, 1024, {
                                     generateMipmaps: !0,
-                                    type: null !== Mt.convert(v) ? v : p,
-                                    minFilter: d,
-                                    magFilter: h,
-                                    wrapS: l,
-                                    wrapT: l,
-                                    useRenderToTexture: J.has("WEBGL_multisampled_render_to_texture")
+                                    type: null !== vt.convert(_t) ? _t : pt,
+                                    minFilter: dt,
+                                    magFilter: ot,
+                                    wrapS: st,
+                                    wrapT: st,
+                                    useRenderToTexture: j.has("WEBGL_multisampled_render_to_texture")
                                 })
                             }
-                            const i = b.getRenderTarget();
-                            b.setRenderTarget(W), b.clear();
-                            const r = b.toneMapping;
-                            b.toneMapping = 0, Ut(t, e, n), b.toneMapping = r, et.updateMultisampleRenderTarget(W), et.updateRenderTargetMipmap(W), b.setRenderTarget(i)
-                        }(r, e, n), i && Q.viewport(L.copy(i)), r.length > 0 && Ut(r, e, n), s.length > 0 && Ut(s, e, n), o.length > 0 && Ut(o, e, n)
+                            const i = y.getRenderTarget();
+                            y.setRenderTarget(H), y.clear();
+                            const r = y.toneMapping;
+                            y.toneMapping = X, Ot(t, e, n), y.toneMapping = r, K.updateMultisampleRenderTarget(H), K.updateRenderTargetMipmap(H), y.setRenderTarget(i)
+                        }(r, e, n), i && Y.viewport(T.copy(i)), r.length > 0 && Ot(r, e, n), s.length > 0 && Ot(s, e, n), a.length > 0 && Ot(a, e, n)
                     }
 
-                    function Ut(t, e, n) {
+                    function Ot(t, e, n) {
                         const i = !0 === e.isScene ? e.overrideMaterial : null;
                         for (let r = 0, s = t.length; r < s; r++) {
                             const s = t[r],
                                 a = s.object,
                                 o = s.geometry,
                                 l = null === i ? s.material : i,
                                 c = s.group;
-                            a.layers.test(n.layers) && Bt(a, e, n, o, l, c)
+                            a.layers.test(n.layers) && Ut(a, e, n, o, l, c)
                         }
                     }
 
-                    function Bt(t, e, n, i, r, s) {
-                        t.onBeforeRender(b, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(b, e, n, i, t, s), !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, b.renderBufferDirect(n, e, i, r, t, s), r.side = 0, r.needsUpdate = !0, b.renderBufferDirect(n, e, i, r, t, s), r.side = 2) : b.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(b, e, n, i, r, s)
+                    function Ut(t, e, n, i, r, s) {
+                        t.onBeforeRender(y, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(y, e, n, i, t, s), !0 === r.transparent && r.side === d ? (r.side = u, r.needsUpdate = !0, y.renderBufferDirect(n, e, i, r, t, s), r.side = h, r.needsUpdate = !0, y.renderBufferDirect(n, e, i, r, t, s), r.side = d) : y.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(y, e, n, i, r, s)
                     }
 
-                    function Ft(t, e, n) {
-                        !0 !== e.isScene && (e = q);
-                        const i = tt.get(t),
-                            r = x.state.lights,
-                            s = x.state.shadowsArray,
+                    function Bt(t, e, n) {
+                        !0 !== e.isScene && (e = k);
+                        const i = Z.get(t),
+                            r = g.state.lights,
+                            s = g.state.shadowsArray,
                             a = r.state.version,
-                            o = ot.getParameters(t, r.state, s, e, n),
-                            l = ot.getProgramCacheKey(o);
+                            o = it.getParameters(t, r.state, s, e, n),
+                            l = it.getProgramCacheKey(o);
                         let c = i.programs;
-                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? it : nt).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", Lt), c = new Map, i.programs = c);
+                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? $ : Q).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", Rt), c = new Map, i.programs = c);
                         let h = c.get(l);
                         if (void 0 !== h) {
-                            if (i.currentProgram === h && i.lightsStateVersion === a) return zt(t, o), h
-                        } else o.uniforms = ot.getUniforms(t), t.onBuild(n, o, b), t.onBeforeCompile(o, b), h = ot.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
+                            if (i.currentProgram === h && i.lightsStateVersion === a) return Ft(t, o), h
+                        } else o.uniforms = it.getUniforms(t), t.onBuild(n, o, y), t.onBeforeCompile(o, y), h = it.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
                         const u = i.uniforms;
-                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = ft.uniform), zt(t, o), i.needsLights = function(t) {
+                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = ct.uniform), Ft(t, o), i.needsLights = function(t) {
                             return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                         }(t), i.lightsStateVersion = a, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                         const d = h.getUniforms(),
-                            p = br.seqWithValue(d.seq, u);
+                            p = la.seqWithValue(d.seq, u);
                         return i.currentProgram = h, i.uniformsList = p, h
                     }
 
-                    function zt(t, e) {
-                        const n = tt.get(t);
+                    function Ft(t, e) {
+                        const n = Z.get(t);
                         n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
                     }
-                    It.setAnimationLoop((function(t) {
-                        Ct && Ct(t)
-                    })), "undefined" != typeof window && It.setContext(window), this.setAnimationLoop = function(t) {
-                        Ct = t, Tt.setAnimationLoop(t), null === t ? It.stop() : It.start()
-                    }, Tt.addEventListener("sessionstart", Pt), Tt.addEventListener("sessionend", Dt), this.render = function(t, e) {
+                    Dt.setAnimationLoop((function(t) {
+                        Lt && Lt(t)
+                    })), "undefined" != typeof window && Dt.setContext(window), this.setAnimationLoop = function(t) {
+                        Lt = t, St.setAnimationLoop(t), null === t ? Dt.stop() : Dt.start()
+                    }, St.addEventListener("sessionstart", Ct), St.addEventListener("sessionend", Pt), this.render = function(t, e) {
                         if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
-                        if (!0 === w) return;
-                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === Tt.enabled && !0 === Tt.isPresenting && (!0 === Tt.cameraAutoUpdate && Tt.updateCamera(e), e = Tt.getCamera()), !0 === t.isScene && t.onBeforeRender(b, t, e, T), x = pt.get(t, M.length), x.init(), M.push(x), j.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), G.setFromProjectionMatrix(j), k = this.localClippingEnabled, V = ft.init(this.clippingPlanes, k, e), f = ct.get(t, _.length), f.init(), _.push(f), Nt(t, e, 0, b.sortObjects), f.finish(), !0 === b.sortObjects && f.sort(U, B), !0 === V && ft.beginShadows();
-                        const n = x.state.shadowsArray;
-                        if (gt.render(n, t, e), !0 === V && ft.endShadows(), !0 === this.info.autoReset && this.info.reset(), vt.render(f, t), x.setupLights(b.physicallyCorrectLights), e.isArrayCamera) {
+                        if (!0 === _) return;
+                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === St.enabled && !0 === St.isPresenting && (!0 === St.cameraAutoUpdate && St.updateCamera(e), e = St.getCamera()), !0 === t.isScene && t.onBeforeRender(y, t, e, w), g = lt.get(t, x.length), g.init(), x.push(g), G.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), B.setFromProjectionMatrix(G), z = this.localClippingEnabled, F = ct.init(this.clippingPlanes, z, e), f = at.get(t, v.length), f.init(), v.push(f), It(t, e, 0, y.sortObjects), f.finish(), !0 === y.sortObjects && f.sort(D, I), !0 === F && ct.beginShadows();
+                        const n = g.state.shadowsArray;
+                        if (ht.render(n, t, e), !0 === F && ct.endShadows(), !0 === this.info.autoReset && this.info.reset(), ut.render(f, t), g.setupLights(y.physicallyCorrectLights), e.isArrayCamera) {
                             const n = e.cameras;
                             for (let e = 0, i = n.length; e < i; e++) {
                                 const i = n[e];
-                                Ot(f, t, i, i.viewport)
+                                Nt(f, t, i, i.viewport)
                             }
-                        } else Ot(f, t, e);
-                        null !== T && (et.updateMultisampleRenderTarget(T), et.updateRenderTargetMipmap(T)), !0 === t.isScene && t.onAfterRender(b, t, e), Q.buffers.depth.setTest(!0), Q.buffers.depth.setMask(!0), Q.buffers.color.setMask(!0), Q.setPolygonOffset(!1), bt.resetDefaultState(), A = -1, R = null, M.pop(), x = M.length > 0 ? M[M.length - 1] : null, _.pop(), f = _.length > 0 ? _[_.length - 1] : null
+                        } else Nt(f, t, e);
+                        null !== w && (K.updateMultisampleRenderTarget(w), K.updateRenderTargetMipmap(w)), !0 === t.isScene && t.onAfterRender(y, t, e), Y.buffers.depth.setTest(!0), Y.buffers.depth.setMask(!0), Y.buffers.color.setMask(!0), Y.setPolygonOffset(!1), xt.resetDefaultState(), S = -1, E = null, x.pop(), g = x.length > 0 ? x[x.length - 1] : null, v.pop(), f = v.length > 0 ? v[v.length - 1] : null
                     }, this.getActiveCubeFace = function() {
-                        return S
+                        return M
                     }, this.getActiveMipmapLevel = function() {
-                        return E
+                        return b
                     }, this.getRenderTarget = function() {
-                        return T
+                        return w
                     }, this.setRenderTargetTextures = function(t, e, n) {
-                        tt.get(t.texture).__webglTexture = e, tt.get(t.depthTexture).__webglTexture = n;
-                        const i = tt.get(t);
+                        Z.get(t.texture).__webglTexture = e, Z.get(t.depthTexture).__webglTexture = n;
+                        const i = Z.get(t);
                         i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || t.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), t.useRenderToTexture = !1, t.useRenderbuffer = !0))
                     }, this.setRenderTargetFramebuffer = function(t, e) {
-                        const n = tt.get(t);
+                        const n = Z.get(t);
                         n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
                     }, this.setRenderTarget = function(t, e = 0, n = 0) {
-                        T = t, S = e, E = n;
+                        w = t, M = e, b = n;
                         let i = !0;
                         if (t) {
-                            const e = tt.get(t);
-                            void 0 !== e.__useDefaultFramebuffer ? (Q.bindFramebuffer(36160, null), i = !1) : void 0 === e.__webglFramebuffer ? et.setupRenderTarget(t) : e.__hasExternalTextures && et.rebindTextures(t, tt.get(t.texture).__webglTexture, tt.get(t.depthTexture).__webglTexture)
+                            const e = Z.get(t);
+                            void 0 !== e.__useDefaultFramebuffer ? (Y.bindFramebuffer(36160, null), i = !1) : void 0 === e.__webglFramebuffer ? K.setupRenderTarget(t) : e.__hasExternalTextures && K.rebindTextures(t, Z.get(t.texture).__webglTexture, Z.get(t.depthTexture).__webglTexture)
                         }
                         let r = null,
                             s = !1,
                             a = !1;
                         if (t) {
                             const n = t.texture;
                             (n.isDataTexture3D || n.isDataTexture2DArray) && (a = !0);
-                            const i = tt.get(t).__webglFramebuffer;
-                            t.isWebGLCubeRenderTarget ? (r = i[e], s = !0) : r = t.useRenderbuffer ? tt.get(t).__webglMultisampledFramebuffer : i, L.copy(t.viewport), C.copy(t.scissor), P = t.scissorTest
-                        } else L.copy(F).multiplyScalar(O).floor(), C.copy(z).multiplyScalar(O).floor(), P = H;
-                        if (Q.bindFramebuffer(36160, r) && Z.drawBuffers && i && Q.drawBuffers(t, r), Q.viewport(L), Q.scissor(C), Q.setScissorTest(P), s) {
-                            const i = tt.get(t.texture);
-                            wt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
+                            const i = Z.get(t).__webglFramebuffer;
+                            t.isWebGLCubeRenderTarget ? (r = i[e], s = !0) : r = t.useRenderbuffer ? Z.get(t).__webglMultisampledFramebuffer : i, T.copy(t.viewport), A.copy(t.scissor), R = t.scissorTest
+                        } else T.copy(N).multiplyScalar(P).floor(), A.copy(O).multiplyScalar(P).floor(), R = U;
+                        if (Y.bindFramebuffer(36160, r) && q.drawBuffers && i && Y.drawBuffers(t, r), Y.viewport(T), Y.scissor(A), Y.setScissorTest(R), s) {
+                            const i = Z.get(t.texture);
+                            Mt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                         } else if (a) {
-                            const i = tt.get(t.texture),
+                            const i = Z.get(t.texture),
                                 r = e || 0;
-                            wt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
+                            Mt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                         }
-                        A = -1
+                        S = -1
                     }, this.readRenderTargetPixels = function(t, e, n, i, r, s, a) {
                         if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
-                        let o = tt.get(t).__webglFramebuffer;
+                        let o = Z.get(t).__webglFramebuffer;
                         if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
-                            Q.bindFramebuffer(36160, o);
+                            Y.bindFramebuffer(36160, o);
                             try {
                                 const a = t.texture,
                                     o = a.format,
                                     l = a.type;
-                                if (o !== y && Mt.convert(o) !== wt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
-                                const c = l === v && (J.has("EXT_color_buffer_half_float") || Z.isWebGL2 && J.has("EXT_color_buffer_float"));
-                                if (!(l === p || Mt.convert(l) === wt.getParameter(35738) || l === g && (Z.isWebGL2 || J.has("OES_texture_float") || J.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
-                                36053 === wt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && wt.readPixels(e, n, i, r, Mt.convert(o), Mt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
+                                if (o !== Et && vt.convert(o) !== Mt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
+                                const c = l === _t && (j.has("EXT_color_buffer_half_float") || q.isWebGL2 && j.has("EXT_color_buffer_float"));
+                                if (!(l === pt || vt.convert(l) === Mt.getParameter(35738) || l === yt && (q.isWebGL2 || j.has("OES_texture_float") || j.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
+                                36053 === Mt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && Mt.readPixels(e, n, i, r, vt.convert(o), vt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                             } finally {
-                                const t = null !== T ? tt.get(T).__webglFramebuffer : null;
-                                Q.bindFramebuffer(36160, t)
+                                const t = null !== w ? Z.get(w).__webglFramebuffer : null;
+                                Y.bindFramebuffer(36160, t)
                             }
                         }
                     }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                         if (!0 !== e.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
                         const i = Math.pow(2, -n),
                             r = Math.floor(e.image.width * i),
                             s = Math.floor(e.image.height * i);
-                        et.setTexture2D(e, 0), wt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, r, s), Q.unbindTexture()
+                        K.setTexture2D(e, 0), Mt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, r, s), Y.unbindTexture()
                     }, this.copyTextureToTexture = function(t, e, n, i = 0) {
                         const r = e.image.width,
                             s = e.image.height,
-                            a = Mt.convert(n.format),
-                            o = Mt.convert(n.type);
-                        et.setTexture2D(n, 0), wt.pixelStorei(37440, n.flipY), wt.pixelStorei(37441, n.premultiplyAlpha), wt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? wt.texSubImage2D(3553, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? wt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : wt.texSubImage2D(3553, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && wt.generateMipmap(3553), Q.unbindTexture()
+                            a = vt.convert(n.format),
+                            o = vt.convert(n.type);
+                        K.setTexture2D(n, 0), Mt.pixelStorei(37440, n.flipY), Mt.pixelStorei(37441, n.premultiplyAlpha), Mt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? Mt.texSubImage2D(3553, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? Mt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : Mt.texSubImage2D(3553, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && Mt.generateMipmap(3553), Y.unbindTexture()
                     }, this.copyTextureToTexture3D = function(t, e, n, i, r = 0) {
-                        if (b.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
+                        if (y.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                         const s = t.max.x - t.min.x + 1,
                             a = t.max.y - t.min.y + 1,
                             o = t.max.z - t.min.z + 1,
-                            l = Mt.convert(i.format),
-                            c = Mt.convert(i.type);
+                            l = vt.convert(i.format),
+                            c = vt.convert(i.type);
                         let h;
-                        if (i.isDataTexture3D) et.setTexture3D(i, 0), h = 32879;
+                        if (i.isDataTexture3D) K.setTexture3D(i, 0), h = 32879;
                         else {
                             if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
-                            et.setTexture2DArray(i, 0), h = 35866
+                            K.setTexture2DArray(i, 0), h = 35866
                         }
-                        wt.pixelStorei(37440, i.flipY), wt.pixelStorei(37441, i.premultiplyAlpha), wt.pixelStorei(3317, i.unpackAlignment);
-                        const u = wt.getParameter(3314),
-                            d = wt.getParameter(32878),
-                            p = wt.getParameter(3316),
-                            m = wt.getParameter(3315),
-                            f = wt.getParameter(32877),
+                        Mt.pixelStorei(37440, i.flipY), Mt.pixelStorei(37441, i.premultiplyAlpha), Mt.pixelStorei(3317, i.unpackAlignment);
+                        const u = Mt.getParameter(3314),
+                            d = Mt.getParameter(32878),
+                            p = Mt.getParameter(3316),
+                            m = Mt.getParameter(3315),
+                            f = Mt.getParameter(32877),
                             g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
-                        wt.pixelStorei(3314, g.width), wt.pixelStorei(32878, g.height), wt.pixelStorei(3316, t.min.x), wt.pixelStorei(3315, t.min.y), wt.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? wt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), wt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data)) : wt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g), wt.pixelStorei(3314, u), wt.pixelStorei(32878, d), wt.pixelStorei(3316, p), wt.pixelStorei(3315, m), wt.pixelStorei(32877, f), 0 === r && i.generateMipmaps && wt.generateMipmap(h), Q.unbindTexture()
+                        Mt.pixelStorei(3314, g.width), Mt.pixelStorei(32878, g.height), Mt.pixelStorei(3316, t.min.x), Mt.pixelStorei(3315, t.min.y), Mt.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Mt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data)) : Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g), Mt.pixelStorei(3314, u), Mt.pixelStorei(32878, d), Mt.pixelStorei(3316, p), Mt.pixelStorei(3315, m), Mt.pixelStorei(32877, f), 0 === r && i.generateMipmaps && Mt.generateMipmap(h), Y.unbindTexture()
                     }, this.initTexture = function(t) {
-                        et.setTexture2D(t, 0), Q.unbindTexture()
+                        K.setTexture2D(t, 0), Y.unbindTexture()
                     }, this.resetState = function() {
-                        S = 0, E = 0, T = null, Q.reset(), bt.reset()
+                        M = 0, b = 0, w = null, Y.reset(), xt.reset()
                     }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                         detail: this
                     }))
                 }
-                fs.prototype.isWebGLRenderer = !0, class extends fs {}.prototype.isWebGL1Renderer = !0;
-                class gs {
+                io.prototype.isWebGLRenderer = !0, class extends io {}.prototype.isWebGL1Renderer = !0;
+                class ro {
                     constructor(t, e = 25e-5) {
-                        this.name = "", this.color = new rt(t), this.density = e
+                        this.name = "", this.color = new Ve(t), this.density = e
                     }
                     clone() {
-                        return new gs(this.color, this.density)
+                        return new ro(this.color, this.density)
                     }
                     toJSON() {
                         return {
                             type: "FogExp2",
                             color: this.color.getHex(),
                             density: this.density
                         }
                     }
                 }
-                gs.prototype.isFogExp2 = !0;
-                class vs {
+                ro.prototype.isFogExp2 = !0;
+                class so {
                     constructor(t, e = 1, n = 1e3) {
-                        this.name = "", this.color = new rt(t), this.near = e, this.far = n
+                        this.name = "", this.color = new Ve(t), this.near = e, this.far = n
                     }
                     clone() {
-                        return new vs(this.color, this.near, this.far)
+                        return new so(this.color, this.near, this.far)
                     }
                     toJSON() {
                         return {
                             type: "Fog",
                             color: this.color.getHex(),
                             near: this.near,
                             far: this.far
                         }
                     }
                 }
-                vs.prototype.isFog = !0;
-                class xs extends ge {
+                so.prototype.isFog = !0;
+                class ao extends ei {
                     constructor() {
                         super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                             detail: this
                         }))
                     }
                     copy(t, e) {
                         return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                     }
                 }
-                xs.prototype.isScene = !0;
-                class ys {
+                ao.prototype.isScene = !0;
+                class oo {
                     constructor(t, e) {
-                        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = O, this.updateRange = {
+                        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = ye, this.updateRange = {
                             offset: 0,
                             count: -1
-                        }, this.version = 0, this.uuid = k()
+                        }, this.version = 0, this.uuid = Ae()
                     }
                     onUploadCallback() {}
                     set needsUpdate(t) {
                         !0 === t && this.version++
                     }
                     setUsage(t) {
                         return this.usage = t, this
@@ -25756,56 +26146,56 @@
                         for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                         return this
                     }
                     set(t, e = 0) {
                         return this.array.set(t, e), this
                     }
                     clone(t) {
-                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = k()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
+                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ae()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                         const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                             n = new this.constructor(e, this.stride);
                         return n.setUsage(this.usage), n
                     }
                     onUpload(t) {
                         return this.onUploadCallback = t, this
                     }
                     toJSON(t) {
-                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = k()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
+                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ae()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                             uuid: this.uuid,
                             buffer: this.array.buffer._uuid,
                             type: this.array.constructor.name,
                             stride: this.stride
                         }
                     }
                 }
-                ys.prototype.isInterleavedBuffer = !0;
-                const _s = new mt;
-                class Ms {
+                oo.prototype.isInterleavedBuffer = !0;
+                const lo = new Qe;
+                class co {
                     constructor(t, e, n, i = !1) {
                         this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
                     }
                     get count() {
                         return this.data.count
                     }
                     get array() {
                         return this.data.array
                     }
                     set needsUpdate(t) {
                         this.data.needsUpdate = t
                     }
                     applyMatrix4(t) {
-                        for (let e = 0, n = this.data.count; e < n; e++) _s.x = this.getX(e), _s.y = this.getY(e), _s.z = this.getZ(e), _s.applyMatrix4(t), this.setXYZ(e, _s.x, _s.y, _s.z);
+                        for (let e = 0, n = this.data.count; e < n; e++) lo.x = this.getX(e), lo.y = this.getY(e), lo.z = this.getZ(e), lo.applyMatrix4(t), this.setXYZ(e, lo.x, lo.y, lo.z);
                         return this
                     }
                     applyNormalMatrix(t) {
-                        for (let e = 0, n = this.count; e < n; e++) _s.x = this.getX(e), _s.y = this.getY(e), _s.z = this.getZ(e), _s.applyNormalMatrix(t), this.setXYZ(e, _s.x, _s.y, _s.z);
+                        for (let e = 0, n = this.count; e < n; e++) lo.x = this.getX(e), lo.y = this.getY(e), lo.z = this.getZ(e), lo.applyNormalMatrix(t), this.setXYZ(e, lo.x, lo.y, lo.z);
                         return this
                     }
                     transformDirection(t) {
-                        for (let e = 0, n = this.count; e < n; e++) _s.x = this.getX(e), _s.y = this.getY(e), _s.z = this.getZ(e), _s.transformDirection(t), this.setXYZ(e, _s.x, _s.y, _s.z);
+                        for (let e = 0, n = this.count; e < n; e++) lo.x = this.getX(e), lo.y = this.getY(e), lo.z = this.getZ(e), lo.transformDirection(t), this.setXYZ(e, lo.x, lo.y, lo.z);
                         return this
                     }
                     setX(t, e) {
                         return this.data.array[t * this.data.stride + this.offset] = e, this
                     }
                     setY(t, e) {
                         return this.data.array[t * this.data.stride + this.offset + 1] = e, this
@@ -25841,17 +26231,17 @@
                         if (void 0 === t) {
                             console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                             const t = [];
                             for (let e = 0; e < this.count; e++) {
                                 const n = e * this.data.stride + this.offset;
                                 for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                             }
-                            return new Ie(new this.array.constructor(t), this.itemSize, this.normalized)
+                            return new xi(new this.array.constructor(t), this.itemSize, this.normalized)
                         }
-                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Ms(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
+                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new co(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                     }
                     toJSON(t) {
                         if (void 0 === t) {
                             console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                             const t = [];
                             for (let e = 0; e < this.count; e++) {
                                 const n = e * this.data.stride + this.offset;
@@ -25869,255 +26259,255 @@
                             itemSize: this.itemSize,
                             data: this.data.uuid,
                             offset: this.offset,
                             normalized: this.normalized
                         }
                     }
                 }
-                Ms.prototype.isInterleavedBufferAttribute = !0;
-                class bs extends Le {
+                co.prototype.isInterleavedBufferAttribute = !0;
+                class ho extends mi {
                     constructor(t) {
-                        super(), this.type = "SpriteMaterial", this.color = new rt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
+                        super(), this.type = "SpriteMaterial", this.color = new Ve(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
                     }
                 }
-                let ws;
-                bs.prototype.isSpriteMaterial = !0;
-                const Ss = new mt,
-                    Es = new mt,
-                    Ts = new mt,
-                    As = new Y,
-                    Rs = new Y,
-                    Ls = new jt,
-                    Cs = new mt,
-                    Ps = new mt,
-                    Ds = new mt,
-                    Is = new Y,
-                    Ns = new Y,
-                    Os = new Y;
-
-                function Us(t, e, n, i, r, s) {
-                    As.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (Rs.x = s * As.x - r * As.y, Rs.y = r * As.x + s * As.y) : Rs.copy(As), t.copy(e), t.x += Rs.x, t.y += Rs.y, t.applyMatrix4(Ls)
-                }(class extends ge {
+                let uo;
+                ho.prototype.isSpriteMaterial = !0;
+                const po = new Qe,
+                    mo = new Qe,
+                    fo = new Qe,
+                    go = new De,
+                    vo = new De,
+                    xo = new Cn,
+                    yo = new Qe,
+                    _o = new Qe,
+                    Mo = new Qe,
+                    bo = new De,
+                    wo = new De,
+                    So = new De;
+
+                function Eo(t, e, n, i, r, s) {
+                    go.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (vo.x = s * go.x - r * go.y, vo.y = r * go.x + s * go.y) : vo.copy(go), t.copy(e), t.x += vo.x, t.y += vo.y, t.applyMatrix4(xo)
+                }(class extends ei {
                     constructor(t) {
-                        if (super(), this.type = "Sprite", void 0 === ws) {
-                            ws = new We;
+                        if (super(), this.type = "Sprite", void 0 === uo) {
+                            uo = new Li;
                             const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
-                                e = new ys(t, 5);
-                            ws.setIndex([0, 1, 2, 0, 2, 3]), ws.setAttribute("position", new Ms(e, 3, 0, !1)), ws.setAttribute("uv", new Ms(e, 2, 3, !1))
+                                e = new oo(t, 5);
+                            uo.setIndex([0, 1, 2, 0, 2, 3]), uo.setAttribute("position", new co(e, 3, 0, !1)), uo.setAttribute("uv", new co(e, 2, 3, !1))
                         }
-                        this.geometry = ws, this.material = void 0 !== t ? t : new bs, this.center = new Y(.5, .5)
+                        this.geometry = uo, this.material = void 0 !== t ? t : new ho, this.center = new De(.5, .5)
                     }
                     raycast(t, e) {
-                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Es.setFromMatrixScale(this.matrixWorld), Ls.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Ts.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Es.multiplyScalar(-Ts.z);
+                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), mo.setFromMatrixScale(this.matrixWorld), xo.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), fo.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && mo.multiplyScalar(-fo.z);
                         const n = this.material.rotation;
                         let i, r;
                         0 !== n && (r = Math.cos(n), i = Math.sin(n));
                         const s = this.center;
-                        Us(Cs.set(-.5, -.5, 0), Ts, s, Es, i, r), Us(Ps.set(.5, -.5, 0), Ts, s, Es, i, r), Us(Ds.set(.5, .5, 0), Ts, s, Es, i, r), Is.set(0, 0), Ns.set(1, 0), Os.set(1, 1);
-                        let a = t.ray.intersectTriangle(Cs, Ps, Ds, !1, Ss);
-                        if (null === a && (Us(Ps.set(-.5, .5, 0), Ts, s, Es, i, r), Ns.set(0, 1), a = t.ray.intersectTriangle(Cs, Ds, Ps, !1, Ss), null === a)) return;
-                        const o = t.ray.origin.distanceTo(Ss);
+                        Eo(yo.set(-.5, -.5, 0), fo, s, mo, i, r), Eo(_o.set(.5, -.5, 0), fo, s, mo, i, r), Eo(Mo.set(.5, .5, 0), fo, s, mo, i, r), bo.set(0, 0), wo.set(1, 0), So.set(1, 1);
+                        let a = t.ray.intersectTriangle(yo, _o, Mo, !1, po);
+                        if (null === a && (Eo(_o.set(-.5, .5, 0), fo, s, mo, i, r), wo.set(0, 1), a = t.ray.intersectTriangle(yo, Mo, _o, !1, po), null === a)) return;
+                        const o = t.ray.origin.distanceTo(po);
                         o < t.near || o > t.far || e.push({
                             distance: o,
-                            point: Ss.clone(),
-                            uv: Ae.getUV(Ss, Cs, Ps, Ds, Is, Ns, Os, new Y),
+                            point: po.clone(),
+                            uv: di.getUV(po, yo, _o, Mo, bo, wo, So, new De),
                             face: null,
                             object: this
                         })
                     }
                     copy(t) {
                         return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                     }
                 }).prototype.isSprite = !0;
-                const Bs = new mt,
-                    Fs = new ht,
-                    zs = new ht,
-                    Hs = new mt,
-                    Gs = new jt;
-                class Vs extends cn {
+                const To = new Qe,
+                    Ao = new Ye,
+                    Ro = new Ye,
+                    Lo = new Qe,
+                    Co = new Cn;
+                class Po extends qi {
                     constructor(t, e) {
-                        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new jt, this.bindMatrixInverse = new jt
+                        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Cn, this.bindMatrixInverse = new Cn
                     }
                     copy(t) {
                         return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                     }
                     bind(t, e) {
                         this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                     }
                     pose() {
                         this.skeleton.pose()
                     }
                     normalizeSkinWeights() {
-                        const t = new ht,
+                        const t = new Ye,
                             e = this.geometry.attributes.skinWeight;
                         for (let n = 0, i = e.count; n < i; n++) {
                             t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                             const i = 1 / t.manhattanLength();
                             i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                         }
                     }
                     updateMatrixWorld(t) {
                         super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                     }
                     boneTransform(t, e) {
                         const n = this.skeleton,
                             i = this.geometry;
-                        Fs.fromBufferAttribute(i.attributes.skinIndex, t), zs.fromBufferAttribute(i.attributes.skinWeight, t), Bs.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
+                        Ao.fromBufferAttribute(i.attributes.skinIndex, t), Ro.fromBufferAttribute(i.attributes.skinWeight, t), To.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                         for (let t = 0; t < 4; t++) {
-                            const i = zs.getComponent(t);
+                            const i = Ro.getComponent(t);
                             if (0 !== i) {
-                                const r = Fs.getComponent(t);
-                                Gs.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Hs.copy(Bs).applyMatrix4(Gs), i)
+                                const r = Ao.getComponent(t);
+                                Co.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Lo.copy(To).applyMatrix4(Co), i)
                             }
                         }
                         return e.applyMatrix4(this.bindMatrixInverse)
                     }
                 }
-                Vs.prototype.isSkinnedMesh = !0;
-                (class extends ge {
+                Po.prototype.isSkinnedMesh = !0;
+                (class extends ei {
                     constructor() {
                         super(), this.type = "Bone"
                     }
                 }).prototype.isBone = !0;
-                (class extends lt {
-                    constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, h, u) {
+                (class extends Xe {
+                    constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = ot, c = ot, h, u) {
                         super(null, s, a, o, l, c, i, r, h, u), this.image = {
                             data: t,
                             width: e,
                             height: n
                         }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                     }
                 }).prototype.isDataTexture = !0;
-                class ks extends Ie {
+                class Do extends xi {
                     constructor(t, e, n, i = 1) {
                         "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = i
                     }
                     copy(t) {
                         return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                     }
                 }
-                ks.prototype.isInstancedBufferAttribute = !0;
-                const Ws = new jt,
-                    js = new jt,
-                    Xs = [],
-                    qs = new cn;
-                (class extends cn {
+                Do.prototype.isInstancedBufferAttribute = !0;
+                const Io = new Cn,
+                    No = new Cn,
+                    Oo = [],
+                    Uo = new qi;
+                (class extends qi {
                     constructor(t, e, n) {
-                        super(t, e), this.instanceMatrix = new ks(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
+                        super(t, e), this.instanceMatrix = new Do(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
                     }
                     copy(t) {
                         return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
                     }
                     getColorAt(t, e) {
                         e.fromArray(this.instanceColor.array, 3 * t)
                     }
                     getMatrixAt(t, e) {
                         e.fromArray(this.instanceMatrix.array, 16 * t)
                     }
                     raycast(t, e) {
                         const n = this.matrixWorld,
                             i = this.count;
-                        if (qs.geometry = this.geometry, qs.material = this.material, void 0 !== qs.material)
+                        if (Uo.geometry = this.geometry, Uo.material = this.material, void 0 !== Uo.material)
                             for (let r = 0; r < i; r++) {
-                                this.getMatrixAt(r, Ws), js.multiplyMatrices(n, Ws), qs.matrixWorld = js, qs.raycast(t, Xs);
-                                for (let t = 0, n = Xs.length; t < n; t++) {
-                                    const n = Xs[t];
+                                this.getMatrixAt(r, Io), No.multiplyMatrices(n, Io), Uo.matrixWorld = No, Uo.raycast(t, Oo);
+                                for (let t = 0, n = Oo.length; t < n; t++) {
+                                    const n = Oo[t];
                                     n.instanceId = r, n.object = this, e.push(n)
                                 }
-                                Xs.length = 0
+                                Oo.length = 0
                             }
                     }
                     setColorAt(t, e) {
-                        null === this.instanceColor && (this.instanceColor = new ks(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
+                        null === this.instanceColor && (this.instanceColor = new Do(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                     }
                     setMatrixAt(t, e) {
                         e.toArray(this.instanceMatrix.array, 16 * t)
                     }
                     updateMorphTargets() {}
                     dispose() {
                         this.dispatchEvent({
                             type: "dispose"
                         })
                     }
                 }).prototype.isInstancedMesh = !0;
-                class Ys extends Le {
+                class Bo extends mi {
                     constructor(t) {
-                        super(), this.type = "LineBasicMaterial", this.color = new rt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
+                        super(), this.type = "LineBasicMaterial", this.color = new Ve(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
                     }
                 }
-                Ys.prototype.isLineBasicMaterial = !0;
-                const Js = new mt,
-                    Zs = new mt,
-                    Ks = new jt,
-                    Qs = new Wt,
-                    $s = new Ut;
-                class ta extends ge {
-                    constructor(t = new We, e = new Ys) {
+                Bo.prototype.isLineBasicMaterial = !0;
+                const Fo = new Qe,
+                    zo = new Qe,
+                    Ho = new Cn,
+                    Go = new Ln,
+                    Vo = new Mn;
+                class ko extends ei {
+                    constructor(t = new Li, e = new Bo) {
                         super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                     }
                     computeLineDistances() {
                         const t = this.geometry;
                         if (t.isBufferGeometry)
                             if (null === t.index) {
                                 const e = t.attributes.position,
                                     n = [0];
-                                for (let t = 1, i = e.count; t < i; t++) Js.fromBufferAttribute(e, t - 1), Zs.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Js.distanceTo(Zs);
-                                t.setAttribute("lineDistance", new Ue(n, 1))
+                                for (let t = 1, i = e.count; t < i; t++) Fo.fromBufferAttribute(e, t - 1), zo.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Fo.distanceTo(zo);
+                                t.setAttribute("lineDistance", new Mi(n, 1))
                             } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                         else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                         return this
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.matrixWorld,
                             r = t.params.Line.threshold,
                             s = n.drawRange;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), $s.copy(n.boundingSphere), $s.applyMatrix4(i), $s.radius += r, !1 === t.ray.intersectsSphere($s)) return;
-                        Ks.copy(i).invert(), Qs.copy(t.ray).applyMatrix4(Ks);
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), Vo.copy(n.boundingSphere), Vo.applyMatrix4(i), Vo.radius += r, !1 === t.ray.intersectsSphere(Vo)) return;
+                        Ho.copy(i).invert(), Go.copy(t.ray).applyMatrix4(Ho);
                         const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                             o = a * a,
-                            l = new mt,
-                            c = new mt,
-                            h = new mt,
-                            u = new mt,
+                            l = new Qe,
+                            c = new Qe,
+                            h = new Qe,
+                            u = new Qe,
                             d = this.isLineSegments ? 2 : 1;
                         if (n.isBufferGeometry) {
                             const i = n.index,
                                 r = n.attributes.position;
                             if (null !== i)
                                 for (let n = Math.max(0, s.start), a = Math.min(i.count, s.start + s.count) - 1; n < a; n += d) {
                                     const s = i.getX(n),
                                         a = i.getX(n + 1);
-                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a), Qs.distanceSqToSegment(l, c, u, h) > o) continue;
+                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a), Go.distanceSqToSegment(l, c, u, h) > o) continue;
                                     u.applyMatrix4(this.matrixWorld);
                                     const d = t.ray.origin.distanceTo(u);
                                     d < t.near || d > t.far || e.push({
                                         distance: d,
                                         point: h.clone().applyMatrix4(this.matrixWorld),
                                         index: n,
                                         face: null,
                                         faceIndex: null,
                                         object: this
                                     })
                                 } else
                                     for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
-                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), Qs.distanceSqToSegment(l, c, u, h) > o) continue;
+                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), Go.distanceSqToSegment(l, c, u, h) > o) continue;
                                         u.applyMatrix4(this.matrixWorld);
                                         const i = t.ray.origin.distanceTo(u);
                                         i < t.near || i > t.far || e.push({
                                             distance: i,
                                             point: h.clone().applyMatrix4(this.matrixWorld),
                                             index: n,
                                             face: null,
@@ -26144,95 +26534,95 @@
                             }
                         } else {
                             const e = t.morphTargets;
                             void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                         }
                     }
                 }
-                ta.prototype.isLine = !0;
-                const ea = new mt,
-                    na = new mt;
-                class ia extends ta {
+                ko.prototype.isLine = !0;
+                const Wo = new Qe,
+                    jo = new Qe;
+                class Xo extends ko {
                     constructor(t, e) {
                         super(t, e), this.type = "LineSegments"
                     }
                     computeLineDistances() {
                         const t = this.geometry;
                         if (t.isBufferGeometry)
                             if (null === t.index) {
                                 const e = t.attributes.position,
                                     n = [];
-                                for (let t = 0, i = e.count; t < i; t += 2) ea.fromBufferAttribute(e, t), na.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + ea.distanceTo(na);
-                                t.setAttribute("lineDistance", new Ue(n, 1))
+                                for (let t = 0, i = e.count; t < i; t += 2) Wo.fromBufferAttribute(e, t), jo.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Wo.distanceTo(jo);
+                                t.setAttribute("lineDistance", new Mi(n, 1))
                             } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                         else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                         return this
                     }
                 }
-                ia.prototype.isLineSegments = !0;
-                (class extends ta {
+                Xo.prototype.isLineSegments = !0;
+                (class extends ko {
                     constructor(t, e) {
                         super(t, e), this.type = "LineLoop"
                     }
                 }).prototype.isLineLoop = !0;
-                class ra extends Le {
+                class qo extends mi {
                     constructor(t) {
-                        super(), this.type = "PointsMaterial", this.color = new rt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
+                        super(), this.type = "PointsMaterial", this.color = new Ve(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
                     }
                 }
-                ra.prototype.isPointsMaterial = !0;
-                const sa = new jt,
-                    aa = new Wt,
-                    oa = new Ut,
-                    la = new mt;
+                qo.prototype.isPointsMaterial = !0;
+                const Yo = new Cn,
+                    Jo = new Ln,
+                    Zo = new Mn,
+                    Ko = new Qe;
 
-                function ca(t, e, n, i, r, s, a) {
-                    const o = aa.distanceSqToPoint(t);
+                function Qo(t, e, n, i, r, s, a) {
+                    const o = Jo.distanceSqToPoint(t);
                     if (o < n) {
-                        const n = new mt;
-                        aa.closestPointToPoint(t, n), n.applyMatrix4(i);
+                        const n = new Qe;
+                        Jo.closestPointToPoint(t, n), n.applyMatrix4(i);
                         const l = r.ray.origin.distanceTo(n);
                         if (l < r.near || l > r.far) return;
                         s.push({
                             distance: l,
                             distanceToRay: Math.sqrt(o),
                             point: n,
                             index: e,
                             face: null,
                             object: a
                         })
                     }
-                }(class extends ge {
-                    constructor(t = new We, e = new ra) {
+                }(class extends ei {
+                    constructor(t = new Li, e = new qo) {
                         super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
                     }
                     copy(t) {
                         return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                     }
                     raycast(t, e) {
                         const n = this.geometry,
                             i = this.matrixWorld,
                             r = t.params.Points.threshold,
                             s = n.drawRange;
-                        if (null === n.boundingSphere && n.computeBoundingSphere(), oa.copy(n.boundingSphere), oa.applyMatrix4(i), oa.radius += r, !1 === t.ray.intersectsSphere(oa)) return;
-                        sa.copy(i).invert(), aa.copy(t.ray).applyMatrix4(sa);
+                        if (null === n.boundingSphere && n.computeBoundingSphere(), Zo.copy(n.boundingSphere), Zo.applyMatrix4(i), Zo.radius += r, !1 === t.ray.intersectsSphere(Zo)) return;
+                        Yo.copy(i).invert(), Jo.copy(t.ray).applyMatrix4(Yo);
                         const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                             o = a * a;
                         if (n.isBufferGeometry) {
                             const r = n.index,
                                 a = n.attributes.position;
                             if (null !== r)
                                 for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                                     const s = r.getX(n);
-                                    la.fromBufferAttribute(a, s), ca(la, s, o, i, t, e, this)
+                                    Ko.fromBufferAttribute(a, s), Qo(Ko, s, o, i, t, e, this)
                                 } else
-                                    for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++) la.fromBufferAttribute(a, n), ca(la, n, o, i, t, e, this)
+                                    for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++) Ko.fromBufferAttribute(a, n), Qo(Ko, n, o, i, t, e, this)
                         } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                     }
                     updateMorphTargets() {
                         const t = this.geometry;
                         if (t.isBufferGeometry) {
                             const e = t.morphAttributes,
                                 n = Object.keys(e);
@@ -26247,50 +26637,50 @@
                                 }
                             }
                         } else {
                             const e = t.morphTargets;
                             void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                         }
                     }
-                }).prototype.isPoints = !0, class extends lt {
+                }).prototype.isPoints = !0, class extends Xe {
                     constructor(t, e, n, i, r, s, a, o, l) {
-                        super(t, e, n, i, r, s, a, o, l), this.minFilter = void 0 !== s ? s : u, this.magFilter = void 0 !== r ? r : u, this.generateMipmaps = !1;
+                        super(t, e, n, i, r, s, a, o, l), this.minFilter = void 0 !== s ? s : ht, this.magFilter = void 0 !== r ? r : ht, this.generateMipmaps = !1;
                         const c = this;
                         "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                             c.needsUpdate = !0, t.requestVideoFrameCallback(e)
                         }))
                     }
                     clone() {
                         return new this.constructor(this.image).copy(this)
                     }
                     update() {
                         const t = this.image;
                         !1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                     }
-                }.prototype.isVideoTexture = !0, class extends lt {
+                }.prototype.isVideoTexture = !0, class extends Xe {
                     constructor(t, e, n) {
                         super({
                             width: t,
                             height: e
-                        }), this.format = n, this.magFilter = h, this.minFilter = h, this.generateMipmaps = !1, this.needsUpdate = !0
+                        }), this.format = n, this.magFilter = ot, this.minFilter = ot, this.generateMipmaps = !1, this.needsUpdate = !0
                     }
                 }.prototype.isFramebufferTexture = !0;
-                (class extends lt {
+                (class extends Xe {
                     constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
                         super(null, s, a, o, l, c, i, r, h, u), this.image = {
                             width: e,
                             height: n
                         }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                     }
-                }).prototype.isCompressedTexture = !0, class extends lt {
+                }).prototype.isCompressedTexture = !0, class extends Xe {
                     constructor(t, e, n, i, r, s, a, o, l) {
                         super(t, e, n, i, r, s, a, o, l), this.needsUpdate = !0
                     }
-                }.prototype.isCanvasTexture = !0, new mt, new mt, new mt, new Ae;
-                class ha {
+                }.prototype.isCanvasTexture = !0, new Qe, new Qe, new Qe, new di;
+                class $o {
                     constructor() {
                         this.type = "Curve", this.arcLengthDivisions = 200
                     }
                     getPoint() {
                         return console.warn("THREE.Curve: .getPoint() not implemented."), null
                     }
                     getPointAt(t, e) {
@@ -26347,48 +26737,48 @@
                     getTangent(t, e) {
                         const n = 1e-4;
                         let i = t - n,
                             r = t + n;
                         i < 0 && (i = 0), r > 1 && (r = 1);
                         const s = this.getPoint(i),
                             a = this.getPoint(r),
-                            o = e || (s.isVector2 ? new Y : new mt);
+                            o = e || (s.isVector2 ? new De : new Qe);
                         return o.copy(a).sub(s).normalize(), o
                     }
                     getTangentAt(t, e) {
                         const n = this.getUtoTmapping(t);
                         return this.getTangent(n, e)
                     }
                     computeFrenetFrames(t, e) {
-                        const n = new mt,
+                        const n = new Qe,
                             i = [],
                             r = [],
                             s = [],
-                            a = new mt,
-                            o = new jt;
+                            a = new Qe,
+                            o = new Cn;
                         for (let e = 0; e <= t; e++) {
                             const n = e / t;
-                            i[e] = this.getTangentAt(n, new mt)
+                            i[e] = this.getTangentAt(n, new Qe)
                         }
-                        r[0] = new mt, s[0] = new mt;
+                        r[0] = new Qe, s[0] = new Qe;
                         let l = Number.MAX_VALUE;
                         const c = Math.abs(i[0].x),
                             h = Math.abs(i[0].y),
                             u = Math.abs(i[0].z);
                         c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), s[0].crossVectors(i[0], r[0]);
                         for (let e = 1; e <= t; e++) {
                             if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), a.crossVectors(i[e - 1], i[e]), a.length() > Number.EPSILON) {
                                 a.normalize();
-                                const t = Math.acos(W(i[e - 1].dot(i[e]), -1, 1));
+                                const t = Math.acos(Re(i[e - 1].dot(i[e]), -1, 1));
                                 r[e].applyMatrix4(o.makeRotationAxis(a, t))
                             }
                             s[e].crossVectors(i[e], r[e])
                         }
                         if (!0 === e) {
-                            let e = Math.acos(W(r[0].dot(r[t]), -1, 1));
+                            let e = Math.acos(Re(r[0].dot(r[t]), -1, 1));
                             e /= t, i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                             for (let n = 1; n <= t; n++) r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
                         }
                         return {
                             tangents: i,
                             normals: r,
                             binormals: s
@@ -26410,20 +26800,20 @@
                         };
                         return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                     }
                     fromJSON(t) {
                         return this.arcLengthDivisions = t.arcLengthDivisions, this
                     }
                 }
-                class ua extends ha {
+                class tl extends $o {
                     constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
                         super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
                     }
                     getPoint(t, e) {
-                        const n = e || new Y,
+                        const n = e || new De,
                             i = 2 * Math.PI;
                         let r = this.aEndAngle - this.aStartAngle;
                         const s = Math.abs(r) < Number.EPSILON;
                         for (; r < 0;) r += i;
                         for (; r > i;) r -= i;
                         r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                         const a = this.aStartAngle + t * r;
@@ -26445,22 +26835,22 @@
                         const t = super.toJSON();
                         return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                     }
                 }
-                ua.prototype.isEllipseCurve = !0;
-                class da extends ua {
+                tl.prototype.isEllipseCurve = !0;
+                class el extends tl {
                     constructor(t, e, n, i, r, s) {
                         super(t, e, n, n, i, r, s), this.type = "ArcCurve"
                     }
                 }
 
-                function pa() {
+                function nl() {
                     let t = 0,
                         e = 0,
                         n = 0,
                         i = 0;
 
                     function r(r, s, a, o) {
                         t = r, e = a, n = -3 * r + 3 * s - 2 * a - o, i = 2 * r - 2 * s + a + o
@@ -26476,41 +26866,41 @@
                         },
                         calc: function(r) {
                             const s = r * r;
                             return t + e * r + n * s + i * (s * r)
                         }
                     }
                 }
-                da.prototype.isArcCurve = !0;
-                const ma = new mt,
-                    fa = new pa,
-                    ga = new pa,
-                    va = new pa;
-                class xa extends ha {
+                el.prototype.isArcCurve = !0;
+                const il = new Qe,
+                    rl = new nl,
+                    sl = new nl,
+                    al = new nl;
+                class ol extends $o {
                     constructor(t = [], e = !1, n = "centripetal", i = .5) {
                         super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i
                     }
-                    getPoint(t, e = new mt) {
+                    getPoint(t, e = new Qe) {
                         const n = e,
                             i = this.points,
                             r = i.length,
                             s = (r - (this.closed ? 0 : 1)) * t;
                         let a, o, l = Math.floor(s),
                             c = s - l;
-                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (ma.subVectors(i[0], i[1]).add(i[0]), a = ma);
+                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (il.subVectors(i[0], i[1]).add(i[0]), a = il);
                         const h = i[l % r],
                             u = i[(l + 1) % r];
-                        if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (ma.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = ma), "centripetal" === this.curveType || "chordal" === this.curveType) {
+                        if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (il.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = il), "centripetal" === this.curveType || "chordal" === this.curveType) {
                             const t = "chordal" === this.curveType ? .5 : .25;
                             let e = Math.pow(a.distanceToSquared(h), t),
                                 n = Math.pow(h.distanceToSquared(u), t),
                                 i = Math.pow(u.distanceToSquared(o), t);
-                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), fa.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i), ga.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i), va.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i)
-                        } else "catmullrom" === this.curveType && (fa.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), ga.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), va.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
-                        return n.set(fa.calc(c), ga.calc(c), va.calc(c)), n
+                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), rl.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i), sl.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i), al.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i)
+                        } else "catmullrom" === this.curveType && (rl.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), sl.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), al.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
+                        return n.set(rl.calc(c), sl.calc(c), al.calc(c)), n
                     }
                     copy(t) {
                         super.copy(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
                             this.points.push(n.clone())
                         }
@@ -26525,188 +26915,188 @@
                         }
                         return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
-                            this.points.push((new mt).fromArray(n))
+                            this.points.push((new Qe).fromArray(n))
                         }
                         return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                     }
                 }
 
-                function ya(t, e, n, i, r) {
+                function ll(t, e, n, i, r) {
                     const s = .5 * (i - e),
                         a = .5 * (r - n),
                         o = t * t;
                     return (2 * n - 2 * i + s + a) * (t * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * t + n
                 }
 
-                function _a(t, e, n, i) {
+                function cl(t, e, n, i) {
                     return function(t, e) {
                         const n = 1 - t;
                         return n * n * e
                     }(t, e) + function(t, e) {
                         return 2 * (1 - t) * t * e
                     }(t, n) + function(t, e) {
                         return t * t * e
                     }(t, i)
                 }
 
-                function Ma(t, e, n, i, r) {
+                function hl(t, e, n, i, r) {
                     return function(t, e) {
                         const n = 1 - t;
                         return n * n * n * e
                     }(t, e) + function(t, e) {
                         const n = 1 - t;
                         return 3 * n * n * t * e
                     }(t, n) + function(t, e) {
                         return 3 * (1 - t) * t * t * e
                     }(t, i) + function(t, e) {
                         return t * t * t * e
                     }(t, r)
                 }
-                xa.prototype.isCatmullRomCurve3 = !0;
-                class ba extends ha {
-                    constructor(t = new Y, e = new Y, n = new Y, i = new Y) {
+                ol.prototype.isCatmullRomCurve3 = !0;
+                class ul extends $o {
+                    constructor(t = new De, e = new De, n = new De, i = new De) {
                         super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                     }
-                    getPoint(t, e = new Y) {
+                    getPoint(t, e = new De) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2,
                             a = this.v3;
-                        return n.set(Ma(t, i.x, r.x, s.x, a.x), Ma(t, i.y, r.y, s.y, a.y)), n
+                        return n.set(hl(t, i.x, r.x, s.x, a.x), hl(t, i.y, r.y, s.y, a.y)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                     }
                 }
-                ba.prototype.isCubicBezierCurve = !0;
-                class wa extends ha {
-                    constructor(t = new mt, e = new mt, n = new mt, i = new mt) {
+                ul.prototype.isCubicBezierCurve = !0;
+                class dl extends $o {
+                    constructor(t = new Qe, e = new Qe, n = new Qe, i = new Qe) {
                         super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                     }
-                    getPoint(t, e = new mt) {
+                    getPoint(t, e = new Qe) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2,
                             a = this.v3;
-                        return n.set(Ma(t, i.x, r.x, s.x, a.x), Ma(t, i.y, r.y, s.y, a.y), Ma(t, i.z, r.z, s.z, a.z)), n
+                        return n.set(hl(t, i.x, r.x, s.x, a.x), hl(t, i.y, r.y, s.y, a.y), hl(t, i.z, r.z, s.z, a.z)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                     }
                 }
-                wa.prototype.isCubicBezierCurve3 = !0;
-                class Sa extends ha {
-                    constructor(t = new Y, e = new Y) {
+                dl.prototype.isCubicBezierCurve3 = !0;
+                class pl extends $o {
+                    constructor(t = new De, e = new De) {
                         super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
                     }
-                    getPoint(t, e = new Y) {
+                    getPoint(t, e = new De) {
                         const n = e;
                         return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                     }
                     getPointAt(t, e) {
                         return this.getPoint(t, e)
                     }
                     getTangent(t, e) {
-                        const n = e || new Y;
+                        const n = e || new De;
                         return n.copy(this.v2).sub(this.v1).normalize(), n
                     }
                     copy(t) {
                         return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                Sa.prototype.isLineCurve = !0;
-                class Ea extends ha {
-                    constructor(t = new Y, e = new Y, n = new Y) {
+                pl.prototype.isLineCurve = !0;
+                class ml extends $o {
+                    constructor(t = new De, e = new De, n = new De) {
                         super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
                     }
-                    getPoint(t, e = new Y) {
+                    getPoint(t, e = new De) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2;
-                        return n.set(_a(t, i.x, r.x, s.x), _a(t, i.y, r.y, s.y)), n
+                        return n.set(cl(t, i.x, r.x, s.x), cl(t, i.y, r.y, s.y)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                Ea.prototype.isQuadraticBezierCurve = !0;
-                class Ta extends ha {
-                    constructor(t = new mt, e = new mt, n = new mt) {
+                ml.prototype.isQuadraticBezierCurve = !0;
+                class fl extends $o {
+                    constructor(t = new Qe, e = new Qe, n = new Qe) {
                         super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
                     }
-                    getPoint(t, e = new mt) {
+                    getPoint(t, e = new Qe) {
                         const n = e,
                             i = this.v0,
                             r = this.v1,
                             s = this.v2;
-                        return n.set(_a(t, i.x, r.x, s.x), _a(t, i.y, r.y, s.y), _a(t, i.z, r.z, s.z)), n
+                        return n.set(cl(t, i.x, r.x, s.x), cl(t, i.y, r.y, s.y), cl(t, i.z, r.z, s.z)), n
                     }
                     copy(t) {
                         return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                     }
                 }
-                Ta.prototype.isQuadraticBezierCurve3 = !0;
-                class Aa extends ha {
+                fl.prototype.isQuadraticBezierCurve3 = !0;
+                class gl extends $o {
                     constructor(t = []) {
                         super(), this.type = "SplineCurve", this.points = t
                     }
-                    getPoint(t, e = new Y) {
+                    getPoint(t, e = new De) {
                         const n = e,
                             i = this.points,
                             r = (i.length - 1) * t,
                             s = Math.floor(r),
                             a = r - s,
                             o = i[0 === s ? s : s - 1],
                             l = i[s],
                             c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                             h = i[s > i.length - 3 ? i.length - 1 : s + 2];
-                        return n.set(ya(a, o.x, l.x, c.x, h.x), ya(a, o.y, l.y, c.y, h.y)), n
+                        return n.set(ll(a, o.x, l.x, c.x, h.x), ll(a, o.y, l.y, c.y, h.y)), n
                     }
                     copy(t) {
                         super.copy(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
                             this.points.push(n.clone())
                         }
@@ -26721,33 +27111,33 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.points = [];
                         for (let e = 0, n = t.points.length; e < n; e++) {
                             const n = t.points[e];
-                            this.points.push((new Y).fromArray(n))
+                            this.points.push((new De).fromArray(n))
                         }
                         return this
                     }
                 }
-                Aa.prototype.isSplineCurve = !0;
-                var Ra = Object.freeze({
+                gl.prototype.isSplineCurve = !0;
+                var vl = Object.freeze({
                     __proto__: null,
-                    ArcCurve: da,
-                    CatmullRomCurve3: xa,
-                    CubicBezierCurve: ba,
-                    CubicBezierCurve3: wa,
-                    EllipseCurve: ua,
-                    LineCurve: Sa,
-                    LineCurve3: class extends ha {
-                        constructor(t = new mt, e = new mt) {
+                    ArcCurve: el,
+                    CatmullRomCurve3: ol,
+                    CubicBezierCurve: ul,
+                    CubicBezierCurve3: dl,
+                    EllipseCurve: tl,
+                    LineCurve: pl,
+                    LineCurve3: class extends $o {
+                        constructor(t = new Qe, e = new Qe) {
                             super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                         }
-                        getPoint(t, e = new mt) {
+                        getPoint(t, e = new Qe) {
                             const n = e;
                             return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                         }
                         getPointAt(t, e) {
                             return this.getPoint(t, e)
                         }
                         copy(t) {
@@ -26757,29 +27147,29 @@
                             const t = super.toJSON();
                             return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                         }
                         fromJSON(t) {
                             return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                         }
                     },
-                    QuadraticBezierCurve: Ea,
-                    QuadraticBezierCurve3: Ta,
-                    SplineCurve: Aa
+                    QuadraticBezierCurve: ml,
+                    QuadraticBezierCurve3: fl,
+                    SplineCurve: gl
                 });
-                class La extends ha {
+                class xl extends $o {
                     constructor() {
                         super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                     }
                     add(t) {
                         this.curves.push(t)
                     }
                     closePath() {
                         const t = this.curves[0].getPoint(0),
                             e = this.curves[this.curves.length - 1].getPoint(1);
-                        t.equals(e) || this.curves.push(new Sa(e, t))
+                        t.equals(e) || this.curves.push(new pl(e, t))
                     }
                     getPoint(t, e) {
                         const n = t * this.getLength(),
                             i = this.getCurveLengths();
                         let r = 0;
                         for (; r < i.length;) {
                             if (i[r] >= n) {
@@ -26843,46 +27233,46 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                         for (let e = 0, n = t.curves.length; e < n; e++) {
                             const n = t.curves[e];
-                            this.curves.push((new Ra[n.type]).fromJSON(n))
+                            this.curves.push((new vl[n.type]).fromJSON(n))
                         }
                         return this
                     }
                 }
-                class Ca extends La {
+                class yl extends xl {
                     constructor(t) {
-                        super(), this.type = "Path", this.currentPoint = new Y, t && this.setFromPoints(t)
+                        super(), this.type = "Path", this.currentPoint = new De, t && this.setFromPoints(t)
                     }
                     setFromPoints(t) {
                         this.moveTo(t[0].x, t[0].y);
                         for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                         return this
                     }
                     moveTo(t, e) {
                         return this.currentPoint.set(t, e), this
                     }
                     lineTo(t, e) {
-                        const n = new Sa(this.currentPoint.clone(), new Y(t, e));
+                        const n = new pl(this.currentPoint.clone(), new De(t, e));
                         return this.curves.push(n), this.currentPoint.set(t, e), this
                     }
                     quadraticCurveTo(t, e, n, i) {
-                        const r = new Ea(this.currentPoint.clone(), new Y(t, e), new Y(n, i));
+                        const r = new ml(this.currentPoint.clone(), new De(t, e), new De(n, i));
                         return this.curves.push(r), this.currentPoint.set(n, i), this
                     }
                     bezierCurveTo(t, e, n, i, r, s) {
-                        const a = new ba(this.currentPoint.clone(), new Y(t, e), new Y(n, i), new Y(r, s));
+                        const a = new ul(this.currentPoint.clone(), new De(t, e), new De(n, i), new De(r, s));
                         return this.curves.push(a), this.currentPoint.set(r, s), this
                     }
                     splineThru(t) {
                         const e = [this.currentPoint.clone()].concat(t),
-                            n = new Aa(e);
+                            n = new gl(e);
                         return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                     }
                     arc(t, e, n, i, r, s) {
                         const a = this.currentPoint.x,
                             o = this.currentPoint.y;
                         return this.absarc(t + a, e + o, n, i, r, s), this
                     }
@@ -26891,15 +27281,15 @@
                     }
                     ellipse(t, e, n, i, r, s, a, o) {
                         const l = this.currentPoint.x,
                             c = this.currentPoint.y;
                         return this.absellipse(t + l, e + c, n, i, r, s, a, o), this
                     }
                     absellipse(t, e, n, i, r, s, a, o) {
-                        const l = new ua(t, e, n, i, r, s, a, o);
+                        const l = new tl(t, e, n, i, r, s, a, o);
                         if (this.curves.length > 0) {
                             const t = l.getPoint(0);
                             t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                         }
                         this.curves.push(l);
                         const c = l.getPoint(1);
                         return this.currentPoint.copy(c), this
@@ -26911,17 +27301,17 @@
                         const t = super.toJSON();
                         return t.currentPoint = this.currentPoint.toArray(), t
                     }
                     fromJSON(t) {
                         return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                     }
                 }
-                class Pa extends Ca {
+                class _l extends yl {
                     constructor(t) {
-                        super(t), this.uuid = k(), this.type = "Shape", this.holes = []
+                        super(t), this.uuid = Ae(), this.type = "Shape", this.holes = []
                     }
                     getPointsHoles(t) {
                         const e = [];
                         for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                         return e
                     }
                     extractPoints(t) {
@@ -26947,53 +27337,53 @@
                         }
                         return t
                     }
                     fromJSON(t) {
                         super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                         for (let e = 0, n = t.holes.length; e < n; e++) {
                             const n = t.holes[e];
-                            this.holes.push((new Ca).fromJSON(n))
+                            this.holes.push((new yl).fromJSON(n))
                         }
                         return this
                     }
                 }
 
-                function Da(t, e, n, i, r) {
+                function Ml(t, e, n, i, r) {
                     let s, a;
                     if (r === function(t, e, n, i) {
                             let r = 0;
                             for (let s = e, a = n - i; s < n; s += i) r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;
                             return r
                         }(t, e, n, i) > 0)
-                        for (s = e; s < n; s += i) a = $a(s, t[s], t[s + 1], a);
+                        for (s = e; s < n; s += i) a = Vl(s, t[s], t[s + 1], a);
                     else
-                        for (s = n - i; s >= e; s -= i) a = $a(s, t[s], t[s + 1], a);
-                    return a && qa(a, a.next) && (to(a), a = a.next), a
+                        for (s = n - i; s >= e; s -= i) a = Vl(s, t[s], t[s + 1], a);
+                    return a && Ul(a, a.next) && (kl(a), a = a.next), a
                 }
 
-                function Ia(t, e) {
+                function bl(t, e) {
                     if (!t) return t;
                     e || (e = t);
                     let n, i = t;
                     do {
-                        if (n = !1, i.steiner || !qa(i, i.next) && 0 !== Xa(i.prev, i, i.next)) i = i.next;
+                        if (n = !1, i.steiner || !Ul(i, i.next) && 0 !== Ol(i.prev, i, i.next)) i = i.next;
                         else {
-                            if (to(i), i = e = i.prev, i === i.next) break;
+                            if (kl(i), i = e = i.prev, i === i.next) break;
                             n = !0
                         }
                     } while (n || i !== e);
                     return e
                 }
 
-                function Na(t, e, n, i, r, s, a) {
+                function wl(t, e, n, i, r, s, a) {
                     if (!t) return;
                     !a && s && function(t, e, n, i) {
                         let r = t;
                         do {
-                            null === r.z && (r.z = Va(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
+                            null === r.z && (r.z = Pl(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                         } while (r !== t);
                         r.prevZ.nextZ = null, r.prevZ = null,
                             function(t) {
                                 let e, n, i, r, s, a, o, l, c = 1;
                                 do {
                                     for (n = t, t = null, s = null, a = 0; n;) {
                                         for (a++, i = n, o = 0, e = 0; e < c && (o++, i = i.nextZ, i); e++);
@@ -27002,93 +27392,93 @@
                                     }
                                     s.nextZ = null, c *= 2
                                 } while (a > 1)
                             }(r)
                     }(t, i, r, s);
                     let o, l, c = t;
                     for (; t.prev !== t.next;)
-                        if (o = t.prev, l = t.next, s ? Ua(t, i, r, s) : Oa(t)) e.push(o.i / n), e.push(t.i / n), e.push(l.i / n), to(t), t = l.next, c = l.next;
+                        if (o = t.prev, l = t.next, s ? El(t, i, r, s) : Sl(t)) e.push(o.i / n), e.push(t.i / n), e.push(l.i / n), kl(t), t = l.next, c = l.next;
                         else if ((t = l) === c) {
-                        a ? 1 === a ? Na(t = Ba(Ia(t), e, n), e, n, i, r, s, 2) : 2 === a && Fa(t, e, n, i, r, s) : Na(Ia(t), e, n, i, r, s, 1);
+                        a ? 1 === a ? wl(t = Tl(bl(t), e, n), e, n, i, r, s, 2) : 2 === a && Al(t, e, n, i, r, s) : wl(bl(t), e, n, i, r, s, 1);
                         break
                     }
                 }
 
-                function Oa(t) {
+                function Sl(t) {
                     const e = t.prev,
                         n = t,
                         i = t.next;
-                    if (Xa(e, n, i) >= 0) return !1;
+                    if (Ol(e, n, i) >= 0) return !1;
                     let r = t.next.next;
                     for (; r !== t.prev;) {
-                        if (Wa(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Xa(r.prev, r, r.next) >= 0) return !1;
+                        if (Il(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Ol(r.prev, r, r.next) >= 0) return !1;
                         r = r.next
                     }
                     return !0
                 }
 
-                function Ua(t, e, n, i) {
+                function El(t, e, n, i) {
                     const r = t.prev,
                         s = t,
                         a = t.next;
-                    if (Xa(r, s, a) >= 0) return !1;
+                    if (Ol(r, s, a) >= 0) return !1;
                     const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x,
                         l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y,
                         c = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x,
                         h = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y,
-                        u = Va(o, l, e, n, i),
-                        d = Va(c, h, e, n, i);
+                        u = Pl(o, l, e, n, i),
+                        d = Pl(c, h, e, n, i);
                     let p = t.prevZ,
                         m = t.nextZ;
                     for (; p && p.z >= u && m && m.z <= d;) {
-                        if (p !== t.prev && p !== t.next && Wa(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Xa(p.prev, p, p.next) >= 0) return !1;
-                        if (p = p.prevZ, m !== t.prev && m !== t.next && Wa(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Xa(m.prev, m, m.next) >= 0) return !1;
+                        if (p !== t.prev && p !== t.next && Il(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Ol(p.prev, p, p.next) >= 0) return !1;
+                        if (p = p.prevZ, m !== t.prev && m !== t.next && Il(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Ol(m.prev, m, m.next) >= 0) return !1;
                         m = m.nextZ
                     }
                     for (; p && p.z >= u;) {
-                        if (p !== t.prev && p !== t.next && Wa(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Xa(p.prev, p, p.next) >= 0) return !1;
+                        if (p !== t.prev && p !== t.next && Il(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Ol(p.prev, p, p.next) >= 0) return !1;
                         p = p.prevZ
                     }
                     for (; m && m.z <= d;) {
-                        if (m !== t.prev && m !== t.next && Wa(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Xa(m.prev, m, m.next) >= 0) return !1;
+                        if (m !== t.prev && m !== t.next && Il(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && Ol(m.prev, m, m.next) >= 0) return !1;
                         m = m.nextZ
                     }
                     return !0
                 }
 
-                function Ba(t, e, n) {
+                function Tl(t, e, n) {
                     let i = t;
                     do {
                         const r = i.prev,
                             s = i.next.next;
-                        !qa(r, s) && Ya(r, i, i.next, s) && Ka(r, s) && Ka(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), to(i), to(i.next), i = t = s), i = i.next
+                        !Ul(r, s) && Bl(r, i, i.next, s) && Hl(r, s) && Hl(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), kl(i), kl(i.next), i = t = s), i = i.next
                     } while (i !== t);
-                    return Ia(i)
+                    return bl(i)
                 }
 
-                function Fa(t, e, n, i, r, s) {
+                function Al(t, e, n, i, r, s) {
                     let a = t;
                     do {
                         let t = a.next.next;
                         for (; t !== a.prev;) {
-                            if (a.i !== t.i && ja(a, t)) {
-                                let o = Qa(a, t);
-                                return a = Ia(a, a.next), o = Ia(o, o.next), Na(a, e, n, i, r, s), void Na(o, e, n, i, r, s)
+                            if (a.i !== t.i && Nl(a, t)) {
+                                let o = Gl(a, t);
+                                return a = bl(a, a.next), o = bl(o, o.next), wl(a, e, n, i, r, s), void wl(o, e, n, i, r, s)
                             }
                             t = t.next
                         }
                         a = a.next
                     } while (a !== t)
                 }
 
-                function za(t, e) {
+                function Rl(t, e) {
                     return t.x - e.x
                 }
 
-                function Ha(t, e) {
+                function Ll(t, e) {
                     if (e = function(t, e) {
                             let n = e;
                             const i = t.x,
                                 r = t.y;
                             let s, a = -1 / 0;
                             do {
                                 if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
@@ -27107,165 +27497,165 @@
                             if (i === a) return s;
                             const o = s,
                                 l = s.x,
                                 c = s.y;
                             let h, u = 1 / 0;
                             n = s;
                             do {
-                                i >= n.x && n.x >= l && i !== n.x && Wa(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), Ka(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && Ga(s, n))) && (s = n, u = h)), n = n.next
+                                i >= n.x && n.x >= l && i !== n.x && Il(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), Hl(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && Cl(s, n))) && (s = n, u = h)), n = n.next
                             } while (n !== o);
                             return s
                         }(t, e), e) {
-                        const n = Qa(e, t);
-                        Ia(e, e.next), Ia(n, n.next)
+                        const n = Gl(e, t);
+                        bl(e, e.next), bl(n, n.next)
                     }
                 }
 
-                function Ga(t, e) {
-                    return Xa(t.prev, t, e.prev) < 0 && Xa(e.next, t, t.next) < 0
+                function Cl(t, e) {
+                    return Ol(t.prev, t, e.prev) < 0 && Ol(e.next, t, t.next) < 0
                 }
 
-                function Va(t, e, n, i, r) {
+                function Pl(t, e, n, i, r) {
                     return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                 }
 
-                function ka(t) {
+                function Dl(t) {
                     let e = t,
                         n = t;
                     do {
                         (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                     } while (e !== t);
                     return n
                 }
 
-                function Wa(t, e, n, i, r, s, a, o) {
+                function Il(t, e, n, i, r, s, a, o) {
                     return (r - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (i - o) - (n - a) * (e - o) >= 0 && (n - a) * (s - o) - (r - a) * (i - o) >= 0
                 }
 
-                function ja(t, e) {
+                function Nl(t, e) {
                     return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                         let n = t;
                         do {
-                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Ya(n, n.next, t, e)) return !0;
+                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Bl(n, n.next, t, e)) return !0;
                             n = n.next
                         } while (n !== t);
                         return !1
-                    }(t, e) && (Ka(t, e) && Ka(e, t) && function(t, e) {
+                    }(t, e) && (Hl(t, e) && Hl(e, t) && function(t, e) {
                         let n = t,
                             i = !1;
                         const r = (t.x + e.x) / 2,
                             s = (t.y + e.y) / 2;
                         do {
                             n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                         } while (n !== t);
                         return i
-                    }(t, e) && (Xa(t.prev, t, e.prev) || Xa(t, e.prev, e)) || qa(t, e) && Xa(t.prev, t, t.next) > 0 && Xa(e.prev, e, e.next) > 0)
+                    }(t, e) && (Ol(t.prev, t, e.prev) || Ol(t, e.prev, e)) || Ul(t, e) && Ol(t.prev, t, t.next) > 0 && Ol(e.prev, e, e.next) > 0)
                 }
 
-                function Xa(t, e, n) {
+                function Ol(t, e, n) {
                     return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
                 }
 
-                function qa(t, e) {
+                function Ul(t, e) {
                     return t.x === e.x && t.y === e.y
                 }
 
-                function Ya(t, e, n, i) {
-                    const r = Za(Xa(t, e, n)),
-                        s = Za(Xa(t, e, i)),
-                        a = Za(Xa(n, i, t)),
-                        o = Za(Xa(n, i, e));
-                    return r !== s && a !== o || !(0 !== r || !Ja(t, n, e)) || !(0 !== s || !Ja(t, i, e)) || !(0 !== a || !Ja(n, t, i)) || !(0 !== o || !Ja(n, e, i))
+                function Bl(t, e, n, i) {
+                    const r = zl(Ol(t, e, n)),
+                        s = zl(Ol(t, e, i)),
+                        a = zl(Ol(n, i, t)),
+                        o = zl(Ol(n, i, e));
+                    return r !== s && a !== o || !(0 !== r || !Fl(t, n, e)) || !(0 !== s || !Fl(t, i, e)) || !(0 !== a || !Fl(n, t, i)) || !(0 !== o || !Fl(n, e, i))
                 }
 
-                function Ja(t, e, n) {
+                function Fl(t, e, n) {
                     return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
                 }
 
-                function Za(t) {
+                function zl(t) {
                     return t > 0 ? 1 : t < 0 ? -1 : 0
                 }
 
-                function Ka(t, e) {
-                    return Xa(t.prev, t, t.next) < 0 ? Xa(t, e, t.next) >= 0 && Xa(t, t.prev, e) >= 0 : Xa(t, e, t.prev) < 0 || Xa(t, t.next, e) < 0
+                function Hl(t, e) {
+                    return Ol(t.prev, t, t.next) < 0 ? Ol(t, e, t.next) >= 0 && Ol(t, t.prev, e) >= 0 : Ol(t, e, t.prev) < 0 || Ol(t, t.next, e) < 0
                 }
 
-                function Qa(t, e) {
-                    const n = new eo(t.i, t.x, t.y),
-                        i = new eo(e.i, e.x, e.y),
+                function Gl(t, e) {
+                    const n = new Wl(t.i, t.x, t.y),
+                        i = new Wl(e.i, e.x, e.y),
                         r = t.next,
                         s = e.prev;
                     return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
                 }
 
-                function $a(t, e, n, i) {
-                    const r = new eo(t, e, n);
+                function Vl(t, e, n, i) {
+                    const r = new Wl(t, e, n);
                     return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
                 }
 
-                function to(t) {
+                function kl(t) {
                     t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                 }
 
-                function eo(t, e, n) {
+                function Wl(t, e, n) {
                     this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
                 }
-                class no {
+                class jl {
                     static area(t) {
                         const e = t.length;
                         let n = 0;
                         for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                         return .5 * n
                     }
                     static isClockWise(t) {
-                        return no.area(t) < 0
+                        return jl.area(t) < 0
                     }
                     static triangulateShape(t, e) {
                         const n = [],
                             i = [],
                             r = [];
-                        io(t), ro(n, t);
+                        Xl(t), ql(n, t);
                         let s = t.length;
-                        e.forEach(io);
-                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, ro(n, e[t]);
+                        e.forEach(Xl);
+                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, ql(n, e[t]);
                         const a = function(t, e, n = 2) {
                             const i = e && e.length,
                                 r = i ? e[0] * n : t.length;
-                            let s = Da(t, 0, r, n, !0);
+                            let s = Ml(t, 0, r, n, !0);
                             const a = [];
                             if (!s || s.next === s.prev) return a;
                             let o, l, c, h, u, d, p;
                             if (i && (s = function(t, e, n, i) {
                                     const r = [];
                                     let s, a, o, l, c;
-                                    for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : t.length, c = Da(t, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(ka(c));
-                                    for (r.sort(za), s = 0; s < r.length; s++) Ha(r[s], n), n = Ia(n, n.next);
+                                    for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : t.length, c = Ml(t, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(Dl(c));
+                                    for (r.sort(Rl), s = 0; s < r.length; s++) Ll(r[s], n), n = bl(n, n.next);
                                     return n
                                 }(t, e, s, n)), t.length > 80 * n) {
                                 o = c = t[0], l = h = t[1];
                                 for (let e = n; e < r; e += n) u = t[e], d = t[e + 1], u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
                                 p = Math.max(c - o, h - l), p = 0 !== p ? 1 / p : 0
                             }
-                            return Na(s, a, n, o, l, p), a
+                            return wl(s, a, n, o, l, p), a
                         }(n, i);
                         for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
                         return r
                     }
                 }
 
-                function io(t) {
+                function Xl(t) {
                     const e = t.length;
                     e > 2 && t[e - 1].equals(t[0]) && t.pop()
                 }
 
-                function ro(t, e) {
+                function ql(t, e) {
                     for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
                 }
-                class so extends We {
-                    constructor(t = new Pa([new Y(.5, .5), new Y(-.5, .5), new Y(-.5, -.5), new Y(.5, -.5)]), e = {}) {
+                class Yl extends Li {
+                    constructor(t = new _l([new De(.5, .5), new De(-.5, .5), new De(-.5, -.5), new De(.5, -.5)]), e = {}) {
                         super(), this.type = "ExtrudeGeometry", this.parameters = {
                             shapes: t,
                             options: e
                         }, t = Array.isArray(t) ? t : [t];
                         const n = this,
                             i = [],
                             r = [];
@@ -27278,29 +27668,29 @@
                             let l = void 0 !== e.depth ? e.depth : 1,
                                 c = void 0 === e.bevelEnabled || e.bevelEnabled,
                                 h = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                                 u = void 0 !== e.bevelSize ? e.bevelSize : h - .1,
                                 d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                 p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                             const m = e.extrudePath,
-                                f = void 0 !== e.UVGenerator ? e.UVGenerator : ao;
+                                f = void 0 !== e.UVGenerator ? e.UVGenerator : Jl;
                             void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                             let g, v, x, y, _, M = !1;
-                            m && (g = m.getSpacedPoints(o), M = !0, c = !1, v = m.computeFrenetFrames(o, !1), x = new mt, y = new mt, _ = new mt), c || (p = 0, h = 0, u = 0, d = 0);
+                            m && (g = m.getSpacedPoints(o), M = !0, c = !1, v = m.computeFrenetFrames(o, !1), x = new Qe, y = new Qe, _ = new Qe), c || (p = 0, h = 0, u = 0, d = 0);
                             const b = t.extractPoints(a);
                             let w = b.shape;
                             const S = b.holes;
-                            if (!no.isClockWise(w)) {
+                            if (!jl.isClockWise(w)) {
                                 w = w.reverse();
                                 for (let t = 0, e = S.length; t < e; t++) {
                                     const e = S[t];
-                                    no.isClockWise(e) && (S[t] = e.reverse())
+                                    jl.isClockWise(e) && (S[t] = e.reverse())
                                 }
                             }
-                            const E = no.triangulateShape(w, S),
+                            const E = jl.triangulateShape(w, S),
                                 T = w;
                             for (let t = 0, e = S.length; t < e; t++) {
                                 const e = S[t];
                                 w = w.concat(e)
                             }
 
                             function A(t, e, n) {
@@ -27321,21 +27711,21 @@
                                     const u = Math.sqrt(h),
                                         d = Math.sqrt(l * l + c * c),
                                         p = e.x - o / u,
                                         m = e.y + a / u,
                                         f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (a * c - o * l);
                                     i = p + a * f - t.x, r = m + o * f - t.y;
                                     const g = i * i + r * r;
-                                    if (g <= 2) return new Y(i, r);
+                                    if (g <= 2) return new De(i, r);
                                     s = Math.sqrt(g / 2)
                                 } else {
                                     let t = !1;
                                     a > Number.EPSILON ? l > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(c) && (t = !0), t ? (i = -o, r = a, s = Math.sqrt(h)) : (i = a, r = o, s = Math.sqrt(h / 2))
                                 }
-                                return new Y(i / s, r / s)
+                                return new De(i / s, r / s)
                             }
                             const P = [];
                             for (let t = 0, e = T.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), P[t] = C(T[t], T[n], T[i]);
                             const D = [];
                             let I, N = P.concat();
                             for (let t = 0, e = S.length; t < e; t++) {
                                 const e = S[t];
@@ -27459,15 +27849,15 @@
                                 for (let t = 0, n = S.length; t < n; t++) {
                                     const n = S[t];
                                     U(n, e), e += n.length
                                 }
                                 n.addGroup(t, i.length / 3 - t, 1)
                             }()
                         }
-                        this.setAttribute("position", new Ue(i, 3)), this.setAttribute("uv", new Ue(r, 2)), this.computeVertexNormals()
+                        this.setAttribute("position", new Mi(i, 3)), this.setAttribute("uv", new Mi(r, 2)), this.computeVertexNormals()
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return function(t, e, n) {
                             if (n.shapes = [], Array.isArray(t))
                                 for (let e = 0, i = t.length; e < i; e++) {
                                     const i = t[e];
@@ -27479,45 +27869,45 @@
                     static fromJSON(t, e) {
                         const n = [];
                         for (let i = 0, r = t.shapes.length; i < r; i++) {
                             const r = e[t.shapes[i]];
                             n.push(r)
                         }
                         const i = t.options.extrudePath;
-                        return void 0 !== i && (t.options.extrudePath = (new Ra[i.type]).fromJSON(i)), new so(n, t.options)
+                        return void 0 !== i && (t.options.extrudePath = (new vl[i.type]).fromJSON(i)), new Yl(n, t.options)
                     }
                 }
-                const ao = {
+                const Jl = {
                     generateTopUV: function(t, e, n, i, r) {
                         const s = e[3 * n],
                             a = e[3 * n + 1],
                             o = e[3 * i],
                             l = e[3 * i + 1],
                             c = e[3 * r],
                             h = e[3 * r + 1];
-                        return [new Y(s, a), new Y(o, l), new Y(c, h)]
+                        return [new De(s, a), new De(o, l), new De(c, h)]
                     },
                     generateSideWallUV: function(t, e, n, i, r, s) {
                         const a = e[3 * n],
                             o = e[3 * n + 1],
                             l = e[3 * n + 2],
                             c = e[3 * i],
                             h = e[3 * i + 1],
                             u = e[3 * i + 2],
                             d = e[3 * r],
                             p = e[3 * r + 1],
                             m = e[3 * r + 2],
                             f = e[3 * s],
                             g = e[3 * s + 1],
                             v = e[3 * s + 2];
-                        return Math.abs(o - h) < Math.abs(a - c) ? [new Y(a, 1 - l), new Y(c, 1 - u), new Y(d, 1 - m), new Y(f, 1 - v)] : [new Y(o, 1 - l), new Y(h, 1 - u), new Y(p, 1 - m), new Y(g, 1 - v)]
+                        return Math.abs(o - h) < Math.abs(a - c) ? [new De(a, 1 - l), new De(c, 1 - u), new De(d, 1 - m), new De(f, 1 - v)] : [new De(o, 1 - l), new De(h, 1 - u), new De(p, 1 - m), new De(g, 1 - v)]
                     }
                 };
-                class oo extends We {
-                    constructor(t = new Pa([new Y(0, .5), new Y(-.5, -.5), new Y(.5, -.5)]), e = 12) {
+                class Zl extends Li {
+                    constructor(t = new _l([new De(0, .5), new De(-.5, -.5), new De(.5, -.5)]), e = 12) {
                         super(), this.type = "ShapeGeometry", this.parameters = {
                             shapes: t,
                             curveSegments: e
                         };
                         const n = [],
                             i = [],
                             r = [],
@@ -27529,20 +27919,20 @@
                             for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(a, o, e), a += o, o = 0;
 
                         function l(t) {
                             const a = i.length / 3,
                                 l = t.extractPoints(e);
                             let c = l.shape;
                             const h = l.holes;
-                            !1 === no.isClockWise(c) && (c = c.reverse());
+                            !1 === jl.isClockWise(c) && (c = c.reverse());
                             for (let t = 0, e = h.length; t < e; t++) {
                                 const e = h[t];
-                                !0 === no.isClockWise(e) && (h[t] = e.reverse())
+                                !0 === jl.isClockWise(e) && (h[t] = e.reverse())
                             }
-                            const u = no.triangulateShape(c, h);
+                            const u = jl.triangulateShape(c, h);
                             for (let t = 0, e = h.length; t < e; t++) {
                                 const e = h[t];
                                 c = c.concat(e)
                             }
                             for (let t = 0, e = c.length; t < e; t++) {
                                 const e = c[t];
                                 i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
@@ -27551,15 +27941,15 @@
                                 const e = u[t],
                                     i = e[0] + a,
                                     r = e[1] + a,
                                     s = e[2] + a;
                                 n.push(i, r, s), o += 3
                             }
                         }
-                        this.setIndex(n), this.setAttribute("position", new Ue(i, 3)), this.setAttribute("normal", new Ue(r, 3)), this.setAttribute("uv", new Ue(s, 2))
+                        this.setIndex(n), this.setAttribute("position", new Mi(i, 3)), this.setAttribute("normal", new Mi(r, 3)), this.setAttribute("uv", new Mi(s, 2))
                     }
                     toJSON() {
                         const t = super.toJSON();
                         return function(t, e) {
                             if (e.shapes = [], Array.isArray(t))
                                 for (let n = 0, i = t.length; n < i; n++) {
                                     const i = t[n];
@@ -27570,50 +27960,50 @@
                     }
                     static fromJSON(t, e) {
                         const n = [];
                         for (let i = 0, r = t.shapes.length; i < r; i++) {
                             const r = e[t.shapes[i]];
                             n.push(r)
                         }
-                        return new oo(n, t.curveSegments)
+                        return new Zl(n, t.curveSegments)
                     }
-                }(class extends Le {
+                }(class extends mi {
                     constructor(t) {
-                        super(), this.type = "ShadowMaterial", this.color = new rt(0), this.transparent = !0, this.setValues(t)
+                        super(), this.type = "ShadowMaterial", this.color = new Ve(0), this.transparent = !0, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this
                     }
                 }).prototype.isShadowMaterial = !0;
-                class lo extends Le {
+                class Kl extends mi {
                     constructor(t) {
                         super(), this.defines = {
                             STANDARD: ""
-                        }, this.type = "MeshStandardMaterial", this.color = new rt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
+                        }, this.type = "MeshStandardMaterial", this.color = new Ve(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ge, this.normalScale = new De(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.defines = {
                             STANDARD: ""
                         }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                     }
                 }
-                lo.prototype.isMeshStandardMaterial = !0;
-                (class extends lo {
+                Kl.prototype.isMeshStandardMaterial = !0;
+                (class extends Kl {
                     constructor(t) {
                         super(), this.defines = {
                             STANDARD: "",
                             PHYSICAL: ""
-                        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Y(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
+                        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new De(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                             get: function() {
-                                return W(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
+                                return Re(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                             },
                             set: function(t) {
                                 this.ior = (1 + .4 * t) / (1 - .4 * t)
                             }
-                        }), this.sheenColor = new rt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new rt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new rt(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
+                        }), this.sheenColor = new Ve(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Ve(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ve(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
                     }
                     get sheen() {
                         return this._sheen
                     }
                     set sheen(t) {
                         this._sheen > 0 != t > 0 && this.version++, this._sheen = t
                     }
@@ -27632,71 +28022,71 @@
                     copy(t) {
                         return super.copy(t), this.defines = {
                             STANDARD: "",
                             PHYSICAL: ""
                         }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
                     }
                 }).prototype.isMeshPhysicalMaterial = !0;
-                (class extends Le {
+                (class extends mi {
                     constructor(t) {
-                        super(), this.type = "MeshPhongMaterial", this.color = new rt(16777215), this.specular = new rt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
+                        super(), this.type = "MeshPhongMaterial", this.color = new Ve(16777215), this.specular = new Ve(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ge, this.normalScale = new De(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = k, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                     }
                 }).prototype.isMeshPhongMaterial = !0;
-                (class extends Le {
+                (class extends mi {
                     constructor(t) {
                         super(), this.defines = {
                             TOON: ""
-                        }, this.type = "MeshToonMaterial", this.color = new rt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        }, this.type = "MeshToonMaterial", this.color = new Ve(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ge, this.normalScale = new De(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }).prototype.isMeshToonMaterial = !0;
-                (class extends Le {
+                (class extends mi {
                     constructor(t) {
-                        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
+                        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ge, this.normalScale = new De(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
                     }
                 }).prototype.isMeshNormalMaterial = !0;
-                (class extends Le {
+                (class extends mi {
                     constructor(t) {
-                        super(), this.type = "MeshLambertMaterial", this.color = new rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
+                        super(), this.type = "MeshLambertMaterial", this.color = new Ve(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = k, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                     }
                 }).prototype.isMeshLambertMaterial = !0;
-                (class extends Le {
+                (class extends mi {
                     constructor(t) {
                         super(), this.defines = {
                             MATCAP: ""
-                        }, this.type = "MeshMatcapMaterial", this.color = new rt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
+                        }, this.type = "MeshMatcapMaterial", this.color = new Ve(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ge, this.normalScale = new De(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.defines = {
                             MATCAP: ""
                         }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this
                     }
                 }).prototype.isMeshMatcapMaterial = !0;
-                (class extends Ys {
+                (class extends Bo {
                     constructor(t) {
                         super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                     }
                     copy(t) {
                         return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
                     }
                 }).prototype.isLineDashedMaterial = !0;
-                const co = {
+                const Ql = {
                     arraySlice: function(t, e, n) {
-                        return co.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
+                        return Ql.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                     },
                     convertArray: function(t, e, n) {
                         return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                     },
                     isTypedArray: function(t) {
                         return ArrayBuffer.isView(t) && !(t instanceof DataView)
                     },
@@ -27749,15 +28139,15 @@
                             for (let t = 0; t < e.times.length; ++t) {
                                 const s = e.times[t] * r;
                                 if (!(s < n || s >= i)) {
                                     l.push(e.times[t]);
                                     for (let n = 0; n < o; ++n) c.push(e.values[t * o + n])
                                 }
                             }
-                            0 !== l.length && (e.times = co.convertArray(l, e.times.constructor), e.values = co.convertArray(c, e.values.constructor), a.push(e))
+                            0 !== l.length && (e.times = Ql.convertArray(l, e.times.constructor), e.values = Ql.convertArray(c, e.values.constructor), a.push(e))
                         }
                         s.tracks = a;
                         let o = 1 / 0;
                         for (let t = 0; t < s.tracks.length; ++t) o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
                         for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);
                         return s.resetDuration(), s
                     },
@@ -27780,40 +28170,40 @@
                             const h = a.getValueSize();
                             a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                             const u = i.times.length - 1;
                             let d;
                             if (s <= i.times[0]) {
                                 const t = o,
                                     e = l - o;
-                                d = co.arraySlice(i.values, t, e)
+                                d = Ql.arraySlice(i.values, t, e)
                             } else if (s >= i.times[u]) {
                                 const t = u * l + o,
                                     e = t + l - o;
-                                d = co.arraySlice(i.values, t, e)
+                                d = Ql.arraySlice(i.values, t, e)
                             } else {
                                 const t = i.createInterpolant(),
                                     e = o,
                                     n = l - o;
-                                t.evaluate(s), d = co.arraySlice(t.resultBuffer, e, n)
+                                t.evaluate(s), d = Ql.arraySlice(t.resultBuffer, e, n)
                             }
-                            "quaternion" === r && (new pt).fromArray(d).normalize().conjugate().toArray(d);
+                            "quaternion" === r && (new Ke).fromArray(d).normalize().conjugate().toArray(d);
                             const p = a.times.length;
                             for (let t = 0; t < p; ++t) {
                                 const e = t * h + c;
-                                if ("quaternion" === r) pt.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
+                                if ("quaternion" === r) Ke.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                                 else {
                                     const t = h - 2 * c;
                                     for (let n = 0; n < t; ++n) a.values[e + n] -= d[n]
                                 }
                             }
                         }
                         return t.blendMode = 2501, t
                     }
                 };
-                class ho {
+                class $l {
                     constructor(t, e, n, i) {
                         this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                     }
                     evaluate(t) {
                         const e = this.parameterPositions;
                         let n = this._cachedIndex,
                             i = e[n],
@@ -27870,43 +28260,43 @@
                         return e
                     }
                     interpolate_() {
                         throw new Error("call to abstract method")
                     }
                     intervalChanged_() {}
                 }
-                ho.prototype.beforeStart_ = ho.prototype.copySampleValue_, ho.prototype.afterEnd_ = ho.prototype.copySampleValue_;
-                class uo extends ho {
+                $l.prototype.beforeStart_ = $l.prototype.copySampleValue_, $l.prototype.afterEnd_ = $l.prototype.copySampleValue_;
+                class tc extends $l {
                     constructor(t, e, n, i) {
                         super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
-                            endingStart: L,
-                            endingEnd: L
+                            endingStart: he,
+                            endingEnd: he
                         }
                     }
                     intervalChanged_(t, e, n) {
                         const i = this.parameterPositions;
                         let r = t - 2,
                             s = t + 1,
                             a = i[r],
                             o = i[s];
                         if (void 0 === a) switch (this.getSettings_().endingStart) {
-                            case C:
+                            case ue:
                                 r = t, a = 2 * e - n;
                                 break;
-                            case P:
+                            case de:
                                 r = i.length - 2, a = e + i[r] - i[r + 1];
                                 break;
                             default:
                                 r = t, a = n
                         }
                         if (void 0 === o) switch (this.getSettings_().endingEnd) {
-                            case C:
+                            case ue:
                                 s = t, o = 2 * n - e;
                                 break;
-                            case P:
+                            case de:
                                 s = 1, o = n + i[1] - i[0];
                                 break;
                             default:
                                 s = t - 1, o = e
                         }
                         const l = .5 * (n - e),
                             c = this.valueSize;
@@ -27929,15 +28319,15 @@
                             v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                             x = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                             y = d * f - d * m;
                         for (let t = 0; t !== a; ++t) r[t] = g * s[c + t] + v * s[l + t] + x * s[o + t] + y * s[h + t];
                         return r
                     }
                 }
-                class po extends ho {
+                class ec extends $l {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t, e, n, i) {
                         const r = this.resultBuffer,
                             s = this.sampleValues,
                             a = this.valueSize,
@@ -27945,62 +28335,62 @@
                             l = o - a,
                             c = (n - e) / (i - e),
                             h = 1 - c;
                         for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;
                         return r
                     }
                 }
-                class mo extends ho {
+                class nc extends $l {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t) {
                         return this.copySampleValue_(t - 1)
                     }
                 }
-                class fo {
+                class ic {
                     constructor(t, e, n, i) {
                         if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                         if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
-                        this.name = t, this.times = co.convertArray(e, this.TimeBufferType), this.values = co.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
+                        this.name = t, this.times = Ql.convertArray(e, this.TimeBufferType), this.values = Ql.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                     }
                     static toJSON(t) {
                         const e = t.constructor;
                         let n;
                         if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                         else {
                             n = {
                                 name: t.name,
-                                times: co.convertArray(t.times, Array),
-                                values: co.convertArray(t.values, Array)
+                                times: Ql.convertArray(t.times, Array),
+                                values: Ql.convertArray(t.values, Array)
                             };
                             const e = t.getInterpolation();
                             e !== t.DefaultInterpolation && (n.interpolation = e)
                         }
                         return n.type = t.ValueTypeName, n
                     }
                     InterpolantFactoryMethodDiscrete(t) {
-                        return new mo(this.times, this.values, this.getValueSize(), t)
+                        return new nc(this.times, this.values, this.getValueSize(), t)
                     }
                     InterpolantFactoryMethodLinear(t) {
-                        return new po(this.times, this.values, this.getValueSize(), t)
+                        return new ec(this.times, this.values, this.getValueSize(), t)
                     }
                     InterpolantFactoryMethodSmooth(t) {
-                        return new uo(this.times, this.values, this.getValueSize(), t)
+                        return new tc(this.times, this.values, this.getValueSize(), t)
                     }
                     setInterpolation(t) {
                         let e;
                         switch (t) {
-                            case T:
+                            case oe:
                                 e = this.InterpolantFactoryMethodDiscrete;
                                 break;
-                            case A:
+                            case le:
                                 e = this.InterpolantFactoryMethodLinear;
                                 break;
-                            case R:
+                            case ce:
                                 e = this.InterpolantFactoryMethodSmooth
                         }
                         if (void 0 === e) {
                             const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                             if (void 0 === this.createInterpolant) {
                                 if (t === this.DefaultInterpolation) throw new Error(e);
                                 this.setInterpolation(this.DefaultInterpolation)
@@ -28008,19 +28398,19 @@
                             return console.warn("THREE.KeyframeTrack:", e), this
                         }
                         return this.createInterpolant = e, this
                     }
                     getInterpolation() {
                         switch (this.createInterpolant) {
                             case this.InterpolantFactoryMethodDiscrete:
-                                return T;
+                                return oe;
                             case this.InterpolantFactoryMethodLinear:
-                                return A;
+                                return le;
                             case this.InterpolantFactoryMethodSmooth:
-                                return R
+                                return ce
                         }
                     }
                     getValueSize() {
                         return this.values.length / this.times.length
                     }
                     shift(t) {
                         if (0 !== t) {
@@ -28042,15 +28432,15 @@
                         let r = 0,
                             s = i - 1;
                         for (; r !== i && n[r] < t;) ++r;
                         for (; - 1 !== s && n[s] > e;) --s;
                         if (++s, 0 !== r || s !== i) {
                             r >= s && (s = Math.max(s, 1), r = s - 1);
                             const t = this.getValueSize();
-                            this.times = co.arraySlice(n, r, s), this.values = co.arraySlice(this.values, r * t, s * t)
+                            this.times = Ql.arraySlice(n, r, s), this.values = Ql.arraySlice(this.values, r * t, s * t)
                         }
                         return this
                     }
                     validate() {
                         let t = !0;
                         const e = this.getValueSize();
                         e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
@@ -28067,29 +28457,29 @@
                             }
                             if (null !== s && s > i) {
                                 console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1;
                                 break
                             }
                             s = i
                         }
-                        if (void 0 !== i && co.isTypedArray(i))
+                        if (void 0 !== i && Ql.isTypedArray(i))
                             for (let e = 0, n = i.length; e !== n; ++e) {
                                 const n = i[e];
                                 if (isNaN(n)) {
                                     console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                                     break
                                 }
                             }
                         return t
                     }
                     optimize() {
-                        const t = co.arraySlice(this.times),
-                            e = co.arraySlice(this.values),
+                        const t = Ql.arraySlice(this.times),
+                            e = Ql.arraySlice(this.values),
                             n = this.getValueSize(),
-                            i = this.getInterpolation() === R,
+                            i = this.getInterpolation() === ce,
                             r = t.length - 1;
                         let s = 1;
                         for (let a = 1; a < r; ++a) {
                             let r = !1;
                             const o = t[a];
                             if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                                 if (i) r = !0;
@@ -28114,88 +28504,88 @@
                             }
                         }
                         if (r > 0) {
                             t[s] = t[r];
                             for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
                             ++s
                         }
-                        return s !== t.length ? (this.times = co.arraySlice(t, 0, s), this.values = co.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
+                        return s !== t.length ? (this.times = Ql.arraySlice(t, 0, s), this.values = Ql.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
                     }
                     clone() {
-                        const t = co.arraySlice(this.times, 0),
-                            e = co.arraySlice(this.values, 0),
+                        const t = Ql.arraySlice(this.times, 0),
+                            e = Ql.arraySlice(this.values, 0),
                             n = new(0, this.constructor)(this.name, t, e);
                         return n.createInterpolant = this.createInterpolant, n
                     }
                 }
-                fo.prototype.TimeBufferType = Float32Array, fo.prototype.ValueBufferType = Float32Array, fo.prototype.DefaultInterpolation = A;
-                class go extends fo {}
-                go.prototype.ValueTypeName = "bool", go.prototype.ValueBufferType = Array, go.prototype.DefaultInterpolation = T, go.prototype.InterpolantFactoryMethodLinear = void 0, go.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class vo extends fo {}
-                vo.prototype.ValueTypeName = "color";
-                class xo extends fo {}
-                xo.prototype.ValueTypeName = "number";
-                class yo extends ho {
+                ic.prototype.TimeBufferType = Float32Array, ic.prototype.ValueBufferType = Float32Array, ic.prototype.DefaultInterpolation = le;
+                class rc extends ic {}
+                rc.prototype.ValueTypeName = "bool", rc.prototype.ValueBufferType = Array, rc.prototype.DefaultInterpolation = oe, rc.prototype.InterpolantFactoryMethodLinear = void 0, rc.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class sc extends ic {}
+                sc.prototype.ValueTypeName = "color";
+                class ac extends ic {}
+                ac.prototype.ValueTypeName = "number";
+                class oc extends $l {
                     constructor(t, e, n, i) {
                         super(t, e, n, i)
                     }
                     interpolate_(t, e, n, i) {
                         const r = this.resultBuffer,
                             s = this.sampleValues,
                             a = this.valueSize,
                             o = (n - e) / (i - e);
                         let l = t * a;
-                        for (let t = l + a; l !== t; l += 4) pt.slerpFlat(r, 0, s, l - a, s, l, o);
+                        for (let t = l + a; l !== t; l += 4) Ke.slerpFlat(r, 0, s, l - a, s, l, o);
                         return r
                     }
                 }
-                class _o extends fo {
+                class lc extends ic {
                     InterpolantFactoryMethodLinear(t) {
-                        return new yo(this.times, this.values, this.getValueSize(), t)
+                        return new oc(this.times, this.values, this.getValueSize(), t)
                     }
                 }
-                _o.prototype.ValueTypeName = "quaternion", _o.prototype.DefaultInterpolation = A, _o.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class Mo extends fo {}
-                Mo.prototype.ValueTypeName = "string", Mo.prototype.ValueBufferType = Array, Mo.prototype.DefaultInterpolation = T, Mo.prototype.InterpolantFactoryMethodLinear = void 0, Mo.prototype.InterpolantFactoryMethodSmooth = void 0;
-                class bo extends fo {}
-                bo.prototype.ValueTypeName = "vector";
-                class wo {
+                lc.prototype.ValueTypeName = "quaternion", lc.prototype.DefaultInterpolation = le, lc.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class cc extends ic {}
+                cc.prototype.ValueTypeName = "string", cc.prototype.ValueBufferType = Array, cc.prototype.DefaultInterpolation = oe, cc.prototype.InterpolantFactoryMethodLinear = void 0, cc.prototype.InterpolantFactoryMethodSmooth = void 0;
+                class hc extends ic {}
+                hc.prototype.ValueTypeName = "vector";
+                class uc {
                     constructor(t, e = -1, n, i = 2500) {
-                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = k(), this.duration < 0 && this.resetDuration()
+                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Ae(), this.duration < 0 && this.resetDuration()
                     }
                     static parse(t) {
                         const e = [],
                             n = t.tracks,
                             i = 1 / (t.fps || 1);
-                        for (let t = 0, r = n.length; t !== r; ++t) e.push(So(n[t]).scale(i));
+                        for (let t = 0, r = n.length; t !== r; ++t) e.push(dc(n[t]).scale(i));
                         const r = new this(t.name, t.duration, e, t.blendMode);
                         return r.uuid = t.uuid, r
                     }
                     static toJSON(t) {
                         const e = [],
                             n = t.tracks,
                             i = {
                                 name: t.name,
                                 duration: t.duration,
                                 tracks: e,
                                 uuid: t.uuid,
                                 blendMode: t.blendMode
                             };
-                        for (let t = 0, i = n.length; t !== i; ++t) e.push(fo.toJSON(n[t]));
+                        for (let t = 0, i = n.length; t !== i; ++t) e.push(ic.toJSON(n[t]));
                         return i
                     }
                     static CreateFromMorphTargetSequence(t, e, n, i) {
                         const r = e.length,
                             s = [];
                         for (let t = 0; t < r; t++) {
                             let a = [],
                                 o = [];
                             a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
-                            const l = co.getKeyframeOrder(a);
-                            a = co.sortedArray(a, 1, l), o = co.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new xo(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / n))
+                            const l = Ql.getKeyframeOrder(a);
+                            a = Ql.sortedArray(a, 1, l), o = Ql.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new ac(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / n))
                         }
                         return new this(t, -1, s)
                     }
                     static findByName(t, e) {
                         let n = t;
                         if (!Array.isArray(t)) {
                             const e = t;
@@ -28223,15 +28613,15 @@
                     }
                     static parseAnimation(t, e) {
                         if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                         const n = function(t, e, n, i, r) {
                                 if (0 !== n.length) {
                                     const s = [],
                                         a = [];
-                                    co.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a))
+                                    Ql.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a))
                                 }
                             },
                             i = [],
                             r = t.name || "default",
                             s = t.fps || 30,
                             a = t.blendMode;
                         let o = t.length || -1;
@@ -28248,20 +28638,20 @@
                                     for (const n in t) {
                                         const t = [],
                                             s = [];
                                         for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                             const i = r[e];
                                             t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                         }
-                                        i.push(new xo(".morphTargetInfluence[" + n + "]", t, s))
+                                        i.push(new ac(".morphTargetInfluence[" + n + "]", t, s))
                                     }
                                     o = t.length * (s || 1)
                                 } else {
                                     const s = ".bones[" + e[t].name + "]";
-                                    n(bo, s + ".position", r, "pos", i), n(_o, s + ".quaternion", r, "rot", i), n(bo, s + ".scale", r, "scl", i)
+                                    n(hc, s + ".position", r, "pos", i), n(lc, s + ".quaternion", r, "rot", i), n(hc, s + ".scale", r, "scl", i)
                                 }
                         }
                         return 0 === i.length ? null : new this(r, o, i, a)
                     }
                     resetDuration() {
                         let t = 0;
                         for (let e = 0, n = this.tracks.length; e !== n; ++e) {
@@ -28289,49 +28679,49 @@
                         return new this.constructor(this.name, this.duration, t, this.blendMode)
                     }
                     toJSON() {
                         return this.constructor.toJSON(this)
                     }
                 }
 
-                function So(t) {
+                function dc(t) {
                     if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                     const e = function(t) {
                         switch (t.toLowerCase()) {
                             case "scalar":
                             case "double":
                             case "float":
                             case "number":
                             case "integer":
-                                return xo;
+                                return ac;
                             case "vector":
                             case "vector2":
                             case "vector3":
                             case "vector4":
-                                return bo;
+                                return hc;
                             case "color":
-                                return vo;
+                                return sc;
                             case "quaternion":
-                                return _o;
+                                return lc;
                             case "bool":
                             case "boolean":
-                                return go;
+                                return rc;
                             case "string":
-                                return Mo
+                                return cc
                         }
                         throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                     }(t.type);
                     if (void 0 === t.times) {
                         const e = [],
                             n = [];
-                        co.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
+                        Ql.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                     }
                     return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                 }
-                const Eo = {
+                const pc = {
                     enabled: !1,
                     files: {},
                     add: function(t, e) {
                         !1 !== this.enabled && (this.files[t] = e)
                     },
                     get: function(t) {
                         if (!1 !== this.enabled) return this.files[t]
@@ -28339,15 +28729,15 @@
                     remove: function(t) {
                         delete this.files[t]
                     },
                     clear: function() {
                         this.files = {}
                     }
                 };
-                const To = new class {
+                const mc = new class {
                     constructor(t, e, n) {
                         const i = this;
                         let r, s = !1,
                             a = 0,
                             o = 0;
                         const l = [];
                         this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
@@ -28371,17 +28761,17 @@
                                     i = l[e + 1];
                                 if (n.global && (n.lastIndex = 0), n.test(t)) return i
                             }
                             return null
                         }
                     }
                 };
-                class Ao {
+                class fc {
                     constructor(t) {
-                        this.manager = void 0 !== t ? t : To, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
+                        this.manager = void 0 !== t ? t : mc, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                     }
                     load() {}
                     loadAsync(t, e) {
                         const n = this;
                         return new Promise((function(i, r) {
                             n.load(t, i, e, r)
                         }))
@@ -28399,45 +28789,45 @@
                     setResourcePath(t) {
                         return this.resourcePath = t, this
                     }
                     setRequestHeader(t) {
                         return this.requestHeader = t, this
                     }
                 }
-                const Ro = {};
-                class Lo extends Ao {
+                const gc = {};
+                class vc extends fc {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
-                        const r = Eo.get(t);
+                        const r = pc.get(t);
                         if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => {
                             e && e(r), this.manager.itemEnd(t)
                         }), 0), r;
-                        if (void 0 !== Ro[t]) return void Ro[t].push({
+                        if (void 0 !== gc[t]) return void gc[t].push({
                             onLoad: e,
                             onProgress: n,
                             onError: i
                         });
-                        Ro[t] = [], Ro[t].push({
+                        gc[t] = [], gc[t].push({
                             onLoad: e,
                             onProgress: n,
                             onError: i
                         });
                         const s = new Request(t, {
                                 headers: new Headers(this.requestHeader),
                                 credentials: this.withCredentials ? "include" : "same-origin"
                             }),
                             a = this.mimeType,
                             o = this.responseType;
                         fetch(s).then((e => {
                             if (200 === e.status || 0 === e.status) {
                                 if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body.getReader) return e;
-                                const n = Ro[t],
+                                const n = gc[t],
                                     i = e.body.getReader(),
                                     r = e.headers.get("Content-Length"),
                                     s = r ? parseInt(r) : 0,
                                     a = 0 !== s;
                                 let o = 0;
                                 const l = new ReadableStream({
                                     start(t) {
@@ -28482,25 +28872,25 @@
                                         const e = /charset="?([^;"\s]*)"?/i.exec(a),
                                             n = e && e[1] ? e[1].toLowerCase() : void 0,
                                             i = new TextDecoder(n);
                                         return t.arrayBuffer().then((t => i.decode(t)))
                                     }
                             }
                         })).then((e => {
-                            Eo.add(t, e);
-                            const n = Ro[t];
-                            delete Ro[t];
+                            pc.add(t, e);
+                            const n = gc[t];
+                            delete gc[t];
                             for (let t = 0, i = n.length; t < i; t++) {
                                 const i = n[t];
                                 i.onLoad && i.onLoad(e)
                             }
                         })).catch((e => {
-                            const n = Ro[t];
+                            const n = gc[t];
                             if (void 0 === n) throw this.manager.itemError(t), e;
-                            delete Ro[t];
+                            delete gc[t];
                             for (let t = 0, i = n.length; t < i; t++) {
                                 const i = n[t];
                                 i.onError && i.onError(e)
                             }
                             this.manager.itemError(t)
                         })).finally((() => {
                             this.manager.itemEnd(t)
@@ -28509,111 +28899,111 @@
                     setResponseType(t) {
                         return this.responseType = t, this
                     }
                     setMimeType(t) {
                         return this.mimeType = t, this
                     }
                 }
-                class Co extends Ao {
+                class xc extends fc {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                         const r = this,
-                            s = Eo.get(t);
+                            s = pc.get(t);
                         if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                             e && e(s), r.manager.itemEnd(t)
                         }), 0), s;
-                        const a = K("img");
+                        const a = Oe("img");
 
                         function o() {
-                            c(), Eo.add(t, this), e && e(this), r.manager.itemEnd(t)
+                            c(), pc.add(t, this), e && e(this), r.manager.itemEnd(t)
                         }
 
                         function l(e) {
                             c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                         }
 
                         function c() {
                             a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
                         }
                         return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                     }
                 }
-                class Po extends Ao {
+                class yc extends fc {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
-                        const r = new _n,
-                            s = new Co(this.manager);
+                        const r = new rr,
+                            s = new xc(this.manager);
                         s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                         let a = 0;
 
                         function o(n) {
                             s.load(t[n], (function(t) {
                                 r.images[n] = t, a++, 6 === a && (r.needsUpdate = !0, e && e(r))
                             }), void 0, i)
                         }
                         for (let e = 0; e < t.length; ++e) o(e);
                         return r
                     }
                 }
-                class Do extends Ao {
+                class _c extends fc {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
-                        const r = new lt,
-                            s = new Co(this.manager);
+                        const r = new Xe,
+                            s = new xc(this.manager);
                         return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(t) {
                             r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                         }), n, i), r
                     }
                 }
-                class Io extends ge {
+                class Mc extends ei {
                     constructor(t, e = 1) {
-                        super(), this.type = "Light", this.color = new rt(t), this.intensity = e
+                        super(), this.type = "Light", this.color = new Ve(t), this.intensity = e
                     }
                     dispose() {}
                     copy(t) {
                         return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                     }
                 }
-                Io.prototype.isLight = !0;
-                (class extends Io {
+                Mc.prototype.isLight = !0;
+                (class extends Mc {
                     constructor(t, e, n) {
-                        super(t, n), this.type = "HemisphereLight", this.position.copy(ge.DefaultUp), this.updateMatrix(), this.groundColor = new rt(e)
+                        super(t, n), this.type = "HemisphereLight", this.position.copy(ei.DefaultUp), this.updateMatrix(), this.groundColor = new Ve(e)
                     }
                     copy(t) {
-                        return Io.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
+                        return Mc.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                     }
                 }).prototype.isHemisphereLight = !0;
-                const No = new jt,
-                    Oo = new mt,
-                    Uo = new mt;
-                class Bo {
+                const bc = new Cn,
+                    wc = new Qe,
+                    Sc = new Qe;
+                class Ec {
                     constructor(t) {
-                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Y(512, 512), this.map = null, this.mapPass = null, this.matrix = new jt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Rn, this._frameExtents = new Y(1, 1), this._viewportCount = 1, this._viewports = [new ht(0, 0, 1, 1)]
+                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new De(512, 512), this.map = null, this.mapPass = null, this.matrix = new Cn, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new dr, this._frameExtents = new De(1, 1), this._viewportCount = 1, this._viewports = [new Ye(0, 0, 1, 1)]
                     }
                     getViewportCount() {
                         return this._viewportCount
                     }
                     getFrustum() {
                         return this._frustum
                     }
                     updateMatrices(t) {
                         const e = this.camera,
                             n = this.matrix;
-                        Oo.setFromMatrixPosition(t.matrixWorld), e.position.copy(Oo), Uo.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Uo), e.updateMatrixWorld(), No.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(No), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
+                        wc.setFromMatrixPosition(t.matrixWorld), e.position.copy(wc), Sc.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Sc), e.updateMatrixWorld(), bc.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(bc), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                     }
                     getViewport(t) {
                         return this._viewports[t]
                     }
                     getFrameExtents() {
                         return this._frameExtents
                     }
@@ -28627,102 +29017,102 @@
                         return (new this.constructor).copy(this)
                     }
                     toJSON() {
                         const t = {};
                         return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                     }
                 }
-                class Fo extends Bo {
+                class Tc extends Ec {
                     constructor() {
-                        super(new vn(50, 1, .5, 500)), this.focus = 1
+                        super(new er(50, 1, .5, 500)), this.focus = 1
                     }
                     updateMatrices(t) {
                         const e = this.camera,
-                            n = 2 * V * t.angle * this.focus,
+                            n = 2 * Te * t.angle * this.focus,
                             i = this.mapSize.width / this.mapSize.height,
                             r = t.distance || e.far;
                         n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                     }
                     copy(t) {
                         return super.copy(t), this.focus = t.focus, this
                     }
                 }
-                Fo.prototype.isSpotLightShadow = !0;
-                (class extends Io {
+                Tc.prototype.isSpotLightShadow = !0;
+                (class extends Mc {
                     constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
-                        super(t, e), this.type = "SpotLight", this.position.copy(ge.DefaultUp), this.updateMatrix(), this.target = new ge, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new Fo
+                        super(t, e), this.type = "SpotLight", this.position.copy(ei.DefaultUp), this.updateMatrix(), this.target = new ei, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new Tc
                     }
                     get power() {
                         return this.intensity * Math.PI
                     }
                     set power(t) {
                         this.intensity = t / Math.PI
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                     }
                 }).prototype.isSpotLight = !0;
-                const zo = new jt,
-                    Ho = new mt,
-                    Go = new mt;
-                class Vo extends Bo {
+                const Ac = new Cn,
+                    Rc = new Qe,
+                    Lc = new Qe;
+                class Cc extends Ec {
                     constructor() {
-                        super(new vn(90, 1, .5, 500)), this._frameExtents = new Y(4, 2), this._viewportCount = 6, this._viewports = [new ht(2, 1, 1, 1), new ht(0, 1, 1, 1), new ht(3, 1, 1, 1), new ht(1, 1, 1, 1), new ht(3, 0, 1, 1), new ht(1, 0, 1, 1)], this._cubeDirections = [new mt(1, 0, 0), new mt(-1, 0, 0), new mt(0, 0, 1), new mt(0, 0, -1), new mt(0, 1, 0), new mt(0, -1, 0)], this._cubeUps = [new mt(0, 1, 0), new mt(0, 1, 0), new mt(0, 1, 0), new mt(0, 1, 0), new mt(0, 0, 1), new mt(0, 0, -1)]
+                        super(new er(90, 1, .5, 500)), this._frameExtents = new De(4, 2), this._viewportCount = 6, this._viewports = [new Ye(2, 1, 1, 1), new Ye(0, 1, 1, 1), new Ye(3, 1, 1, 1), new Ye(1, 1, 1, 1), new Ye(3, 0, 1, 1), new Ye(1, 0, 1, 1)], this._cubeDirections = [new Qe(1, 0, 0), new Qe(-1, 0, 0), new Qe(0, 0, 1), new Qe(0, 0, -1), new Qe(0, 1, 0), new Qe(0, -1, 0)], this._cubeUps = [new Qe(0, 1, 0), new Qe(0, 1, 0), new Qe(0, 1, 0), new Qe(0, 1, 0), new Qe(0, 0, 1), new Qe(0, 0, -1)]
                     }
                     updateMatrices(t, e = 0) {
                         const n = this.camera,
                             i = this.matrix,
                             r = t.distance || n.far;
-                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Ho.setFromMatrixPosition(t.matrixWorld), n.position.copy(Ho), Go.copy(n.position), Go.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Go), n.updateMatrixWorld(), i.makeTranslation(-Ho.x, -Ho.y, -Ho.z), zo.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(zo)
+                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Rc.setFromMatrixPosition(t.matrixWorld), n.position.copy(Rc), Lc.copy(n.position), Lc.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Lc), n.updateMatrixWorld(), i.makeTranslation(-Rc.x, -Rc.y, -Rc.z), Ac.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ac)
                     }
                 }
-                Vo.prototype.isPointLightShadow = !0;
-                (class extends Io {
+                Cc.prototype.isPointLightShadow = !0;
+                (class extends Mc {
                     constructor(t, e, n = 0, i = 1) {
-                        super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Vo
+                        super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Cc
                     }
                     get power() {
                         return 4 * this.intensity * Math.PI
                     }
                     set power(t) {
                         this.intensity = t / (4 * Math.PI)
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                     }
                 }).prototype.isPointLight = !0;
-                class ko extends Bo {
+                class Pc extends Ec {
                     constructor() {
-                        super(new Gn(-5, 5, 5, -5, .5, 500))
+                        super(new Er(-5, 5, 5, -5, .5, 500))
                     }
                 }
-                ko.prototype.isDirectionalLightShadow = !0;
-                (class extends Io {
+                Pc.prototype.isDirectionalLightShadow = !0;
+                (class extends Mc {
                     constructor(t, e) {
-                        super(t, e), this.type = "DirectionalLight", this.position.copy(ge.DefaultUp), this.updateMatrix(), this.target = new ge, this.shadow = new ko
+                        super(t, e), this.type = "DirectionalLight", this.position.copy(ei.DefaultUp), this.updateMatrix(), this.target = new ei, this.shadow = new Pc
                     }
                     dispose() {
                         this.shadow.dispose()
                     }
                     copy(t) {
                         return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                     }
                 }).prototype.isDirectionalLight = !0;
-                (class extends Io {
+                (class extends Mc {
                     constructor(t, e) {
                         super(t, e), this.type = "AmbientLight"
                     }
                 }).prototype.isAmbientLight = !0;
-                (class extends Io {
+                (class extends Mc {
                     constructor(t, e, n = 10, i = 10) {
                         super(t, e), this.type = "RectAreaLight", this.width = n, this.height = i
                     }
                     get power() {
                         return this.intensity * this.width * this.height * Math.PI
                     }
                     set power(t) {
@@ -28732,18 +29122,18 @@
                         return super.copy(t), this.width = t.width, this.height = t.height, this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.width = this.width, e.object.height = this.height, e
                     }
                 }).prototype.isRectAreaLight = !0;
-                class Wo {
+                class Dc {
                     constructor() {
                         this.coefficients = [];
-                        for (let t = 0; t < 9; t++) this.coefficients.push(new mt)
+                        for (let t = 0; t < 9; t++) this.coefficients.push(new Qe)
                     }
                     set(t) {
                         for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                         return this
                     }
                     zero() {
                         for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
@@ -28803,32 +29193,32 @@
                     static getBasisAt(t, e) {
                         const n = t.x,
                             i = t.y,
                             r = t.z;
                         e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                     }
                 }
-                Wo.prototype.isSphericalHarmonics3 = !0;
-                class jo extends Io {
-                    constructor(t = new Wo, e = 1) {
+                Dc.prototype.isSphericalHarmonics3 = !0;
+                class Ic extends Mc {
+                    constructor(t = new Dc, e = 1) {
                         super(void 0, e), this.sh = t
                     }
                     copy(t) {
                         return super.copy(t), this.sh.copy(t.sh), this
                     }
                     fromJSON(t) {
                         return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.object.sh = this.sh.toArray(), e
                     }
                 }
-                jo.prototype.isLightProbe = !0;
-                class Xo {
+                Ic.prototype.isLightProbe = !0;
+                class Nc {
                     static decodeText(t) {
                         if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                         let e = "";
                         for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                         try {
                             return decodeURIComponent(escape(e))
                         } catch (t) {
@@ -28839,96 +29229,96 @@
                         const e = t.lastIndexOf("/");
                         return -1 === e ? "./" : t.substr(0, e + 1)
                     }
                     static resolveURL(t, e) {
                         return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                     }
                 }
-                let qo;
-                (class extends We {
+                let Oc;
+                (class extends Li {
                     constructor() {
                         super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                     }
                     copy(t) {
                         return super.copy(t), this.instanceCount = t.instanceCount, this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     toJSON() {
                         const t = super.toJSON(this);
                         return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                     }
-                }).prototype.isInstancedBufferGeometry = !0, class extends Ao {
+                }).prototype.isInstancedBufferGeometry = !0, class extends fc {
                     constructor(t) {
                         super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                             premultiplyAlpha: "none"
                         }
                     }
                     setOptions(t) {
                         return this.options = t, this
                     }
                     load(t, e, n, i) {
                         void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                         const r = this,
-                            s = Eo.get(t);
+                            s = pc.get(t);
                         if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                             e && e(s), r.manager.itemEnd(t)
                         }), 0), s;
                         const a = {};
                         a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(t, a).then((function(t) {
                             return t.blob()
                         })).then((function(t) {
                             return createImageBitmap(t, Object.assign(r.options, {
                                 colorSpaceConversion: "none"
                             }))
                         })).then((function(n) {
-                            Eo.add(t, n), e && e(n), r.manager.itemEnd(t)
+                            pc.add(t, n), e && e(n), r.manager.itemEnd(t)
                         })).catch((function(e) {
                             i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                         })), r.manager.itemStart(t)
                     }
                 }.prototype.isImageBitmapLoader = !0;
-                class Yo extends Ao {
+                class Uc extends fc {
                     constructor(t) {
                         super(t)
                     }
                     load(t, e, n, i) {
                         const r = this,
-                            s = new Lo(this.manager);
+                            s = new vc(this.manager);
                         s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                             try {
                                 const t = n.slice(0);
-                                (void 0 === qo && (qo = new(window.AudioContext || window.webkitAudioContext)), qo).decodeAudioData(t, (function(t) {
+                                (void 0 === Oc && (Oc = new(window.AudioContext || window.webkitAudioContext)), Oc).decodeAudioData(t, (function(t) {
                                     e(t)
                                 }))
                             } catch (e) {
                                 i ? i(e) : console.error(e), r.manager.itemError(t)
                             }
                         }), n, i)
                     }
-                }(class extends jo {
+                }(class extends Ic {
                     constructor(t, e, n = 1) {
                         super(void 0, n);
-                        const i = (new rt).set(t),
-                            r = (new rt).set(e),
-                            s = new mt(i.r, i.g, i.b),
-                            a = new mt(r.r, r.g, r.b),
+                        const i = (new Ve).set(t),
+                            r = (new Ve).set(e),
+                            s = new Qe(i.r, i.g, i.b),
+                            a = new Qe(r.r, r.g, r.b),
                             o = Math.sqrt(Math.PI),
                             l = o * Math.sqrt(.75);
                         this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
                     }
-                }).prototype.isHemisphereLightProbe = !0, class extends jo {
+                }).prototype.isHemisphereLightProbe = !0, class extends Ic {
                     constructor(t, e = 1) {
                         super(void 0, e);
-                        const n = (new rt).set(t);
+                        const n = (new Ve).set(t);
                         this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                     }
                 }.prototype.isAmbientLightProbe = !0;
-                class Jo {
+                class Bc {
                     constructor(t, e, n) {
                         let i, r, s;
                         switch (this.binding = t, this.valueSize = n, e) {
                             case "quaternion":
                                 i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                                 break;
                             case "string":
@@ -29006,19 +29396,19 @@
                         for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                     }
                     _select(t, e, n, i, r) {
                         if (i >= .5)
                             for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
                     }
                     _slerp(t, e, n, i) {
-                        pt.slerpFlat(t, e, t, e, t, n, i)
+                        Ke.slerpFlat(t, e, t, e, t, n, i)
                     }
                     _slerpAdditive(t, e, n, i, r) {
                         const s = this._workIndex * r;
-                        pt.multiplyQuaternionsFlat(t, s, t, e, t, n), pt.slerpFlat(t, e, t, e, t, s, i)
+                        Ke.multiplyQuaternionsFlat(t, s, t, e, t, n), Ke.slerpFlat(t, e, t, e, t, s, i)
                     }
                     _lerp(t, e, n, i, r) {
                         const s = 1 - i;
                         for (let a = 0; a !== r; ++a) {
                             const r = e + a;
                             t[r] = t[r] * s + t[n + a] * i
                         }
@@ -29026,46 +29416,47 @@
                     _lerpAdditive(t, e, n, i, r) {
                         for (let s = 0; s !== r; ++s) {
                             const r = e + s;
                             t[r] = t[r] + t[n + s] * i
                         }
                     }
                 }
-                const Zo = new RegExp("[\\[\\]\\.:\\/]", "g"),
-                    Ko = "[^\\[\\]\\.:\\/]",
-                    Qo = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
-                    $o = /((?:WC+[\/:])*)/.source.replace("WC", Ko),
-                    tl = /(WCOD+)?/.source.replace("WCOD", Qo),
-                    el = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ko),
-                    nl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ko),
-                    il = new RegExp("^" + $o + tl + el + nl + "$"),
-                    rl = ["material", "materials", "bones"];
-                class sl {
+                const Fc = "\\[\\]\\.:\\/",
+                    zc = new RegExp("[" + Fc + "]", "g"),
+                    Hc = "[^" + Fc + "]",
+                    Gc = "[^" + Fc.replace("\\.", "") + "]",
+                    Vc = /((?:WC+[\/:])*)/.source.replace("WC", Hc),
+                    kc = /(WCOD+)?/.source.replace("WCOD", Gc),
+                    Wc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Hc),
+                    jc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Hc),
+                    Xc = new RegExp("^" + Vc + kc + Wc + jc + "$"),
+                    qc = ["material", "materials", "bones"];
+                class Yc {
                     constructor(t, e, n) {
-                        this.path = e, this.parsedPath = n || sl.parseTrackName(e), this.node = sl.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
+                        this.path = e, this.parsedPath = n || Yc.parseTrackName(e), this.node = Yc.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                     }
                     static create(t, e, n) {
-                        return t && t.isAnimationObjectGroup ? new sl.Composite(t, e, n) : new sl(t, e, n)
+                        return t && t.isAnimationObjectGroup ? new Yc.Composite(t, e, n) : new Yc(t, e, n)
                     }
                     static sanitizeNodeName(t) {
-                        return t.replace(/\s/g, "_").replace(Zo, "")
+                        return t.replace(/\s/g, "_").replace(zc, "")
                     }
                     static parseTrackName(t) {
-                        const e = il.exec(t);
+                        const e = Xc.exec(t);
                         if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                         const n = {
                                 nodeName: e[2],
                                 objectName: e[3],
                                 objectIndex: e[4],
                                 propertyName: e[5],
                                 propertyIndex: e[6]
                             },
                             i = n.nodeName && n.nodeName.lastIndexOf(".");
                         if (void 0 !== i && -1 !== i) {
-                            const t = n.nodeName.substring(i + 1); - 1 !== rl.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
+                            const t = n.nodeName.substring(i + 1); - 1 !== qc.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                         }
                         if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                         return n
                     }
                     static findNode(t, e) {
                         if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                         if (t.skeleton) {
@@ -29151,15 +29542,15 @@
                     }
                     bind() {
                         let t = this.node;
                         const e = this.parsedPath,
                             n = e.objectName,
                             i = e.propertyName;
                         let r = e.propertyIndex;
-                        if (t || (t = sl.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
+                        if (t || (t = Yc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                         if (n) {
                             let i = e.objectIndex;
                             switch (n) {
                                 case "materials":
                                     if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                     if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                     t = t.material.materials;
@@ -29200,17 +29591,17 @@
                         } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                         this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
                     }
                     unbind() {
                         this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                     }
                 }
-                sl.Composite = class {
+                Yc.Composite = class {
                     constructor(t, e, n) {
-                        const i = n || sl.parseTrackName(e);
+                        const i = n || Yc.parseTrackName(e);
                         this._targetGroup = t, this._bindings = t.subscribe_(e, i)
                     }
                     getValue(t, e) {
                         this.bind();
                         const n = this._targetGroup.nCachedObjects_,
                             i = this._bindings[n];
                         void 0 !== i && i.getValue(t, e)
@@ -29223,38 +29614,38 @@
                         const t = this._bindings;
                         for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                     }
                     unbind() {
                         const t = this._bindings;
                         for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                     }
-                }, sl.prototype.BindingType = {
+                }, Yc.prototype.BindingType = {
                     Direct: 0,
                     EntireArray: 1,
                     ArrayElement: 2,
                     HasFromToArray: 3
-                }, sl.prototype.Versioning = {
+                }, Yc.prototype.Versioning = {
                     None: 0,
                     NeedsUpdate: 1,
                     MatrixWorldNeedsUpdate: 2
-                }, sl.prototype.GetterByBindingType = [sl.prototype._getValue_direct, sl.prototype._getValue_array, sl.prototype._getValue_arrayElement, sl.prototype._getValue_toArray], sl.prototype.SetterByBindingTypeAndVersioning = [
-                    [sl.prototype._setValue_direct, sl.prototype._setValue_direct_setNeedsUpdate, sl.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
-                    [sl.prototype._setValue_array, sl.prototype._setValue_array_setNeedsUpdate, sl.prototype._setValue_array_setMatrixWorldNeedsUpdate],
-                    [sl.prototype._setValue_arrayElement, sl.prototype._setValue_arrayElement_setNeedsUpdate, sl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
-                    [sl.prototype._setValue_fromArray, sl.prototype._setValue_fromArray_setNeedsUpdate, sl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
+                }, Yc.prototype.GetterByBindingType = [Yc.prototype._getValue_direct, Yc.prototype._getValue_array, Yc.prototype._getValue_arrayElement, Yc.prototype._getValue_toArray], Yc.prototype.SetterByBindingTypeAndVersioning = [
+                    [Yc.prototype._setValue_direct, Yc.prototype._setValue_direct_setNeedsUpdate, Yc.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
+                    [Yc.prototype._setValue_array, Yc.prototype._setValue_array_setNeedsUpdate, Yc.prototype._setValue_array_setMatrixWorldNeedsUpdate],
+                    [Yc.prototype._setValue_arrayElement, Yc.prototype._setValue_arrayElement_setNeedsUpdate, Yc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
+                    [Yc.prototype._setValue_fromArray, Yc.prototype._setValue_fromArray_setNeedsUpdate, Yc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                 ];
-                class al {
+                class Jc {
                     constructor(t, e, n = null, i = e.blendMode) {
                         this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                         const r = e.tracks,
                             s = r.length,
                             a = new Array(s),
                             o = {
-                                endingStart: L,
-                                endingEnd: L
+                                endingStart: he,
+                                endingEnd: he
                             };
                         for (let t = 0; t !== s; ++t) {
                             const e = r[t].createInterpolant(null);
                             a[t] = e, e.settings = o
                         }
                         this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                     }
@@ -29437,26 +29828,26 @@
                             } else this.time = i;
                             if (s && 1 == (1 & r)) return e - i
                         }
                         return i
                     }
                     _setEndings(t, e, n) {
                         const i = this._interpolantSettings;
-                        n ? (i.endingStart = C, i.endingEnd = C) : (i.endingStart = t ? this.zeroSlopeAtStart ? C : L : P, i.endingEnd = e ? this.zeroSlopeAtEnd ? C : L : P)
+                        n ? (i.endingStart = ue, i.endingEnd = ue) : (i.endingStart = t ? this.zeroSlopeAtStart ? ue : he : de, i.endingEnd = e ? this.zeroSlopeAtEnd ? ue : he : de)
                     }
                     _scheduleFading(t, e, n) {
                         const i = this._mixer,
                             r = i.time;
                         let s = this._weightInterpolant;
                         null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                         const a = s.parameterPositions,
                             o = s.sampleValues;
                         return a[0] = r, o[0] = e, a[1] = r + t, o[1] = n, this
                     }
-                }(class extends z {
+                }(class extends we {
                     constructor(t) {
                         super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                     }
                     _bindAction(t, e) {
                         const n = t._localRoot || this._root,
                             i = t._clip.tracks,
                             r = i.length,
@@ -29473,15 +29864,15 @@
                             if (void 0 !== h) ++h.referenceCount, s[t] = h;
                             else {
                                 if (h = s[t], void 0 !== h) {
                                     null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l));
                                     continue
                                 }
                                 const i = e && e._propertyBindings[t].binding.parsedPath;
-                                h = new Jo(sl.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), s[t] = h
+                                h = new Bc(Yc.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), s[t] = h
                             }
                             a[t].resultBuffer = h.buffer
                         }
                     }
                     _activateAction(t) {
                         if (!this._isActiveAction(t)) {
                             if (null === t._cacheIndex) {
@@ -29621,43 +30012,43 @@
                             r = e[i];
                         t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                     }
                     _lendControlInterpolant() {
                         const t = this._controlInterpolants,
                             e = this._nActiveControlInterpolants++;
                         let n = t[e];
-                        return void 0 === n && (n = new po(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
+                        return void 0 === n && (n = new ec(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                     }
                     _takeBackControlInterpolant(t) {
                         const e = this._controlInterpolants,
                             n = t.__cacheIndex,
                             i = --this._nActiveControlInterpolants,
                             r = e[i];
                         t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                     }
                     clipAction(t, e, n) {
                         const i = e || this._root,
                             r = i.uuid;
-                        let s = "string" == typeof t ? wo.findByName(i, t) : t;
+                        let s = "string" == typeof t ? uc.findByName(i, t) : t;
                         const a = null !== s ? s.uuid : t,
                             o = this._actionsByClip[a];
                         let l = null;
                         if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o) {
                             const t = o.actionByRoot[r];
                             if (void 0 !== t && t.blendMode === n) return t;
                             l = o.knownActions[0], null === s && (s = l._clip)
                         }
                         if (null === s) return null;
-                        const c = new al(this, s, e, n);
+                        const c = new Jc(this, s, e, n);
                         return this._bindAction(c, l), this._addInactiveAction(c, a, r), c
                     }
                     existingAction(t, e) {
                         const n = e || this._root,
                             i = n.uuid,
-                            r = "string" == typeof t ? wo.findByName(n, t) : t,
+                            r = "string" == typeof t ? uc.findByName(n, t) : t,
                             s = r ? r.uuid : t,
                             a = this._actionsByClip[s];
                         return void 0 !== a && a.actionByRoot[i] || null
                     }
                     stopAllAction() {
                         const t = this._actions;
                         for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
@@ -29716,22 +30107,22 @@
                             }
                     }
                     uncacheAction(t, e) {
                         const n = this.existingAction(t, e);
                         null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                     }
                 }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
-                class ol {
+                class Zc {
                     constructor(t) {
                         "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                     }
                     clone() {
-                        return new ol(void 0 === this.value.clone ? this.value : this.value.clone())
+                        return new Zc(void 0 === this.value.clone ? this.value : this.value.clone())
                     }
-                }(class extends ys {
+                }(class extends oo {
                     constructor(t, e, n = 1) {
                         super(t, e), this.meshPerAttribute = n
                     }
                     copy(t) {
                         return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                     }
                     clone(t) {
@@ -29739,15 +30130,15 @@
                         return e.meshPerAttribute = this.meshPerAttribute, e
                     }
                     toJSON(t) {
                         const e = super.toJSON(t);
                         return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                     }
                 }).prototype.isInstancedInterleavedBuffer = !0;
-                class ll {
+                class Kc {
                     constructor(t = 1, e = 0, n = 0) {
                         return this.radius = t, this.phi = e, this.theta = n, this
                     }
                     set(t, e, n) {
                         return this.radius = t, this.phi = e, this.theta = n, this
                     }
                     copy(t) {
@@ -29757,35 +30148,35 @@
                         const t = 1e-6;
                         return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
                     }
                     setFromVector3(t) {
                         return this.setFromCartesianCoords(t.x, t.y, t.z)
                     }
                     setFromCartesianCoords(t, e, n) {
-                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(W(e / this.radius, -1, 1))), this
+                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Re(e / this.radius, -1, 1))), this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                 }
-                const cl = new Y;
-                class hl {
-                    constructor(t = new Y(1 / 0, 1 / 0), e = new Y(-1 / 0, -1 / 0)) {
+                const Qc = new De;
+                class $c {
+                    constructor(t = new De(1 / 0, 1 / 0), e = new De(-1 / 0, -1 / 0)) {
                         this.min = t, this.max = e
                     }
                     set(t, e) {
                         return this.min.copy(t), this.max.copy(e), this
                     }
                     setFromPoints(t) {
                         this.makeEmpty();
                         for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                         return this
                     }
                     setFromCenterAndSize(t, e) {
-                        const n = cl.copy(e).multiplyScalar(.5);
+                        const n = Qc.copy(e).multiplyScalar(.5);
                         return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                     }
                     clone() {
                         return (new this.constructor).copy(this)
                     }
                     copy(t) {
                         return this.min.copy(t.min), this.max.copy(t.max), this
@@ -29823,251 +30214,251 @@
                     intersectsBox(t) {
                         return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                     }
                     clampPoint(t, e) {
                         return e.copy(t).clamp(this.min, this.max)
                     }
                     distanceToPoint(t) {
-                        return cl.copy(t).clamp(this.min, this.max).sub(t).length()
+                        return Qc.copy(t).clamp(this.min, this.max).sub(t).length()
                     }
                     intersect(t) {
                         return this.min.max(t.min), this.max.min(t.max), this
                     }
                     union(t) {
                         return this.min.min(t.min), this.max.max(t.max), this
                     }
                     translate(t) {
                         return this.min.add(t), this.max.add(t), this
                     }
                     equals(t) {
                         return t.min.equals(this.min) && t.max.equals(this.max)
                     }
                 }
-                hl.prototype.isBox2 = !0;
-                const ul = new mt,
-                    dl = new jt,
-                    pl = new jt;
+                $c.prototype.isBox2 = !0;
+                const th = new Qe,
+                    eh = new Cn,
+                    nh = new Cn;
 
-                function ml(t) {
+                function ih(t) {
                     const e = [];
                     t && t.isBone && e.push(t);
-                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, ml(t.children[n]));
+                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, ih(t.children[n]));
                     return e
                 }
-                const fl = new Float32Array(1);
-                new Int32Array(fl.buffer), ha.create = function(t, e) {
-                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(ha.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
-                }, Ca.prototype.fromPoints = function(t) {
+                const rh = new Float32Array(1);
+                new Int32Array(rh.buffer), $o.create = function(t, e) {
+                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create($o.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
+                }, yl.prototype.fromPoints = function(t) {
                     return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
-                }, class extends ia {
+                }, class extends Xo {
                     constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
-                        n = new rt(n), i = new rt(i);
+                        n = new Ve(n), i = new Ve(i);
                         const r = e / 2,
                             s = t / e,
                             a = t / 2,
                             o = [],
                             l = [];
                         for (let t = 0, c = 0, h = -a; t <= e; t++, h += s) {
                             o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
                             const e = t === r ? n : i;
                             e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3
                         }
-                        const c = new We;
-                        c.setAttribute("position", new Ue(o, 3)), c.setAttribute("color", new Ue(l, 3)), super(c, new Ys({
+                        const c = new Li;
+                        c.setAttribute("position", new Mi(o, 3)), c.setAttribute("color", new Mi(l, 3)), super(c, new Bo({
                             vertexColors: !0,
                             toneMapped: !1
                         })), this.type = "GridHelper"
                     }
                 }.prototype.setColors = function() {
                     console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
-                }, class extends ia {
+                }, class extends Xo {
                     constructor(t) {
-                        const e = ml(t),
-                            n = new We,
+                        const e = ih(t),
+                            n = new Li,
                             i = [],
                             r = [],
-                            s = new rt(0, 0, 1),
-                            a = new rt(0, 1, 0);
+                            s = new Ve(0, 0, 1),
+                            a = new Ve(0, 1, 0);
                         for (let t = 0; t < e.length; t++) {
                             const n = e[t];
                             n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
                         }
-                        n.setAttribute("position", new Ue(i, 3)), n.setAttribute("color", new Ue(r, 3)), super(n, new Ys({
+                        n.setAttribute("position", new Mi(i, 3)), n.setAttribute("color", new Mi(r, 3)), super(n, new Bo({
                             vertexColors: !0,
                             depthTest: !1,
                             depthWrite: !1,
                             toneMapped: !1,
                             transparent: !0
                         })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                     }
                     updateMatrixWorld(t) {
                         const e = this.bones,
                             n = this.geometry,
                             i = n.getAttribute("position");
-                        pl.copy(this.root.matrixWorld).invert();
+                        nh.copy(this.root.matrixWorld).invert();
                         for (let t = 0, n = 0; t < e.length; t++) {
                             const r = e[t];
-                            r.parent && r.parent.isBone && (dl.multiplyMatrices(pl, r.matrixWorld), ul.setFromMatrixPosition(dl), i.setXYZ(n, ul.x, ul.y, ul.z), dl.multiplyMatrices(pl, r.parent.matrixWorld), ul.setFromMatrixPosition(dl), i.setXYZ(n + 1, ul.x, ul.y, ul.z), n += 2)
+                            r.parent && r.parent.isBone && (eh.multiplyMatrices(nh, r.matrixWorld), th.setFromMatrixPosition(eh), i.setXYZ(n, th.x, th.y, th.z), eh.multiplyMatrices(nh, r.parent.matrixWorld), th.setFromMatrixPosition(eh), i.setXYZ(n + 1, th.x, th.y, th.z), n += 2)
                         }
                         n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                     }
                 }.prototype.update = function() {
                     console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
-                }, Ao.prototype.extractUrlBase = function(t) {
-                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Xo.extractUrlBase(t)
-                }, Ao.Handlers = {
+                }, fc.prototype.extractUrlBase = function(t) {
+                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Nc.extractUrlBase(t)
+                }, fc.Handlers = {
                     add: function() {
                         console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                     },
                     get: function() {
                         console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                     }
-                }, hl.prototype.center = function(t) {
+                }, $c.prototype.center = function(t) {
                     return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
-                }, hl.prototype.empty = function() {
+                }, $c.prototype.empty = function() {
                     return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, hl.prototype.isIntersectionBox = function(t) {
+                }, $c.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, hl.prototype.size = function(t) {
+                }, $c.prototype.size = function(t) {
                     return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
-                }, vt.prototype.center = function(t) {
+                }, en.prototype.center = function(t) {
                     return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
-                }, vt.prototype.empty = function() {
+                }, en.prototype.empty = function() {
                     return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, vt.prototype.isIntersectionBox = function(t) {
+                }, en.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, vt.prototype.isIntersectionSphere = function(t) {
+                }, en.prototype.isIntersectionSphere = function(t) {
                     return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
-                }, vt.prototype.size = function(t) {
+                }, en.prototype.size = function(t) {
                     return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
-                }, Ut.prototype.empty = function() {
+                }, Mn.prototype.empty = function() {
                     return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
-                }, Rn.prototype.setFromMatrix = function(t) {
+                }, dr.prototype.setFromMatrix = function(t) {
                     return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
-                }, J.prototype.flattenToArrayOffset = function(t, e) {
+                }, Ie.prototype.flattenToArrayOffset = function(t, e) {
                     return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
-                }, J.prototype.multiplyVector3 = function(t) {
+                }, Ie.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
-                }, J.prototype.multiplyVector3Array = function() {
+                }, Ie.prototype.multiplyVector3Array = function() {
                     console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
-                }, J.prototype.applyToBufferAttribute = function(t) {
+                }, Ie.prototype.applyToBufferAttribute = function(t) {
                     return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
-                }, J.prototype.applyToVector3Array = function() {
+                }, Ie.prototype.applyToVector3Array = function() {
                     console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
-                }, J.prototype.getInverse = function(t) {
+                }, Ie.prototype.getInverse = function(t) {
                     return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
-                }, jt.prototype.extractPosition = function(t) {
+                }, Cn.prototype.extractPosition = function(t) {
                     return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
-                }, jt.prototype.flattenToArrayOffset = function(t, e) {
+                }, Cn.prototype.flattenToArrayOffset = function(t, e) {
                     return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
-                }, jt.prototype.getPosition = function() {
-                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new mt).setFromMatrixColumn(this, 3)
-                }, jt.prototype.setRotationFromQuaternion = function(t) {
+                }, Cn.prototype.getPosition = function() {
+                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Qe).setFromMatrixColumn(this, 3)
+                }, Cn.prototype.setRotationFromQuaternion = function(t) {
                     return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
-                }, jt.prototype.multiplyToArray = function() {
+                }, Cn.prototype.multiplyToArray = function() {
                     console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
-                }, jt.prototype.multiplyVector3 = function(t) {
+                }, Cn.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, jt.prototype.multiplyVector4 = function(t) {
+                }, Cn.prototype.multiplyVector4 = function(t) {
                     return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, jt.prototype.multiplyVector3Array = function() {
+                }, Cn.prototype.multiplyVector3Array = function() {
                     console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
-                }, jt.prototype.rotateAxis = function(t) {
+                }, Cn.prototype.rotateAxis = function(t) {
                     console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
-                }, jt.prototype.crossVector = function(t) {
+                }, Cn.prototype.crossVector = function(t) {
                     return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, jt.prototype.translate = function() {
+                }, Cn.prototype.translate = function() {
                     console.error("THREE.Matrix4: .translate() has been removed.")
-                }, jt.prototype.rotateX = function() {
+                }, Cn.prototype.rotateX = function() {
                     console.error("THREE.Matrix4: .rotateX() has been removed.")
-                }, jt.prototype.rotateY = function() {
+                }, Cn.prototype.rotateY = function() {
                     console.error("THREE.Matrix4: .rotateY() has been removed.")
-                }, jt.prototype.rotateZ = function() {
+                }, Cn.prototype.rotateZ = function() {
                     console.error("THREE.Matrix4: .rotateZ() has been removed.")
-                }, jt.prototype.rotateByAxis = function() {
+                }, Cn.prototype.rotateByAxis = function() {
                     console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
-                }, jt.prototype.applyToBufferAttribute = function(t) {
+                }, Cn.prototype.applyToBufferAttribute = function(t) {
                     return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
-                }, jt.prototype.applyToVector3Array = function() {
+                }, Cn.prototype.applyToVector3Array = function() {
                     console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
-                }, jt.prototype.makeFrustum = function(t, e, n, i, r, s) {
+                }, Cn.prototype.makeFrustum = function(t, e, n, i, r, s) {
                     return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, s)
-                }, jt.prototype.getInverse = function(t) {
+                }, Cn.prototype.getInverse = function(t) {
                     return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
-                }, En.prototype.isIntersectionLine = function(t) {
+                }, cr.prototype.isIntersectionLine = function(t) {
                     return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
-                }, pt.prototype.multiplyVector3 = function(t) {
+                }, Ke.prototype.multiplyVector3 = function(t) {
                     return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
-                }, pt.prototype.inverse = function() {
+                }, Ke.prototype.inverse = function() {
                     return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
-                }, Wt.prototype.isIntersectionBox = function(t) {
+                }, Ln.prototype.isIntersectionBox = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
-                }, Wt.prototype.isIntersectionPlane = function(t) {
+                }, Ln.prototype.isIntersectionPlane = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
-                }, Wt.prototype.isIntersectionSphere = function(t) {
+                }, Ln.prototype.isIntersectionSphere = function(t) {
                     return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
-                }, Ae.prototype.area = function() {
+                }, di.prototype.area = function() {
                     return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
-                }, Ae.prototype.barycoordFromPoint = function(t, e) {
+                }, di.prototype.barycoordFromPoint = function(t, e) {
                     return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
-                }, Ae.prototype.midpoint = function(t) {
+                }, di.prototype.midpoint = function(t) {
                     return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
-                }, Ae.prototypenormal = function(t) {
+                }, di.prototypenormal = function(t) {
                     return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
-                }, Ae.prototype.plane = function(t) {
+                }, di.prototype.plane = function(t) {
                     return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
-                }, Ae.barycoordFromPoint = function(t, e, n, i, r) {
-                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Ae.getBarycoord(t, e, n, i, r)
-                }, Ae.normal = function(t, e, n, i) {
-                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Ae.getNormal(t, e, n, i)
-                }, Pa.prototype.extractAllPoints = function(t) {
+                }, di.barycoordFromPoint = function(t, e, n, i, r) {
+                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), di.getBarycoord(t, e, n, i, r)
+                }, di.normal = function(t, e, n, i) {
+                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), di.getNormal(t, e, n, i)
+                }, _l.prototype.extractAllPoints = function(t) {
                     return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
-                }, Pa.prototype.extrude = function(t) {
-                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new so(this, t)
-                }, Pa.prototype.makeGeometry = function(t) {
-                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new oo(this, t)
-                }, Y.prototype.fromAttribute = function(t, e, n) {
+                }, _l.prototype.extrude = function(t) {
+                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Yl(this, t)
+                }, _l.prototype.makeGeometry = function(t) {
+                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Zl(this, t)
+                }, De.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, Y.prototype.distanceToManhattan = function(t) {
+                }, De.prototype.distanceToManhattan = function(t) {
                     return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
-                }, Y.prototype.lengthManhattan = function() {
+                }, De.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, mt.prototype.setEulerFromRotationMatrix = function() {
+                }, Qe.prototype.setEulerFromRotationMatrix = function() {
                     console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
-                }, mt.prototype.setEulerFromQuaternion = function() {
+                }, Qe.prototype.setEulerFromQuaternion = function() {
                     console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
-                }, mt.prototype.getPositionFromMatrix = function(t) {
+                }, Qe.prototype.getPositionFromMatrix = function(t) {
                     return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
-                }, mt.prototype.getScaleFromMatrix = function(t) {
+                }, Qe.prototype.getScaleFromMatrix = function(t) {
                     return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
-                }, mt.prototype.getColumnFromMatrix = function(t, e) {
+                }, Qe.prototype.getColumnFromMatrix = function(t, e) {
                     return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
-                }, mt.prototype.applyProjection = function(t) {
+                }, Qe.prototype.applyProjection = function(t) {
                     return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
-                }, mt.prototype.fromAttribute = function(t, e, n) {
+                }, Qe.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, mt.prototype.distanceToManhattan = function(t) {
+                }, Qe.prototype.distanceToManhattan = function(t) {
                     return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
-                }, mt.prototype.lengthManhattan = function() {
+                }, Qe.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, ht.prototype.fromAttribute = function(t, e, n) {
+                }, Ye.prototype.fromAttribute = function(t, e, n) {
                     return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
-                }, ht.prototype.lengthManhattan = function() {
+                }, Ye.prototype.lengthManhattan = function() {
                     return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
-                }, ge.prototype.getChildByName = function(t) {
+                }, ei.prototype.getChildByName = function(t) {
                     return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
-                }, ge.prototype.renderDepth = function() {
+                }, ei.prototype.renderDepth = function() {
                     console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
-                }, ge.prototype.translate = function(t, e) {
+                }, ei.prototype.translate = function(t, e) {
                     return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
-                }, ge.prototype.getWorldRotation = function() {
+                }, ei.prototype.getWorldRotation = function() {
                     console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
-                }, ge.prototype.applyMatrix = function(t) {
+                }, ei.prototype.applyMatrix = function(t) {
                     return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
-                }, Object.defineProperties(ge.prototype, {
+                }, Object.defineProperties(ei.prototype, {
                     eulerOrder: {
                         get: function() {
                             return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                         },
                         set: function(t) {
                             console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                         }
@@ -30076,30 +30467,30 @@
                         get: function() {
                             console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                         },
                         set: function() {
                             console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                         }
                     }
-                }), cn.prototype.setDrawMode = function() {
+                }), qi.prototype.setDrawMode = function() {
                     console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
-                }, Object.defineProperties(cn.prototype, {
+                }, Object.defineProperties(qi.prototype, {
                     drawMode: {
                         get: function() {
                             return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                         },
                         set: function() {
                             console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                         }
                     }
-                }), Vs.prototype.initBones = function() {
+                }), Po.prototype.initBones = function() {
                     console.error("THREE.SkinnedMesh: initBones() has been removed.")
-                }, vn.prototype.setLens = function(t, e) {
+                }, er.prototype.setLens = function(t, e) {
                     console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
-                }, Object.defineProperties(Io.prototype, {
+                }, Object.defineProperties(Mc.prototype, {
                     onlyShadow: {
                         set: function() {
                             console.warn("THREE.Light: .onlyShadow has been removed.")
                         }
                     },
                     shadowCameraFov: {
                         set: function(t) {
@@ -30157,74 +30548,74 @@
                         }
                     },
                     shadowMapHeight: {
                         set: function(t) {
                             console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                         }
                     }
-                }), Object.defineProperties(Ie.prototype, {
+                }), Object.defineProperties(xi.prototype, {
                     length: {
                         get: function() {
                             return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                         }
                     },
                     dynamic: {
                         get: function() {
-                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === U
+                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === _e
                         },
                         set: function() {
-                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(U)
+                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(_e)
                         }
                     }
-                }), Ie.prototype.setDynamic = function(t) {
-                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? U : O), this
-                }, Ie.prototype.copyIndicesArray = function() {
+                }), xi.prototype.setDynamic = function(t) {
+                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? _e : ye), this
+                }, xi.prototype.copyIndicesArray = function() {
                     console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
-                }, Ie.prototype.setArray = function() {
+                }, xi.prototype.setArray = function() {
                     console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
-                }, We.prototype.addIndex = function(t) {
+                }, Li.prototype.addIndex = function(t) {
                     console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
-                }, We.prototype.addAttribute = function(t, e) {
-                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Ie(arguments[1], arguments[2])))
-                }, We.prototype.addDrawCall = function(t, e, n) {
+                }, Li.prototype.addAttribute = function(t, e) {
+                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new xi(arguments[1], arguments[2])))
+                }, Li.prototype.addDrawCall = function(t, e, n) {
                     void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
-                }, We.prototype.clearDrawCalls = function() {
+                }, Li.prototype.clearDrawCalls = function() {
                     console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
-                }, We.prototype.computeOffsets = function() {
+                }, Li.prototype.computeOffsets = function() {
                     console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
-                }, We.prototype.removeAttribute = function(t) {
+                }, Li.prototype.removeAttribute = function(t) {
                     return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
-                }, We.prototype.applyMatrix = function(t) {
+                }, Li.prototype.applyMatrix = function(t) {
                     return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
-                }, Object.defineProperties(We.prototype, {
+                }, Object.defineProperties(Li.prototype, {
                     drawcalls: {
                         get: function() {
                             return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                         }
                     },
                     offsets: {
                         get: function() {
                             return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                         }
                     }
-                }), ys.prototype.setDynamic = function(t) {
-                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? U : O), this
-                }, ys.prototype.setArray = function() {
+                }), oo.prototype.setDynamic = function(t) {
+                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? _e : ye), this
+                }, oo.prototype.setArray = function() {
                     console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
-                }, so.prototype.getArrays = function() {
+                }, Yl.prototype.getArrays = function() {
                     console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
-                }, so.prototype.addShapeList = function() {
+                }, Yl.prototype.addShapeList = function() {
                     console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
-                }, so.prototype.addShape = function() {
+                }, Yl.prototype.addShape = function() {
                     console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
-                }, xs.prototype.dispose = function() {
+                }, ao.prototype.dispose = function() {
                     console.error("THREE.Scene: .dispose() has been removed.")
-                }, ol.prototype.onUpdate = function() {
+                }, Zc.prototype.onUpdate = function() {
                     return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
-                }, Object.defineProperties(Le.prototype, {
+                }, Object.defineProperties(mi.prototype, {
                     wrapAround: {
                         get: function() {
                             console.warn("THREE.Material: .wrapAround has been removed.")
                         },
                         set: function() {
                             console.warn("THREE.Material: .wrapAround has been removed.")
                         }
@@ -30235,15 +30626,15 @@
                         },
                         set: function() {
                             console.warn("THREE.Material: .overdraw has been removed.")
                         }
                     },
                     wrapRGB: {
                         get: function() {
-                            return console.warn("THREE.Material: .wrapRGB has been removed."), new rt
+                            return console.warn("THREE.Material: .wrapRGB has been removed."), new Ve
                         }
                     },
                     shading: {
                         get: function() {
                             console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                         },
                         set: function(t) {
@@ -30262,74 +30653,74 @@
                         get: function() {
                             console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                         },
                         set: function() {
                             console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                         }
                     }
-                }), Object.defineProperties(fn.prototype, {
+                }), Object.defineProperties($i.prototype, {
                     derivatives: {
                         get: function() {
                             return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                         },
                         set: function(t) {
                             console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                         }
                     }
-                }), fs.prototype.clearTarget = function(t, e, n, i) {
+                }), io.prototype.clearTarget = function(t, e, n, i) {
                     console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
-                }, fs.prototype.animate = function(t) {
+                }, io.prototype.animate = function(t) {
                     console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
-                }, fs.prototype.getCurrentRenderTarget = function() {
+                }, io.prototype.getCurrentRenderTarget = function() {
                     return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
-                }, fs.prototype.getMaxAnisotropy = function() {
+                }, io.prototype.getMaxAnisotropy = function() {
                     return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
-                }, fs.prototype.getPrecision = function() {
+                }, io.prototype.getPrecision = function() {
                     return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
-                }, fs.prototype.resetGLState = function() {
+                }, io.prototype.resetGLState = function() {
                     return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
-                }, fs.prototype.supportsFloatTextures = function() {
+                }, io.prototype.supportsFloatTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
-                }, fs.prototype.supportsHalfFloatTextures = function() {
+                }, io.prototype.supportsHalfFloatTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
-                }, fs.prototype.supportsStandardDerivatives = function() {
+                }, io.prototype.supportsStandardDerivatives = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
-                }, fs.prototype.supportsCompressedTextureS3TC = function() {
+                }, io.prototype.supportsCompressedTextureS3TC = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
-                }, fs.prototype.supportsCompressedTexturePVRTC = function() {
+                }, io.prototype.supportsCompressedTexturePVRTC = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
-                }, fs.prototype.supportsBlendMinMax = function() {
+                }, io.prototype.supportsBlendMinMax = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
-                }, fs.prototype.supportsVertexTextures = function() {
+                }, io.prototype.supportsVertexTextures = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
-                }, fs.prototype.supportsInstancedArrays = function() {
+                }, io.prototype.supportsInstancedArrays = function() {
                     return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
-                }, fs.prototype.enableScissorTest = function(t) {
+                }, io.prototype.enableScissorTest = function(t) {
                     console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
-                }, fs.prototype.initMaterial = function() {
+                }, io.prototype.initMaterial = function() {
                     console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
-                }, fs.prototype.addPrePlugin = function() {
+                }, io.prototype.addPrePlugin = function() {
                     console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
-                }, fs.prototype.addPostPlugin = function() {
+                }, io.prototype.addPostPlugin = function() {
                     console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
-                }, fs.prototype.updateShadowMap = function() {
+                }, io.prototype.updateShadowMap = function() {
                     console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
-                }, fs.prototype.setFaceCulling = function() {
+                }, io.prototype.setFaceCulling = function() {
                     console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
-                }, fs.prototype.allocTextureUnit = function() {
+                }, io.prototype.allocTextureUnit = function() {
                     console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
-                }, fs.prototype.setTexture = function() {
+                }, io.prototype.setTexture = function() {
                     console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
-                }, fs.prototype.setTexture2D = function() {
+                }, io.prototype.setTexture2D = function() {
                     console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
-                }, fs.prototype.setTextureCube = function() {
+                }, io.prototype.setTextureCube = function() {
                     console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
-                }, fs.prototype.getActiveMipMapLevel = function() {
+                }, io.prototype.getActiveMipMapLevel = function() {
                     return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
-                }, Object.defineProperties(fs.prototype, {
+                }, Object.defineProperties(io.prototype, {
                     shadowMapEnabled: {
                         get: function() {
                             return this.shadowMap.enabled
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                         }
@@ -30369,15 +30760,15 @@
                         }
                     },
                     gammaOutput: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                         },
                         set: function(t) {
-                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? I : D
+                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? me : pe
                         }
                     },
                     toneMappingWhitePoint: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                         },
                         set: function() {
@@ -30388,15 +30779,15 @@
                         get: function() {
                             return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                         }
                     }
-                }), Object.defineProperties(rs.prototype, {
+                }), Object.defineProperties(Xa.prototype, {
                     cullFace: {
                         get: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                         }
@@ -30413,15 +30804,15 @@
                         get: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                         },
                         set: function() {
                             console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                         }
                     }
-                }), Object.defineProperties(ut.prototype, {
+                }), Object.defineProperties(Je.prototype, {
                     wrapS: {
                         get: function() {
                             return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                         }
@@ -30494,15 +30885,15 @@
                         get: function() {
                             return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                         },
                         set: function(t) {
                             console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                         }
                     }
-                }), class extends ge {
+                }), class extends ei {
                     constructor(t) {
                         super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                     }
                     getOutput() {
                         return this.gain
                     }
                     setNodeSource(t) {
@@ -30594,54 +30985,54 @@
                     }
                     setVolume(t) {
                         return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                     }
                 }.prototype.load = function(t) {
                     console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                     const e = this;
-                    return (new Yo).load(t, (function(t) {
+                    return (new Uc).load(t, (function(t) {
                         e.setBuffer(t)
                     })), this
-                }, yn.prototype.updateCubeMap = function(t, e) {
+                }, ir.prototype.updateCubeMap = function(t, e) {
                     return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
-                }, yn.prototype.clear = function(t, e, n, i) {
+                }, ir.prototype.clear = function(t, e, n, i) {
                     return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i)
-                }, at.crossOrigin = void 0, at.loadTexture = function(t, e, n, i) {
+                }, We.crossOrigin = void 0, We.loadTexture = function(t, e, n, i) {
                     console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
-                    const r = new Do;
+                    const r = new _c;
                     r.setCrossOrigin(this.crossOrigin);
                     const s = r.load(t, n, void 0, i);
                     return e && (s.mapping = e), s
-                }, at.loadTextureCube = function(t, e, n, i) {
+                }, We.loadTextureCube = function(t, e, n, i) {
                     console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
-                    const r = new Po;
+                    const r = new yc;
                     r.setCrossOrigin(this.crossOrigin);
                     const s = r.load(t, n, void 0, i);
                     return e && (s.mapping = e), s
-                }, at.loadCompressedTexture = function() {
+                }, We.loadCompressedTexture = function() {
                     console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
-                }, at.loadCompressedTextureCube = function() {
+                }, We.loadCompressedTextureCube = function() {
                     console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                 }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                     detail: {
-                        revision: "137"
+                        revision: i
                     }
-                })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "137");
-                const gl = {
+                })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i);
+                const sh = {
                         type: "change"
                     },
-                    vl = {
+                    ah = {
                         type: "start"
                     },
-                    xl = {
+                    oh = {
                         type: "end"
                     };
-                class yl extends z {
+                class lh extends we {
                     constructor(t, e) {
-                        super(), void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new mt, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
+                        super(), void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new Qe, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
                             LEFT: "ArrowLeft",
                             UP: "ArrowUp",
                             RIGHT: "ArrowRight",
                             BOTTOM: "ArrowDown"
                         }, this.mouseButtons = {
                             LEFT: 0,
                             MIDDLE: 1,
@@ -30656,28 +31047,28 @@
                         }, this.getDistance = function() {
                             return this.object.position.distanceTo(this.target)
                         }, this.listenToKeyEvents = function(t) {
                             t.addEventListener("keydown", k), this._domElementKeyEvents = t
                         }, this.saveState = function() {
                             n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
                         }, this.reset = function() {
-                            n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(gl), n.update(), r = i.NONE
+                            n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(sh), n.update(), r = i.NONE
                         }, this.update = function() {
-                            const e = new mt,
-                                u = (new pt).setFromUnitVectors(t.up, new mt(0, 1, 0)),
+                            const e = new Qe,
+                                u = (new Ke).setFromUnitVectors(t.up, new Qe(0, 1, 0)),
                                 d = u.clone().invert(),
-                                p = new mt,
-                                m = new pt,
+                                p = new Qe,
+                                m = new Ke,
                                 f = 2 * Math.PI;
                             return function() {
                                 const t = n.object.position;
                                 e.copy(t).sub(n.target), e.applyQuaternion(u), a.setFromVector3(e), n.autoRotate && r === i.NONE && w(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (a.theta += o.theta * n.dampingFactor, a.phi += o.phi * n.dampingFactor) : (a.theta += o.theta, a.phi += o.phi);
                                 let g = n.minAzimuthAngle,
                                     v = n.maxAzimuthAngle;
-                                return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += f : g > Math.PI && (g -= f), v < -Math.PI ? v += f : v > Math.PI && (v -= f), a.theta = g <= v ? Math.max(g, Math.min(v, a.theta)) : a.theta > (g + v) / 2 ? Math.max(g, a.theta) : Math.min(v, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), a.radius *= l, a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)), !0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c), e.setFromSpherical(a), e.applyQuaternion(d), t.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (o.theta *= 1 - n.dampingFactor, o.phi *= 1 - n.dampingFactor, c.multiplyScalar(1 - n.dampingFactor)) : (o.set(0, 0, 0), c.set(0, 0, 0)), l = 1, !!(h || p.distanceToSquared(n.object.position) > s || 8 * (1 - m.dot(n.object.quaternion)) > s) && (n.dispatchEvent(gl), p.copy(n.object.position), m.copy(n.object.quaternion), h = !1, !0)
+                                return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += f : g > Math.PI && (g -= f), v < -Math.PI ? v += f : v > Math.PI && (v -= f), a.theta = g <= v ? Math.max(g, Math.min(v, a.theta)) : a.theta > (g + v) / 2 ? Math.max(g, a.theta) : Math.min(v, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), a.radius *= l, a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)), !0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c), e.setFromSpherical(a), e.applyQuaternion(d), t.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (o.theta *= 1 - n.dampingFactor, o.phi *= 1 - n.dampingFactor, c.multiplyScalar(1 - n.dampingFactor)) : (o.set(0, 0, 0), c.set(0, 0, 0)), l = 1, !!(h || p.distanceToSquared(n.object.position) > s || 8 * (1 - m.dot(n.object.quaternion)) > s) && (n.dispatchEvent(sh), p.copy(n.object.position), m.copy(n.object.quaternion), h = !1, !0)
                             }
                         }(), this.dispose = function() {
                             n.domElement.removeEventListener("contextmenu", W), n.domElement.removeEventListener("pointerdown", F), n.domElement.removeEventListener("pointercancel", G), n.domElement.removeEventListener("wheel", V), n.domElement.removeEventListener("pointermove", z), n.domElement.removeEventListener("pointerup", H), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", k)
                         };
                         const n = this,
                             i = {
                                 NONE: -1,
@@ -30687,28 +31078,28 @@
                                 TOUCH_ROTATE: 3,
                                 TOUCH_PAN: 4,
                                 TOUCH_DOLLY_PAN: 5,
                                 TOUCH_DOLLY_ROTATE: 6
                             };
                         let r = i.NONE;
                         const s = 1e-6,
-                            a = new ll,
-                            o = new ll;
+                            a = new Kc,
+                            o = new Kc;
                         let l = 1;
-                        const c = new mt;
+                        const c = new Qe;
                         let h = !1;
-                        const u = new Y,
-                            d = new Y,
-                            p = new Y,
-                            m = new Y,
-                            f = new Y,
-                            g = new Y,
-                            v = new Y,
-                            x = new Y,
-                            y = new Y,
+                        const u = new De,
+                            d = new De,
+                            p = new De,
+                            m = new De,
+                            f = new De,
+                            g = new De,
+                            v = new De,
+                            x = new De,
+                            y = new De,
                             _ = [],
                             M = {};
 
                         function b() {
                             return Math.pow(.95, n.zoomSpeed)
                         }
 
@@ -30716,27 +31107,27 @@
                             o.theta -= t
                         }
 
                         function S(t) {
                             o.phi -= t
                         }
                         const E = function() {
-                                const t = new mt;
+                                const t = new Qe;
                                 return function(e, n) {
                                     t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), c.add(t)
                                 }
                             }(),
                             T = function() {
-                                const t = new mt;
+                                const t = new Qe;
                                 return function(e, i) {
                                     !0 === n.screenSpacePanning ? t.setFromMatrixColumn(i, 1) : (t.setFromMatrixColumn(i, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), c.add(t)
                                 }
                             }(),
                             A = function() {
-                                const t = new mt;
+                                const t = new Qe;
                                 return function(e, i) {
                                     const r = n.domElement;
                                     if (n.object.isPerspectiveCamera) {
                                         const s = n.object.position;
                                         t.copy(s).sub(n.target);
                                         let a = t.length();
                                         a *= Math.tan(n.object.fov / 2 * Math.PI / 180), E(2 * e * a / r.clientHeight, n.object.matrix), T(2 * i * a / r.clientHeight, n.object.matrix)
@@ -30849,15 +31240,15 @@
                                             default:
                                                 r = i.NONE
                                         }
                                         break;
                                     default:
                                         r = i.NONE
                                 }
-                                r !== i.NONE && n.dispatchEvent(vl)
+                                r !== i.NONE && n.dispatchEvent(ah)
                             }(t) : function(t) {
                                 let e;
                                 switch (t.button) {
                                     case 0:
                                         e = n.mouseButtons.LEFT;
                                         break;
                                     case 1:
@@ -30893,15 +31284,15 @@
                                             if (!1 === n.enablePan) return;
                                             P(t), r = i.PAN
                                         }
                                         break;
                                     default:
                                         r = i.NONE
                                 }
-                                r !== i.NONE && n.dispatchEvent(vl)
+                                r !== i.NONE && n.dispatchEvent(ah)
                             }(t))
                         }
 
                         function z(t) {
                             !1 !== n.enabled && ("touch" === t.pointerType ? function(t) {
                                 switch (X(t), r) {
                                     case i.TOUCH_ROTATE:
@@ -30949,25 +31340,25 @@
                                             f.set(t.clientX, t.clientY), g.subVectors(f, m).multiplyScalar(n.panSpeed), A(g.x, g.y), m.copy(f), n.update()
                                         }(t)
                                 }
                             }(t))
                         }
 
                         function H(t) {
-                            j(t), 0 === _.length && (n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", z), n.domElement.removeEventListener("pointerup", H)), n.dispatchEvent(xl), r = i.NONE
+                            j(t), 0 === _.length && (n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", z), n.domElement.removeEventListener("pointerup", H)), n.dispatchEvent(oh), r = i.NONE
                         }
 
                         function G(t) {
                             j(t)
                         }
 
                         function V(t) {
-                            !1 !== n.enabled && !1 !== n.enableZoom && r === i.NONE && (t.preventDefault(), n.dispatchEvent(vl), function(t) {
+                            !1 !== n.enabled && !1 !== n.enableZoom && r === i.NONE && (t.preventDefault(), n.dispatchEvent(ah), function(t) {
                                 t.deltaY < 0 ? L(b()) : t.deltaY > 0 && R(b()), n.update()
-                            }(t), n.dispatchEvent(xl))
+                            }(t), n.dispatchEvent(oh))
                         }
 
                         function k(t) {
                             !1 !== n.enabled && !1 !== n.enablePan && function(t) {
                                 let e = !1;
                                 switch (t.code) {
                                     case n.keys.UP:
@@ -30994,252 +31385,31 @@
                             delete M[t.pointerId];
                             for (let e = 0; e < _.length; e++)
                                 if (_[e].pointerId == t.pointerId) return void _.splice(e, 1)
                         }
 
                         function X(t) {
                             let e = M[t.pointerId];
-                            void 0 === e && (e = new Y, M[t.pointerId] = e), e.set(t.pageX, t.pageY)
+                            void 0 === e && (e = new De, M[t.pointerId] = e), e.set(t.pageX, t.pageY)
                         }
 
                         function q(t) {
                             const e = t.pointerId === _[0].pointerId ? _[1] : _[0];
                             return M[e.pointerId]
                         }
                         n.domElement.addEventListener("contextmenu", W), n.domElement.addEventListener("pointerdown", F), n.domElement.addEventListener("pointercancel", G), n.domElement.addEventListener("wheel", V, {
                             passive: !1
                         }), this.update()
                     }
                 }
-                class _l extends yl {
+                class ch extends lh {
                     constructor(t, e) {
                         super(t, e), this.screenSpacePanning = !1, this.mouseButtons.LEFT = 2, this.mouseButtons.RIGHT = 0, this.touches.ONE = 1, this.touches.TWO = 3
                     }
                 }
-            },
-            421: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.GridQubit = void 0;
-                const i = n(691),
-                    r = n(99);
-                class s extends i.Group {
-                    constructor(t, e, n, i = 1) {
-                        super(), this.row = t, this.col = e, this.add(this.createLine(n, i)), this.add(this.addLocationLabel(i))
-                    }
-                    addSymbol(t) {
-                        this.add(t)
-                    }
-                    createLine(t, e) {
-                        const n = [new i.Vector3(this.row * e, 0, this.col * e), new i.Vector3(this.row * e, t * e, this.col * e)];
-                        return new r.QubitLine(n[0], n[1])
-                    }
-                    addLocationLabel(t) {
-                        const e = new r.QubitLabel(`(${this.row}, ${this.col})`);
-                        return e.position.copy(new i.Vector3(this.row * t, -.6 * t, this.col * t)), e
-                    }
-                }
-                e.GridQubit = s
-            },
-            99: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.BoxGate3DSymbol = e.Swap3DSymbol = e.X3DSymbol = e.Control3DSymbol = e.QubitLine = e.QubitLabel = e.ConnectionLine = void 0;
-                const i = n(691);
-                class r extends i.Line {
-                    constructor(t, e) {
-                        const n = new i.LineBasicMaterial({
-                                color: "black"
-                            }),
-                            r = [t, e];
-                        return super((new i.BufferGeometry).setFromPoints(r), n), this
-                    }
-                }
-                e.ConnectionLine = r;
-                class s extends i.Sprite {
-                    constructor(t) {
-                        const e = document.createElement("canvas");
-                        e.width = 128, e.height = 128, e.textContent = t;
-                        const n = e.getContext("2d");
-                        n.fillStyle = "#000000", n.textAlign = "center", n.font = "20px Arial", n.fillText(t, 64, 64);
-                        const r = new i.Texture(e);
-                        return r.needsUpdate = !0, super(new i.SpriteMaterial({
-                            map: r,
-                            transparent: !0
-                        })), this.text = t, this
-                    }
-                }
-                e.QubitLabel = s;
-                class a extends i.Line {
-                    constructor(t, e) {
-                        const n = new i.LineBasicMaterial({
-                                color: "gray"
-                            }),
-                            r = [t, e];
-                        return super((new i.BufferGeometry).setFromPoints(r), n), this
-                    }
-                }
-                e.QubitLine = a;
-                class o extends i.Mesh {
-                    constructor() {
-                        const t = new i.MeshBasicMaterial({
-                            color: "black"
-                        });
-                        return super(new i.SphereGeometry(.1, 32, 32), t), this
-                    }
-                }
-                e.Control3DSymbol = o;
-                class l extends i.Group {
-                    constructor(t) {
-                        super();
-                        const e = new i.MeshBasicMaterial({
-                                color: t,
-                                side: i.DoubleSide
-                            }),
-                            n = new i.CylinderGeometry(.3, .3, .1, 32, 1, !0, 0, 2 * Math.PI),
-                            r = new i.Mesh(n, e);
-                        this.add(r);
-                        const s = Math.PI / 2,
-                            a = new i.MeshBasicMaterial({
-                                color: t
-                            }),
-                            o = new i.CylinderGeometry(.01, .01, .6),
-                            l = new i.Mesh(o, a);
-                        l.rotation.x = s;
-                        const c = new i.MeshBasicMaterial({
-                                color: t
-                            }),
-                            h = new i.CylinderGeometry(.01, .01, .6),
-                            u = new i.Mesh(h, c);
-                        return u.rotation.z = s, this.add(l), this.add(u), this
-                    }
-                }
-                e.X3DSymbol = l;
-                class c extends i.Group {
-                    constructor() {
-                        super();
-                        const t = new i.MeshBasicMaterial({
-                                color: "black"
-                            }),
-                            e = new i.CylinderGeometry(.01, .01, .3),
-                            n = new i.Mesh(e, t);
-                        n.rotation.x = Math.PI / 2, n.rotation.z = 3 * Math.PI / 4;
-                        const r = new i.MeshBasicMaterial({
-                                color: "black"
-                            }),
-                            s = new i.CylinderGeometry(.01, .01, .3),
-                            a = new i.Mesh(s, r);
-                        return a.rotation.x = Math.PI / 2, a.rotation.z = Math.PI / 4, this.add(n), this.add(a), this
-                    }
-                }
-                e.Swap3DSymbol = c;
-                class h extends i.Mesh {
-                    constructor(t, e) {
-                        const n = document.createElement("canvas"),
-                            r = n.getContext("2d");
-                        n.width = n.height = 128, r.fillStyle = e, r.fillRect(0, 0, n.width, n.height);
-                        let s, a = 60;
-                        do {
-                            a /= 1.2, r.font = `${a}pt arial bold`, s = r.measureText(t).width
-                        } while (s > n.width);
-                        const o = new i.Color(e).getHSL({
-                            h: 0,
-                            s: 0,
-                            l: 0
-                        });
-                        r.fillStyle = o.l < .5 ? "white" : "black", r.fillText(t, n.width / 2 - s / 2, n.height / 2 + a / 2);
-                        const l = new i.Texture(n);
-                        return l.needsUpdate = !0, super(new i.BoxGeometry(.5, .5, .5), new i.MeshBasicMaterial({
-                            map: l,
-                            color: "white"
-                        })), this
-                    }
-                }
-                e.BoxGate3DSymbol = h
-            },
-            883: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.Symbol3D = void 0;
-                const i = n(691),
-                    r = n(99);
-                class s extends i.Group {
-                    constructor(t, e = 1) {
-                        super(), this.padding_factor = e, this.moment = t.moment, this.buildAndAddMeshesToGroup(t), this.addConnectionLines(t)
-                    }
-                    buildAndAddMeshesToGroup(t) {
-                        const e = t.location_info;
-                        t.wire_symbols.forEach(((n, i) => {
-                            let s;
-                            switch (n) {
-                                case "X":
-                                    s = new r.X3DSymbol(t.color_info[i]);
-                                    break;
-                                case "@":
-                                    s = new r.Control3DSymbol;
-                                    break;
-                                case "×":
-                                    s = new r.Swap3DSymbol;
-                                    break;
-                                default:
-                                    s = new r.BoxGate3DSymbol(n, t.color_info[i])
-                            }
-                            s.position.set(e[i].row * this.padding_factor, t.moment * this.padding_factor, e[i].col * this.padding_factor), this.add(s)
-                        }))
-                    }
-                    addConnectionLines(t) {
-                        const e = t.location_info;
-                        if (e.length > 1) {
-                            let n = 0;
-                            for (; n < e.length - 1;) {
-                                const s = [new i.Vector3(e[n].row * this.padding_factor, t.moment * this.padding_factor, e[n].col * this.padding_factor), new i.Vector3(e[n + 1].row * this.padding_factor, t.moment * this.padding_factor, e[n + 1].col * this.padding_factor)];
-                                this.add(new r.ConnectionLine(s[0], s[1])), n++
-                            }
-                        }
-                    }
-                }
-                e.Symbol3D = s
-            },
-            25: (t, e, n) => {
-                Object.defineProperty(e, "__esModule", {
-                    value: !0
-                }), e.GridCircuit = void 0;
-                const i = n(691),
-                    r = n(421),
-                    s = n(883);
-                class a extends i.Group {
-                    constructor(t, e, n = 1) {
-                        super(), this.padding_factor = n, this.qubit_map = new Map;
-                        for (const n of e) {
-                            for (const e of n.location_info) this.hasQubit(e.row, e.col) || this.addQubit(e.row, e.col, t);
-                            this.addSymbol(n, t)
-                        }
-                    }
-                    addSymbol(t, e) {
-                        const n = new s.Symbol3D(t, this.padding_factor);
-                        if (t.moment < 0 || t.moment > e) throw new Error(`The SymbolInformation object ${t} has an invalid moment ${t.moment}`);
-                        this.getQubit(t.location_info[0].row, t.location_info[0].col).addSymbol(n)
-                    }
-                    addQubit(t, e, n) {
-                        const i = new r.GridQubit(t, e, n, this.padding_factor);
-                        this.setQubit(t, e, i), this.add(i)
-                    }
-                    getQubit(t, e) {
-                        return this.qubit_map.get(t).get(e)
-                    }
-                    setQubit(t, e, n) {
-                        const i = this.qubit_map.get(t);
-                        i ? i.set(e, n) : this.qubit_map.set(t, (new Map).set(e, n))
-                    }
-                    hasQubit(t, e) {
-                        const n = this.qubit_map.get(t);
-                        return !!n && n.has(e)
-                    }
-                }
-                e.GridCircuit = a
             }
         },
         e = {};
 
     function n(i) {
         var r = e[i];
         if (void 0 !== r) return r.exports;
@@ -31262,16 +31432,16 @@
     };
     var i = {};
     (() => {
         var t = i;
         Object.defineProperty(t, "__esModule", {
             value: !0
         }), t.createGridCircuit = void 0;
-        const e = n(691),
-            r = n(296),
+        const e = n(232),
+            r = n(379),
             s = n(25);
         class a extends e.Scene {
             constructor(t) {
                 super(), this.WIDTH = 1e3, this.HEIGHT = 700, this.renderer = new e.WebGLRenderer({
                     alpha: !0,
                     antialias: !0
                 }), this.renderer.setSize(this.WIDTH, this.HEIGHT), this.perspectiveCamera = new e.PerspectiveCamera(75, this.WIDTH / this.HEIGHT, .1, 1e3), this.orthographicCamera = new e.OrthographicCamera(this.WIDTH / this.HEIGHT / -2, this.WIDTH / this.HEIGHT / 2, this.HEIGHT / this.WIDTH / 2, this.HEIGHT / this.WIDTH / -2, .1, 100), this.orthographicCamera.zoom = .1, this.camera = this.perspectiveCamera, this.perspectiveControls = new r.OrbitControls(this.perspectiveCamera, this.renderer.domElement), this.orthographicControls = new r.OrbitControls(this.orthographicCamera, this.renderer.domElement), this.controls = this.perspectiveControls, document.getElementById(t).appendChild(this.renderer.domElement), this.animate()
```

## cirq_web/_version.py

```diff
@@ -1 +1 @@
-__version__ = "1.2.0.dev20230413211938"
+__version__ = "1.2.0.dev20230413214151"
```

## Comparing `cirq_web-1.2.0.dev20230413211938.dist-info/LICENSE` & `cirq_web-1.2.0.dev20230413214151.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `cirq_web-1.2.0.dev20230413211938.dist-info/METADATA` & `cirq_web-1.2.0.dev20230413214151.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 Metadata-Version: 2.1
 Name: cirq-web
-Version: 1.2.0.dev20230413211938
+Version: 1.2.0.dev20230413214151
 Summary: Web-based 3D visualization tools for Cirq.
 Home-page: http://github.com/quantumlib/cirq
 Author: The Cirq Developers
 Author-email: cirq-dev@googlegroups.com
 License: Apache 2
 Platform: UNKNOWN
 Requires-Python: >=3.7.0
-Requires-Dist: cirq-core (==1.2.0.dev20230413211938)
+Requires-Dist: cirq-core (==1.2.0.dev20230413214151)
 
 **This is a development version of cirq-web and may be unstable.**
 
 **For the latest stable release of cirq-web see**
 `here <https://pypi.org/project/cirq-web>`__.
 
 .. image:: https://raw.githubusercontent.com/quantumlib/Cirq/master/docs/images/Cirq_logo_color.png
```

