# Comparing `tmp/azure-multiapi-storage-1.0.0.tar.gz` & `tmp/azure-multiapi-storage-1.1.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "/mnt/vss/_work/1/a/azure-multiapi-storage-1.0.0.tar", last modified: Mon Dec  5 08:25:05 2022, max compression
+gzip compressed data, was "/mnt/vss/_work/1/a/azure-multiapi-storage-1.1.0.tar", last modified: Thu Apr 13 05:27:03 2023, max compression
```

## Comparing `azure-multiapi-storage-1.0.0.tar` & `azure-multiapi-storage-1.1.0.tar`

### file list

```diff
@@ -1,913 +1,911 @@
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1078 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/LICENSE
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       40 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/MANIFEST.in
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5977 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/PKG-INFO
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5057 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/README.rst
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       56 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1289 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4842 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_auth.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3663 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_common_conversion.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6707 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_connection.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1855 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12708 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9540 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7751 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_error.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_http/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2452 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_http/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4505 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_http/httpclient.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12244 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6465 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/cloudstorageaccount.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26207 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10013 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/retry.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15303 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/sharedaccesssignature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16244 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/storageclient.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1005 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11600 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12934 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/_encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3475 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7713 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/_request.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8065 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7366 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9333 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/tablebatch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    53331 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/tableservice.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1142 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4398 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_auth.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2874 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_common_conversion.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5691 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_connection.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1681 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10544 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3167 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_error.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_http/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2555 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_http/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13919 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_http/batchclient.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8266 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_http/httpclient.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2926 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_http/requestsclient.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10972 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_serialization.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1324 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12377 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13817 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1537 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4377 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24350 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/appendblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   143392 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/baseblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38381 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/blockblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23327 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    46296 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/pageblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8911 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/cloudstorageaccount.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/common/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1144 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/common/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       22 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/common/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       22 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/common/models.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1008 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9570 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6513 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2799 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    95690 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/fileservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14855 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22947 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/models.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      884 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4783 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1381 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2442 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8549 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    40604 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/queueservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35228 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/sharedaccesssignature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5095 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/storageclient.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1006 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8743 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3113 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4118 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/_request.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8147 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7247 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8561 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/tablebatch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    46676 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/tableservice.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      742 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1322 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/__init__.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)      997 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15754 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5225 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_download_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7596 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1537 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4423 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18312 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_upload_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27638 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/appendblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   165964 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/baseblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50536 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/blockblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26126 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    74008 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/pageblobservice.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    10060 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/sharedaccesssignature.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     1297 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/__init__.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     4084 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_auth.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     3663 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_common_conversion.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     6590 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_connection.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     2086 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_constants.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    12791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_deserialization.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     9506 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_encryption.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     7751 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_error.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_http/
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     2452 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_http/__init__.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     4505 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_http/httpclient.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    12208 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_serialization.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     9450 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/cloudstorageaccount.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    25988 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/models.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    11481 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/retry.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    10477 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/sharedaccesssignature.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    16912 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/storageclient.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1026 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/__init__.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)      889 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7536 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4373 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/_download_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2893 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5225 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/_upload_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   112937 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/fileservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15903 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/models.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    10408 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/sharedaccesssignature.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      883 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/__init__.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)      889 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5357 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7143 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/_encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1449 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2595 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8501 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    47641 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/queueservice.py
--rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     4532 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/sharedaccesssignature.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      742 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      888 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      565 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16128 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_download_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7162 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1103 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3989 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18315 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_upload_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27474 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/appendblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   169237 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/baseblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50367 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/blockblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27183 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    74190 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/pageblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9626 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/sharedaccesssignature.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      935 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4381 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_auth.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3229 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_common_conversion.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6517 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_connection.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2187 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13348 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9072 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7444 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_error.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_http/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2018 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_http/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4235 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_http/httpclient.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12383 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9016 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/cloudstorageaccount.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27046 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12668 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/retry.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10043 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/sharedaccesssignature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17638 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/storageclient.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1833 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/tokencredential.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      592 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      457 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7102 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3939 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/_download_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2459 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/_upload_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   112555 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/fileservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15460 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9974 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/sharedaccesssignature.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      449 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      457 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4911 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6709 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/_encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1015 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2161 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8067 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    47646 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/queueservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4098 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/sharedaccesssignature.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      742 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      888 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      562 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20626 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7264 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_download_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7145 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1103 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5218 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18819 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_upload_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    41817 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/appendblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   177228 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/baseblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    61592 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/blockblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29575 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    82000 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/pageblobservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14986 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/sharedaccesssignature.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      992 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4688 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_auth.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3229 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_common_conversion.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6629 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_connection.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2305 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14315 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9072 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9025 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_error.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_http/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2018 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_http/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4235 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_http/httpclient.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13262 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9660 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/cloudstorageaccount.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28076 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12705 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/retry.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8207 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/sharedaccesssignature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20088 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/storageclient.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1833 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/tokencredential.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      592 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      454 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9297 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6685 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/_download_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2459 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/_upload_chunking.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   123033 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/fileservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17028 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11858 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/sharedaccesssignature.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      449 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      454 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/_constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4911 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/_deserialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6692 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/_encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1015 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/_error.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2161 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8067 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    48303 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/queueservice.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5583 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/sharedaccesssignature.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       59 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8228 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   158646 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_blob_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28784 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_blob_service_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    66438 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_container_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3356 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_deserialize.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22816 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_download.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      609 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3493 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/_azure_blob_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2209 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/_configuration.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      561 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3675 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/_azure_blob_storage_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2256 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/_configuration_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1087 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34281 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_append_blob_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   145141 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_blob_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    48007 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_block_blob_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    73061 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_container_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    42775 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_directory_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    79967 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_page_blob_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28466 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6645 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10047 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_azure_blob_storage_enums.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    63369 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    64150 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_models_py3.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1045 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34229 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_append_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   144795 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    47925 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_block_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    72844 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_container_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    42693 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_directory_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    79825 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_page_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28315 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_service_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      498 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/version.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15900 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_lease.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    48762 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4342 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_serialize.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5176 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/authentication.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15991 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/base_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6499 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/base_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1007 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18701 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26709 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/policies.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9949 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/policies_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5297 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/request_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6675 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/response_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9488 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20016 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/uploads.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13192 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/uploads_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29353 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11008 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_upload_helpers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      330 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6542 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   110874 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_blob_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27183 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_blob_service_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    57030 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_container_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19660 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_download_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15172 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_lease_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10426 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10116 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_upload_helpers.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9297 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   215964 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_blob_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34604 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_blob_service_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    81125 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_container_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8060 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_deserialize.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25503 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_download.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      779 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4907 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_azure_blob_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2821 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1197 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_vendor.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      779 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4767 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_azure_blob_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2653 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_patch.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      957 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36933 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_append_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   163444 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    59370 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_block_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    92506 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_container_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    76370 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_page_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35307 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_service_operations.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8345 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12288 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_azure_blob_storage_enums.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   103782 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   110664 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_models_py3.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      957 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    59637 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_append_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   242157 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    96200 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_block_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   134896 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_container_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   121685 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_page_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50251 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_service_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16639 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_lease.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11076 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_list_blobs_helper.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    57292 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6270 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_quick_query_helper.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7864 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_serialize.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6701 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/authentication.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      310 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16446 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/avro_io.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16593 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/avro_io_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8563 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/datafile.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7334 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/datafile_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36373 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/schema.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17790 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/base_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7050 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/base_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      704 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20674 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28970 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/policies.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11530 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/policies_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10014 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/request_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8640 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/response_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10330 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22746 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/uploads.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15229 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/uploads_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31629 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12810 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_upload_helpers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      331 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7001 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   149107 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_blob_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    32623 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_blob_service_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    64530 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_container_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22338 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_download_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16327 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_lease_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7905 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_list_blobs_helper.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7685 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11914 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_upload_helpers.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9915 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   217473 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_blob_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35330 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_blob_service_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    82891 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_container_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8060 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_deserialize.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31848 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_download.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    41056 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_encryption.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      843 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4829 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_azure_blob_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2646 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    77452 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1169 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_vendor.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      843 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4895 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_azure_blob_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2612 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_patch.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1196 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38371 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_append_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   172848 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    62003 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_block_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    97943 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_container_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    79480 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_page_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    37599 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_service_operations.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6318 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12935 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_azure_blob_storage_enums.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   109753 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_models_py3.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_patch.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1196 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    57060 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_append_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   238681 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    92591 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_block_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   134950 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_container_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   116882 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_page_blob_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50925 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_service_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16639 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_lease.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11076 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_list_blobs_helper.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    57292 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6270 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_quick_query_helper.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7882 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_serialize.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6701 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/authentication.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      310 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16446 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/avro_io.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16593 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/avro_io_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8563 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/datafile.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7334 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/datafile_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36373 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/schema.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18008 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/base_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7050 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/base_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      704 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20674 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29122 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/policies.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11530 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/policies_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10014 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/request_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8640 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/response_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10330 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22285 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/uploads.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15661 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/uploads_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31629 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13976 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_upload_helpers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      333 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7618 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   150123 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_blob_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33058 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_blob_service_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    65681 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_container_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28946 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_download_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16327 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_lease_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7905 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_list_blobs_helper.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7684 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13231 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_upload_helpers.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       59 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2002 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    30652 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_directory_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28057 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_file_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13266 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_lease.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19045 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_service_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4957 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_deserialize.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34958 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_file_system_client.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      625 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2714 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2608 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/_data_lake_storage_client.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      577 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2765 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/_configuration_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2714 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/_data_lake_storage_client_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      736 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25074 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_file_system_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    87573 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_path_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6192 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1992 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1089 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_data_lake_storage_client_enums.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10554 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10775 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_models_py3.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      718 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24992 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_file_system_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    87392 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_path_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6170 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_service_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      498 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/version.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22020 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35382 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_path_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3131 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_serialize.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5176 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/authentication.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15870 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/base_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6466 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/base_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1007 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18635 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27763 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/policies.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9949 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/policies_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5297 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/request_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6675 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/response_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9488 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20016 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/uploads.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13192 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/uploads_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18357 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      332 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      884 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29446 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_directory_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24363 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_file_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13249 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_lease_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17153 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_service_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    32965 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_file_system_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4643 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29374 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_path_client_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3048 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36179 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_directory_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    46871 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_file_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13377 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_lease.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28023 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_service_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9942 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_deserialize.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2664 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_download.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    51904 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_file_system_client.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      878 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4790 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_azure_data_lake_storage_restapi.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3409 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    77452 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1169 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_vendor.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      878 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4844 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_azure_data_lake_storage_restapi.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3375 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_patch.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      951 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31614 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_file_system_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   107271 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_path_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7290 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_service_operations.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2758 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2241 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_azure_data_lake_storage_restapi_enums.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38715 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_models_py3.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_patch.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      951 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    42848 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_file_system_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   147178 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_path_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9134 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_service_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7371 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_list_paths_helper.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50553 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    53977 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_path_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2499 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_quick_query_helper.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4750 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_serialize.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5369 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/authentication.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18032 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/base_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6792 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/base_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      668 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20683 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1590 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27627 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/policies.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9993 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/policies_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9737 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/request_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8627 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/response_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10456 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22184 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/uploads.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15661 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/uploads_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21995 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4375 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_upload_helper.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      332 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      967 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35406 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_directory_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35630 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_file_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13416 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_lease_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25834 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_service_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2716 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_download_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    49315 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_file_system_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7564 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_list_paths_helper.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2011 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    46852 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_path_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4443 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_upload_helper.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       59 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1796 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2054 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_deserialize.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    30099 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_directory_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19599 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_download.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    59539 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_file_client.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      609 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2767 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/_azure_file_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2562 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/_configuration.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      561 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2901 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/_azure_file_storage_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2609 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/_configuration_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      808 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    37857 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_directory_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    97891 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_file_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12118 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38425 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_share_operations_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3760 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4829 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_azure_file_storage_enums.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33327 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33666 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_models_py3.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      784 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    37730 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_directory_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    97590 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_file_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12066 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_service_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38253 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_share_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      498 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/version.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7084 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_lease.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    40637 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1745 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4779 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_serialize.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28414 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_share_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15925 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_share_service_client.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5176 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/authentication.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15959 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/base_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6466 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/base_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1007 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18718 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26709 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/policies.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9949 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/policies_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5297 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/request_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6675 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/response_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9488 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20016 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/uploads.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13213 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/uploads_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24437 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      330 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      701 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25762 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_directory_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18144 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_download_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    51846 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_file_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6890 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_lease_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8418 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23508 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_share_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14123 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_share_service_client_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2106 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2795 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_deserialize.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    41903 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_directory_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19052 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_download.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    73947 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_file_client.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      843 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4586 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_azure_file_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3127 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    77452 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1169 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_vendor.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      843 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4644 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/_azure_file_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3093 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/_patch.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1017 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    51410 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_directory_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   112599 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_file_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13805 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_service_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    85250 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_share_operations.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3934 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6387 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_azure_file_storage_enums.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    58450 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    60862 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_models_py3.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_patch.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1017 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    69689 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_directory_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   152563 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_file_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18427 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_service_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   115459 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_share_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10623 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_lease.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    46268 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1790 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6908 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_serialize.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    40398 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_share_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19345 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_share_service_client.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5369 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/authentication.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18032 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/base_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6792 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/base_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      668 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20689 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27627 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/policies.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9993 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/policies_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9737 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/request_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8641 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/response_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9989 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22184 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/uploads.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15661 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/uploads_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24380 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      333 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      701 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36221 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_directory_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18384 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_download_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    64579 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_file_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10214 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_lease_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8560 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33332 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_share_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16826 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_share_service_client_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       59 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1592 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1514 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_deserialize.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      782 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4396 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_azure_queue_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2823 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1197 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_vendor.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      782 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4248 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_azure_queue_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2781 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_azure_queue_storage_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2655 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2258 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_configuration_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_patch.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9762 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_message_id_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17821 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_messages_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22941 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_queue_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18240 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_service_operations.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      821 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9320 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_message_id_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18033 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_messages_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21596 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_queue_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17341 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_service_operations_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2649 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3830 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_azure_queue_storage_enums.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    30089 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31633 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_models_py3.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13587 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_message_id_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25428 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_messages_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    32815 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_queue_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25992 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_service_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      498 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/version.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5354 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_message_encoding.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19635 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    39773 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_queue_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19082 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_queue_service_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      955 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_serialize.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5369 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/authentication.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17835 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/base_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6788 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/base_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      668 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22646 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20678 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27829 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/policies.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9993 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/policies_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9737 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/request_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8747 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/response_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9985 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22645 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/uploads.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15223 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/uploads_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12337 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      493 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      477 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4942 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34942 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_queue_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17177 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_queue_service_client_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1592 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1462 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_deserialize.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      612 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2647 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/_azure_queue_storage.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2211 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/_configuration.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      564 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2781 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/_azure_queue_storage_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2258 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/_configuration_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      821 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9320 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_message_id_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18033 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_messages_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21596 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_queue_operations_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17341 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2525 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3643 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_azure_queue_storage_enums.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23880 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23909 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_models_py3.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      797 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9283 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_message_id_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17966 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_messages_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21499 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_queue_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17274 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_service_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      498 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/version.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5312 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_message_encoding.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19115 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34860 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_queue_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18504 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_queue_service_client.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5176 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/authentication.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15870 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/base_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6466 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/base_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1007 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/constants.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/encryption.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17498 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/parser.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27763 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/policies.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9949 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/policies_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5297 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/request_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6675 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/response_handlers.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9488 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20016 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/uploads.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13192 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/uploads_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12432 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared_access_signature.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      493 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      477 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4349 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/_models.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31263 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/_queue_client_async.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16980 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/_queue_service_client_async.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure_multiapi_storage.egg-info/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5977 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure_multiapi_storage.egg-info/PKG-INFO
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    54381 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure_multiapi_storage.egg-info/SOURCES.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure_multiapi_storage.egg-info/dependency_links.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2022-12-05 08:25:04.000000 azure-multiapi-storage-1.0.0/azure_multiapi_storage.egg-info/not-zip-safe
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      170 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure_multiapi_storage.egg-info/requires.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        6 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/azure_multiapi_storage.egg-info/top_level.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2022-12-05 08:25:05.000000 azure-multiapi-storage-1.0.0/setup.cfg
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2620 2022-12-05 08:24:41.000000 azure-multiapi-storage-1.0.0/setup.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1078 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/LICENSE
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       40 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/MANIFEST.in
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6058 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/PKG-INFO
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5138 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/README.rst
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       56 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1289 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4842 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_auth.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3663 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_common_conversion.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6707 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_connection.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1855 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12708 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9540 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7751 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_error.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_http/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2452 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_http/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4505 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_http/httpclient.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12244 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6465 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/cloudstorageaccount.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26207 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10013 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/retry.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15303 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/sharedaccesssignature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16244 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/storageclient.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1005 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11600 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12934 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/_encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3475 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7713 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/_request.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8065 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7366 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9333 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/tablebatch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    53331 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/tableservice.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1142 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4398 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_auth.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2874 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_common_conversion.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5691 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_connection.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1681 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10544 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3167 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_error.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_http/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2555 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_http/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13919 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_http/batchclient.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8266 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_http/httpclient.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2926 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_http/requestsclient.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10972 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_serialization.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1324 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12377 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13817 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1537 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4377 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24350 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/appendblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   143392 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/baseblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38381 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/blockblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23327 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    46296 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/pageblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8911 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/cloudstorageaccount.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/common/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1144 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/common/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       22 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/common/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       22 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/common/models.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1008 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9570 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6513 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2799 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    95690 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/fileservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14855 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22947 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/models.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      884 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4783 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1381 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2442 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8549 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    40604 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/queueservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35228 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/sharedaccesssignature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5095 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/storageclient.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1006 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8743 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3113 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4118 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/_request.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8147 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7247 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8561 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/tablebatch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    46676 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/tableservice.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      742 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1322 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/__init__.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)      997 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15754 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5225 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_download_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7596 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1537 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4423 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18312 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_upload_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27638 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/appendblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   165964 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/baseblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50536 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/blockblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26126 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    74008 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/pageblobservice.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    10060 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/sharedaccesssignature.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     1297 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/__init__.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     4084 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_auth.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     3663 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_common_conversion.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     6590 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_connection.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     2086 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_constants.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    12791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_deserialization.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     9506 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_encryption.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     7751 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_error.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_http/
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     2452 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_http/__init__.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     4505 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_http/httpclient.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    12208 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_serialization.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     9450 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/cloudstorageaccount.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    25988 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/models.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    11481 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/retry.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    10477 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/sharedaccesssignature.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    16912 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/storageclient.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1026 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/__init__.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)      889 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7536 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4373 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/_download_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2893 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5225 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/_upload_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   112937 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/fileservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15903 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/models.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)    10408 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/sharedaccesssignature.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      883 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/__init__.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)      889 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5357 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7143 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/_encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1449 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2595 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8501 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    47641 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/queueservice.py
+-rwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)     4532 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/sharedaccesssignature.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      742 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      888 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      565 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16128 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_download_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7162 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1103 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3989 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18315 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_upload_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27474 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/appendblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   169237 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/baseblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50367 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/blockblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27183 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    74190 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/pageblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9626 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/sharedaccesssignature.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      935 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4381 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_auth.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3229 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_common_conversion.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6517 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_connection.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2187 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13348 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9072 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7444 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_error.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_http/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2018 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_http/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4235 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_http/httpclient.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12383 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9016 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/cloudstorageaccount.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27046 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12668 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/retry.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10043 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/sharedaccesssignature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17638 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/storageclient.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1833 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/tokencredential.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      592 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      457 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7102 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3939 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/_download_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2459 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/_upload_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   112555 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/fileservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15460 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9974 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/sharedaccesssignature.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      449 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      457 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4911 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6709 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/_encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1015 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2161 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8067 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    47646 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/queueservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4098 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/sharedaccesssignature.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      742 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      888 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      562 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20626 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7264 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_download_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7145 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1103 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5218 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18819 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_upload_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    41817 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/appendblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   177228 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/baseblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    61592 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/blockblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29575 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    82000 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/pageblobservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14986 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/sharedaccesssignature.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      992 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4688 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_auth.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3229 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_common_conversion.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6629 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_connection.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2305 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14315 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9072 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9025 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_error.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_http/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2018 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_http/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4235 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_http/httpclient.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13262 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9660 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/cloudstorageaccount.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28076 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12705 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/retry.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8207 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/sharedaccesssignature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20088 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/storageclient.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1833 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/tokencredential.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      592 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      454 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9297 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6685 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/_download_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2459 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/_upload_chunking.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   123033 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/fileservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17028 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11858 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/sharedaccesssignature.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      449 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      454 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/_constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4911 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/_deserialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6692 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/_encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1015 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/_error.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2161 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8067 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    48303 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/queueservice.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5583 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/sharedaccesssignature.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       59 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8228 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   158646 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_blob_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28784 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_blob_service_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    66438 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_container_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3356 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_deserialize.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22816 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_download.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      609 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3493 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/_azure_blob_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2209 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/_configuration.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      561 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3675 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/_azure_blob_storage_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2256 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/_configuration_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1087 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34281 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_append_blob_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   145141 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_blob_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    48007 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_block_blob_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    73061 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_container_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    42775 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_directory_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    79967 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_page_blob_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28466 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6645 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10047 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_azure_blob_storage_enums.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    63369 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    64150 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_models_py3.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1045 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34229 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_append_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   144795 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    47925 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_block_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    72844 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_container_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    42693 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_directory_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    79825 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_page_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28315 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_service_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      498 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/version.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15900 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_lease.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    48762 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4342 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_serialize.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5176 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/authentication.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15991 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/base_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6499 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/base_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1007 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18701 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26709 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/policies.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9949 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/policies_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5297 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/request_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6675 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/response_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9488 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20016 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/uploads.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13192 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/uploads_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29353 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11008 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_upload_helpers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      330 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6542 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   110874 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_blob_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27183 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_blob_service_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    57030 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_container_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19660 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_download_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15172 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_lease_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10426 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10116 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_upload_helpers.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9297 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   215964 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_blob_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34604 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_blob_service_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    81125 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_container_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8060 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_deserialize.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25503 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_download.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      779 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4907 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_azure_blob_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2821 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1197 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_vendor.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      779 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4767 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_azure_blob_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2653 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_patch.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      957 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36933 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_append_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   163444 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    59370 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_block_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    92506 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_container_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    76370 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_page_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35307 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_service_operations.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8345 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12288 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_azure_blob_storage_enums.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   103782 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   110664 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_models_py3.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      957 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    59637 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_append_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   242157 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    96200 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_block_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   134896 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_container_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   121685 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_page_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50251 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_service_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16639 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_lease.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11076 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_list_blobs_helper.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    57292 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6270 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_quick_query_helper.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7864 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_serialize.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6701 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/authentication.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      310 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16446 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/avro_io.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16593 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/avro_io_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8563 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/datafile.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7334 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/datafile_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36373 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/schema.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17790 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/base_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7050 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/base_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      704 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20674 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28970 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/policies.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11530 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/policies_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10014 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/request_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8640 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/response_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10330 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22746 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/uploads.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15229 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/uploads_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31629 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12810 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_upload_helpers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      331 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7001 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   149107 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_blob_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    32623 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_blob_service_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    64530 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_container_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22338 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_download_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16327 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_lease_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7905 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_list_blobs_helper.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7685 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11914 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_upload_helpers.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9915 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   217473 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_blob_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35330 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_blob_service_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    82891 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_container_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8060 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_deserialize.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31848 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_download.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    41056 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_encryption.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      843 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4829 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_azure_blob_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2646 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    77452 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1169 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_vendor.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      843 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4895 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_azure_blob_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2612 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_patch.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1196 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38371 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_append_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   172848 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    62003 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_block_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    97943 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_container_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    79480 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_page_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    37599 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_service_operations.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6318 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12935 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_azure_blob_storage_enums.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   109753 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_models_py3.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_patch.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1196 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    57060 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_append_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   238681 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    92591 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_block_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   134950 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_container_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   116882 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_page_blob_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50925 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_service_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16639 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_lease.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11076 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_list_blobs_helper.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    57292 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6270 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_quick_query_helper.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7882 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_serialize.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6701 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/authentication.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      310 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16446 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/avro_io.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16593 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/avro_io_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8563 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/datafile.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7334 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/datafile_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36373 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/schema.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18008 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/base_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7050 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/base_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      704 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20674 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29122 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/policies.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11530 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/policies_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10014 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/request_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8640 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/response_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10330 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22285 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/uploads.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15661 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/uploads_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31629 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13976 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_upload_helpers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      333 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7618 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   150123 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_blob_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33058 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_blob_service_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    65681 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_container_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28946 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_download_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16327 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_lease_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7905 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_list_blobs_helper.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7684 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13231 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_upload_helpers.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       59 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2002 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    30652 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_directory_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28057 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_file_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13266 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_lease.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19045 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_service_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4957 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_deserialize.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34958 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_file_system_client.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      625 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2714 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2608 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/_data_lake_storage_client.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      577 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2765 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/_configuration_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2714 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/_data_lake_storage_client_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      736 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25074 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_file_system_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    87573 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_path_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6192 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1992 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1089 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_data_lake_storage_client_enums.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10554 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10775 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_models_py3.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      718 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24992 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_file_system_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    87392 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_path_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6170 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_service_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      498 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/version.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22020 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35382 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_path_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3131 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_serialize.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5176 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/authentication.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15870 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/base_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6466 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/base_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1007 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18635 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27763 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/policies.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9949 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/policies_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5297 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/request_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6675 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/response_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9488 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20016 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/uploads.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13192 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/uploads_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18357 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      332 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      884 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29446 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_directory_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24363 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_file_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13249 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_lease_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17153 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_service_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    32965 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_file_system_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4643 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29374 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_path_client_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3048 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    36179 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_directory_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    46871 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_file_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13377 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_lease.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28023 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_service_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9942 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_deserialize.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2664 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_download.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    51904 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_file_system_client.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      878 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4790 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_azure_data_lake_storage_restapi.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3409 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    77452 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1169 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_vendor.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      878 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4844 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_azure_data_lake_storage_restapi.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3375 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_patch.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      951 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31614 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_file_system_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   107271 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_path_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7290 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_service_operations.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2758 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2241 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_azure_data_lake_storage_restapi_enums.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38715 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_models_py3.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_patch.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      951 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    42848 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_file_system_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   147178 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_path_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9134 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_service_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7371 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_list_paths_helper.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50553 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    53977 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_path_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2499 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_quick_query_helper.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4750 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_serialize.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5369 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/authentication.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18032 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/base_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6792 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/base_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      668 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20683 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1590 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27627 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/policies.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9993 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/policies_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9737 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/request_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8627 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/response_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10456 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22184 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/uploads.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15661 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/uploads_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21995 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4375 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_upload_helper.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      332 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      967 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35406 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_directory_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35630 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_file_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13416 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_lease_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25834 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_service_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2716 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_download_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    49315 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_file_system_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7564 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_list_paths_helper.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2011 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    46852 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_path_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4443 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_upload_helper.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       59 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1796 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2054 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_deserialize.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    30099 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_directory_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19599 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_download.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    59539 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_file_client.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      609 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2767 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/_azure_file_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2562 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/_configuration.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      561 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2901 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/_azure_file_storage_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2609 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/_configuration_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      808 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    37857 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_directory_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    97891 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_file_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12118 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38425 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_share_operations_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3760 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4829 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_azure_file_storage_enums.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33327 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33666 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_models_py3.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      784 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    37730 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_directory_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    97590 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_file_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12066 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_service_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    38253 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_share_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      498 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/version.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7084 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_lease.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    40637 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1745 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4779 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_serialize.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    28414 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_share_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15925 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_share_service_client.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5176 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/authentication.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15959 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/base_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6466 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/base_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1007 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18718 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26709 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/policies.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9949 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/policies_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5297 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/request_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6675 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/response_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9488 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20016 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/uploads.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13213 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/uploads_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24437 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      330 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      701 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25762 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_directory_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18144 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_download_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    51846 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_file_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6890 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_lease_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8418 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23508 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_share_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14123 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_share_service_client_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2749 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2795 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_deserialize.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    49793 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_directory_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19304 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_download.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    83598 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_file_client.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      835 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5492 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_azure_file_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4288 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    78824 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1302 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_vendor.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      835 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5608 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/_azure_file_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4299 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1530 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/_patch.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1002 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    53512 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_directory_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   116468 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_file_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14252 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_service_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    86740 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_share_operations.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4059 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6510 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/_azure_file_storage_enums.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    62679 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/_models_py3.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/_patch.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1002 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    76437 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_directory_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   165586 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_file_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18995 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_service_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   118171 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_share_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12763 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_lease.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    46513 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1790 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6962 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_serialize.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    48728 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_share_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23360 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_share_service_client.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1477 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7148 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/authentication.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17824 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/base_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7019 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/base_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      620 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21044 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1590 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29100 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/policies.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11530 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/policies_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9968 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/request_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8897 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/response_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10032 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22114 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/uploads.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16818 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/uploads_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24380 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      333 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      701 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    44563 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_directory_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18624 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_download_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    74849 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_file_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12354 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_lease_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8596 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    42026 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_share_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20967 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_share_service_client_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       59 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1592 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1514 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_deserialize.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      782 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4396 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_azure_queue_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2823 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1197 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_vendor.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      782 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4248 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_azure_queue_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2781 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_azure_queue_storage_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2655 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2258 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_configuration_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_patch.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9762 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_message_id_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17821 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_messages_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22941 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_queue_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18240 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_service_operations.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      821 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9320 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_message_id_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18033 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_messages_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21596 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_queue_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17341 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_service_operations_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2649 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3830 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_azure_queue_storage_enums.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    30089 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31633 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_models_py3.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      791 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13587 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_message_id_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25428 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_messages_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    32815 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_queue_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25992 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_service_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      498 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/version.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5354 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_message_encoding.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19635 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    39773 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_queue_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19082 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_queue_service_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      955 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_serialize.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5369 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/authentication.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17835 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/base_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6788 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/base_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      668 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22646 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20678 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27829 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/policies.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9993 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/policies_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9737 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/request_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8747 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/response_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9985 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22645 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/uploads.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15223 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/uploads_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12337 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      493 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      477 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4942 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34942 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_queue_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17177 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_queue_service_client_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1592 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1462 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_deserialize.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      612 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2647 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/_azure_queue_storage.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2211 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/_configuration.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      564 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2781 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/_azure_queue_storage_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2258 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/_configuration_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      821 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9320 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_message_id_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18033 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_messages_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21596 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_queue_operations_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17341 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2525 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3643 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_azure_queue_storage_enums.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23880 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23909 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_models_py3.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      797 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9283 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_message_id_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17966 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_messages_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    21499 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_queue_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17274 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_service_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      498 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/version.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5312 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_message_encoding.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19115 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34860 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_queue_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18504 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_queue_service_client.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1529 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5176 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/authentication.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    15870 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/base_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6466 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/base_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1007 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/constants.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22608 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/encryption.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    17498 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      617 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/parser.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    27763 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/policies.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9949 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/policies_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5297 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/request_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6675 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/response_handlers.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9488 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    20016 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/uploads.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13192 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/uploads_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12432 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared_access_signature.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      493 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      477 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4349 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/_models.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31263 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/_queue_client_async.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    16980 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/_queue_service_client_async.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/azure_multiapi_storage.egg-info/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6058 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure_multiapi_storage.egg-info/PKG-INFO
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    54236 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure_multiapi_storage.egg-info/SOURCES.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure_multiapi_storage.egg-info/dependency_links.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure_multiapi_storage.egg-info/not-zip-safe
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      170 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure_multiapi_storage.egg-info/requires.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        6 2023-04-13 05:27:02.000000 azure-multiapi-storage-1.1.0/azure_multiapi_storage.egg-info/top_level.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       67 2023-04-13 05:27:03.000000 azure-multiapi-storage-1.1.0/setup.cfg
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2620 2023-04-13 05:26:52.000000 azure-multiapi-storage-1.1.0/setup.py
```

### Comparing `azure-multiapi-storage-1.0.0/LICENSE` & `azure-multiapi-storage-1.1.0/LICENSE`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/PKG-INFO` & `azure-multiapi-storage-1.1.0/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-multiapi-storage
-Version: 1.0.0
+Version: 1.1.0
 Summary: Microsoft Azure Storage Client Library for Python with multi API version support.
 Home-page: https://github.com/Azure/azure-multiapi-storage-python
 Author: Microsoft Corporation
 Author-email: azpycli@microsoft.com
 License: MIT
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python
@@ -35,14 +35,18 @@
 
 - The official Azure CosmosDB Table SDK is at https://github.com/Azure/azure-cosmosdb-python/tree/master/azure-cosmosdb-table.
 
 - **Please file issues at the appropriate repository above.**
 
 Change Log
 ----------
+1.1.0
+++++++
+* fileshare: Support v2022-11-02(12.12.0b1) and remove v2021-06-08
+
 1.0.0
 ++++++
 * storageV1:
     - Keep only v2018-11-09, v2017-11-09, v2017-04-17, v2015-04-05
 * blob:
     - Keep only v2021-08-06, v2021-06-08, v2019-07-07
 * fileshare:
```

### Comparing `azure-multiapi-storage-1.0.0/README.rst` & `azure-multiapi-storage-1.1.0/README.rst`

 * *Files 2% similar despite different names*

```diff
@@ -13,14 +13,18 @@
 
 - The official Azure CosmosDB Table SDK is at https://github.com/Azure/azure-cosmosdb-python/tree/master/azure-cosmosdb-table.
 
 - **Please file issues at the appropriate repository above.**
 
 Change Log
 ----------
+1.1.0
+++++++
+* fileshare: Support v2022-11-02(12.12.0b1) and remove v2021-06-08
+
 1.0.0
 ++++++
 * storageV1:
     - Keep only v2018-11-09, v2017-11-09, v2017-04-17, v2015-04-05
 * blob:
     - Keep only v2021-08-06, v2021-06-08, v2019-07-07
 * fileshare:
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_auth.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_auth.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_common_conversion.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_common_conversion.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_connection.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_connection.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_http/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_http/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_http/httpclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_http/httpclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/cloudstorageaccount.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/cloudstorageaccount.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/retry.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/retry.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/common/storageclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/common/storageclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/_request.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/_request.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/tablebatch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/tablebatch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/cosmosdb/v2017_04_17/table/tableservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/cosmosdb/v2017_04_17/table/tableservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_auth.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_auth.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_common_conversion.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_common_conversion.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_connection.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_connection.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_http/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_http/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_http/batchclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_http/batchclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_http/httpclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_http/httpclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_http/requestsclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_http/requestsclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/appendblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/appendblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/baseblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/baseblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/blockblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/blockblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/blob/pageblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/blob/pageblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/cloudstorageaccount.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/cloudstorageaccount.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/common/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/common/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/fileservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/fileservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/file/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/file/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/queue/queueservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/queue/queueservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/storageclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/storageclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/_request.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/_request.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/tablebatch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/tablebatch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2015_04_05/table/tableservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2015_04_05/table/tableservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_download_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_download_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/_upload_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/_upload_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/appendblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/appendblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/baseblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/baseblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/blockblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/blockblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/pageblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/pageblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/blob/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/blob/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_auth.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_auth.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_common_conversion.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_common_conversion.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_connection.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_connection.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_http/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_http/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_http/httpclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_http/httpclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/cloudstorageaccount.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/cloudstorageaccount.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/retry.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/retry.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/common/storageclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/common/storageclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/_constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/_constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/_download_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/_download_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/_upload_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/_upload_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/fileservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/fileservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/file/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/file/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/_constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/_constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/queueservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/queueservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_04_17/queue/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_04_17/queue/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_download_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_download_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/_upload_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/_upload_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/appendblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/appendblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/baseblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/baseblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/blockblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/blockblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/pageblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/pageblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/blob/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/blob/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_auth.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_auth.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_common_conversion.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_common_conversion.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_connection.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_connection.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_http/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_http/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_http/httpclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_http/httpclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/cloudstorageaccount.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/cloudstorageaccount.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/retry.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/retry.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/storageclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/storageclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/common/tokencredential.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/common/tokencredential.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/_download_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/_download_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/_upload_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/_upload_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/fileservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/fileservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/file/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/file/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/queueservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/queueservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2017_11_09/queue/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2017_11_09/queue/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_download_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_download_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/_upload_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/_upload_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/appendblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/appendblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/baseblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/baseblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/blockblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/blockblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/pageblobservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/pageblobservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/blob/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/blob/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_auth.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_auth.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_common_conversion.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_common_conversion.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_connection.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_connection.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_http/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_http/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_http/httpclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_http/httpclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/cloudstorageaccount.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/cloudstorageaccount.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/retry.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/retry.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/storageclient.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/storageclient.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/common/tokencredential.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/common/tokencredential.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/_download_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/_download_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/_upload_chunking.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/_upload_chunking.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/fileservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/fileservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/file/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/file/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/_deserialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/_deserialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/_error.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/_error.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/queueservice.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/queueservice.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storage/v2018_11_09/queue/sharedaccesssignature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storage/v2018_11_09/queue/sharedaccesssignature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_blob_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_blob_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_blob_service_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_blob_service_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_container_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_container_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_deserialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_deserialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_download.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_download.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/_azure_blob_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/_azure_blob_storage.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/_azure_blob_storage_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/_azure_blob_storage_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/_configuration_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/_configuration_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_append_blob_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_append_blob_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_blob_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_blob_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_block_blob_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_block_blob_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_container_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_container_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_directory_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_directory_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_page_blob_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_page_blob_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_azure_blob_storage_enums.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_azure_blob_storage_enums.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_models_py3.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/models/_models_py3.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_append_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_append_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_block_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_block_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_container_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_container_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_directory_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_directory_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_page_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_page_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_generated/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_lease.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_lease.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_serialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_serialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/authentication.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/authentication.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/base_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/base_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/base_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/base_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/parser.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/parser.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/policies.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/policies.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/policies_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/policies_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/request_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/request_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/response_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/response_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/uploads.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/uploads.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/uploads_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared/uploads_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/_upload_helpers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/_upload_helpers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_blob_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_blob_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_blob_service_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_blob_service_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_container_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_container_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_download_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_download_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_lease_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_lease_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_upload_helpers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2019_07_07/aio/_upload_helpers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_blob_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_blob_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_blob_service_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_blob_service_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_container_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_container_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_deserialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_deserialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_download.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_download.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_azure_blob_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_azure_blob_storage.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_vendor.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/_vendor.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_azure_blob_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_azure_blob_storage.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_append_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_append_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_block_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_block_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_container_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_container_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_page_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_page_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/aio/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_azure_blob_storage_enums.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_azure_blob_storage_enums.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_models_py3.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/models/_models_py3.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_append_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_append_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_block_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_block_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_container_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_container_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_page_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_page_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_generated/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_lease.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_lease.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_list_blobs_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_list_blobs_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_quick_query_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_quick_query_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_serialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_serialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/authentication.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/authentication.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/avro_io.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/avro_io.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/avro_io_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/avro_io_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/datafile.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/datafile.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/datafile_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/datafile_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/schema.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/avro/schema.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/base_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/base_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/base_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/base_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/parser.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/parser.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/policies.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/policies.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/policies_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/policies_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/request_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/request_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/response_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/response_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/uploads.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/uploads.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/uploads_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared/uploads_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/_upload_helpers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/_upload_helpers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_blob_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_blob_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_blob_service_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_blob_service_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_container_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_container_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_download_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_download_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_lease_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_lease_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_list_blobs_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_list_blobs_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_upload_helpers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_06_08/aio/_upload_helpers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_blob_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_blob_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_blob_service_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_blob_service_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_container_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_container_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_deserialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_deserialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_download.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_download.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_azure_blob_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_azure_blob_storage.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_vendor.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/_vendor.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_azure_blob_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_azure_blob_storage.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_append_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_append_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_block_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_block_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_container_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_container_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_page_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_page_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/aio/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_azure_blob_storage_enums.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_azure_blob_storage_enums.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_models_py3.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_models_py3.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/models/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_append_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_append_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_block_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_block_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_container_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_container_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_page_blob_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_page_blob_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_generated/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_lease.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_lease.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_list_blobs_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_list_blobs_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_quick_query_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_quick_query_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_serialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_serialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/authentication.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/authentication.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/avro_io.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/avro_io.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/avro_io_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/avro_io_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/datafile.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/datafile.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/datafile_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/datafile_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/schema.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/avro/schema.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/base_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/base_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/base_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/base_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/parser.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/parser.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/policies.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/policies.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/policies_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/policies_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/request_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/request_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/response_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/response_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/uploads.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/uploads.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/uploads_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared/uploads_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/_upload_helpers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/_upload_helpers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_blob_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_blob_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_blob_service_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_blob_service_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_container_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_container_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_download_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_download_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_lease_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_lease_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_list_blobs_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_list_blobs_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_upload_helpers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/blob/v2021_08_06/aio/_upload_helpers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_directory_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_directory_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_file_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_file_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_lease.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_lease.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_service_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_data_lake_service_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_deserialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_deserialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_file_system_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_file_system_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/_data_lake_storage_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/_data_lake_storage_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/_configuration_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/_configuration_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/_data_lake_storage_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/_data_lake_storage_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_file_system_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_file_system_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_path_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_path_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_data_lake_storage_client_enums.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_data_lake_storage_client_enums.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_models_py3.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/models/_models_py3.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_file_system_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_file_system_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_path_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_path_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_generated/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_path_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_path_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_serialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_serialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/authentication.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/authentication.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/base_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/base_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/base_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/base_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/parser.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/parser.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/policies.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/policies.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/policies_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/policies_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/request_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/request_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/response_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/response_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/uploads.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/uploads.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/uploads_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared/uploads_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/_shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_directory_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_directory_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_file_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_file_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_lease_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_lease_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_service_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_data_lake_service_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_file_system_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_file_system_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_path_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2019_07_07/aio/_path_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_directory_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_directory_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_file_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_file_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_lease.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_lease.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_service_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_data_lake_service_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_deserialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_deserialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_download.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_download.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_file_system_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_file_system_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_azure_data_lake_storage_restapi.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_azure_data_lake_storage_restapi.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_serialization.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_vendor.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/_vendor.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_azure_data_lake_storage_restapi.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_azure_data_lake_storage_restapi.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_file_system_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_file_system_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_path_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_path_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/aio/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_azure_data_lake_storage_restapi_enums.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_azure_data_lake_storage_restapi_enums.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_models_py3.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_models_py3.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/models/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_file_system_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_file_system_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_path_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_path_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_generated/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_list_paths_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_list_paths_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_path_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_path_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_quick_query_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_quick_query_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_serialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_serialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/authentication.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/authentication.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/base_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/base_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/base_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/base_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/parser.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/parser.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/policies.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/policies.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/policies_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/policies_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/request_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/request_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/response_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/response_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/uploads.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/uploads.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/uploads_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared/uploads_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_upload_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/_upload_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_directory_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_directory_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_file_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_file_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_lease_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_lease_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_service_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_data_lake_service_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_download_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_download_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_file_system_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_file_system_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_list_paths_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_list_paths_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_path_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_path_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_upload_helper.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/filedatalake/v2021_08_06/aio/_upload_helper.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_deserialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_deserialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_directory_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_directory_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_download.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_download.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_file_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_file_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/_azure_file_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/_azure_file_storage.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/_azure_file_storage_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/_azure_file_storage_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/_configuration_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/_configuration_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_directory_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_directory_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_file_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_file_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_share_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/aio/operations_async/_share_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_azure_file_storage_enums.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_azure_file_storage_enums.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_models_py3.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/models/_models_py3.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_directory_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_directory_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_file_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_file_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_share_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_generated/operations/_share_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_lease.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_lease.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_parser.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_parser.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_serialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_serialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_share_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_share_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_share_service_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_share_service_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/authentication.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/authentication.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/base_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/base_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/base_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/base_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/parser.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/parser.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/policies.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/policies.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/policies_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/policies_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/request_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/request_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/response_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/response_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/uploads.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/uploads.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/uploads_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared/uploads_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/_shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_directory_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_directory_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_download_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_download_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_file_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_file_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_lease_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_lease_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_share_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_share_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_share_service_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_share_service_client_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,82 +1,60 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 
 from ._version import VERSION
-from ._file_client import ShareFileClient
-from ._directory_client import ShareDirectoryClient
-from ._share_client import ShareClient
-from ._share_service_client import ShareServiceClient
-from ._lease import ShareLeaseClient
-from ._shared_access_signature import generate_account_sas, generate_share_sas, generate_file_sas
+from ._queue_client import QueueClient
+from ._queue_service_client import QueueServiceClient
+from ._shared_access_signature import generate_account_sas, generate_queue_sas
 from ._shared.policies import ExponentialRetry, LinearRetry
-from ._shared.models import (
+from ._shared.models import(
     LocationMode,
     ResourceTypes,
     AccountSasPermissions,
-    StorageErrorCode)
+    StorageErrorCode
+)
+from ._message_encoding import (
+    TextBase64EncodePolicy,
+    TextBase64DecodePolicy,
+    BinaryBase64EncodePolicy,
+    BinaryBase64DecodePolicy,
+)
 from ._models import (
-    ShareProperties,
-    DirectoryProperties,
-    Handle,
-    FileProperties,
+    QueueMessage,
+    QueueProperties,
+    QueueSasPermissions,
+    AccessPolicy,
+    QueueAnalyticsLogging,
     Metrics,
-    RetentionPolicy,
     CorsRule,
-    ShareSmbSettings,
-    SmbMultichannel,
-    ShareProtocolSettings,
-    ShareProtocols,
-    AccessPolicy,
-    FileSasPermissions,
-    ShareSasPermissions,
-    ContentSettings,
-    NTFSAttributes)
-from ._generated.models import (
-    HandleItem,
-    ShareAccessTier
-)
-from ._generated.models import (
-    ShareRootSquash
+    RetentionPolicy,
 )
 
 __version__ = VERSION
 
-
 __all__ = [
-    'ShareFileClient',
-    'ShareDirectoryClient',
-    'ShareClient',
-    'ShareServiceClient',
-    'ShareLeaseClient',
+    'QueueClient',
+    'QueueServiceClient',
     'ExponentialRetry',
     'LinearRetry',
     'LocationMode',
     'ResourceTypes',
     'AccountSasPermissions',
     'StorageErrorCode',
+    'QueueMessage',
+    'QueueProperties',
+    'QueueSasPermissions',
+    'AccessPolicy',
+    'TextBase64EncodePolicy',
+    'TextBase64DecodePolicy',
+    'BinaryBase64EncodePolicy',
+    'BinaryBase64DecodePolicy',
+    'QueueAnalyticsLogging',
     'Metrics',
-    'RetentionPolicy',
     'CorsRule',
-    'ShareSmbSettings',
-    'ShareAccessTier',
-    'SmbMultichannel',
-    'ShareProtocolSettings',
-    'AccessPolicy',
-    'FileSasPermissions',
-    'ShareSasPermissions',
-    'ShareProtocols',
-    'ShareProperties',
-    'DirectoryProperties',
-    'FileProperties',
-    'ContentSettings',
-    'Handle',
-    'NTFSAttributes',
-    'HandleItem',
-    'ShareRootSquash',
+    'RetentionPolicy',
     'generate_account_sas',
-    'generate_share_sas',
-    'generate_file_sas'
+    'generate_queue_sas'
 ]
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_deserialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_deserialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_directory_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_directory_client.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,47 +1,48 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 
 import functools
+import sys
 import time
-from typing import (  # pylint: disable=unused-import
-    Optional, Union, Any, Dict, TYPE_CHECKING
+from datetime import datetime
+from typing import (
+    Any, AnyStr, Dict, IO, Iterable, Optional, Union,
+    TYPE_CHECKING
 )
+from urllib.parse import urlparse, quote, unquote
 
+from typing_extensions import Self
 
-try:
-    from urllib.parse import urlparse, quote, unquote
-except ImportError:
-    from urlparse import urlparse # type: ignore
-    from urllib2 import quote, unquote # type: ignore
-
-import six
 from azure.core.exceptions import HttpResponseError, ResourceNotFoundError
 from azure.core.paging import ItemPaged
 from azure.core.pipeline import Pipeline
 from azure.core.tracing.decorator import distributed_trace
-
 from ._generated import AzureFileStorage
 from ._shared.base_client import StorageAccountHostsMixin, TransportWrapper, parse_connection_str, parse_query
 from ._shared.request_handlers import add_metadata_headers
 from ._shared.response_handlers import return_response_headers, process_storage_error
 from ._shared.parser import _str
 from ._parser import _get_file_permission, _datetime_to_str
 from ._deserialize import deserialize_directory_properties
 from ._serialize import get_api_version, get_dest_access_conditions, get_rename_smb_properties
 from ._file_client import ShareFileClient
-from ._models import DirectoryPropertiesPaged, HandlesPaged, NTFSAttributes  # pylint: disable=unused-import
+from ._models import DirectoryPropertiesPaged, HandlesPaged
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # pylint: disable=ungrouped-imports
 
 if TYPE_CHECKING:
-    from datetime import datetime
-    from ._models import ShareProperties, DirectoryProperties, ContentSettings
-    from ._generated.models import HandleItem
+    from azure.core.credentials import AzureNamedKeyCredential, AzureSasCredential, TokenCredential
+    from ._models import DirectoryProperties, Handle, NTFSAttributes
 
 
 class ShareDirectoryClient(StorageAccountHostsMixin):
     """A client to interact with a specific directory, although it may not yet exist.
 
     For operations relating to a specific subdirectory or file in this share, the clients for those
     entities can also be retrieved using the :func:`get_subdirectory_client` and :func:`get_file_client` functions.
@@ -67,45 +68,54 @@
         account URL already has a SAS token. The value can be a SAS token string,
         an instance of a AzureSasCredential or AzureNamedKeyCredential from azure.core.credentials,
         an account shared access key, or an instance of a TokenCredentials class from azure.identity.
         If the resource URI already contains a SAS token, this will be ignored in favor of an explicit credential
         - except in the case of AzureSasCredential, where the conflicting SAS tokens will raise a ValueError.
         If using an instance of AzureNamedKeyCredential, "name" should be the storage account name, and "key"
         should be the storage account key.
+    :keyword token_intent:
+        Required when using `TokenCredential` for authentication and ignored for other forms of authentication.
+        Specifies the intent for all requests when using `TokenCredential` authentication. Possible values are:
+
+        backup - Specifies requests are intended for backup/admin type operations, meaning that all file/directory
+                 ACLs are bypassed and full permissions are granted. User must also have required RBAC permission.
+
+    :paramtype token_intent: Literal['backup']
+    :keyword bool allow_trailing_dot: If true, the trailing dot will not be trimmed from the target URI.
+    :keyword bool allow_source_trailing_dot: If true, the trailing dot will not be trimmed from the source URI.
     :keyword str api_version:
         The Storage API version to use for requests. Default value is the most recent service version that is
         compatible with the current SDK. Setting to an older version may result in reduced feature compatibility.
 
         .. versionadded:: 12.1.0
 
     :keyword str secondary_hostname:
         The hostname of the secondary endpoint.
     :keyword int max_range_size: The maximum range size used for a file upload. Defaults to 4*1024*1024.
     """
-    def __init__( # type: ignore
-            self, account_url,  # type: str
-            share_name, # type: str
-            directory_path, # type: str
-            snapshot=None,  # type: Optional[Union[str, Dict[str, Any]]]
-            credential=None, # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs # type: Optional[Any]
-        ):
-        # type: (...) -> None
+    def __init__(
+            self, account_url: str,
+            share_name: str,
+            directory_path: str,
+            snapshot: Optional[Union[str, Dict[str, Any]]] = None,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            *,
+            token_intent: Optional[Literal['backup']] = None,
+            **kwargs: Any
+        ) -> None:
         try:
             if not account_url.lower().startswith('http'):
                 account_url = "https://" + account_url
         except AttributeError:
             raise ValueError("Account URL must be a string.")
         parsed_url = urlparse(account_url.rstrip('/'))
         if not share_name:
             raise ValueError("Please specify a share name.")
         if not parsed_url.netloc:
             raise ValueError("Invalid URL: {}".format(account_url))
-        if hasattr(credential, 'get_token'):
-            raise ValueError("Token credentials not supported by the File service.")
 
         path_snapshot, sas_token = parse_query(parsed_url.query)
         if not sas_token and not credential:
             raise ValueError(
                 'You need to provide either an account shared key or SAS token when creating a storage service.')
         try:
             self.snapshot = snapshot.snapshot # type: ignore
@@ -117,24 +127,30 @@
 
         self.share_name = share_name
         self.directory_path = directory_path
 
         self._query_str, credential = self._format_query_string(
             sas_token, credential, share_snapshot=self.snapshot)
         super(ShareDirectoryClient, self).__init__(parsed_url, service='file-share', credential=credential, **kwargs)
-        self._client = AzureFileStorage(url=self.url, base_url=self.url, pipeline=self._pipeline)
+        self.allow_trailing_dot = kwargs.pop('allow_trailing_dot', None)
+        self.allow_source_trailing_dot = kwargs.pop('allow_source_trailing_dot', None)
+        self.file_request_intent = token_intent
+        self._client = AzureFileStorage(url=self.url, base_url=self.url, pipeline=self._pipeline,
+                                        allow_trailing_dot=self.allow_trailing_dot,
+                                        allow_source_trailing_dot=self.allow_source_trailing_dot,
+                                        file_request_intent=self.file_request_intent)
         self._client._config.version = get_api_version(kwargs)  # pylint: disable=protected-access
 
     @classmethod
-    def from_directory_url(cls, directory_url,  # type: str
-            snapshot=None,  # type: Optional[Union[str, Dict[str, Any]]]
-            credential=None, # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs # type: Optional[Any]
-        ):
-        # type: (...) -> ShareDirectoryClient
+    def from_directory_url(
+            cls, directory_url: str,
+            snapshot: Optional[Union[str, Dict[str, Any]]] = None,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            **kwargs: Any
+        ) -> Self:
         """Create a ShareDirectoryClient from a directory url.
 
         :param str directory_url:
             The full URI to the directory.
         :param str snapshot:
             An optional share snapshot on which to operate. This can be the snapshot ID string
             or the response returned from :func:`ShareClient.create_snapshot`.
@@ -172,35 +188,34 @@
             credential=credential, **kwargs)
 
     def _format_url(self, hostname):
         """Format the endpoint URL according to the current location
         mode hostname.
         """
         share_name = self.share_name
-        if isinstance(share_name, six.text_type):
+        if isinstance(share_name, str):
             share_name = share_name.encode('UTF-8')
         directory_path = ""
         if self.directory_path:
             directory_path = "/" + quote(self.directory_path, safe='~')
         return "{}://{}/{}{}{}".format(
             self.scheme,
             hostname,
             quote(share_name),
             directory_path,
             self._query_str)
 
     @classmethod
     def from_connection_string(
-            cls, conn_str,  # type: str
-            share_name,  # type: str
-            directory_path,  # type: str
-            credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs  # type: Any
-        ):
-        # type: (...) -> ShareDirectoryClient
+            cls, conn_str: str,
+            share_name: str,
+            directory_path: str,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            **kwargs: Any
+        ) -> Self:
         """Create ShareDirectoryClient from a Connection String.
 
         :param str conn_str:
             A connection string to an Azure Storage account.
         :param share_name: The name of the share.
         :type share_name: str
         :param str directory_path:
@@ -239,17 +254,19 @@
 
         _pipeline = Pipeline(
             transport=TransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
             policies=self._pipeline._impl_policies # pylint: disable = protected-access
         )
         return ShareFileClient(
             self.url, file_path=file_name, share_name=self.share_name, snapshot=self.snapshot,
-            credential=self.credential, api_version=self.api_version,
+            credential=self.credential, token_intent=self.file_request_intent, api_version=self.api_version,
             _hosts=self._hosts, _configuration=self._config,
-            _pipeline=_pipeline, _location_mode=self._location_mode, **kwargs)
+            _pipeline=_pipeline, _location_mode=self._location_mode,
+            allow_trailing_dot=self.allow_trailing_dot,
+            allow_source_trailing_dot=self.allow_source_trailing_dot, **kwargs)
 
     def get_subdirectory_client(self, directory_name, **kwargs):
         # type: (str, Any) -> ShareDirectoryClient
         """Get a client to interact with a specific subdirectory.
 
         The subdirectory need not already exist.
 
@@ -271,17 +288,18 @@
 
         _pipeline = Pipeline(
             transport=TransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
             policies=self._pipeline._impl_policies # pylint: disable = protected-access
         )
         return ShareDirectoryClient(
             self.url, share_name=self.share_name, directory_path=directory_path, snapshot=self.snapshot,
-            credential=self.credential, api_version=self.api_version,
+            credential=self.credential, token_intent=self.file_request_intent, api_version=self.api_version,
             _hosts=self._hosts, _configuration=self._config, _pipeline=_pipeline,
-            _location_mode=self._location_mode, **kwargs)
+            _location_mode=self._location_mode, allow_trailing_dot=self.allow_trailing_dot,
+            allow_source_trailing_dot=self.allow_source_trailing_dot, **kwargs)
 
     @distributed_trace
     def create_directory(self, **kwargs):
         # type: (Any) -> Dict[str, Any]
         """Creates a new directory under the directory referenced by the client.
 
         :keyword file_attributes:
@@ -311,15 +329,19 @@
             .. versionadded:: 12.8.0
                 This parameter was introduced in API version '2021-06-08'.
 
         :paramtype file_change_time: str or ~datetime.datetime
         :keyword dict(str,str) metadata:
             Name-value pairs associated with the directory as metadata.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: Directory-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory.py
                 :start-after: [START create_directory]
@@ -359,15 +381,19 @@
     @distributed_trace
     def delete_directory(self, **kwargs):
         # type: (**Any) -> None
         """Marks the directory for deletion. The directory is
         later deleted during garbage collection.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory.py
                 :start-after: [START delete_directory]
                 :end-before: [END delete_directory]
@@ -389,15 +415,19 @@
         # type: (...) -> ShareDirectoryClient
         """
         Rename the source directory.
 
         :param str new_name:
             The new directory name.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword bool overwrite:
             A boolean value for if the destination file already exists, whether this request will
             overwrite the file or not. If true, the rename will succeed and will overwrite the
             destination file. If not provided or if false and the destination file does exist, the
             request will not overwrite the destination file. If provided and the destination file
             doesn't exist, the rename will succeed.
         :keyword bool ignore_read_only:
@@ -449,15 +479,16 @@
         else:
             new_dir_sas = self._query_str.strip('?')
 
         new_directory_client = ShareDirectoryClient(
             '{}://{}'.format(self.scheme, self.primary_hostname), self.share_name, new_dir_path,
             credential=new_dir_sas or self.credential, api_version=self.api_version,
             _hosts=self._hosts, _configuration=self._config, _pipeline=self._pipeline,
-            _location_mode=self._location_mode
+            _location_mode=self._location_mode, allow_trailing_dot=self.allow_trailing_dot,
+            allow_source_trailing_dot=self.allow_source_trailing_dot, token_intent=self.file_request_intent
         )
 
         kwargs.update(get_rename_smb_properties(kwargs))
 
         timeout = kwargs.pop('timeout', None)
         overwrite = kwargs.pop('overwrite', None)
         metadata = kwargs.pop('metadata', None)
@@ -497,15 +528,19 @@
         :keyword bool include_extended_info:
             If this is set to true, file id will be returned in listed results.
 
             .. versionadded:: 12.6.0
             This keyword argument was introduced in API version '2020-10-02'.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: An auto-paging iterable of dict-like DirectoryProperties and FileProperties
         :rtype: ~azure.core.paging.ItemPaged[DirectoryProperties and FileProperties]
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory.py
                 :start-after: [START lists_directory]
@@ -530,17 +565,21 @@
         # type: (bool, Any) -> ItemPaged
         """Lists opened handles on a directory or a file under the directory.
 
         :param bool recursive:
             Boolean that specifies if operation should apply to the directory specified by the client,
             its files, its subdirectories and their files. Default value is False.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: An auto-paging iterable of HandleItem
-        :rtype: ~azure.core.paging.ItemPaged[~azure.storage.fileshare.HandleItem]
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
+        :returns: An auto-paging iterable of Handle
+        :rtype: ~azure.core.paging.ItemPaged[~azure.storage.fileshare.Handle]
         """
         timeout = kwargs.pop('timeout', None)
         results_per_page = kwargs.pop('results_per_page', None)
         command = functools.partial(
             self._client.directory.list_handles,
             sharesnapshot=self.snapshot,
             timeout=timeout,
@@ -548,22 +587,26 @@
             **kwargs)
         return ItemPaged(
             command, results_per_page=results_per_page,
             page_iterator_class=HandlesPaged)
 
     @distributed_trace
     def close_handle(self, handle, **kwargs):
-        # type: (Union[str, HandleItem], Any) -> Dict[str, int]
+        # type: (Union[str, Handle], Any) -> Dict[str, int]
         """Close an open file handle.
 
         :param handle:
             A specific handle to close.
         :type handle: str or ~azure.storage.fileshare.Handle
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns:
             The number of handles closed (this may be 0 if the specified handle was not found)
             and the number of handles failed to close in a dict.
         :rtype: dict[str, int]
         """
         try:
             handle_id = handle.id # type: ignore
@@ -594,15 +637,19 @@
 
         This operation will block until the service has closed all open handles.
 
         :param bool recursive:
             Boolean that specifies if operation should apply to the directory specified by the client,
             its files, its subdirectories and their files. Default value is False.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: The number of handles closed (this may be 0 if the specified handle was not found)
             and the number of handles failed to close in a dict.
         :rtype: dict[str, int]
         """
         timeout = kwargs.pop('timeout', None)
         start_time = time.time()
 
@@ -638,15 +685,19 @@
     def get_directory_properties(self, **kwargs):
         # type: (Any) -> DirectoryProperties
         """Returns all user-defined metadata and system properties for the
         specified directory. The data returned does not include the directory's
         list of files.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: DirectoryProperties
         :rtype: ~azure.storage.fileshare.DirectoryProperties
         """
         timeout = kwargs.pop('timeout', None)
         try:
             response = self._client.directory.get_properties(
                 timeout=timeout,
@@ -665,15 +716,19 @@
         attached to the directory. To remove all metadata from the directory,
         call this operation with an empty metadata dict.
 
         :param metadata:
             Name-value pairs associated with the directory as metadata.
         :type metadata: dict(str, str)
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: Directory-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
         """
         timeout = kwargs.pop('timeout', None)
         headers = kwargs.pop('headers', {})
         headers.update(add_metadata_headers(metadata))
         try:
@@ -688,15 +743,19 @@
     @distributed_trace
     def exists(self, **kwargs):
         # type: (**Any) -> bool
         """
         Returns True if a directory exists and returns False otherwise.
 
         :kwarg int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: True if the directory exists, False otherwise.
         :rtype: bool
         """
         try:
             self._client.directory.get_properties(**kwargs)
             return True
         except HttpResponseError as error:
@@ -742,15 +801,19 @@
             Change time for the directory. If not specified, change time will be set to the current date/time.
 
             .. versionadded:: 12.8.0
                 This parameter was introduced in API version '2021-06-08'.
 
         :paramtype file_change_time: str or ~datetime.datetime
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
         """
         timeout = kwargs.pop('timeout', None)
         file_permission = _get_file_permission(file_permission, permission_key, 'preserve')
         file_change_time = kwargs.pop('file_change_time', None)
         try:
@@ -776,15 +839,19 @@
         with the subdirectory.
 
         :param str directory_name:
             The name of the subdirectory.
         :keyword dict(str,str) metadata:
             Name-value pairs associated with the subdirectory as metadata.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: ShareDirectoryClient
         :rtype: ~azure.storage.fileshare.ShareDirectoryClient
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory.py
                 :start-after: [START create_subdirectory]
@@ -806,15 +873,19 @@
         ):
         # type: (...) -> None
         """Deletes a subdirectory.
 
         :param str directory_name:
             The name of the subdirectory.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory.py
                 :start-after: [START delete_subdirectory]
                 :end-before: [END delete_subdirectory]
@@ -824,26 +895,25 @@
         """
         timeout = kwargs.pop('timeout', None)
         subdir = self.get_subdirectory_client(directory_name)
         subdir.delete_directory(timeout=timeout, **kwargs)
 
     @distributed_trace
     def upload_file(
-            self, file_name,  # type: str
-            data, # type: Any
-            length=None, # type: Optional[int]
-            **kwargs # type: Any
-        ):
-        # type: (...) -> ShareFileClient
+            self, file_name: str,
+            data: Union[bytes, str, Iterable[AnyStr], IO[AnyStr]],
+            length: Optional[int] = None,
+            **kwargs
+        ) -> ShareFileClient:
         """Creates a new file in the directory and returns a ShareFileClient
         to interact with the file.
 
         :param str file_name:
             The name of the file.
-        :param Any data:
+        :param data:
             Content of the file.
         :param int length:
             Length of the file in bytes. Specify its maximum size, up to 1 TiB.
         :keyword dict(str,str) metadata:
             Name-value pairs associated with the file as metadata.
         :keyword ~azure.storage.fileshare.ContentSettings content_settings:
             ContentSettings object used to set file properties. Used to set content type, encoding,
@@ -859,15 +929,19 @@
             Maximum number of parallel connections to use.
         :keyword progress_hook:
             A callback to track the progress of a long running upload. The signature is
             function(current: int, total: Optional[int]) where current is the number of bytes transferred
             so far, and total is the size of the blob or None if the size is unknown.
         :paramtype progress_hook: Callable[[int, Optional[int]], None]
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword str encoding:
             Defaults to UTF-8.
         :returns: ShareFileClient
         :rtype: ~azure.storage.fileshare.ShareFileClient
 
         .. admonition:: Example:
 
@@ -879,29 +953,33 @@
                 :caption: Upload a file to a directory.
         """
         file_client = self.get_file_client(file_name)
         file_client.upload_file(
             data,
             length=length,
             **kwargs)
-        return file_client # type: ignore
+        return file_client
 
     @distributed_trace
     def delete_file(
             self, file_name,  # type: str
             **kwargs  # type: Optional[Any]
         ):
         # type: (...) -> None
         """Marks the specified file for deletion. The file is later
         deleted during garbage collection.
 
         :param str file_name:
             The name of the file to delete.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory.py
                 :start-after: [START delete_file_in_directory]
                 :end-before: [END delete_file_in_directory]
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_download.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_download.py`

 * *Files 2% similar despite different names*

```diff
@@ -197,15 +197,15 @@
         The full path of the file.
     :ivar str share:
         The name of the share where the file is.
     :ivar ~azure.storage.fileshare.FileProperties properties:
         The properties of the file being downloaded. If only a range of the data is being
         downloaded, this will be reflected in the properties.
     :ivar int size:
-        The size of the total data in the stream. This will be the byte range if speficied,
+        The size of the total data in the stream. This will be the byte range if specified,
         otherwise the total size of the file.
     """
 
     def __init__(
         self,
         client=None,
         config=None,
@@ -307,27 +307,27 @@
             # Check the location we read from to ensure we use the same one
             # for subsequent requests.
             self._location_mode = location_mode
 
             # Parse the total file size and adjust the download size if ranges
             # were specified
             self._file_size = parse_length_from_content_range(response.properties.content_range)
-            if not self._file_size:
+            if self._file_size is None:
                 raise ValueError("Required Content-Range response header is missing or malformed.")
 
             if self._end_range is not None:
                 # Use the end range index unless it is over the end of the file
                 self.size = min(self._file_size, self._end_range - self._start_range + 1)
             elif self._start_range is not None:
                 self.size = self._file_size - self._start_range
             else:
                 self.size = self._file_size
 
         except HttpResponseError as error:
-            if self._start_range is None and error.response.status_code == 416:
+            if self._start_range is None and error.response and error.response.status_code == 416:
                 # Get range will fail on an empty file. If the user did not
                 # request a range, do a regular get request in order to get
                 # any properties.
                 try:
                     _, response = self._client.download(
                         validate_content=self._validate_content,
                         data_stream_total=0,
@@ -394,34 +394,38 @@
         self.readinto(stream)
         data = stream.getvalue()
         if self._encoding:
             return data.decode(self._encoding)
         return data
 
     def content_as_bytes(self, max_concurrency=1):
-        """Download the contents of this file.
+        """DEPRECATED: Download the contents of this file.
 
         This operation is blocking until all data is downloaded.
 
+        This method is deprecated, use func:`readall` instead.
+
         :keyword int max_concurrency:
             The number of parallel connections with which to download.
         :rtype: bytes
         """
         warnings.warn(
             "content_as_bytes is deprecated, use readall instead",
             DeprecationWarning
         )
         self._max_concurrency = max_concurrency
         return self.readall()
 
     def content_as_text(self, max_concurrency=1, encoding="UTF-8"):
-        """Download the contents of this file, and decode as text.
+        """DEPRECATED: Download the contents of this file, and decode as text.
 
         This operation is blocking until all data is downloaded.
 
+        This method is deprecated, use func:`readall` instead.
+
         :keyword int max_concurrency:
             The number of parallel connections with which to download.
         :param str encoding:
             Test encoding to decode the downloaded bytes. Default is UTF-8.
         :rtype: str
         """
         warnings.warn(
@@ -491,15 +495,17 @@
                     ))
         else:
             for chunk in downloader.get_chunk_offsets():
                 downloader.process_chunk(chunk)
         return self.size
 
     def download_to_stream(self, stream, max_concurrency=1):
-        """Download the contents of this file to a stream.
+        """DEPRECATED: Download the contents of this file to a stream.
+
+        This method is deprecated, use func:`readinto` instead.
 
         :param stream:
             The stream to download to. This can be an open file-handle,
             or any writable stream. The stream must be seekable if the download
             uses more than one parallel connection.
         :returns: The properties of the downloaded file.
         :rtype: Any
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_file_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_file_client.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,33 +1,29 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=too-many-lines, too-many-public-methods
 import functools
+import sys
 import time
+from datetime import datetime
 from io import BytesIO
-from typing import ( # pylint: disable=unused-import
-    Optional, Union, IO, List, Dict, Any, Iterable, Tuple,
+from typing import (
+    Any, AnyStr, Dict, IO, Iterable, List, Optional, Tuple, Union,
     TYPE_CHECKING
 )
+from urllib.parse import urlparse, quote, unquote
 
+from typing_extensions import Self
 
-try:
-    from urllib.parse import urlparse, quote, unquote
-except ImportError:
-    from urlparse import urlparse # type: ignore
-    from urllib2 import quote, unquote # type: ignore
-
-import six
 from azure.core.exceptions import HttpResponseError
 from azure.core.paging import ItemPaged  # pylint: disable=ungrouped-imports
 from azure.core.tracing.decorator import distributed_trace
-
 from ._generated import AzureFileStorage
 from ._generated.models import FileHTTPHeaders
 from ._shared.uploads import IterStreamer, FileChunkUploader, upload_data_chunks
 from ._shared.base_client import StorageAccountHostsMixin, parse_connection_str, parse_query
 from ._shared.request_handlers import add_metadata_headers, get_length
 from ._shared.response_handlers import return_response_headers, process_storage_error
 from ._shared.parser import _str
@@ -38,21 +34,25 @@
     get_api_version,
     get_dest_access_conditions,
     get_rename_smb_properties,
     get_smb_properties,
     get_source_conditions,
     get_source_access_conditions)
 from ._deserialize import deserialize_file_properties, deserialize_file_stream, get_file_ranges_result
-from ._models import HandlesPaged, NTFSAttributes  # pylint: disable=unused-import
+from ._models import HandlesPaged
 from ._download import StorageStreamDownloader
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
-    from datetime import datetime
-    from ._models import ShareProperties, ContentSettings, FileProperties, Handle
-    from ._generated.models import HandleItem
+    from azure.core.credentials import AzureNamedKeyCredential, AzureSasCredential, TokenCredential
+    from ._models import ContentSettings, FileProperties, Handle, NTFSAttributes
 
 
 def _upload_file_helper(
         client,
         stream,
         size,
         metadata,
@@ -127,45 +127,54 @@
         account URL already has a SAS token. The value can be a SAS token string,
         an instance of a AzureSasCredential or AzureNamedKeyCredential from azure.core.credentials,
         an account shared access key, or an instance of a TokenCredentials class from azure.identity.
         If the resource URI already contains a SAS token, this will be ignored in favor of an explicit credential
         - except in the case of AzureSasCredential, where the conflicting SAS tokens will raise a ValueError.
         If using an instance of AzureNamedKeyCredential, "name" should be the storage account name, and "key"
         should be the storage account key.
+    :keyword token_intent:
+        Required when using `TokenCredential` for authentication and ignored for other forms of authentication.
+        Specifies the intent for all requests when using `TokenCredential` authentication. Possible values are:
+
+        backup - Specifies requests are intended for backup/admin type operations, meaning that all file/directory
+                 ACLs are bypassed and full permissions are granted. User must also have required RBAC permission.
+
+    :paramtype token_intent: Literal['backup']
+    :keyword bool allow_trailing_dot: If true, the trailing dot will not be trimmed from the target URI.
+    :keyword bool allow_source_trailing_dot: If true, the trailing dot will not be trimmed from the source URI.
     :keyword str api_version:
         The Storage API version to use for requests. Default value is the most recent service version that is
         compatible with the current SDK. Setting to an older version may result in reduced feature compatibility.
 
         .. versionadded:: 12.1.0
 
     :keyword str secondary_hostname:
         The hostname of the secondary endpoint.
     :keyword int max_range_size: The maximum range size used for a file upload. Defaults to 4*1024*1024.
     """
-    def __init__( # type: ignore
-            self, account_url,  # type: str
-            share_name,  # type: str
-            file_path,  # type: str
-            snapshot=None,  # type: Optional[Union[str, Dict[str, Any]]]
-            credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs  # type: Any
-        ):
-        # type: (...) -> None
+    def __init__(
+            self, account_url: str,
+            share_name: str,
+            file_path: str,
+            snapshot: Optional[Union[str, Dict[str, Any]]] = None,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            *,
+            token_intent: Optional[Literal['backup']] = None,
+            **kwargs: Any
+        ) -> None:
         try:
             if not account_url.lower().startswith('http'):
                 account_url = "https://" + account_url
         except AttributeError:
             raise ValueError("Account URL must be a string.")
         parsed_url = urlparse(account_url.rstrip('/'))
         if not (share_name and file_path):
             raise ValueError("Please specify a share name and file name.")
         if not parsed_url.netloc:
             raise ValueError("Invalid URL: {}".format(account_url))
-        if hasattr(credential, 'get_token'):
-            raise ValueError("Token credentials not supported by the File service.")
 
         path_snapshot = None
         path_snapshot, sas_token = parse_query(parsed_url.query)
         if not sas_token and not credential:
             raise ValueError(
                 'You need to provide either an account shared key or SAS token when creating a storage service.')
         try:
@@ -180,25 +189,30 @@
         self.file_path = file_path.split('/')
         self.file_name = self.file_path[-1]
         self.directory_path = "/".join(self.file_path[:-1])
 
         self._query_str, credential = self._format_query_string(
             sas_token, credential, share_snapshot=self.snapshot)
         super(ShareFileClient, self).__init__(parsed_url, service='file-share', credential=credential, **kwargs)
-        self._client = AzureFileStorage(url=self.url, base_url=self.url, pipeline=self._pipeline)
+        self.allow_trailing_dot = kwargs.pop('allow_trailing_dot', None)
+        self.allow_source_trailing_dot = kwargs.pop('allow_source_trailing_dot', None)
+        self.file_request_intent = token_intent
+        self._client = AzureFileStorage(url=self.url, base_url=self.url, pipeline=self._pipeline,
+                                        allow_trailing_dot=self.allow_trailing_dot,
+                                        allow_source_trailing_dot=self.allow_source_trailing_dot,
+                                        file_request_intent=self.file_request_intent)
         self._client._config.version = get_api_version(kwargs) # pylint: disable=protected-access
 
     @classmethod
     def from_file_url(
-            cls, file_url,  # type: str
-            snapshot=None,  # type: Optional[Union[str, Dict[str, Any]]]
-            credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs  # type: Any
-        ):
-        # type: (...) -> ShareFileClient
+            cls, file_url: str,
+            snapshot: Optional[Union[str, Dict[str, Any]]] = None,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            **kwargs: Any
+        ) -> Self:
         """A client to interact with a specific file, although that file may not yet exist.
 
         :param str file_url: The full URI to the file.
         :param str snapshot:
             An optional file snapshot on which to operate. This can be the snapshot ID string
             or the response returned from :func:`ShareClient.create_snapshot`.
         :param credential:
@@ -232,33 +246,32 @@
         return cls(account_url, share_name, file_path, snapshot, credential, **kwargs)
 
     def _format_url(self, hostname):
         """Format the endpoint URL according to the current location
         mode hostname.
         """
         share_name = self.share_name
-        if isinstance(share_name, six.text_type):
+        if isinstance(share_name, str):
             share_name = share_name.encode('UTF-8')
         return "{}://{}/{}/{}{}".format(
             self.scheme,
             hostname,
             quote(share_name),
             "/".join([quote(p, safe='~') for p in self.file_path]),
             self._query_str)
 
     @classmethod
     def from_connection_string(
-            cls, conn_str,  # type: str
-            share_name,  # type: str
-            file_path,  # type: str
-            snapshot=None,  # type: Optional[Union[str, Dict[str, Any]]]
-            credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs  # type: Any
-        ):
-        # type: (...) -> ShareFileClient
+            cls, conn_str: str,
+            share_name: str,
+            file_path: str,
+            snapshot: Optional[Union[str, Dict[str, Any]]] = None,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            **kwargs: Any
+        ) -> Self:
         """Create ShareFileClient from a Connection String.
 
         :param str conn_str:
             A connection string to an Azure Storage account.
         :param share_name: The name of the share.
         :type share_name: str
         :param str file_path:
@@ -302,15 +315,19 @@
         Service creates a lease on the blob and returns a new lease.
 
         :param str lease_id:
             Proposed lease ID, in a GUID string format. The File Service
             returns 400 (Invalid request) if the proposed lease ID is not
             in the correct format.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: A ShareLeaseClient object.
         :rtype: ~azure.storage.fileshare.ShareLeaseClient
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_client.py
                 :start-after: [START acquire_and_release_lease_on_file]
@@ -380,15 +397,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_client.py
                 :start-after: [START create_file]
@@ -432,27 +453,26 @@
                 cls=return_response_headers,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace
     def upload_file(
-            self, data,  # type: Any
-            length=None,  # type: Optional[int]
-            file_attributes="none",  # type: Union[str, NTFSAttributes]
-            file_creation_time="now",  # type: Optional[Union[str, datetime]]
-            file_last_write_time="now",  # type: Optional[Union[str, datetime]]
-            file_permission=None,  # type: Optional[str]
-            permission_key=None,  # type: Optional[str]
-            **kwargs  # type: Any
-        ):
-        # type: (...) -> Dict[str, Any]
+            self, data: Union[bytes, str, Iterable[AnyStr], IO[AnyStr]],
+            length: Optional[int] = None,
+            file_attributes: Union[str, "NTFSAttributes"] = "none",
+            file_creation_time: Optional[Union[str, datetime]] = "now",
+            file_last_write_time: Optional[Union[str, datetime]] = "now",
+            file_permission: Optional[str] = None,
+            permission_key: Optional[str] = None,
+            **kwargs
+        ) -> Dict[str, Any]:
         """Uploads a new file.
 
-        :param Any data:
+        :param data:
             Content of the file.
         :param int length:
             Length of the file in bytes. Specify its maximum size, up to 1 TiB.
         :param file_attributes:
             The file system attributes for files and directories.
             If not set, the default value would be "None" and the attributes will be set to "Archive".
             Here is an example for when the var type is str: 'Temporary|Archive'.
@@ -505,15 +525,19 @@
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword progress_hook:
             A callback to track the progress of a long running upload. The signature is
             function(current: int, total: Optional[int]) where current is the number of bytes transferred
             so far, and total is the size of the blob or None if the size is unknown.
         :paramtype progress_hook: Callable[[int, Optional[int]], None]
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword str encoding:
             Defaults to UTF-8.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
@@ -528,30 +552,30 @@
         content_settings = kwargs.pop('content_settings', None)
         max_concurrency = kwargs.pop('max_concurrency', 1)
         validate_content = kwargs.pop('validate_content', False)
         progress_hook = kwargs.pop('progress_hook', None)
         timeout = kwargs.pop('timeout', None)
         encoding = kwargs.pop('encoding', 'UTF-8')
 
-        if isinstance(data, six.text_type):
+        if isinstance(data, str):
             data = data.encode(encoding)
         if length is None:
             length = get_length(data)
         if isinstance(data, bytes):
             data = data[:length]
 
         if isinstance(data, bytes):
             stream = BytesIO(data)
         elif hasattr(data, 'read'):
             stream = data
         elif hasattr(data, '__iter__'):
-            stream = IterStreamer(data, encoding=encoding) # type: ignore
+            stream = IterStreamer(data, encoding=encoding)
         else:
             raise TypeError("Unsupported data type: {}".format(type(data)))
-        return _upload_file_helper( # type: ignore
+        return _upload_file_helper(
             self,
             stream,
             length,
             metadata,
             content_settings,
             validate_content,
             timeout,
@@ -654,15 +678,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_client.py
                 :start-after: [START copy_file_from_url]
                 :end-before: [END copy_file_from_url]
@@ -703,15 +731,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
             copy_id = copy_id.copy.id
         except AttributeError:
@@ -763,15 +795,19 @@
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword progress_hook:
             A callback to track the progress of a long running download. The signature is
             function(current: int, total: int) where current is the number of bytes transferred
             so far, and total is the total size of the download.
         :paramtype progress_hook: Callable[[int, int], None]
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: A streaming object (StorageStreamDownloader)
         :rtype: ~azure.storage.fileshare.StorageStreamDownloader
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_client.py
                 :start-after: [START download_file]
@@ -811,15 +847,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_client.py
                 :start-after: [START delete_file]
                 :end-before: [END delete_file]
@@ -842,15 +882,19 @@
         # type: (...) -> ShareFileClient
         """
         Rename the source file.
 
         :param str new_name:
             The new file name.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword bool overwrite:
             A boolean value for if the destination file already exists, whether this request will
             overwrite the file or not. If true, the rename will succeed and will overwrite the
             destination file. If not provided or if false and the destination file does exist, the
             request will not overwrite the destination file. If provided and the destination file
             doesn't exist, the rename will succeed.
         :keyword bool ignore_read_only:
@@ -912,15 +956,16 @@
         else:
             new_file_sas = self._query_str.strip('?')
 
         new_file_client = ShareFileClient(
             '{}://{}'.format(self.scheme, self.primary_hostname), self.share_name, new_file_path,
             credential=new_file_sas or self.credential, api_version=self.api_version,
             _hosts=self._hosts, _configuration=self._config, _pipeline=self._pipeline,
-            _location_mode=self._location_mode
+            _location_mode=self._location_mode, allow_trailing_dot=self.allow_trailing_dot,
+            allow_source_trailing_dot=self.allow_source_trailing_dot, token_intent=self.file_request_intent
         )
 
         kwargs.update(get_rename_smb_properties(kwargs))
 
         file_http_headers = None
         content_type = kwargs.pop('content_type', None)
         if content_type:
@@ -962,15 +1007,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: FileProperties
         :rtype: ~azure.storage.fileshare.FileProperties
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
             file_props = self._client.file.get_properties(
@@ -1035,15 +1084,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         file_content_length = kwargs.pop('size', None)
         file_http_headers = FileHTTPHeaders(
@@ -1090,15 +1143,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         headers = kwargs.pop('headers', {})
         headers.update(add_metadata_headers(metadata)) # type: ignore
@@ -1151,25 +1208,29 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword str encoding:
             Defaults to UTF-8.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: Dict[str, Any]
         """
         validate_content = kwargs.pop('validate_content', False)
         timeout = kwargs.pop('timeout', None)
         encoding = kwargs.pop('encoding', 'UTF-8')
         file_last_write_mode = kwargs.pop('file_last_write_mode', None)
-        if isinstance(data, six.text_type):
+        if isinstance(data, str):
             data = data.encode(encoding)
 
         end_range = offset + length - 1  # Reformat to an inclusive range index
         content_range = 'bytes={0}-{1}'.format(offset, end_range)
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         try:
             return self._client.file.upload_range( # type: ignore
@@ -1283,15 +1344,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword str source_authorization:
             Authenticate as a service principal using a client secret to access a source blob. Ensure "bearer " is
             the prefix of the source_authorization string.
         """
         options = self._upload_range_from_url_options(
             source_url=source_url,
             offset=offset,
@@ -1354,15 +1419,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns:
             A list of valid ranges.
         :rtype: List[dict[str, int]]
         """
         options = self._get_ranges_options(
             offset=offset,
             length=length,
@@ -1395,15 +1464,19 @@
             specifies a previous file snapshot to be compared
             against a more recent snapshot or the current file.
         :keyword lease:
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns:
             A tuple of two lists of file ranges as dictionaries with 'start' and 'end' keys.
             The first element are filled file ranges, the 2nd element is cleared file ranges.
         :rtype: tuple(list(dict(str, str), list(dict(str, str))
         """
         options = self._get_ranges_options(
             offset=offset,
@@ -1436,15 +1509,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: Dict[str, Any]
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
 
         if offset is None or offset % 512 != 0:
@@ -1477,15 +1554,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: Dict[str, Any]
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
             return self._client.file.set_http_headers( # type: ignore
@@ -1503,39 +1584,47 @@
 
     @distributed_trace
     def list_handles(self, **kwargs):
         # type: (Any) -> ItemPaged[Handle]
         """Lists handles for file.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: An auto-paging iterable of HandleItem
-        :rtype: ~azure.core.paging.ItemPaged[~azure.storage.fileshare.HandleItem]
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
+        :returns: An auto-paging iterable of Handle
+        :rtype: ~azure.core.paging.ItemPaged[~azure.storage.fileshare.Handle]
         """
         timeout = kwargs.pop('timeout', None)
         results_per_page = kwargs.pop('results_per_page', None)
         command = functools.partial(
             self._client.file.list_handles,
             sharesnapshot=self.snapshot,
             timeout=timeout,
             **kwargs)
         return ItemPaged(
             command, results_per_page=results_per_page,
             page_iterator_class=HandlesPaged)
 
     @distributed_trace
     def close_handle(self, handle, **kwargs):
-        # type: (Union[str, HandleItem], Any) -> Dict[str, int]
+        # type: (Union[str, Handle], Any) -> Dict[str, int]
         """Close an open file handle.
 
         :param handle:
             A specific handle to close.
         :type handle: str or ~azure.storage.fileshare.Handle
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns:
             The number of handles closed (this may be 0 if the specified handle was not found)
             and the number of handles failed to close in a dict.
         :rtype: dict[str, int]
         """
         try:
             handle_id = handle.id # type: ignore
@@ -1562,15 +1651,19 @@
     def close_all_handles(self, **kwargs):
         # type: (Any) -> Dict[str, int]
         """Close any open file handles.
 
         This operation will block until the service has closed all open handles.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: The number of handles closed (this may be 0 if the specified handle was not found)
             and the number of handles failed to close in a dict.
         :rtype: dict[str, int]
         """
         timeout = kwargs.pop('timeout', None)
         start_time = time.time()
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -2,20 +2,14 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from ._azure_file_storage import AzureFileStorage
+from ._azure_queue_storage import AzureQueueStorage
+__all__ = ['AzureQueueStorage']
 
-try:
-    from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
-except ImportError:
-    _patch_all = []
-from ._patch import patch_sdk as _patch_sdk
-
-__all__ = ["AzureFileStorage"]
-__all__.extend([p for p in _patch_all if p not in __all__])
-
-_patch_sdk()
+# `._patch.py` is used for handwritten extensions to the generated code
+# Example: https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/customize_code/how-to-patch-sdk-code.md
+from ._patch import patch_sdk
+patch_sdk()
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_azure_file_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_azure_file_storage.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
-from typing import Any
+from typing import Any, Optional, Union
 
 from azure.core import PipelineClient
 from azure.core.rest import HttpRequest, HttpResponse
 
-from . import models
+from . import models as _models
 from ._configuration import AzureFileStorageConfiguration
 from ._serialization import Deserializer, Serializer
 from .operations import DirectoryOperations, FileOperations, ServiceOperations, ShareOperations
 
 
 class AzureFileStorage:  # pylint: disable=client-accepts-api-version-keyword
     """AzureFileStorage.
@@ -30,30 +30,50 @@
     :ivar file: FileOperations operations
     :vartype file: azure.storage.fileshare.operations.FileOperations
     :param url: The URL of the service account, share, directory or file that is the target of the
      desired operation. Required.
     :type url: str
     :param base_url: Service URL. Required. Default value is "".
     :type base_url: str
+    :param file_request_intent: Valid value is backup. "backup" Default value is None.
+    :type file_request_intent: str or ~azure.storage.fileshare.models.ShareTokenIntent
+    :param allow_trailing_dot: If true, the trailing dot will not be trimmed from the target URI.
+     Default value is None.
+    :type allow_trailing_dot: bool
+    :param allow_source_trailing_dot: If true, the trailing dot will not be trimmed from the source
+     URI. Default value is None.
+    :type allow_source_trailing_dot: bool
     :keyword version: Specifies the version of the operation to use for this request. Default value
-     is "2021-06-08". Note that overriding this default value may result in unsupported behavior.
+     is "2022-11-02". Note that overriding this default value may result in unsupported behavior.
     :paramtype version: str
     :keyword file_range_write_from_url: Only update is supported: - Update: Writes the bytes
      downloaded from the source url into the specified range. Default value is "update". Note that
      overriding this default value may result in unsupported behavior.
     :paramtype file_range_write_from_url: str
     """
 
     def __init__(  # pylint: disable=missing-client-constructor-parameter-credential
-        self, url: str, base_url: str = "", **kwargs: Any
+        self,
+        url: str,
+        base_url: str = "",
+        file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
+        allow_trailing_dot: Optional[bool] = None,
+        allow_source_trailing_dot: Optional[bool] = None,
+        **kwargs: Any
     ) -> None:
-        self._config = AzureFileStorageConfiguration(url=url, **kwargs)
+        self._config = AzureFileStorageConfiguration(
+            url=url,
+            file_request_intent=file_request_intent,
+            allow_trailing_dot=allow_trailing_dot,
+            allow_source_trailing_dot=allow_source_trailing_dot,
+            **kwargs
+        )
         self._client = PipelineClient(base_url=base_url, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.service = ServiceOperations(self._client, self._config, self._serialize, self._deserialize)
         self.share = ShareOperations(self._client, self._config, self._serialize, self._deserialize)
         self.directory = DirectoryOperations(self._client, self._config, self._serialize, self._deserialize)
         self.file = FileOperations(self._client, self._config, self._serialize, self._deserialize)
@@ -76,19 +96,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> AzureFileStorage
+    def __enter__(self) -> "AzureFileStorage":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_configuration_async.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,61 +1,53 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
-# Licensed under the MIT License. See License.txt in the project root for license information.
+# Licensed under the MIT License. See License.txt in the project root for
+# license information.
+#
 # Code generated by Microsoft (R) AutoRest Code Generator.
-# Changes may cause incorrect behavior and will be lost if the code is regenerated.
+# Changes may cause incorrect behavior and will be lost if the code is
+# regenerated.
 # --------------------------------------------------------------------------
 
-from typing import Any
-
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
-VERSION = "unknown"
-
+from ..version import VERSION
 
-class AzureFileStorageConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
-    """Configuration for AzureFileStorage.
 
+class AzureQueueStorageConfiguration(Configuration):
+    """Configuration for AzureQueueStorage
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :param url: The URL of the service account, share, directory or file that is the target of the
-     desired operation. Required.
+    :param url: The URL of the service account, queue or message that is the
+     targe of the desired operation.
     :type url: str
-    :keyword version: Specifies the version of the operation to use for this request. Default value
-     is "2021-06-08". Note that overriding this default value may result in unsupported behavior.
-    :paramtype version: str
-    :keyword file_range_write_from_url: Only update is supported: - Update: Writes the bytes
-     downloaded from the source url into the specified range. Default value is "update". Note that
-     overriding this default value may result in unsupported behavior.
-    :paramtype file_range_write_from_url: str
+    :ivar version: Specifies the version of the operation to use for this
+     request.
+    :type version: str
     """
 
-    def __init__(self, url: str, **kwargs: Any) -> None:
-        super(AzureFileStorageConfiguration, self).__init__(**kwargs)
-        version = kwargs.pop("version", "2021-06-08")  # type: str
-        file_range_write_from_url = kwargs.pop("file_range_write_from_url", "update")  # type: str
+    def __init__(self, url, **kwargs):
 
         if url is None:
             raise ValueError("Parameter 'url' must not be None.")
 
-        self.url = url
-        self.version = version
-        self.file_range_write_from_url = file_range_write_from_url
-        kwargs.setdefault("sdk_moniker", "azurefilestorage/{}".format(VERSION))
+        super(AzureQueueStorageConfiguration, self).__init__(**kwargs)
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
-        self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
-        self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
-        self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
-        self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
-        self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
-        self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
-        self.authentication_policy = kwargs.get("authentication_policy")
+        self.user_agent_policy.add_user_agent('azsdk-python-azurequeuestorage/{}'.format(VERSION))
+        self.generate_client_request_id = True
+        self.accept_language = None
+
+        self.url = url
+        self.version = "2018-03-28"
+
+    def _configure(self, **kwargs):
+        self.user_agent_policy = kwargs.get('user_agent_policy') or policies.UserAgentPolicy(**kwargs)
+        self.headers_policy = kwargs.get('headers_policy') or policies.HeadersPolicy(**kwargs)
+        self.proxy_policy = kwargs.get('proxy_policy') or policies.ProxyPolicy(**kwargs)
+        self.logging_policy = kwargs.get('logging_policy') or policies.NetworkTraceLoggingPolicy(**kwargs)
+        self.retry_policy = kwargs.get('retry_policy') or policies.AsyncRetryPolicy(**kwargs)
+        self.custom_hook_policy = kwargs.get('custom_hook_policy') or policies.CustomHookPolicy(**kwargs)
+        self.redirect_policy = kwargs.get('redirect_policy') or policies.AsyncRedirectPolicy(**kwargs)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_serialization.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_serialization.py`

 * *Files 3% similar despite different names*

```diff
@@ -21,56 +21,71 @@
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 # IN THE SOFTWARE.
 #
 # --------------------------------------------------------------------------
 
 # pylint: skip-file
+# pyright: reportUnnecessaryTypeIgnoreComment=false
 
 from base64 import b64decode, b64encode
 import calendar
 import datetime
 import decimal
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
+from typing import (
+    Dict,
+    Any,
+    cast,
+    Optional,
+    Union,
+    AnyStr,
+    IO,
+    Mapping,
+    Callable,
+    TypeVar,
+    MutableMapping,
+    Type,
+    List,
+    Mapping,
+)
 
 try:
     from urllib import quote  # type: ignore
 except ImportError:
-    from urllib.parse import quote  # type: ignore
+    from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
-import isodate
-
-from typing import Dict, Any, cast, TYPE_CHECKING
+import isodate  # type: ignore
 
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
+from azure.core.serialization import NULL as AzureCoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
-if TYPE_CHECKING:
-    from typing import Optional, Union, AnyStr, IO, Mapping
+ModelType = TypeVar("ModelType", bound="Model")
+JSON = MutableMapping[str, Any]
 
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
     JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
     CONTEXT_NAME = "deserialized_data"
 
     @classmethod
-    def deserialize_from_text(cls, data, content_type=None):
-        # type: (Optional[Union[AnyStr, IO]], Optional[str]) -> Any
+    def deserialize_from_text(cls, data: Optional[Union[AnyStr, IO]], content_type: Optional[str] = None) -> Any:
         """Decode data according to content-type.
 
         Accept a stream of data as well, but will be load at once in memory for now.
 
         If no content-type, will return the string version (not bytes, not stream)
 
         :param data: Input, could be bytes or stream (will be decoded with UTF8) or text
@@ -128,16 +143,15 @@
                 # The function hack is because Py2.7 messes up with exception
                 # context otherwise.
                 _LOGGER.critical("Wasn't XML not JSON, failing")
                 raise_with_traceback(DeserializationError, "XML is invalid")
         raise DeserializationError("Cannot deserialize content-type: {}".format(content_type))
 
     @classmethod
-    def deserialize_from_http_generics(cls, body_bytes, headers):
-        # type: (Optional[Union[AnyStr, IO]], Mapping) -> Any
+    def deserialize_from_http_generics(cls, body_bytes: Optional[Union[AnyStr, IO]], headers: Mapping) -> Any:
         """Deserialize from HTTP response.
 
         Use bytes and headers to NOT use any requests/aiohttp or whatever
         specific implementation.
         Headers will tested for "content-type"
         """
         # Try to use content-type from headers if available
@@ -156,16 +170,16 @@
         return None
 
 
 try:
     basestring  # type: ignore
     unicode_str = unicode  # type: ignore
 except NameError:
-    basestring = str  # type: ignore
-    unicode_str = str  # type: ignore
+    basestring = str
+    unicode_str = str
 
 _LOGGER = logging.getLogger(__name__)
 
 try:
     _long_type = long  # type: ignore
 except NameError:
     _long_type = int
@@ -184,15 +198,15 @@
 
     def dst(self, dt):
         """No daylight saving for UTC."""
         return datetime.timedelta(hours=1)
 
 
 try:
-    from datetime import timezone as _FixedOffset
+    from datetime import timezone as _FixedOffset  # type: ignore
 except ImportError:  # Python 2.7
 
     class _FixedOffset(datetime.tzinfo):  # type: ignore
         """Fixed offset in minutes east from UTC.
         Copy/pasted from Python doc
         :param datetime.timedelta offset: offset in timedelta format
         """
@@ -215,15 +229,15 @@
         def __getinitargs__(self):
             return (self.__offset,)
 
 
 try:
     from datetime import timezone
 
-    TZ_UTC = timezone.utc  # type: ignore
+    TZ_UTC = timezone.utc
 except ImportError:
     TZ_UTC = UTC()  # type: ignore
 
 _FLATTEN = re.compile(r"(?<!\\)\.")
 
 
 def attribute_transformer(key, attr_desc, value):
@@ -272,79 +286,84 @@
 
 
 class Model(object):
     """Mixin for all client request body/response body models to support
     serialization and deserialization.
     """
 
-    _subtype_map = {}  # type: Dict[str, Dict[str, Any]]
-    _attribute_map = {}  # type: Dict[str, Dict[str, Any]]
-    _validation = {}  # type: Dict[str, Dict[str, Any]]
+    _subtype_map: Dict[str, Dict[str, Any]] = {}
+    _attribute_map: Dict[str, Dict[str, Any]] = {}
+    _validation: Dict[str, Dict[str, Any]] = {}
 
-    def __init__(self, **kwargs):
-        self.additional_properties = {}
+    def __init__(self, **kwargs: Any) -> None:
+        self.additional_properties: Dict[str, Any] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other):
+    def __ne__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls):
+    def enable_additional_properties_sending(cls) -> None:
         cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls):
+    def is_xml_model(cls) -> bool:
         try:
-            cls._xml_map
+            cls._xml_map  # type: ignore
         except AttributeError:
             return False
         return True
 
     @classmethod
     def _create_xml_node(cls):
         """Create XML node."""
         try:
-            xml_map = cls._xml_map
+            xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly=False, **kwargs):
+    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
-        """Return a dict that can be JSONify using json.dump.
+    def as_dict(
+        self,
+        keep_readonly: bool = True,
+        key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
+        **kwargs: Any
+    ) -> JSON:
+        """Return a dict that can be serialized using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -383,41 +402,46 @@
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls, data, content_type=None):
+    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(cls, data, key_extractors=None, content_type=None):
+    def from_dict(
+        cls: Type[ModelType],
+        data: Any,
+        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
+        content_type: Optional[str] = None,
+    ) -> ModelType:
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = (
-            [
+        deserializer.key_extractors = (  # type: ignore
+            [  # type: ignore
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
@@ -449,15 +473,15 @@
             if subtype_value:
                 # Try to match base class. Can be class name only
                 # (bug to fix in Autorest to support x-ms-discriminator-name)
                 if cls.__name__ == subtype_value:
                     return cls
                 flatten_mapping_type = cls._flatten_subtype(subtype_key, objects)
                 try:
-                    return objects[flatten_mapping_type[subtype_value]]
+                    return objects[flatten_mapping_type[subtype_value]]  # type: ignore
                 except KeyError:
                     _LOGGER.warning(
                         "Subtype value %s has no mapping, use base class %s.",
                         subtype_value,
                         cls.__name__,
                     )
                     break
@@ -517,15 +541,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -533,15 +557,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -602,46 +626,45 @@
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
                                 xml_name = "{}{}".format(xml_ns, xml_name)
-                            serialized.set(xml_name, new_attr)
+                            serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
-                            serialized.text = new_attr
+                            serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
-                            serialized.extend(new_attr)
+                            serialized.extend(new_attr)  # type: ignore
                         elif isinstance(new_attr, ET.Element):
                             # If the down XML has no XML/Name, we MUST replace the tag with the local tag. But keeping the namespaces.
                             if "name" not in getattr(orig_attr, "_xml_map", {}):
                                 splitted_tag = new_attr.tag.split("}")
                                 if len(splitted_tag) == 2:  # Namespace
                                     new_attr.tag = "}".join([splitted_tag[0], xml_name])
                                 else:
                                     new_attr.tag = xml_name
-                            serialized.append(new_attr)
+                            serialized.append(new_attr)  # type: ignore
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
-                            serialized.append(local_node)
+                            serialized.append(local_node)  # type: ignore
                     else:  # JSON
-                        for k in reversed(keys):
-                            unflattened = {k: new_attr}
-                            new_attr = unflattened
+                        for k in reversed(keys):  # type: ignore
+                            new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
-                        for k in keys:
+                        for k in keys:  # type: ignore
                             if k not in _serialized:
-                                _serialized.update(_new_attr)
-                            _new_attr = _new_attr[k]
+                                _serialized.update(_new_attr)  # type: ignore
+                            _new_attr = _new_attr[k]  # type: ignore
                             _serialized = _serialized[k]
                 except ValueError:
                     continue
 
         except (AttributeError, KeyError, TypeError) as err:
             msg = "Attribute {} in object {} cannot be serialized.\n{}".format(attr_name, class_name, str(target_obj))
             raise_with_traceback(SerializationError, msg, err)
@@ -655,31 +678,31 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type = data_type.strip("[]{}")
-        internal_data_type = self.dependencies.get(internal_data_type, None)
+        internal_data_type_str = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type_str, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
         if internal_data_type and not isinstance(internal_data_type, Enum):
             try:
                 deserializer = Deserializer(self.dependencies)
                 # Since it's on serialization, it's almost sure that format is not JSON REST
                 # We're not able to deal with additional properties for now.
                 deserializer.additional_properties_detection = False
                 if is_xml_model_serialization:
-                    deserializer.key_extractors = [
+                    deserializer.key_extractors = [  # type: ignore
                         attribute_key_case_insensitive_extractor,
                     ]
                 else:
                     deserializer.key_extractors = [
                         rest_key_case_insensitive_extractor,
                         attribute_key_case_insensitive_extractor,
                         last_rest_key_case_insensitive_extractor,
@@ -776,14 +799,16 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
+            if data is AzureCoreNull:
+                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
@@ -839,15 +864,15 @@
         """
         try:  # If I received an enum, return its value
             return data.value
         except AttributeError:
             pass
 
         try:
-            if isinstance(data, unicode):
+            if isinstance(data, unicode):  # type: ignore
                 # Don't change it, JSON and XML ElementTree are totally able
                 # to serialize correctly u'' strings
                 return data
         except NameError:
             return str(data)
         else:
             return str(data)
@@ -997,18 +1022,18 @@
     @staticmethod
     def serialize_enum(attr, enum_obj=None):
         try:
             result = attr.value
         except AttributeError:
             result = attr
         try:
-            enum_obj(result)
+            enum_obj(result)  # type: ignore
             return result
         except ValueError:
-            for enum_value in enum_obj:
+            for enum_value in enum_obj:  # type: ignore
                 if enum_value.value.lower() == str(attr).lower():
                     return enum_value.value
             error = "{!r} is not valid value for enum {!r}"
             raise SerializationError(error.format(attr, enum_obj))
 
     @staticmethod
     def serialize_bytearray(attr, **kwargs):
@@ -1160,15 +1185,16 @@
 
 
 def rest_key_extractor(attr, attr_desc, data):
     key = attr_desc["key"]
     working_data = data
 
     while "." in key:
-        dict_keys = _FLATTEN.split(key)
+        # Need the cast, as for some reasons "split" is typed as list[str | Any]
+        dict_keys = cast(List[str], _FLATTEN.split(key))
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
@@ -1331,15 +1357,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1351,15 +1377,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1412,15 +1438,15 @@
             return self.deserialize_data(data, response)
         elif isinstance(response, type) and issubclass(response, Enum):
             return self.deserialize_enum(data, response)
 
         if data is None:
             return data
         try:
-            attributes = response._attribute_map
+            attributes = response._attribute_map  # type: ignore
             d_attrs = {}
             for attr, attr_desc in attributes.items():
                 # Check empty string. If it's not empty, someone has a real "additionalProperties"...
                 if attr == "additional_properties" and attr_desc["key"] == "":
                     continue
                 raw_value = None
                 # Enhance attr_desc with some dynamic data
@@ -1440,15 +1466,15 @@
                             _LOGGER.warning(msg, found_value, key_extractor, attr)
                             continue
                         raw_value = found_value
 
                 value = self.deserialize_data(raw_value, attr_desc["type"])
                 d_attrs[attr] = value
         except (AttributeError, TypeError, KeyError) as err:
-            msg = "Unable to deserialize to object: " + class_name
+            msg = "Unable to deserialize to object: " + class_name  # type: ignore
             raise_with_traceback(DeserializationError, msg, err)
         else:
             additional_properties = self._build_additional_properties(attributes, data)
             return self._instantiate_model(response, d_attrs, additional_properties)
 
     def _build_additional_properties(self, attribute_map, data):
         if not self.additional_properties_detection:
@@ -1470,46 +1496,46 @@
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__
+        return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
-            _LOGGER.warning(
+            _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
             )
             return None
 
     @staticmethod
     def _unpack_content(raw_data, content_type=None):
         """Extract the correct structure for deserialization.
@@ -1539,15 +1565,15 @@
             return RawDeserializer.deserialize_from_http_generics(raw_data.text(), raw_data.headers)
 
         # Assume this enough to recognize requests.Response without importing it.
         if hasattr(raw_data, "_content_consumed"):
             return RawDeserializer.deserialize_from_http_generics(raw_data.text, raw_data.headers)
 
         if isinstance(raw_data, (basestring, bytes)) or hasattr(raw_data, "read"):
-            return RawDeserializer.deserialize_from_text(raw_data, content_type)
+            return RawDeserializer.deserialize_from_text(raw_data, content_type)  # type: ignore
         return raw_data
 
     def _instantiate_model(self, response, attrs, additional_properties=None):
         """Instantiate a response model passing in deserialized args.
 
         :param response: The response model class.
         :param d_attrs: The deserialized response attributes.
@@ -1561,15 +1587,15 @@
                 response_obj = response(**kwargs)
                 for attr in readonly:
                     setattr(response_obj, attr, attrs.get(attr))
                 if additional_properties:
                     response_obj.additional_properties = additional_properties
                 return response_obj
             except TypeError as err:
-                msg = "Unable to deserialize {} into model {}. ".format(kwargs, response)
+                msg = "Unable to deserialize {} into model {}. ".format(kwargs, response)  # type: ignore
                 raise DeserializationError(msg + str(err))
         else:
             try:
                 for attr, value in attrs.items():
                     setattr(response, attr, value)
                 return response
             except Exception as exp:
@@ -1743,15 +1769,15 @@
         # We might be here because we have an enum modeled as string,
         # and we try to deserialize a partial dict with enum inside
         if isinstance(data, Enum):
             return data
 
         # Consider this is real string
         try:
-            if isinstance(data, unicode):
+            if isinstance(data, unicode):  # type: ignore
                 return data
         except NameError:
             return str(data)
         else:
             return str(data)
 
     @staticmethod
@@ -1794,58 +1820,58 @@
 
         :param str attr: response string to be deserialized.
         :rtype: bytearray
         :raises: TypeError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        return bytearray(b64decode(attr))
+        return bytearray(b64decode(attr))  # type: ignore
 
     @staticmethod
     def deserialize_base64(attr):
         """Deserialize base64 encoded string into string.
 
         :param str attr: response string to be deserialized.
         :rtype: bytearray
         :raises: TypeError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        padding = "=" * (3 - (len(attr) + 3) % 4)
-        attr = attr + padding
+        padding = "=" * (3 - (len(attr) + 3) % 4)  # type: ignore
+        attr = attr + padding  # type: ignore
         encoded = attr.replace("-", "+").replace("_", "/")
         return b64decode(encoded)
 
     @staticmethod
     def deserialize_decimal(attr):
         """Deserialize string into Decimal object.
 
         :param str attr: response string to be deserialized.
         :rtype: Decimal
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            return decimal.Decimal(attr)
+            return decimal.Decimal(attr)  # type: ignore
         except decimal.DecimalException as err:
             msg = "Invalid decimal {}".format(attr)
             raise_with_traceback(DeserializationError, msg, err)
 
     @staticmethod
     def deserialize_long(attr):
         """Deserialize string into long (Py2) or int (Py3).
 
         :param str attr: response string to be deserialized.
         :rtype: long or int
         :raises: ValueError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        return _long_type(attr)
+        return _long_type(attr)  # type: ignore
 
     @staticmethod
     def deserialize_duration(attr):
         """Deserialize ISO-8601 formatted string into TimeDelta object.
 
         :param str attr: response string to be deserialized.
         :rtype: TimeDelta
@@ -1867,45 +1893,45 @@
 
         :param str attr: response string to be deserialized.
         :rtype: Date
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        if re.search(r"[^\W\d_]", attr, re.I + re.U):
+        if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         # This must NOT use defaultmonth/defaultday. Using None ensure this raises an exception.
         return isodate.parse_date(attr, defaultmonth=None, defaultday=None)
 
     @staticmethod
     def deserialize_time(attr):
         """Deserialize ISO-8601 formatted string into time object.
 
         :param str attr: response string to be deserialized.
         :rtype: datetime.time
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        if re.search(r"[^\W\d_]", attr, re.I + re.U):
+        if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         return isodate.parse_time(attr)
 
     @staticmethod
     def deserialize_rfc(attr):
         """Deserialize RFC-1123 formatted string into Datetime object.
 
         :param str attr: response string to be deserialized.
         :rtype: Datetime
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            parsed_date = email.utils.parsedate_tz(attr)
+            parsed_date = email.utils.parsedate_tz(attr)  # type: ignore
             date_obj = datetime.datetime(
                 *parsed_date[:6], tzinfo=_FixedOffset(datetime.timedelta(minutes=(parsed_date[9] or 0) / 60))
             )
             if not date_obj.tzinfo:
                 date_obj = date_obj.astimezone(tz=TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to rfc datetime object."
@@ -1920,15 +1946,15 @@
         :param str attr: response string to be deserialized.
         :rtype: Datetime
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            attr = attr.upper()
+            attr = attr.upper()  # type: ignore
             match = Deserializer.valid_date.match(attr)
             if not match:
                 raise ValueError("Invalid datetime string: " + attr)
 
             check_decimal = attr.split(".")
             if len(check_decimal) > 1:
                 decimal_str = ""
@@ -1956,15 +1982,15 @@
         This is represented as seconds.
 
         :param int attr: Object to be serialized.
         :rtype: Datetime
         :raises: DeserializationError if format invalid
         """
         if isinstance(attr, ET.Element):
-            attr = int(attr.text)
+            attr = int(attr.text)  # type: ignore
         try:
             date_obj = datetime.datetime.fromtimestamp(attr, TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to unix datetime object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
             return date_obj
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_vendor.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_vendor.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+from typing import List, cast
+
 from azure.core.pipeline.transport import HttpRequest
 
 
 def _convert_request(request, files=None):
     data = request.content if not files else None
     request = HttpRequest(method=request.method, url=request.url, headers=request.headers, data=data)
     if files:
@@ -18,10 +20,11 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -2,20 +2,14 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from ._azure_file_storage import AzureFileStorage
+from ._azure_queue_storage import AzureQueueStorage
+__all__ = ['AzureQueueStorage']
 
-try:
-    from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
-except ImportError:
-    _patch_all = []
-from ._patch import patch_sdk as _patch_sdk
-
-__all__ = ["AzureFileStorage"]
-__all__.extend([p for p in _patch_all if p not in __all__])
-
-_patch_sdk()
+# `._patch.py` is used for handwritten extensions to the generated code
+# Example: https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/customize_code/how-to-patch-sdk-code.md
+from ._patch import patch_sdk
+patch_sdk()
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/_azure_file_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/_azure_file_storage.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
-from typing import Any, Awaitable
+from typing import Any, Awaitable, Optional, Union
 
 from azure.core import AsyncPipelineClient
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 
-from .. import models
+from .. import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import AzureFileStorageConfiguration
 from .operations import DirectoryOperations, FileOperations, ServiceOperations, ShareOperations
 
 
 class AzureFileStorage:  # pylint: disable=client-accepts-api-version-keyword
     """AzureFileStorage.
@@ -30,30 +30,50 @@
     :ivar file: FileOperations operations
     :vartype file: azure.storage.fileshare.aio.operations.FileOperations
     :param url: The URL of the service account, share, directory or file that is the target of the
      desired operation. Required.
     :type url: str
     :param base_url: Service URL. Required. Default value is "".
     :type base_url: str
+    :param file_request_intent: Valid value is backup. "backup" Default value is None.
+    :type file_request_intent: str or ~azure.storage.fileshare.models.ShareTokenIntent
+    :param allow_trailing_dot: If true, the trailing dot will not be trimmed from the target URI.
+     Default value is None.
+    :type allow_trailing_dot: bool
+    :param allow_source_trailing_dot: If true, the trailing dot will not be trimmed from the source
+     URI. Default value is None.
+    :type allow_source_trailing_dot: bool
     :keyword version: Specifies the version of the operation to use for this request. Default value
-     is "2021-06-08". Note that overriding this default value may result in unsupported behavior.
+     is "2022-11-02". Note that overriding this default value may result in unsupported behavior.
     :paramtype version: str
     :keyword file_range_write_from_url: Only update is supported: - Update: Writes the bytes
      downloaded from the source url into the specified range. Default value is "update". Note that
      overriding this default value may result in unsupported behavior.
     :paramtype file_range_write_from_url: str
     """
 
     def __init__(  # pylint: disable=missing-client-constructor-parameter-credential
-        self, url: str, base_url: str = "", **kwargs: Any
+        self,
+        url: str,
+        base_url: str = "",
+        file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
+        allow_trailing_dot: Optional[bool] = None,
+        allow_source_trailing_dot: Optional[bool] = None,
+        **kwargs: Any
     ) -> None:
-        self._config = AzureFileStorageConfiguration(url=url, **kwargs)
+        self._config = AzureFileStorageConfiguration(
+            url=url,
+            file_request_intent=file_request_intent,
+            allow_trailing_dot=allow_trailing_dot,
+            allow_source_trailing_dot=allow_source_trailing_dot,
+            **kwargs
+        )
         self._client = AsyncPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.service = ServiceOperations(self._client, self._config, self._serialize, self._deserialize)
         self.share = ShareOperations(self._client, self._config, self._serialize, self._deserialize)
         self.directory = DirectoryOperations(self._client, self._config, self._serialize, self._deserialize)
         self.file = FileOperations(self._client, self._config, self._serialize, self._deserialize)
@@ -83,9 +103,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "AzureFileStorage":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/_configuration_async.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,58 +1,53 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
-# Licensed under the MIT License. See License.txt in the project root for license information.
+# Licensed under the MIT License. See License.txt in the project root for
+# license information.
+#
 # Code generated by Microsoft (R) AutoRest Code Generator.
-# Changes may cause incorrect behavior and will be lost if the code is regenerated.
+# Changes may cause incorrect behavior and will be lost if the code is
+# regenerated.
 # --------------------------------------------------------------------------
 
-from typing import Any
-
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
-VERSION = "unknown"
-
+from ..version import VERSION
 
-class AzureFileStorageConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
-    """Configuration for AzureFileStorage.
 
+class AzureQueueStorageConfiguration(Configuration):
+    """Configuration for AzureQueueStorage
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :param url: The URL of the service account, share, directory or file that is the target of the
-     desired operation. Required.
+    :param url: The URL of the service account, queue or message that is the
+     targe of the desired operation.
     :type url: str
-    :keyword version: Specifies the version of the operation to use for this request. Default value
-     is "2021-06-08". Note that overriding this default value may result in unsupported behavior.
-    :paramtype version: str
-    :keyword file_range_write_from_url: Only update is supported: - Update: Writes the bytes
-     downloaded from the source url into the specified range. Default value is "update". Note that
-     overriding this default value may result in unsupported behavior.
-    :paramtype file_range_write_from_url: str
+    :ivar version: Specifies the version of the operation to use for this
+     request.
+    :type version: str
     """
 
-    def __init__(self, url: str, **kwargs: Any) -> None:
-        super(AzureFileStorageConfiguration, self).__init__(**kwargs)
-        version = kwargs.pop("version", "2021-06-08")  # type: str
-        file_range_write_from_url = kwargs.pop("file_range_write_from_url", "update")  # type: str
+    def __init__(self, url, **kwargs):
 
         if url is None:
             raise ValueError("Parameter 'url' must not be None.")
 
-        self.url = url
-        self.version = version
-        self.file_range_write_from_url = file_range_write_from_url
-        kwargs.setdefault("sdk_moniker", "azurefilestorage/{}".format(VERSION))
+        super(AzureQueueStorageConfiguration, self).__init__(**kwargs)
         self._configure(**kwargs)
 
-    def _configure(self, **kwargs: Any) -> None:
-        self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
-        self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
-        self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
-        self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
-        self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
-        self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
-        self.authentication_policy = kwargs.get("authentication_policy")
+        self.user_agent_policy.add_user_agent('azsdk-python-azurequeuestorage/{}'.format(VERSION))
+        self.generate_client_request_id = True
+        self.accept_language = None
+
+        self.url = url
+        self.version = "2018-03-28"
+
+    def _configure(self, **kwargs):
+        self.user_agent_policy = kwargs.get('user_agent_policy') or policies.UserAgentPolicy(**kwargs)
+        self.headers_policy = kwargs.get('headers_policy') or policies.HeadersPolicy(**kwargs)
+        self.proxy_policy = kwargs.get('proxy_policy') or policies.ProxyPolicy(**kwargs)
+        self.logging_policy = kwargs.get('logging_policy') or policies.NetworkTraceLoggingPolicy(**kwargs)
+        self.retry_policy = kwargs.get('retry_policy') or policies.AsyncRetryPolicy(**kwargs)
+        self.custom_hook_policy = kwargs.get('custom_hook_policy') or policies.CustomHookPolicy(**kwargs)
+        self.redirect_policy = kwargs.get('redirect_policy') or policies.AsyncRedirectPolicy(**kwargs)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from ._service_operations import ServiceOperations
 from ._share_operations import ShareOperations
 from ._directory_operations import DirectoryOperations
 from ._file_operations import FileOperations
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "ServiceOperations",
     "ShareOperations",
     "DirectoryOperations",
     "FileOperations",
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_directory_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_directory_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,21 +2,23 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, List, Optional, TypeVar, Union
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
@@ -31,14 +33,18 @@
     build_list_files_and_directories_segment_request,
     build_list_handles_request,
     build_rename_request,
     build_set_metadata_request,
     build_set_properties_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DirectoryOperations:
     """
     .. warning::
@@ -108,43 +114,50 @@
          value may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_create_request(
             url=self._config.url,
             timeout=timeout,
             metadata=metadata,
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             file_attributes=file_attributes,
             file_creation_time=file_creation_time,
             file_last_write_time=file_last_write_time,
             file_change_time=file_change_time,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             version=self._config.version,
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -177,15 +190,15 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    create.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    create.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace_async
     async def get_properties(  # pylint: disable=inconsistent-return-statements
         self, sharesnapshot: Optional[str] = None, timeout: Optional[int] = None, **kwargs: Any
     ) -> None:
         """Returns all system properties for the specified directory, and can also be used to check the
         existence of a directory. The data returned does not include the files in the directory or any
@@ -203,37 +216,44 @@
          value may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_get_properties_request(
             url=self._config.url,
             sharesnapshot=sharesnapshot,
             timeout=timeout,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             version=self._config.version,
             template_url=self.get_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -267,15 +287,15 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    get_properties.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    get_properties.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace_async
     async def delete(  # pylint: disable=inconsistent-return-statements
         self, timeout: Optional[int] = None, **kwargs: Any
     ) -> None:
         """Removes the specified empty directory. Note that the directory must be empty before it can be
         deleted.
@@ -289,36 +309,43 @@
          value may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             url=self._config.url,
             timeout=timeout,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             version=self._config.version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -329,15 +356,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    delete.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    delete.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace_async
     async def set_properties(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         file_permission: str = "inherit",
         file_permission_key: Optional[str] = None,
@@ -384,44 +411,51 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_set_properties_request(
             url=self._config.url,
             timeout=timeout,
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             file_attributes=file_attributes,
             file_creation_time=file_creation_time,
             file_last_write_time=file_last_write_time,
             file_change_time=file_change_time,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.set_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -454,15 +488,15 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_properties.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    set_properties.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace_async
     async def set_metadata(  # pylint: disable=inconsistent-return-statements
         self, timeout: Optional[int] = None, metadata: Optional[Dict[str, str]] = None, **kwargs: Any
     ) -> None:
         """Updates user defined metadata for the specified directory.
 
@@ -481,39 +515,46 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "metadata"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        comp: Literal["metadata"] = kwargs.pop("comp", _params.pop("comp", "metadata"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_set_metadata_request(
             url=self._config.url,
             timeout=timeout,
             metadata=metadata,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.set_metadata.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -528,25 +569,25 @@
         response_headers["x-ms-request-server-encrypted"] = self._deserialize(
             "bool", response.headers.get("x-ms-request-server-encrypted")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_metadata.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    set_metadata.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace_async
     async def list_files_and_directories_segment(
         self,
         prefix: Optional[str] = None,
         sharesnapshot: Optional[str] = None,
         marker: Optional[str] = None,
         maxresults: Optional[int] = None,
         timeout: Optional[int] = None,
-        include: Optional[List[Union[str, "_models.ListFilesIncludeType"]]] = None,
+        include: Optional[List[Union[str, _models.ListFilesIncludeType]]] = None,
         include_extended_info: Optional[bool] = None,
         **kwargs: Any
     ) -> _models.ListFilesAndDirectoriesSegmentResponse:
         """Returns a list of files or directories under the specified share or directory. It lists the
         contents only for a single level of the directory hierarchy.
 
         :param prefix: Filters the results to return only entries whose name begins with the specified
@@ -581,44 +622,51 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ListFilesAndDirectoriesSegmentResponse or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ListFilesAndDirectoriesSegmentResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "list"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ListFilesAndDirectoriesSegmentResponse]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        comp: Literal["list"] = kwargs.pop("comp", _params.pop("comp", "list"))
+        cls: ClsType[_models.ListFilesAndDirectoriesSegmentResponse] = kwargs.pop("cls", None)
 
         request = build_list_files_and_directories_segment_request(
             url=self._config.url,
             prefix=prefix,
             sharesnapshot=sharesnapshot,
             marker=marker,
             maxresults=maxresults,
             timeout=timeout,
             include=include,
             include_extended_info=include_extended_info,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.list_files_and_directories_segment.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -634,15 +682,15 @@
         deserialized = self._deserialize("ListFilesAndDirectoriesSegmentResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    list_files_and_directories_segment.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    list_files_and_directories_segment.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace_async
     async def list_handles(
         self,
         marker: Optional[str] = None,
         maxresults: Optional[int] = None,
         timeout: Optional[int] = None,
@@ -676,40 +724,47 @@
          may result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ListHandlesResponse or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ListHandlesResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "listhandles"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ListHandlesResponse]
+        comp: Literal["listhandles"] = kwargs.pop("comp", _params.pop("comp", "listhandles"))
+        cls: ClsType[_models.ListHandlesResponse] = kwargs.pop("cls", None)
 
         request = build_list_handles_request(
             url=self._config.url,
             marker=marker,
             maxresults=maxresults,
             timeout=timeout,
             sharesnapshot=sharesnapshot,
             recursive=recursive,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.list_handles.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -725,15 +780,15 @@
         deserialized = self._deserialize("ListHandlesResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    list_handles.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    list_handles.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace_async
     async def force_close_handles(  # pylint: disable=inconsistent-return-statements
         self,
         handle_id: str,
         timeout: Optional[int] = None,
         marker: Optional[str] = None,
@@ -766,40 +821,47 @@
          value may result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["forceclosehandles"] = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_force_close_handles_request(
             url=self._config.url,
             handle_id=handle_id,
             timeout=timeout,
             marker=marker,
             sharesnapshot=sharesnapshot,
             recursive=recursive,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.force_close_handles.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -817,15 +879,15 @@
         response_headers["x-ms-number-of-handles-failed"] = self._deserialize(
             "int", response.headers.get("x-ms-number-of-handles-failed")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    force_close_handles.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    force_close_handles.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace_async
     async def rename(  # pylint: disable=inconsistent-return-statements
         self,
         rename_source: str,
         timeout: Optional[int] = None,
         replace_if_exists: Optional[bool] = None,
@@ -888,23 +950,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "rename"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        comp: Literal["rename"] = kwargs.pop("comp", _params.pop("comp", "rename"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _source_lease_id = None
         _destination_lease_id = None
         _file_attributes = None
         _file_creation_time = None
         _file_last_write_time = None
         _file_change_time = None
@@ -929,25 +996,28 @@
             file_attributes=_file_attributes,
             file_creation_time=_file_creation_time,
             file_last_write_time=_file_last_write_time,
             file_change_time=_file_change_time,
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             metadata=metadata,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            allow_source_trailing_dot=self._config.allow_source_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.rename.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -980,8 +1050,8 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    rename.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    rename.metadata = {"url": "{url}/{shareName}/{directory}"}
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_file_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_file_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,21 +2,23 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterator, Callable, Dict, IO, Optional, TypeVar, Union
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
@@ -40,14 +42,18 @@
     build_set_http_headers_request,
     build_set_metadata_request,
     build_start_copy_request,
     build_upload_range_from_url_request,
     build_upload_range_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class FileOperations:
     """
     .. warning::
@@ -126,22 +132,27 @@
          value is "file". Note that overriding this default value may result in unsupported behavior.
         :paramtype file_type_constant: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
-        file_type_constant = kwargs.pop("file_type_constant", _headers.pop("x-ms-type", "file"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        file_type_constant: Literal["file"] = kwargs.pop("file_type_constant", _headers.pop("x-ms-type", "file"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _file_content_type = None
         _file_content_encoding = None
         _file_content_language = None
         _file_cache_control = None
         _file_content_md5 = None
         _file_content_disposition = None
@@ -170,24 +181,26 @@
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             file_attributes=file_attributes,
             file_creation_time=file_creation_time,
             file_last_write_time=file_last_write_time,
             file_change_time=file_change_time,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             file_type_constant=file_type_constant,
             version=self._config.version,
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -220,15 +233,15 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    create.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    create.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def download(
         self,
         timeout: Optional[int] = None,
         range: Optional[str] = None,
         range_get_content_md5: Optional[bool] = None,
@@ -251,41 +264,48 @@
         :param lease_access_conditions: Parameter group. Default value is None.
         :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Async iterator of the response bytes or the result of cls(response)
         :rtype: AsyncIterator[bytes]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
-        cls = kwargs.pop("cls", None)  # type: ClsType[AsyncIterator[bytes]]
+        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_download_request(
             url=self._config.url,
             timeout=timeout,
             range=range,
             range_get_content_md5=range_get_content_md5,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             version=self._config.version,
             template_url=self.download.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=True, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 206]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -416,19 +436,19 @@
             )
             response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
             response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
 
             deserialized = response.stream_download(self._client._pipeline)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    download.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    download.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def get_properties(  # pylint: disable=inconsistent-return-statements
         self,
         sharesnapshot: Optional[str] = None,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -448,40 +468,47 @@
         :param lease_access_conditions: Parameter group. Default value is None.
         :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_get_properties_request(
             url=self._config.url,
             sharesnapshot=sharesnapshot,
             timeout=timeout,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             version=self._config.version,
             template_url=self.get_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -536,15 +563,15 @@
         response_headers["x-ms-lease-duration"] = self._deserialize("str", response.headers.get("x-ms-lease-duration"))
         response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
         response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    get_properties.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    get_properties.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def delete(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
@@ -559,39 +586,46 @@
         :param lease_access_conditions: Parameter group. Default value is None.
         :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_delete_request(
             url=self._config.url,
             timeout=timeout,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             version=self._config.version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -602,15 +636,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    delete.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    delete.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def set_http_headers(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         file_content_length: Optional[int] = None,
         file_permission: str = "inherit",
@@ -665,22 +699,27 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _file_content_type = None
         _file_content_encoding = None
         _file_content_language = None
         _file_cache_control = None
         _file_content_md5 = None
         _file_content_disposition = None
@@ -708,24 +747,26 @@
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             file_attributes=file_attributes,
             file_creation_time=file_creation_time,
             file_last_write_time=file_last_write_time,
             file_change_time=file_change_time,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.set_http_headers.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -758,15 +799,15 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_http_headers.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    set_http_headers.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def set_metadata(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         metadata: Optional[Dict[str, str]] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -788,42 +829,49 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "metadata"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["metadata"] = kwargs.pop("comp", _params.pop("comp", "metadata"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_set_metadata_request(
             url=self._config.url,
             timeout=timeout,
             metadata=metadata,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.set_metadata.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -838,15 +886,15 @@
         response_headers["x-ms-request-server-encrypted"] = self._deserialize(
             "bool", response.headers.get("x-ms-request-server-encrypted")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_metadata.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    set_metadata.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def acquire_lease(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         duration: Optional[int] = None,
         proposed_lease_id: Optional[str] = None,
@@ -880,41 +928,48 @@
          overriding this default value may result in unsupported behavior.
         :paramtype action: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["acquire"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_acquire_lease_request(
             url=self._config.url,
             timeout=timeout,
             duration=duration,
             proposed_lease_id=proposed_lease_id,
             request_id_parameter=request_id_parameter,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             action=action,
             version=self._config.version,
             template_url=self.acquire_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -931,15 +986,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    acquire_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    acquire_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def release_lease(  # pylint: disable=inconsistent-return-statements
         self, lease_id: str, timeout: Optional[int] = None, request_id_parameter: Optional[str] = None, **kwargs: Any
     ) -> None:
         """[Update] The Lease File operation establishes and manages a lock on a file for write and delete
         operations.
@@ -962,40 +1017,47 @@
          overriding this default value may result in unsupported behavior.
         :paramtype action: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["release"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_release_lease_request(
             url=self._config.url,
             lease_id=lease_id,
             timeout=timeout,
             request_id_parameter=request_id_parameter,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             action=action,
             version=self._config.version,
             template_url=self.release_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1011,15 +1073,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    release_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    release_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def change_lease(  # pylint: disable=inconsistent-return-statements
         self,
         lease_id: str,
         timeout: Optional[int] = None,
         proposed_lease_id: Optional[str] = None,
@@ -1051,41 +1113,48 @@
          overriding this default value may result in unsupported behavior.
         :paramtype action: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["change"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_change_lease_request(
             url=self._config.url,
             lease_id=lease_id,
             timeout=timeout,
             proposed_lease_id=proposed_lease_id,
             request_id_parameter=request_id_parameter,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             action=action,
             version=self._config.version,
             template_url=self.change_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1102,15 +1171,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    change_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    change_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def break_lease(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         request_id_parameter: Optional[str] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -1137,44 +1206,51 @@
          overriding this default value may result in unsupported behavior.
         :paramtype action: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["break"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_break_lease_request(
             url=self._config.url,
             timeout=timeout,
             lease_id=_lease_id,
             request_id_parameter=request_id_parameter,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             action=action,
             version=self._config.version,
             template_url=self.break_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1191,25 +1267,25 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    break_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    break_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def upload_range(  # pylint: disable=inconsistent-return-statements
         self,
         range: str,
         content_length: int,
         timeout: Optional[int] = None,
-        file_range_write: Union[str, "_models.FileRangeWriteType"] = "update",
+        file_range_write: Union[str, _models.FileRangeWriteType] = "update",
         content_md5: Optional[bytes] = None,
-        file_last_written_mode: Optional[Union[str, "_models.FileLastWrittenMode"]] = None,
+        file_last_written_mode: Optional[Union[str, _models.FileLastWrittenMode]] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         optionalbody: Optional[IO] = None,
         **kwargs: Any
     ) -> None:
         """Upload a range of bytes to a file.
 
         :param range: Specifies the range of bytes to be written. Both the start and end of the range
@@ -1250,23 +1326,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "range"))  # type: str
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["range"] = kwargs.pop("comp", _params.pop("comp", "range"))
+        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
         _content = optionalbody
 
         request = build_upload_range_request(
@@ -1274,26 +1355,28 @@
             range=range,
             content_length=content_length,
             timeout=timeout,
             file_range_write=file_range_write,
             content_md5=content_md5,
             lease_id=_lease_id,
             file_last_written_mode=file_last_written_mode,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             content_type=content_type,
             version=self._config.version,
             content=_content,
             template_url=self.upload_range.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1313,27 +1396,27 @@
         response_headers["x-ms-file-last-write-time"] = self._deserialize(
             "str", response.headers.get("x-ms-file-last-write-time")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    upload_range.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    upload_range.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def upload_range_from_url(  # pylint: disable=inconsistent-return-statements
         self,
         range: str,
         copy_source: str,
         content_length: int,
         timeout: Optional[int] = None,
         source_range: Optional[str] = None,
         source_content_crc64: Optional[bytes] = None,
         copy_source_authorization: Optional[str] = None,
-        file_last_written_mode: Optional[Union[str, "_models.FileLastWrittenMode"]] = None,
+        file_last_written_mode: Optional[Union[str, _models.FileLastWrittenMode]] = None,
         source_modified_access_conditions: Optional[_models.SourceModifiedAccessConditions] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
     ) -> None:
         """Upload a range of bytes to a file where the contents are read from a URL.
 
         :param range: Writes data to the specified byte range in the file. Required.
@@ -1375,22 +1458,27 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "range"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["range"] = kwargs.pop("comp", _params.pop("comp", "range"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _source_if_match_crc64 = None
         _source_if_none_match_crc64 = None
         _lease_id = None
         if source_modified_access_conditions is not None:
             _source_if_match_crc64 = source_modified_access_conditions.source_if_match_crc64
             _source_if_none_match_crc64 = source_modified_access_conditions.source_if_none_match_crc64
@@ -1406,25 +1494,27 @@
             source_range=source_range,
             source_content_crc64=source_content_crc64,
             source_if_match_crc64=_source_if_match_crc64,
             source_if_none_match_crc64=_source_if_none_match_crc64,
             lease_id=_lease_id,
             copy_source_authorization=copy_source_authorization,
             file_last_written_mode=file_last_written_mode,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            allow_source_trailing_dot=self._config.allow_source_trailing_dot,
             comp=comp,
             file_range_write_from_url=self._config.file_range_write_from_url,
             version=self._config.version,
             template_url=self.upload_range_from_url.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1446,15 +1536,15 @@
         response_headers["x-ms-file-last-write-time"] = self._deserialize(
             "str", response.headers.get("x-ms-file-last-write-time")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    upload_range_from_url.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    upload_range_from_url.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def get_range_list(
         self,
         sharesnapshot: Optional[str] = None,
         prevsharesnapshot: Optional[str] = None,
         timeout: Optional[int] = None,
@@ -1484,44 +1574,51 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShareFileRangeList or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ShareFileRangeList
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "rangelist"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ShareFileRangeList]
+        comp: Literal["rangelist"] = kwargs.pop("comp", _params.pop("comp", "rangelist"))
+        cls: ClsType[_models.ShareFileRangeList] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_get_range_list_request(
             url=self._config.url,
             sharesnapshot=sharesnapshot,
             prevsharesnapshot=prevsharesnapshot,
             timeout=timeout,
             range=range,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.get_range_list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1539,15 +1636,15 @@
         deserialized = self._deserialize("ShareFileRangeList", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    get_range_list.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    get_range_list.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def start_copy(  # pylint: disable=inconsistent-return-statements
         self,
         copy_source: str,
         timeout: Optional[int] = None,
         metadata: Optional[Dict[str, str]] = None,
@@ -1590,21 +1687,26 @@
         :param lease_access_conditions: Parameter group. Default value is None.
         :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _file_permission_copy_mode = None
         _ignore_read_only = None
         _file_attributes = None
         _file_creation_time = None
         _file_last_write_time = None
         _file_change_time = None
@@ -1632,23 +1734,26 @@
             ignore_read_only=_ignore_read_only,
             file_attributes=_file_attributes,
             file_creation_time=_file_creation_time,
             file_last_write_time=_file_last_write_time,
             file_change_time=_file_change_time,
             set_archive_attribute=_set_archive_attribute,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            allow_source_trailing_dot=self._config.allow_source_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             version=self._config.version,
             template_url=self.start_copy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1663,15 +1768,15 @@
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
         response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
         response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    start_copy.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    start_copy.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def abort_copy(  # pylint: disable=inconsistent-return-statements
         self,
         copy_id: str,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -1697,46 +1802,53 @@
          default value may result in unsupported behavior.
         :paramtype copy_action_abort_constant: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "copy"))  # type: str
-        copy_action_abort_constant = kwargs.pop(
+        comp: Literal["copy"] = kwargs.pop("comp", _params.pop("comp", "copy"))
+        copy_action_abort_constant: Literal["abort"] = kwargs.pop(
             "copy_action_abort_constant", _headers.pop("x-ms-copy-action", "abort")
-        )  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        )
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_abort_copy_request(
             url=self._config.url,
             copy_id=copy_id,
             timeout=timeout,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             copy_action_abort_constant=copy_action_abort_constant,
             version=self._config.version,
             template_url=self.abort_copy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1747,15 +1859,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    abort_copy.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    abort_copy.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def list_handles(
         self,
         marker: Optional[str] = None,
         maxresults: Optional[int] = None,
         timeout: Optional[int] = None,
@@ -1785,39 +1897,46 @@
          may result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ListHandlesResponse or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ListHandlesResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "listhandles"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ListHandlesResponse]
+        comp: Literal["listhandles"] = kwargs.pop("comp", _params.pop("comp", "listhandles"))
+        cls: ClsType[_models.ListHandlesResponse] = kwargs.pop("cls", None)
 
         request = build_list_handles_request(
             url=self._config.url,
             marker=marker,
             maxresults=maxresults,
             timeout=timeout,
             sharesnapshot=sharesnapshot,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.list_handles.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1833,15 +1952,15 @@
         deserialized = self._deserialize("ListHandlesResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    list_handles.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    list_handles.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def force_close_handles(  # pylint: disable=inconsistent-return-statements
         self,
         handle_id: str,
         timeout: Optional[int] = None,
         marker: Optional[str] = None,
@@ -1870,39 +1989,46 @@
          value may result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["forceclosehandles"] = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_force_close_handles_request(
             url=self._config.url,
             handle_id=handle_id,
             timeout=timeout,
             marker=marker,
             sharesnapshot=sharesnapshot,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.force_close_handles.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1920,15 +2046,15 @@
         response_headers["x-ms-number-of-handles-failed"] = self._deserialize(
             "int", response.headers.get("x-ms-number-of-handles-failed")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    force_close_handles.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    force_close_handles.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace_async
     async def rename(  # pylint: disable=inconsistent-return-statements
         self,
         rename_source: str,
         timeout: Optional[int] = None,
         replace_if_exists: Optional[bool] = None,
@@ -1991,22 +2117,27 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "rename"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["rename"] = kwargs.pop("comp", _params.pop("comp", "rename"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _source_lease_id = None
         _destination_lease_id = None
         _file_attributes = None
         _file_creation_time = None
         _file_last_write_time = None
         _file_change_time = None
@@ -2035,24 +2166,27 @@
             file_creation_time=_file_creation_time,
             file_last_write_time=_file_last_write_time,
             file_change_time=_file_change_time,
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             metadata=metadata,
             file_content_type=_file_content_type,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            allow_source_trailing_dot=self._config.allow_source_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.rename.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2085,8 +2219,8 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    rename.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    rename.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_service_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,21 +2,23 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, List, Optional, TypeVar, Union
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
@@ -25,14 +27,18 @@
 from ..._vendor import _convert_request
 from ...operations._service_operations import (
     build_get_properties_request,
     build_list_shares_segment_request,
     build_set_properties_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
@@ -73,24 +79,29 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "service"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["service"] = kwargs.pop("restype", _params.pop("restype", "service"))
+        comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _content = self._serialize.body(storage_service_properties, "StorageServiceProperties", is_xml=True)
 
         request = build_set_properties_request(
             url=self._config.url,
             timeout=timeout,
             restype=restype,
@@ -99,17 +110,17 @@
             version=self._config.version,
             content=_content,
             template_url=self.set_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -119,15 +130,15 @@
         response_headers = {}
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_properties.metadata = {"url": "{url}"}  # type: ignore
+    set_properties.metadata = {"url": "{url}"}
 
     @distributed_trace_async
     async def get_properties(self, timeout: Optional[int] = None, **kwargs: Any) -> _models.StorageServiceProperties:
         """Gets the properties of a storage account's File service, including properties for Storage
         Analytics metrics and CORS (Cross-Origin Resource Sharing) rules.
 
         :param timeout: The timeout parameter is expressed in seconds. For more information, see
@@ -142,38 +153,43 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageServiceProperties or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.StorageServiceProperties
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "service"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageServiceProperties]
+        restype: Literal["service"] = kwargs.pop("restype", _params.pop("restype", "service"))
+        comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+        cls: ClsType[_models.StorageServiceProperties] = kwargs.pop("cls", None)
 
         request = build_get_properties_request(
             url=self._config.url,
             timeout=timeout,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.get_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -187,23 +203,23 @@
         deserialized = self._deserialize("StorageServiceProperties", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    get_properties.metadata = {"url": "{url}"}  # type: ignore
+    get_properties.metadata = {"url": "{url}"}
 
     @distributed_trace_async
     async def list_shares_segment(
         self,
         prefix: Optional[str] = None,
         marker: Optional[str] = None,
         maxresults: Optional[int] = None,
-        include: Optional[List[Union[str, "_models.ListSharesIncludeType"]]] = None,
+        include: Optional[List[Union[str, _models.ListSharesIncludeType]]] = None,
         timeout: Optional[int] = None,
         **kwargs: Any
     ) -> _models.ListSharesResponse:
         """The List Shares Segment operation returns a list of the shares and share snapshots under the
         specified account.
 
         :param prefix: Filters the results to return only entries whose name begins with the specified
@@ -230,22 +246,27 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ListSharesResponse or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ListSharesResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "list"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ListSharesResponse]
+        comp: Literal["list"] = kwargs.pop("comp", _params.pop("comp", "list"))
+        cls: ClsType[_models.ListSharesResponse] = kwargs.pop("cls", None)
 
         request = build_list_shares_segment_request(
             url=self._config.url,
             prefix=prefix,
             marker=marker,
             maxresults=maxresults,
             include=include,
@@ -253,17 +274,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.list_shares_segment.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -277,8 +298,8 @@
         deserialized = self._deserialize("ListSharesResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    list_shares_segment.metadata = {"url": "{url}"}  # type: ignore
+    list_shares_segment.metadata = {"url": "{url}"}
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_share_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_share_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,21 +2,23 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
@@ -39,14 +41,18 @@
     build_renew_lease_request,
     build_restore_request,
     build_set_access_policy_request,
     build_set_metadata_request,
     build_set_properties_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ShareOperations:
     """
     .. warning::
@@ -68,17 +74,17 @@
 
     @distributed_trace_async
     async def create(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         metadata: Optional[Dict[str, str]] = None,
         quota: Optional[int] = None,
-        access_tier: Optional[Union[str, "_models.ShareAccessTier"]] = None,
+        access_tier: Optional[Union[str, _models.ShareAccessTier]] = None,
         enabled_protocols: Optional[str] = None,
-        root_squash: Optional[Union[str, "_models.ShareRootSquash"]] = None,
+        root_squash: Optional[Union[str, _models.ShareRootSquash]] = None,
         **kwargs: Any
     ) -> None:
         """Creates a new share under the specified account. If the share with the same name already
         exists, the operation fails.
 
         :param timeout: The timeout parameter is expressed in seconds. For more information, see
          :code:`<a
@@ -102,22 +108,27 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_create_request(
             url=self._config.url,
             timeout=timeout,
             metadata=metadata,
             quota=quota,
             access_tier=access_tier,
@@ -126,17 +137,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -149,15 +160,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    create.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    create.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def get_properties(  # pylint: disable=inconsistent-return-statements
         self,
         sharesnapshot: Optional[str] = None,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -180,22 +191,27 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_get_properties_request(
             url=self._config.url,
@@ -205,17 +221,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.get_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -259,22 +275,22 @@
             "str", response.headers.get("x-ms-enabled-protocols")
         )
         response_headers["x-ms-root-squash"] = self._deserialize("str", response.headers.get("x-ms-root-squash"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    get_properties.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    get_properties.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def delete(  # pylint: disable=inconsistent-return-statements
         self,
         sharesnapshot: Optional[str] = None,
         timeout: Optional[int] = None,
-        delete_snapshots: Optional[Union[str, "_models.DeleteSnapshotsOptionType"]] = None,
+        delete_snapshots: Optional[Union[str, _models.DeleteSnapshotsOptionType]] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
     ) -> None:
         """Operation marks the specified share or share snapshot for deletion. The share or share snapshot
         and any files contained within it are later deleted during garbage collection.
 
         :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
@@ -294,22 +310,27 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_delete_request(
             url=self._config.url,
@@ -320,17 +341,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -341,15 +362,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    delete.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    delete.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def acquire_lease(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         duration: Optional[int] = None,
         proposed_lease_id: Optional[str] = None,
@@ -390,24 +411,29 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))  # type: str
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["acquire"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_acquire_lease_request(
             url=self._config.url,
             timeout=timeout,
             duration=duration,
             proposed_lease_id=proposed_lease_id,
             sharesnapshot=sharesnapshot,
@@ -417,17 +443,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.acquire_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -444,15 +470,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    acquire_lease.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    acquire_lease.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def release_lease(  # pylint: disable=inconsistent-return-statements
         self,
         lease_id: str,
         timeout: Optional[int] = None,
         sharesnapshot: Optional[str] = None,
@@ -486,24 +512,29 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))  # type: str
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["release"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_release_lease_request(
             url=self._config.url,
             lease_id=lease_id,
             timeout=timeout,
             sharesnapshot=sharesnapshot,
             request_id_parameter=request_id_parameter,
@@ -512,17 +543,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.release_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -538,15 +569,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    release_lease.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    release_lease.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def change_lease(  # pylint: disable=inconsistent-return-statements
         self,
         lease_id: str,
         timeout: Optional[int] = None,
         proposed_lease_id: Optional[str] = None,
@@ -585,24 +616,29 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))  # type: str
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["change"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_change_lease_request(
             url=self._config.url,
             lease_id=lease_id,
             timeout=timeout,
             proposed_lease_id=proposed_lease_id,
             sharesnapshot=sharesnapshot,
@@ -612,17 +648,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.change_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -639,15 +675,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    change_lease.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    change_lease.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def renew_lease(  # pylint: disable=inconsistent-return-statements
         self,
         lease_id: str,
         timeout: Optional[int] = None,
         sharesnapshot: Optional[str] = None,
@@ -681,24 +717,29 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "renew"))  # type: str
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["renew"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "renew"))
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_renew_lease_request(
             url=self._config.url,
             lease_id=lease_id,
             timeout=timeout,
             sharesnapshot=sharesnapshot,
             request_id_parameter=request_id_parameter,
@@ -707,17 +748,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.renew_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -734,15 +775,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    renew_lease.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    renew_lease.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def break_lease(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         break_period: Optional[int] = None,
         request_id_parameter: Optional[str] = None,
@@ -785,24 +826,29 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))  # type: str
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["break"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_break_lease_request(
             url=self._config.url,
@@ -816,17 +862,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.break_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -844,15 +890,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    break_lease.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    break_lease.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def create_snapshot(  # pylint: disable=inconsistent-return-statements
         self, timeout: Optional[int] = None, metadata: Optional[Dict[str, str]] = None, **kwargs: Any
     ) -> None:
         """Creates a read-only snapshot of a share.
 
@@ -871,39 +917,44 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "snapshot"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["snapshot"] = kwargs.pop("comp", _params.pop("comp", "snapshot"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_create_snapshot_request(
             url=self._config.url,
             timeout=timeout,
             metadata=metadata,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.create_snapshot.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -917,15 +968,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    create_snapshot.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    create_snapshot.metadata = {"url": "{url}/{shareName}"}
 
     @overload
     async def create_permission(  # pylint: disable=inconsistent-return-statements
         self,
         share_permission: _models.SharePermission,
         timeout: Optional[int] = None,
         *,
@@ -992,15 +1043,15 @@
     @distributed_trace_async
     async def create_permission(  # pylint: disable=inconsistent-return-statements
         self, share_permission: Union[_models.SharePermission, IO], timeout: Optional[int] = None, **kwargs: Any
     ) -> None:
         """Create a permission (a security descriptor).
 
         :param share_permission: A permission (a security descriptor) at the share level. Is either a
-         model type or a IO type. Required.
+         SharePermission type or a IO type. Required.
         :type share_permission: ~azure.storage.fileshare.models.SharePermission or IO
         :param timeout: The timeout parameter is expressed in seconds. For more information, see
          :code:`<a
          href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
          Timeouts for File Service Operations.</a>`. Default value is None.
         :type timeout: int
         :keyword restype: restype. Default value is "share". Note that overriding this default value
@@ -1013,50 +1064,56 @@
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "filepermission"))  # type: str
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["filepermission"] = kwargs.pop("comp", _params.pop("comp", "filepermission"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(share_permission, (IO, bytes)):
             _content = share_permission
         else:
             _json = self._serialize.body(share_permission, "SharePermission")
 
         request = build_create_permission_request(
             url=self._config.url,
             timeout=timeout,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             content_type=content_type,
             version=self._config.version,
             json=_json,
             content=_content,
             template_url=self.create_permission.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1070,15 +1127,15 @@
         response_headers["x-ms-file-permission-key"] = self._deserialize(
             "str", response.headers.get("x-ms-file-permission-key")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    create_permission.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    create_permission.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def get_permission(
         self, file_permission_key: str, timeout: Optional[int] = None, **kwargs: Any
     ) -> _models.SharePermission:
         """Returns the permission (security descriptor) for a given key.
 
@@ -1096,39 +1153,45 @@
          may result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SharePermission or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.SharePermission
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "filepermission"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SharePermission]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["filepermission"] = kwargs.pop("comp", _params.pop("comp", "filepermission"))
+        cls: ClsType[_models.SharePermission] = kwargs.pop("cls", None)
 
         request = build_get_permission_request(
             url=self._config.url,
             file_permission_key=file_permission_key,
             timeout=timeout,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.get_permission.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1143,23 +1206,23 @@
         deserialized = self._deserialize("SharePermission", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    get_permission.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    get_permission.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def set_properties(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         quota: Optional[int] = None,
-        access_tier: Optional[Union[str, "_models.ShareAccessTier"]] = None,
-        root_squash: Optional[Union[str, "_models.ShareRootSquash"]] = None,
+        access_tier: Optional[Union[str, _models.ShareAccessTier]] = None,
+        root_squash: Optional[Union[str, _models.ShareRootSquash]] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
     ) -> None:
         """Sets properties for the specified share.
 
         :param timeout: The timeout parameter is expressed in seconds. For more information, see
          :code:`<a
@@ -1183,23 +1246,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_set_properties_request(
             url=self._config.url,
@@ -1212,17 +1280,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.set_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1235,15 +1303,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_properties.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    set_properties.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def set_metadata(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         metadata: Optional[Dict[str, str]] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -1268,23 +1336,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "metadata"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["metadata"] = kwargs.pop("comp", _params.pop("comp", "metadata"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_set_metadata_request(
             url=self._config.url,
@@ -1295,17 +1368,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.set_metadata.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1318,15 +1391,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_metadata.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    set_metadata.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def get_access_policy(
         self,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
@@ -1347,23 +1420,28 @@
          in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: list of SignedIdentifier or the result of cls(response)
         :rtype: list[~azure.storage.fileshare.models.SignedIdentifier]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "acl"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[List[_models.SignedIdentifier]]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["acl"] = kwargs.pop("comp", _params.pop("comp", "acl"))
+        cls: ClsType[List[_models.SignedIdentifier]] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_get_access_policy_request(
             url=self._config.url,
@@ -1373,17 +1451,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.get_access_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1400,15 +1478,15 @@
         deserialized = self._deserialize("[SignedIdentifier]", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    get_access_policy.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    get_access_policy.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def set_access_policy(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         share_acl: Optional[List[_models.SignedIdentifier]] = None,
@@ -1432,24 +1510,29 @@
          in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "acl"))  # type: str
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["acl"] = kwargs.pop("comp", _params.pop("comp", "acl"))
+        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
         serialization_ctxt = {"xml": {"name": "SignedIdentifiers", "wrapped": True}}
         if share_acl is not None:
             _content = self._serialize.body(
@@ -1468,17 +1551,17 @@
             version=self._config.version,
             content=_content,
             template_url=self.set_access_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1491,15 +1574,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_access_policy.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    set_access_policy.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def get_statistics(
         self,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
@@ -1520,23 +1603,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShareStats or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ShareStats
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "stats"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ShareStats]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["stats"] = kwargs.pop("comp", _params.pop("comp", "stats"))
+        cls: ClsType[_models.ShareStats] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_get_statistics_request(
             url=self._config.url,
@@ -1546,17 +1634,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.get_statistics.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1573,15 +1661,15 @@
         deserialized = self._deserialize("ShareStats", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    get_statistics.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    get_statistics.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace_async
     async def restore(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         request_id_parameter: Optional[str] = None,
         deleted_share_name: Optional[str] = None,
@@ -1612,23 +1700,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "undelete"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["undelete"] = kwargs.pop("comp", _params.pop("comp", "undelete"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_restore_request(
             url=self._config.url,
             timeout=timeout,
             request_id_parameter=request_id_parameter,
             deleted_share_name=deleted_share_name,
             deleted_share_version=deleted_share_version,
@@ -1636,17 +1729,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.restore.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1662,8 +1755,8 @@
         )
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    restore.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    restore.metadata = {"url": "{url}/{shareName}"}
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -33,30 +33,32 @@
 from ._models_py3 import ShareStats
 from ._models_py3 import SignedIdentifier
 from ._models_py3 import SmbMultichannel
 from ._models_py3 import SourceLeaseAccessConditions
 from ._models_py3 import SourceModifiedAccessConditions
 from ._models_py3 import StorageError
 from ._models_py3 import StorageServiceProperties
+from ._models_py3 import StringEncoded
 
 from ._azure_file_storage_enums import CopyStatusType
 from ._azure_file_storage_enums import DeleteSnapshotsOptionType
 from ._azure_file_storage_enums import FileLastWrittenMode
 from ._azure_file_storage_enums import FileRangeWriteType
 from ._azure_file_storage_enums import LeaseDurationType
 from ._azure_file_storage_enums import LeaseStateType
 from ._azure_file_storage_enums import LeaseStatusType
 from ._azure_file_storage_enums import ListFilesIncludeType
 from ._azure_file_storage_enums import ListSharesIncludeType
 from ._azure_file_storage_enums import PermissionCopyModeType
 from ._azure_file_storage_enums import ShareAccessTier
 from ._azure_file_storage_enums import ShareRootSquash
+from ._azure_file_storage_enums import ShareTokenIntent
 from ._azure_file_storage_enums import StorageErrorCode
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "AccessPolicy",
     "ClearRange",
     "CopyFileSmbInfo",
     "CorsRule",
@@ -83,23 +85,25 @@
     "ShareStats",
     "SignedIdentifier",
     "SmbMultichannel",
     "SourceLeaseAccessConditions",
     "SourceModifiedAccessConditions",
     "StorageError",
     "StorageServiceProperties",
+    "StringEncoded",
     "CopyStatusType",
     "DeleteSnapshotsOptionType",
     "FileLastWrittenMode",
     "FileRangeWriteType",
     "LeaseDurationType",
     "LeaseStateType",
     "LeaseStatusType",
     "ListFilesIncludeType",
     "ListSharesIncludeType",
     "PermissionCopyModeType",
     "ShareAccessTier",
     "ShareRootSquash",
+    "ShareTokenIntent",
     "StorageErrorCode",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_azure_file_storage_enums.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/_azure_file_storage_enums.py`

 * *Files 2% similar despite different names*

```diff
@@ -100,14 +100,20 @@
     """ShareRootSquash."""
 
     NO_ROOT_SQUASH = "NoRootSquash"
     ROOT_SQUASH = "RootSquash"
     ALL_SQUASH = "AllSquash"
 
 
+class ShareTokenIntent(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """ShareTokenIntent."""
+
+    BACKUP = "backup"
+
+
 class StorageErrorCode(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Error codes returned by the service."""
 
     ACCOUNT_ALREADY_EXISTS = "AccountAlreadyExists"
     ACCOUNT_BEING_CREATED = "AccountBeingCreated"
     ACCOUNT_IS_DISABLED = "AccountIsDisabled"
     AUTHENTICATION_FAILED = "AuthenticationFailed"
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/_models_py3.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,94 +1,100 @@
 # coding=utf-8
+# pylint: disable=too-many-lines
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from azure.core.exceptions import HttpResponseError
-import msrest.serialization
+import datetime
+from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
 
+from .. import _serialization
 
-class AccessPolicy(msrest.serialization.Model):
+if TYPE_CHECKING:
+    # pylint: disable=unused-import,ungrouped-imports
+    from .. import models as _models
+
+
+class AccessPolicy(_serialization.Model):
     """An Access policy.
 
     :ivar start: The date-time the policy is active.
     :vartype start: str
     :ivar expiry: The date-time the policy expires.
     :vartype expiry: str
     :ivar permission: The permissions for the ACL policy.
     :vartype permission: str
     """
 
     _attribute_map = {
-        'start': {'key': 'Start', 'type': 'str'},
-        'expiry': {'key': 'Expiry', 'type': 'str'},
-        'permission': {'key': 'Permission', 'type': 'str'},
+        "start": {"key": "Start", "type": "str"},
+        "expiry": {"key": "Expiry", "type": "str"},
+        "permission": {"key": "Permission", "type": "str"},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        start: Optional[str] = None,
+        expiry: Optional[str] = None,
+        permission: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword start: The date-time the policy is active.
         :paramtype start: str
         :keyword expiry: The date-time the policy expires.
         :paramtype expiry: str
         :keyword permission: The permissions for the ACL policy.
         :paramtype permission: str
         """
-        super(AccessPolicy, self).__init__(**kwargs)
-        self.start = kwargs.get('start', None)
-        self.expiry = kwargs.get('expiry', None)
-        self.permission = kwargs.get('permission', None)
+        super().__init__(**kwargs)
+        self.start = start
+        self.expiry = expiry
+        self.permission = permission
 
 
-class ClearRange(msrest.serialization.Model):
+class ClearRange(_serialization.Model):
     """ClearRange.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar start: Required.
-    :vartype start: long
+    :vartype start: int
     :ivar end: Required.
-    :vartype end: long
+    :vartype end: int
     """
 
     _validation = {
-        'start': {'required': True},
-        'end': {'required': True},
+        "start": {"required": True},
+        "end": {"required": True},
     }
 
     _attribute_map = {
-        'start': {'key': 'Start', 'type': 'long', 'xml': {'name': 'Start'}},
-        'end': {'key': 'End', 'type': 'long', 'xml': {'name': 'End'}},
-    }
-    _xml_map = {
-        'name': 'ClearRange'
+        "start": {"key": "Start", "type": "int", "xml": {"name": "Start"}},
+        "end": {"key": "End", "type": "int", "xml": {"name": "End"}},
     }
+    _xml_map = {"name": "ClearRange"}
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, start: int, end: int, **kwargs: Any) -> None:
         """
         :keyword start: Required.
-        :paramtype start: long
+        :paramtype start: int
         :keyword end: Required.
-        :paramtype end: long
+        :paramtype end: int
         """
-        super(ClearRange, self).__init__(**kwargs)
-        self.start = kwargs['start']
-        self.end = kwargs['end']
+        super().__init__(**kwargs)
+        self.start = start
+        self.end = end
 
 
-class CopyFileSmbInfo(msrest.serialization.Model):
+class CopyFileSmbInfo(_serialization.Model):
     """Parameter group.
 
     :ivar file_attributes: Specifies either the option to copy file attributes from a source
      file(source) to a target file or a list of attributes to set on a target file.
     :vartype file_attributes: str
     :ivar file_creation_time: Specifies either the option to copy file creation time from a source
      file(source) to a target file or a time value in ISO 8601 format to set as creation time on a
@@ -100,41 +106,48 @@
     :vartype file_last_write_time: str
     :ivar file_change_time: Specifies either the option to copy file last write time from a source
      file(source) to a target file or a time value in ISO 8601 format to set as last write time on a
      target file.
     :vartype file_change_time: str
     :ivar file_permission_copy_mode: Specifies the option to copy file security descriptor from
      source file or to set it using the value which is defined by the header value of
-     x-ms-file-permission or x-ms-file-permission-key. Possible values include: "source",
-     "override".
+     x-ms-file-permission or x-ms-file-permission-key. Known values are: "source" and "override".
     :vartype file_permission_copy_mode: str or
      ~azure.storage.fileshare.models.PermissionCopyModeType
     :ivar ignore_read_only: Specifies the option to overwrite the target file if it already exists
      and has read-only attribute set.
     :vartype ignore_read_only: bool
     :ivar set_archive_attribute: Specifies the option to set archive attribute on a target file.
      True means archive attribute will be set on a target file despite attribute overrides or a
      source file state.
     :vartype set_archive_attribute: bool
     """
 
     _attribute_map = {
-        'file_attributes': {'key': 'fileAttributes', 'type': 'str'},
-        'file_creation_time': {'key': 'fileCreationTime', 'type': 'str'},
-        'file_last_write_time': {'key': 'fileLastWriteTime', 'type': 'str'},
-        'file_change_time': {'key': 'fileChangeTime', 'type': 'str'},
-        'file_permission_copy_mode': {'key': 'filePermissionCopyMode', 'type': 'str'},
-        'ignore_read_only': {'key': 'ignoreReadOnly', 'type': 'bool'},
-        'set_archive_attribute': {'key': 'setArchiveAttribute', 'type': 'bool'},
+        "file_attributes": {"key": "fileAttributes", "type": "str"},
+        "file_creation_time": {"key": "fileCreationTime", "type": "str"},
+        "file_last_write_time": {"key": "fileLastWriteTime", "type": "str"},
+        "file_change_time": {"key": "fileChangeTime", "type": "str"},
+        "file_permission_copy_mode": {"key": "filePermissionCopyMode", "type": "str"},
+        "ignore_read_only": {"key": "ignoreReadOnly", "type": "bool"},
+        "set_archive_attribute": {"key": "setArchiveAttribute", "type": "bool"},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        file_attributes: Optional[str] = None,
+        file_creation_time: Optional[str] = None,
+        file_last_write_time: Optional[str] = None,
+        file_change_time: Optional[str] = None,
+        file_permission_copy_mode: Optional[Union[str, "_models.PermissionCopyModeType"]] = None,
+        ignore_read_only: Optional[bool] = None,
+        set_archive_attribute: Optional[bool] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword file_attributes: Specifies either the option to copy file attributes from a source
          file(source) to a target file or a list of attributes to set on a target file.
         :paramtype file_attributes: str
         :keyword file_creation_time: Specifies either the option to copy file creation time from a
          source file(source) to a target file or a time value in ISO 8601 format to set as creation time
          on a target file.
@@ -145,323 +158,343 @@
         :paramtype file_last_write_time: str
         :keyword file_change_time: Specifies either the option to copy file last write time from a
          source file(source) to a target file or a time value in ISO 8601 format to set as last write
          time on a target file.
         :paramtype file_change_time: str
         :keyword file_permission_copy_mode: Specifies the option to copy file security descriptor from
          source file or to set it using the value which is defined by the header value of
-         x-ms-file-permission or x-ms-file-permission-key. Possible values include: "source",
-         "override".
+         x-ms-file-permission or x-ms-file-permission-key. Known values are: "source" and "override".
         :paramtype file_permission_copy_mode: str or
          ~azure.storage.fileshare.models.PermissionCopyModeType
         :keyword ignore_read_only: Specifies the option to overwrite the target file if it already
          exists and has read-only attribute set.
         :paramtype ignore_read_only: bool
         :keyword set_archive_attribute: Specifies the option to set archive attribute on a target file.
          True means archive attribute will be set on a target file despite attribute overrides or a
          source file state.
         :paramtype set_archive_attribute: bool
         """
-        super(CopyFileSmbInfo, self).__init__(**kwargs)
-        self.file_attributes = kwargs.get('file_attributes', None)
-        self.file_creation_time = kwargs.get('file_creation_time', None)
-        self.file_last_write_time = kwargs.get('file_last_write_time', None)
-        self.file_change_time = kwargs.get('file_change_time', None)
-        self.file_permission_copy_mode = kwargs.get('file_permission_copy_mode', None)
-        self.ignore_read_only = kwargs.get('ignore_read_only', None)
-        self.set_archive_attribute = kwargs.get('set_archive_attribute', None)
+        super().__init__(**kwargs)
+        self.file_attributes = file_attributes
+        self.file_creation_time = file_creation_time
+        self.file_last_write_time = file_last_write_time
+        self.file_change_time = file_change_time
+        self.file_permission_copy_mode = file_permission_copy_mode
+        self.ignore_read_only = ignore_read_only
+        self.set_archive_attribute = set_archive_attribute
 
 
-class CorsRule(msrest.serialization.Model):
-    """CORS is an HTTP feature that enables a web application running under one domain to access resources in another domain. Web browsers implement a security restriction known as same-origin policy that prevents a web page from calling APIs in a different domain; CORS provides a secure way to allow one domain (the origin domain) to call APIs in another domain.
+class CorsRule(_serialization.Model):
+    """CORS is an HTTP feature that enables a web application running under one domain to access
+    resources in another domain. Web browsers implement a security restriction known as same-origin
+    policy that prevents a web page from calling APIs in a different domain; CORS provides a secure
+    way to allow one domain (the origin domain) to call APIs in another domain.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar allowed_origins: Required. The origin domains that are permitted to make a request
-     against the storage service via CORS. The origin domain is the domain from which the request
-     originates. Note that the origin must be an exact case-sensitive match with the origin that the
-     user age sends to the service. You can also use the wildcard character '*' to allow all origin
-     domains to make requests via CORS.
+    :ivar allowed_origins: The origin domains that are permitted to make a request against the
+     storage service via CORS. The origin domain is the domain from which the request originates.
+     Note that the origin must be an exact case-sensitive match with the origin that the user age
+     sends to the service. You can also use the wildcard character '*' to allow all origin domains
+     to make requests via CORS. Required.
     :vartype allowed_origins: str
-    :ivar allowed_methods: Required. The methods (HTTP request verbs) that the origin domain may
-     use for a CORS request. (comma separated).
+    :ivar allowed_methods: The methods (HTTP request verbs) that the origin domain may use for a
+     CORS request. (comma separated). Required.
     :vartype allowed_methods: str
-    :ivar allowed_headers: Required. The request headers that the origin domain may specify on the
-     CORS request.
+    :ivar allowed_headers: The request headers that the origin domain may specify on the CORS
+     request. Required.
     :vartype allowed_headers: str
-    :ivar exposed_headers: Required. The response headers that may be sent in the response to the
-     CORS request and exposed by the browser to the request issuer.
+    :ivar exposed_headers: The response headers that may be sent in the response to the CORS
+     request and exposed by the browser to the request issuer. Required.
     :vartype exposed_headers: str
-    :ivar max_age_in_seconds: Required. The maximum amount time that a browser should cache the
-     preflight OPTIONS request.
+    :ivar max_age_in_seconds: The maximum amount time that a browser should cache the preflight
+     OPTIONS request. Required.
     :vartype max_age_in_seconds: int
     """
 
     _validation = {
-        'allowed_origins': {'required': True},
-        'allowed_methods': {'required': True},
-        'allowed_headers': {'required': True},
-        'exposed_headers': {'required': True},
-        'max_age_in_seconds': {'required': True, 'minimum': 0},
+        "allowed_origins": {"required": True},
+        "allowed_methods": {"required": True},
+        "allowed_headers": {"required": True},
+        "exposed_headers": {"required": True},
+        "max_age_in_seconds": {"required": True, "minimum": 0},
     }
 
     _attribute_map = {
-        'allowed_origins': {'key': 'AllowedOrigins', 'type': 'str'},
-        'allowed_methods': {'key': 'AllowedMethods', 'type': 'str'},
-        'allowed_headers': {'key': 'AllowedHeaders', 'type': 'str'},
-        'exposed_headers': {'key': 'ExposedHeaders', 'type': 'str'},
-        'max_age_in_seconds': {'key': 'MaxAgeInSeconds', 'type': 'int'},
+        "allowed_origins": {"key": "AllowedOrigins", "type": "str"},
+        "allowed_methods": {"key": "AllowedMethods", "type": "str"},
+        "allowed_headers": {"key": "AllowedHeaders", "type": "str"},
+        "exposed_headers": {"key": "ExposedHeaders", "type": "str"},
+        "max_age_in_seconds": {"key": "MaxAgeInSeconds", "type": "int"},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        allowed_origins: str,
+        allowed_methods: str,
+        allowed_headers: str,
+        exposed_headers: str,
+        max_age_in_seconds: int,
+        **kwargs: Any
+    ) -> None:
         """
-        :keyword allowed_origins: Required. The origin domains that are permitted to make a request
-         against the storage service via CORS. The origin domain is the domain from which the request
-         originates. Note that the origin must be an exact case-sensitive match with the origin that the
-         user age sends to the service. You can also use the wildcard character '*' to allow all origin
-         domains to make requests via CORS.
+        :keyword allowed_origins: The origin domains that are permitted to make a request against the
+         storage service via CORS. The origin domain is the domain from which the request originates.
+         Note that the origin must be an exact case-sensitive match with the origin that the user age
+         sends to the service. You can also use the wildcard character '*' to allow all origin domains
+         to make requests via CORS. Required.
         :paramtype allowed_origins: str
-        :keyword allowed_methods: Required. The methods (HTTP request verbs) that the origin domain may
-         use for a CORS request. (comma separated).
+        :keyword allowed_methods: The methods (HTTP request verbs) that the origin domain may use for a
+         CORS request. (comma separated). Required.
         :paramtype allowed_methods: str
-        :keyword allowed_headers: Required. The request headers that the origin domain may specify on
-         the CORS request.
+        :keyword allowed_headers: The request headers that the origin domain may specify on the CORS
+         request. Required.
         :paramtype allowed_headers: str
-        :keyword exposed_headers: Required. The response headers that may be sent in the response to
-         the CORS request and exposed by the browser to the request issuer.
+        :keyword exposed_headers: The response headers that may be sent in the response to the CORS
+         request and exposed by the browser to the request issuer. Required.
         :paramtype exposed_headers: str
-        :keyword max_age_in_seconds: Required. The maximum amount time that a browser should cache the
-         preflight OPTIONS request.
+        :keyword max_age_in_seconds: The maximum amount time that a browser should cache the preflight
+         OPTIONS request. Required.
         :paramtype max_age_in_seconds: int
         """
-        super(CorsRule, self).__init__(**kwargs)
-        self.allowed_origins = kwargs['allowed_origins']
-        self.allowed_methods = kwargs['allowed_methods']
-        self.allowed_headers = kwargs['allowed_headers']
-        self.exposed_headers = kwargs['exposed_headers']
-        self.max_age_in_seconds = kwargs['max_age_in_seconds']
+        super().__init__(**kwargs)
+        self.allowed_origins = allowed_origins
+        self.allowed_methods = allowed_methods
+        self.allowed_headers = allowed_headers
+        self.exposed_headers = exposed_headers
+        self.max_age_in_seconds = max_age_in_seconds
 
 
-class DestinationLeaseAccessConditions(msrest.serialization.Model):
+class DestinationLeaseAccessConditions(_serialization.Model):
     """Parameter group.
 
     :ivar destination_lease_id: Required if the destination file has an active infinite lease. The
      lease ID specified for this header must match the lease ID of the destination file. If the
      request does not include the lease ID or it is not valid, the operation fails with status code
      412 (Precondition Failed). If this header is specified and the destination file does not
      currently have an active lease, the operation will also fail with status code 412 (Precondition
      Failed).
     :vartype destination_lease_id: str
     """
 
     _attribute_map = {
-        'destination_lease_id': {'key': 'destinationLeaseId', 'type': 'str'},
+        "destination_lease_id": {"key": "destinationLeaseId", "type": "str"},
     }
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, destination_lease_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword destination_lease_id: Required if the destination file has an active infinite lease.
          The lease ID specified for this header must match the lease ID of the destination file. If the
          request does not include the lease ID or it is not valid, the operation fails with status code
          412 (Precondition Failed). If this header is specified and the destination file does not
          currently have an active lease, the operation will also fail with status code 412 (Precondition
          Failed).
         :paramtype destination_lease_id: str
         """
-        super(DestinationLeaseAccessConditions, self).__init__(**kwargs)
-        self.destination_lease_id = kwargs.get('destination_lease_id', None)
+        super().__init__(**kwargs)
+        self.destination_lease_id = destination_lease_id
 
 
-class DirectoryItem(msrest.serialization.Model):
+class DirectoryItem(_serialization.Model):
     """A listed directory item.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar name: Required.
-    :vartype name: str
+    :vartype name: ~azure.storage.fileshare.models.StringEncoded
     :ivar file_id:
     :vartype file_id: str
     :ivar properties: File properties.
     :vartype properties: ~azure.storage.fileshare.models.FileProperty
     :ivar attributes:
     :vartype attributes: str
     :ivar permission_key:
     :vartype permission_key: str
     """
 
     _validation = {
-        'name': {'required': True},
+        "name": {"required": True},
     }
 
     _attribute_map = {
-        'name': {'key': 'Name', 'type': 'str'},
-        'file_id': {'key': 'FileId', 'type': 'str'},
-        'properties': {'key': 'Properties', 'type': 'FileProperty'},
-        'attributes': {'key': 'Attributes', 'type': 'str'},
-        'permission_key': {'key': 'PermissionKey', 'type': 'str'},
-    }
-    _xml_map = {
-        'name': 'Directory'
+        "name": {"key": "Name", "type": "StringEncoded"},
+        "file_id": {"key": "FileId", "type": "str"},
+        "properties": {"key": "Properties", "type": "FileProperty"},
+        "attributes": {"key": "Attributes", "type": "str"},
+        "permission_key": {"key": "PermissionKey", "type": "str"},
     }
+    _xml_map = {"name": "Directory"}
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        name: "_models.StringEncoded",
+        file_id: Optional[str] = None,
+        properties: Optional["_models.FileProperty"] = None,
+        attributes: Optional[str] = None,
+        permission_key: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: Required.
-        :paramtype name: str
+        :paramtype name: ~azure.storage.fileshare.models.StringEncoded
         :keyword file_id:
         :paramtype file_id: str
         :keyword properties: File properties.
         :paramtype properties: ~azure.storage.fileshare.models.FileProperty
         :keyword attributes:
         :paramtype attributes: str
         :keyword permission_key:
         :paramtype permission_key: str
         """
-        super(DirectoryItem, self).__init__(**kwargs)
-        self.name = kwargs['name']
-        self.file_id = kwargs.get('file_id', None)
-        self.properties = kwargs.get('properties', None)
-        self.attributes = kwargs.get('attributes', None)
-        self.permission_key = kwargs.get('permission_key', None)
+        super().__init__(**kwargs)
+        self.name = name
+        self.file_id = file_id
+        self.properties = properties
+        self.attributes = attributes
+        self.permission_key = permission_key
 
 
-class FileHTTPHeaders(msrest.serialization.Model):
+class FileHTTPHeaders(_serialization.Model):
     """Parameter group.
 
     :ivar file_content_type: Sets the MIME content type of the file. The default type is
      'application/octet-stream'.
     :vartype file_content_type: str
     :ivar file_content_encoding: Specifies which content encodings have been applied to the file.
     :vartype file_content_encoding: str
     :ivar file_content_language: Specifies the natural languages used by this resource.
     :vartype file_content_language: str
     :ivar file_cache_control: Sets the file's cache control. The File service stores this value but
      does not use or modify it.
     :vartype file_cache_control: str
     :ivar file_content_md5: Sets the file's MD5 hash.
-    :vartype file_content_md5: bytearray
+    :vartype file_content_md5: bytes
     :ivar file_content_disposition: Sets the file's Content-Disposition header.
     :vartype file_content_disposition: str
     """
 
     _attribute_map = {
-        'file_content_type': {'key': 'fileContentType', 'type': 'str'},
-        'file_content_encoding': {'key': 'fileContentEncoding', 'type': 'str'},
-        'file_content_language': {'key': 'fileContentLanguage', 'type': 'str'},
-        'file_cache_control': {'key': 'fileCacheControl', 'type': 'str'},
-        'file_content_md5': {'key': 'fileContentMD5', 'type': 'bytearray'},
-        'file_content_disposition': {'key': 'fileContentDisposition', 'type': 'str'},
+        "file_content_type": {"key": "fileContentType", "type": "str"},
+        "file_content_encoding": {"key": "fileContentEncoding", "type": "str"},
+        "file_content_language": {"key": "fileContentLanguage", "type": "str"},
+        "file_cache_control": {"key": "fileCacheControl", "type": "str"},
+        "file_content_md5": {"key": "fileContentMD5", "type": "bytearray"},
+        "file_content_disposition": {"key": "fileContentDisposition", "type": "str"},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        file_content_type: Optional[str] = None,
+        file_content_encoding: Optional[str] = None,
+        file_content_language: Optional[str] = None,
+        file_cache_control: Optional[str] = None,
+        file_content_md5: Optional[bytes] = None,
+        file_content_disposition: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword file_content_type: Sets the MIME content type of the file. The default type is
          'application/octet-stream'.
         :paramtype file_content_type: str
         :keyword file_content_encoding: Specifies which content encodings have been applied to the
          file.
         :paramtype file_content_encoding: str
         :keyword file_content_language: Specifies the natural languages used by this resource.
         :paramtype file_content_language: str
         :keyword file_cache_control: Sets the file's cache control. The File service stores this value
          but does not use or modify it.
         :paramtype file_cache_control: str
         :keyword file_content_md5: Sets the file's MD5 hash.
-        :paramtype file_content_md5: bytearray
+        :paramtype file_content_md5: bytes
         :keyword file_content_disposition: Sets the file's Content-Disposition header.
         :paramtype file_content_disposition: str
         """
-        super(FileHTTPHeaders, self).__init__(**kwargs)
-        self.file_content_type = kwargs.get('file_content_type', None)
-        self.file_content_encoding = kwargs.get('file_content_encoding', None)
-        self.file_content_language = kwargs.get('file_content_language', None)
-        self.file_cache_control = kwargs.get('file_cache_control', None)
-        self.file_content_md5 = kwargs.get('file_content_md5', None)
-        self.file_content_disposition = kwargs.get('file_content_disposition', None)
+        super().__init__(**kwargs)
+        self.file_content_type = file_content_type
+        self.file_content_encoding = file_content_encoding
+        self.file_content_language = file_content_language
+        self.file_cache_control = file_cache_control
+        self.file_content_md5 = file_content_md5
+        self.file_content_disposition = file_content_disposition
 
 
-class FileItem(msrest.serialization.Model):
+class FileItem(_serialization.Model):
     """A listed file item.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar name: Required.
-    :vartype name: str
+    :vartype name: ~azure.storage.fileshare.models.StringEncoded
     :ivar file_id:
     :vartype file_id: str
-    :ivar properties: Required. File properties.
+    :ivar properties: File properties. Required.
     :vartype properties: ~azure.storage.fileshare.models.FileProperty
     :ivar attributes:
     :vartype attributes: str
     :ivar permission_key:
     :vartype permission_key: str
     """
 
     _validation = {
-        'name': {'required': True},
-        'properties': {'required': True},
+        "name": {"required": True},
+        "properties": {"required": True},
     }
 
     _attribute_map = {
-        'name': {'key': 'Name', 'type': 'str'},
-        'file_id': {'key': 'FileId', 'type': 'str'},
-        'properties': {'key': 'Properties', 'type': 'FileProperty'},
-        'attributes': {'key': 'Attributes', 'type': 'str'},
-        'permission_key': {'key': 'PermissionKey', 'type': 'str'},
-    }
-    _xml_map = {
-        'name': 'File'
+        "name": {"key": "Name", "type": "StringEncoded"},
+        "file_id": {"key": "FileId", "type": "str"},
+        "properties": {"key": "Properties", "type": "FileProperty"},
+        "attributes": {"key": "Attributes", "type": "str"},
+        "permission_key": {"key": "PermissionKey", "type": "str"},
     }
+    _xml_map = {"name": "File"}
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        name: "_models.StringEncoded",
+        properties: "_models.FileProperty",
+        file_id: Optional[str] = None,
+        attributes: Optional[str] = None,
+        permission_key: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: Required.
-        :paramtype name: str
+        :paramtype name: ~azure.storage.fileshare.models.StringEncoded
         :keyword file_id:
         :paramtype file_id: str
-        :keyword properties: Required. File properties.
+        :keyword properties: File properties. Required.
         :paramtype properties: ~azure.storage.fileshare.models.FileProperty
         :keyword attributes:
         :paramtype attributes: str
         :keyword permission_key:
         :paramtype permission_key: str
         """
-        super(FileItem, self).__init__(**kwargs)
-        self.name = kwargs['name']
-        self.file_id = kwargs.get('file_id', None)
-        self.properties = kwargs['properties']
-        self.attributes = kwargs.get('attributes', None)
-        self.permission_key = kwargs.get('permission_key', None)
+        super().__init__(**kwargs)
+        self.name = name
+        self.file_id = file_id
+        self.properties = properties
+        self.attributes = attributes
+        self.permission_key = permission_key
 
 
-class FileProperty(msrest.serialization.Model):
+class FileProperty(_serialization.Model):
     """File properties.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar content_length: Required. Content length of the file. This value may not be up-to-date
-     since an SMB client may have modified the file locally. The value of Content-Length may not
-     reflect that fact until the handle is closed or the op-lock is broken. To retrieve current
-     property values, call Get File Properties.
-    :vartype content_length: long
+    :ivar content_length: Content length of the file. This value may not be up-to-date since an SMB
+     client may have modified the file locally. The value of Content-Length may not reflect that
+     fact until the handle is closed or the op-lock is broken. To retrieve current property values,
+     call Get File Properties. Required.
+    :vartype content_length: int
     :ivar creation_time:
     :vartype creation_time: ~datetime.datetime
     :ivar last_access_time:
     :vartype last_access_time: ~datetime.datetime
     :ivar last_write_time:
     :vartype last_write_time: ~datetime.datetime
     :ivar change_time:
@@ -469,374 +502,395 @@
     :ivar last_modified:
     :vartype last_modified: ~datetime.datetime
     :ivar etag:
     :vartype etag: str
     """
 
     _validation = {
-        'content_length': {'required': True},
+        "content_length": {"required": True},
     }
 
     _attribute_map = {
-        'content_length': {'key': 'Content-Length', 'type': 'long'},
-        'creation_time': {'key': 'CreationTime', 'type': 'iso-8601'},
-        'last_access_time': {'key': 'LastAccessTime', 'type': 'iso-8601'},
-        'last_write_time': {'key': 'LastWriteTime', 'type': 'iso-8601'},
-        'change_time': {'key': 'ChangeTime', 'type': 'iso-8601'},
-        'last_modified': {'key': 'Last-Modified', 'type': 'rfc-1123'},
-        'etag': {'key': 'Etag', 'type': 'str'},
+        "content_length": {"key": "Content-Length", "type": "int"},
+        "creation_time": {"key": "CreationTime", "type": "iso-8601"},
+        "last_access_time": {"key": "LastAccessTime", "type": "iso-8601"},
+        "last_write_time": {"key": "LastWriteTime", "type": "iso-8601"},
+        "change_time": {"key": "ChangeTime", "type": "iso-8601"},
+        "last_modified": {"key": "Last-Modified", "type": "rfc-1123"},
+        "etag": {"key": "Etag", "type": "str"},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        content_length: int,
+        creation_time: Optional[datetime.datetime] = None,
+        last_access_time: Optional[datetime.datetime] = None,
+        last_write_time: Optional[datetime.datetime] = None,
+        change_time: Optional[datetime.datetime] = None,
+        last_modified: Optional[datetime.datetime] = None,
+        etag: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
-        :keyword content_length: Required. Content length of the file. This value may not be up-to-date
-         since an SMB client may have modified the file locally. The value of Content-Length may not
-         reflect that fact until the handle is closed or the op-lock is broken. To retrieve current
-         property values, call Get File Properties.
-        :paramtype content_length: long
+        :keyword content_length: Content length of the file. This value may not be up-to-date since an
+         SMB client may have modified the file locally. The value of Content-Length may not reflect that
+         fact until the handle is closed or the op-lock is broken. To retrieve current property values,
+         call Get File Properties. Required.
+        :paramtype content_length: int
         :keyword creation_time:
         :paramtype creation_time: ~datetime.datetime
         :keyword last_access_time:
         :paramtype last_access_time: ~datetime.datetime
         :keyword last_write_time:
         :paramtype last_write_time: ~datetime.datetime
         :keyword change_time:
         :paramtype change_time: ~datetime.datetime
         :keyword last_modified:
         :paramtype last_modified: ~datetime.datetime
         :keyword etag:
         :paramtype etag: str
         """
-        super(FileProperty, self).__init__(**kwargs)
-        self.content_length = kwargs['content_length']
-        self.creation_time = kwargs.get('creation_time', None)
-        self.last_access_time = kwargs.get('last_access_time', None)
-        self.last_write_time = kwargs.get('last_write_time', None)
-        self.change_time = kwargs.get('change_time', None)
-        self.last_modified = kwargs.get('last_modified', None)
-        self.etag = kwargs.get('etag', None)
+        super().__init__(**kwargs)
+        self.content_length = content_length
+        self.creation_time = creation_time
+        self.last_access_time = last_access_time
+        self.last_write_time = last_write_time
+        self.change_time = change_time
+        self.last_modified = last_modified
+        self.etag = etag
 
 
-class FileRange(msrest.serialization.Model):
+class FileRange(_serialization.Model):
     """An Azure Storage file range.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar start: Required. Start of the range.
-    :vartype start: long
-    :ivar end: Required. End of the range.
-    :vartype end: long
+    :ivar start: Start of the range. Required.
+    :vartype start: int
+    :ivar end: End of the range. Required.
+    :vartype end: int
     """
 
     _validation = {
-        'start': {'required': True},
-        'end': {'required': True},
+        "start": {"required": True},
+        "end": {"required": True},
     }
 
     _attribute_map = {
-        'start': {'key': 'Start', 'type': 'long'},
-        'end': {'key': 'End', 'type': 'long'},
-    }
-    _xml_map = {
-        'name': 'Range'
+        "start": {"key": "Start", "type": "int"},
+        "end": {"key": "End", "type": "int"},
     }
+    _xml_map = {"name": "Range"}
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, start: int, end: int, **kwargs: Any) -> None:
         """
-        :keyword start: Required. Start of the range.
-        :paramtype start: long
-        :keyword end: Required. End of the range.
-        :paramtype end: long
+        :keyword start: Start of the range. Required.
+        :paramtype start: int
+        :keyword end: End of the range. Required.
+        :paramtype end: int
         """
-        super(FileRange, self).__init__(**kwargs)
-        self.start = kwargs['start']
-        self.end = kwargs['end']
+        super().__init__(**kwargs)
+        self.start = start
+        self.end = end
 
 
-class FilesAndDirectoriesListSegment(msrest.serialization.Model):
+class FilesAndDirectoriesListSegment(_serialization.Model):
     """Abstract for entries that can be listed from Directory.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar directory_items: Required.
     :vartype directory_items: list[~azure.storage.fileshare.models.DirectoryItem]
     :ivar file_items: Required.
     :vartype file_items: list[~azure.storage.fileshare.models.FileItem]
     """
 
     _validation = {
-        'directory_items': {'required': True},
-        'file_items': {'required': True},
+        "directory_items": {"required": True},
+        "file_items": {"required": True},
     }
 
     _attribute_map = {
-        'directory_items': {'key': 'DirectoryItems', 'type': '[DirectoryItem]'},
-        'file_items': {'key': 'FileItems', 'type': '[FileItem]'},
-    }
-    _xml_map = {
-        'name': 'Entries'
+        "directory_items": {"key": "DirectoryItems", "type": "[DirectoryItem]", "xml": {"itemsName": "Directory"}},
+        "file_items": {"key": "FileItems", "type": "[FileItem]", "xml": {"itemsName": "File"}},
     }
+    _xml_map = {"name": "Entries"}
 
     def __init__(
-        self,
-        **kwargs
-    ):
+        self, *, directory_items: List["_models.DirectoryItem"], file_items: List["_models.FileItem"], **kwargs: Any
+    ) -> None:
         """
         :keyword directory_items: Required.
         :paramtype directory_items: list[~azure.storage.fileshare.models.DirectoryItem]
         :keyword file_items: Required.
         :paramtype file_items: list[~azure.storage.fileshare.models.FileItem]
         """
-        super(FilesAndDirectoriesListSegment, self).__init__(**kwargs)
-        self.directory_items = kwargs['directory_items']
-        self.file_items = kwargs['file_items']
+        super().__init__(**kwargs)
+        self.directory_items = directory_items
+        self.file_items = file_items
 
 
-class HandleItem(msrest.serialization.Model):
+class HandleItem(_serialization.Model):
     """A listed Azure Storage handle item.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar handle_id: Required. XSMB service handle ID.
+    :ivar handle_id: XSMB service handle ID. Required.
     :vartype handle_id: str
-    :ivar path: Required. File or directory name including full path starting from share root.
-    :vartype path: str
-    :ivar file_id: Required. FileId uniquely identifies the file or directory.
+    :ivar path: Required.
+    :vartype path: ~azure.storage.fileshare.models.StringEncoded
+    :ivar file_id: FileId uniquely identifies the file or directory. Required.
     :vartype file_id: str
     :ivar parent_id: ParentId uniquely identifies the parent directory of the object.
     :vartype parent_id: str
-    :ivar session_id: Required. SMB session ID in context of which the file handle was opened.
+    :ivar session_id: SMB session ID in context of which the file handle was opened. Required.
     :vartype session_id: str
-    :ivar client_ip: Required. Client IP that opened the handle.
+    :ivar client_ip: Client IP that opened the handle. Required.
     :vartype client_ip: str
-    :ivar open_time: Required. Time when the session that previously opened the handle has last
-     been reconnected. (UTC).
+    :ivar open_time: Time when the session that previously opened the handle has last been
+     reconnected. (UTC). Required.
     :vartype open_time: ~datetime.datetime
     :ivar last_reconnect_time: Time handle was last connected to (UTC).
     :vartype last_reconnect_time: ~datetime.datetime
     """
 
     _validation = {
-        'handle_id': {'required': True},
-        'path': {'required': True},
-        'file_id': {'required': True},
-        'session_id': {'required': True},
-        'client_ip': {'required': True},
-        'open_time': {'required': True},
+        "handle_id": {"required": True},
+        "path": {"required": True},
+        "file_id": {"required": True},
+        "session_id": {"required": True},
+        "client_ip": {"required": True},
+        "open_time": {"required": True},
     }
 
     _attribute_map = {
-        'handle_id': {'key': 'HandleId', 'type': 'str'},
-        'path': {'key': 'Path', 'type': 'str'},
-        'file_id': {'key': 'FileId', 'type': 'str'},
-        'parent_id': {'key': 'ParentId', 'type': 'str'},
-        'session_id': {'key': 'SessionId', 'type': 'str'},
-        'client_ip': {'key': 'ClientIp', 'type': 'str'},
-        'open_time': {'key': 'OpenTime', 'type': 'rfc-1123'},
-        'last_reconnect_time': {'key': 'LastReconnectTime', 'type': 'rfc-1123'},
-    }
-    _xml_map = {
-        'name': 'Handle'
-    }
+        "handle_id": {"key": "HandleId", "type": "str"},
+        "path": {"key": "Path", "type": "StringEncoded"},
+        "file_id": {"key": "FileId", "type": "str"},
+        "parent_id": {"key": "ParentId", "type": "str"},
+        "session_id": {"key": "SessionId", "type": "str"},
+        "client_ip": {"key": "ClientIp", "type": "str"},
+        "open_time": {"key": "OpenTime", "type": "rfc-1123"},
+        "last_reconnect_time": {"key": "LastReconnectTime", "type": "rfc-1123"},
+    }
+    _xml_map = {"name": "Handle"}
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        handle_id: str,
+        path: "_models.StringEncoded",
+        file_id: str,
+        session_id: str,
+        client_ip: str,
+        open_time: datetime.datetime,
+        parent_id: Optional[str] = None,
+        last_reconnect_time: Optional[datetime.datetime] = None,
+        **kwargs: Any
+    ) -> None:
         """
-        :keyword handle_id: Required. XSMB service handle ID.
+        :keyword handle_id: XSMB service handle ID. Required.
         :paramtype handle_id: str
-        :keyword path: Required. File or directory name including full path starting from share root.
-        :paramtype path: str
-        :keyword file_id: Required. FileId uniquely identifies the file or directory.
+        :keyword path: Required.
+        :paramtype path: ~azure.storage.fileshare.models.StringEncoded
+        :keyword file_id: FileId uniquely identifies the file or directory. Required.
         :paramtype file_id: str
         :keyword parent_id: ParentId uniquely identifies the parent directory of the object.
         :paramtype parent_id: str
-        :keyword session_id: Required. SMB session ID in context of which the file handle was opened.
+        :keyword session_id: SMB session ID in context of which the file handle was opened. Required.
         :paramtype session_id: str
-        :keyword client_ip: Required. Client IP that opened the handle.
+        :keyword client_ip: Client IP that opened the handle. Required.
         :paramtype client_ip: str
-        :keyword open_time: Required. Time when the session that previously opened the handle has last
-         been reconnected. (UTC).
+        :keyword open_time: Time when the session that previously opened the handle has last been
+         reconnected. (UTC). Required.
         :paramtype open_time: ~datetime.datetime
         :keyword last_reconnect_time: Time handle was last connected to (UTC).
         :paramtype last_reconnect_time: ~datetime.datetime
         """
-        super(HandleItem, self).__init__(**kwargs)
-        self.handle_id = kwargs['handle_id']
-        self.path = kwargs['path']
-        self.file_id = kwargs['file_id']
-        self.parent_id = kwargs.get('parent_id', None)
-        self.session_id = kwargs['session_id']
-        self.client_ip = kwargs['client_ip']
-        self.open_time = kwargs['open_time']
-        self.last_reconnect_time = kwargs.get('last_reconnect_time', None)
+        super().__init__(**kwargs)
+        self.handle_id = handle_id
+        self.path = path
+        self.file_id = file_id
+        self.parent_id = parent_id
+        self.session_id = session_id
+        self.client_ip = client_ip
+        self.open_time = open_time
+        self.last_reconnect_time = last_reconnect_time
 
 
-class LeaseAccessConditions(msrest.serialization.Model):
+class LeaseAccessConditions(_serialization.Model):
     """Parameter group.
 
     :ivar lease_id: If specified, the operation only succeeds if the resource's lease is active and
      matches this ID.
     :vartype lease_id: str
     """
 
     _attribute_map = {
-        'lease_id': {'key': 'leaseId', 'type': 'str'},
+        "lease_id": {"key": "leaseId", "type": "str"},
     }
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, lease_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
          and matches this ID.
         :paramtype lease_id: str
         """
-        super(LeaseAccessConditions, self).__init__(**kwargs)
-        self.lease_id = kwargs.get('lease_id', None)
+        super().__init__(**kwargs)
+        self.lease_id = lease_id
 
 
-class ListFilesAndDirectoriesSegmentResponse(msrest.serialization.Model):
+class ListFilesAndDirectoriesSegmentResponse(_serialization.Model):  # pylint: disable=too-many-instance-attributes
     """An enumeration of directories and files.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar service_endpoint: Required.
     :vartype service_endpoint: str
     :ivar share_name: Required.
     :vartype share_name: str
     :ivar share_snapshot:
     :vartype share_snapshot: str
+    :ivar encoded:
+    :vartype encoded: bool
     :ivar directory_path: Required.
     :vartype directory_path: str
     :ivar prefix: Required.
-    :vartype prefix: str
+    :vartype prefix: ~azure.storage.fileshare.models.StringEncoded
     :ivar marker:
     :vartype marker: str
     :ivar max_results:
     :vartype max_results: int
-    :ivar segment: Required. Abstract for entries that can be listed from Directory.
+    :ivar segment: Abstract for entries that can be listed from Directory. Required.
     :vartype segment: ~azure.storage.fileshare.models.FilesAndDirectoriesListSegment
     :ivar next_marker: Required.
     :vartype next_marker: str
     :ivar directory_id:
     :vartype directory_id: str
     """
 
     _validation = {
-        'service_endpoint': {'required': True},
-        'share_name': {'required': True},
-        'directory_path': {'required': True},
-        'prefix': {'required': True},
-        'segment': {'required': True},
-        'next_marker': {'required': True},
+        "service_endpoint": {"required": True},
+        "share_name": {"required": True},
+        "directory_path": {"required": True},
+        "prefix": {"required": True},
+        "segment": {"required": True},
+        "next_marker": {"required": True},
     }
 
     _attribute_map = {
-        'service_endpoint': {'key': 'ServiceEndpoint', 'type': 'str', 'xml': {'attr': True}},
-        'share_name': {'key': 'ShareName', 'type': 'str', 'xml': {'attr': True}},
-        'share_snapshot': {'key': 'ShareSnapshot', 'type': 'str', 'xml': {'attr': True}},
-        'directory_path': {'key': 'DirectoryPath', 'type': 'str', 'xml': {'attr': True}},
-        'prefix': {'key': 'Prefix', 'type': 'str'},
-        'marker': {'key': 'Marker', 'type': 'str'},
-        'max_results': {'key': 'MaxResults', 'type': 'int'},
-        'segment': {'key': 'Segment', 'type': 'FilesAndDirectoriesListSegment'},
-        'next_marker': {'key': 'NextMarker', 'type': 'str'},
-        'directory_id': {'key': 'DirectoryId', 'type': 'str'},
-    }
-    _xml_map = {
-        'name': 'EnumerationResults'
-    }
+        "service_endpoint": {"key": "ServiceEndpoint", "type": "str", "xml": {"attr": True}},
+        "share_name": {"key": "ShareName", "type": "str", "xml": {"attr": True}},
+        "share_snapshot": {"key": "ShareSnapshot", "type": "str", "xml": {"attr": True}},
+        "encoded": {"key": "Encoded", "type": "bool", "xml": {"attr": True}},
+        "directory_path": {"key": "DirectoryPath", "type": "str", "xml": {"attr": True}},
+        "prefix": {"key": "Prefix", "type": "StringEncoded"},
+        "marker": {"key": "Marker", "type": "str"},
+        "max_results": {"key": "MaxResults", "type": "int"},
+        "segment": {"key": "Segment", "type": "FilesAndDirectoriesListSegment"},
+        "next_marker": {"key": "NextMarker", "type": "str"},
+        "directory_id": {"key": "DirectoryId", "type": "str"},
+    }
+    _xml_map = {"name": "EnumerationResults"}
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        service_endpoint: str,
+        share_name: str,
+        directory_path: str,
+        prefix: "_models.StringEncoded",
+        segment: "_models.FilesAndDirectoriesListSegment",
+        next_marker: str,
+        share_snapshot: Optional[str] = None,
+        encoded: Optional[bool] = None,
+        marker: Optional[str] = None,
+        max_results: Optional[int] = None,
+        directory_id: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword service_endpoint: Required.
         :paramtype service_endpoint: str
         :keyword share_name: Required.
         :paramtype share_name: str
         :keyword share_snapshot:
         :paramtype share_snapshot: str
+        :keyword encoded:
+        :paramtype encoded: bool
         :keyword directory_path: Required.
         :paramtype directory_path: str
         :keyword prefix: Required.
-        :paramtype prefix: str
+        :paramtype prefix: ~azure.storage.fileshare.models.StringEncoded
         :keyword marker:
         :paramtype marker: str
         :keyword max_results:
         :paramtype max_results: int
-        :keyword segment: Required. Abstract for entries that can be listed from Directory.
+        :keyword segment: Abstract for entries that can be listed from Directory. Required.
         :paramtype segment: ~azure.storage.fileshare.models.FilesAndDirectoriesListSegment
         :keyword next_marker: Required.
         :paramtype next_marker: str
         :keyword directory_id:
         :paramtype directory_id: str
         """
-        super(ListFilesAndDirectoriesSegmentResponse, self).__init__(**kwargs)
-        self.service_endpoint = kwargs['service_endpoint']
-        self.share_name = kwargs['share_name']
-        self.share_snapshot = kwargs.get('share_snapshot', None)
-        self.directory_path = kwargs['directory_path']
-        self.prefix = kwargs['prefix']
-        self.marker = kwargs.get('marker', None)
-        self.max_results = kwargs.get('max_results', None)
-        self.segment = kwargs['segment']
-        self.next_marker = kwargs['next_marker']
-        self.directory_id = kwargs.get('directory_id', None)
+        super().__init__(**kwargs)
+        self.service_endpoint = service_endpoint
+        self.share_name = share_name
+        self.share_snapshot = share_snapshot
+        self.encoded = encoded
+        self.directory_path = directory_path
+        self.prefix = prefix
+        self.marker = marker
+        self.max_results = max_results
+        self.segment = segment
+        self.next_marker = next_marker
+        self.directory_id = directory_id
 
 
-class ListHandlesResponse(msrest.serialization.Model):
+class ListHandlesResponse(_serialization.Model):
     """An enumeration of handles.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar handle_list:
     :vartype handle_list: list[~azure.storage.fileshare.models.HandleItem]
     :ivar next_marker: Required.
     :vartype next_marker: str
     """
 
     _validation = {
-        'next_marker': {'required': True},
+        "next_marker": {"required": True},
     }
 
     _attribute_map = {
-        'handle_list': {'key': 'HandleList', 'type': '[HandleItem]', 'xml': {'name': 'Entries', 'wrapped': True, 'itemsName': 'Handle'}},
-        'next_marker': {'key': 'NextMarker', 'type': 'str'},
-    }
-    _xml_map = {
-        'name': 'EnumerationResults'
+        "handle_list": {
+            "key": "HandleList",
+            "type": "[HandleItem]",
+            "xml": {"name": "Entries", "wrapped": True, "itemsName": "Handle"},
+        },
+        "next_marker": {"key": "NextMarker", "type": "str"},
     }
+    _xml_map = {"name": "EnumerationResults"}
 
     def __init__(
-        self,
-        **kwargs
-    ):
+        self, *, next_marker: str, handle_list: Optional[List["_models.HandleItem"]] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword handle_list:
         :paramtype handle_list: list[~azure.storage.fileshare.models.HandleItem]
         :keyword next_marker: Required.
         :paramtype next_marker: str
         """
-        super(ListHandlesResponse, self).__init__(**kwargs)
-        self.handle_list = kwargs.get('handle_list', None)
-        self.next_marker = kwargs['next_marker']
+        super().__init__(**kwargs)
+        self.handle_list = handle_list
+        self.next_marker = next_marker
 
 
-class ListSharesResponse(msrest.serialization.Model):
+class ListSharesResponse(_serialization.Model):
     """An enumeration of shares.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar service_endpoint: Required.
     :vartype service_endpoint: str
     :ivar prefix:
@@ -848,273 +902,289 @@
     :ivar share_items:
     :vartype share_items: list[~azure.storage.fileshare.models.ShareItemInternal]
     :ivar next_marker: Required.
     :vartype next_marker: str
     """
 
     _validation = {
-        'service_endpoint': {'required': True},
-        'next_marker': {'required': True},
+        "service_endpoint": {"required": True},
+        "next_marker": {"required": True},
     }
 
     _attribute_map = {
-        'service_endpoint': {'key': 'ServiceEndpoint', 'type': 'str', 'xml': {'attr': True}},
-        'prefix': {'key': 'Prefix', 'type': 'str'},
-        'marker': {'key': 'Marker', 'type': 'str'},
-        'max_results': {'key': 'MaxResults', 'type': 'int'},
-        'share_items': {'key': 'ShareItems', 'type': '[ShareItemInternal]', 'xml': {'name': 'Shares', 'wrapped': True, 'itemsName': 'Share'}},
-        'next_marker': {'key': 'NextMarker', 'type': 'str'},
-    }
-    _xml_map = {
-        'name': 'EnumerationResults'
-    }
+        "service_endpoint": {"key": "ServiceEndpoint", "type": "str", "xml": {"attr": True}},
+        "prefix": {"key": "Prefix", "type": "str"},
+        "marker": {"key": "Marker", "type": "str"},
+        "max_results": {"key": "MaxResults", "type": "int"},
+        "share_items": {
+            "key": "ShareItems",
+            "type": "[ShareItemInternal]",
+            "xml": {"name": "Shares", "wrapped": True, "itemsName": "Share"},
+        },
+        "next_marker": {"key": "NextMarker", "type": "str"},
+    }
+    _xml_map = {"name": "EnumerationResults"}
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        service_endpoint: str,
+        next_marker: str,
+        prefix: Optional[str] = None,
+        marker: Optional[str] = None,
+        max_results: Optional[int] = None,
+        share_items: Optional[List["_models.ShareItemInternal"]] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword service_endpoint: Required.
         :paramtype service_endpoint: str
         :keyword prefix:
         :paramtype prefix: str
         :keyword marker:
         :paramtype marker: str
         :keyword max_results:
         :paramtype max_results: int
         :keyword share_items:
         :paramtype share_items: list[~azure.storage.fileshare.models.ShareItemInternal]
         :keyword next_marker: Required.
         :paramtype next_marker: str
         """
-        super(ListSharesResponse, self).__init__(**kwargs)
-        self.service_endpoint = kwargs['service_endpoint']
-        self.prefix = kwargs.get('prefix', None)
-        self.marker = kwargs.get('marker', None)
-        self.max_results = kwargs.get('max_results', None)
-        self.share_items = kwargs.get('share_items', None)
-        self.next_marker = kwargs['next_marker']
+        super().__init__(**kwargs)
+        self.service_endpoint = service_endpoint
+        self.prefix = prefix
+        self.marker = marker
+        self.max_results = max_results
+        self.share_items = share_items
+        self.next_marker = next_marker
 
 
-class Metrics(msrest.serialization.Model):
+class Metrics(_serialization.Model):
     """Storage Analytics metrics for file service.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar version: Required. The version of Storage Analytics to configure.
+    :ivar version: The version of Storage Analytics to configure. Required.
     :vartype version: str
-    :ivar enabled: Required. Indicates whether metrics are enabled for the File service.
+    :ivar enabled: Indicates whether metrics are enabled for the File service. Required.
     :vartype enabled: bool
     :ivar include_apis: Indicates whether metrics should generate summary statistics for called API
      operations.
     :vartype include_apis: bool
     :ivar retention_policy: The retention policy.
     :vartype retention_policy: ~azure.storage.fileshare.models.RetentionPolicy
     """
 
     _validation = {
-        'version': {'required': True},
-        'enabled': {'required': True},
+        "version": {"required": True},
+        "enabled": {"required": True},
     }
 
     _attribute_map = {
-        'version': {'key': 'Version', 'type': 'str'},
-        'enabled': {'key': 'Enabled', 'type': 'bool'},
-        'include_apis': {'key': 'IncludeAPIs', 'type': 'bool'},
-        'retention_policy': {'key': 'RetentionPolicy', 'type': 'RetentionPolicy'},
+        "version": {"key": "Version", "type": "str"},
+        "enabled": {"key": "Enabled", "type": "bool"},
+        "include_apis": {"key": "IncludeAPIs", "type": "bool"},
+        "retention_policy": {"key": "RetentionPolicy", "type": "RetentionPolicy"},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        version: str,
+        enabled: bool,
+        include_apis: Optional[bool] = None,
+        retention_policy: Optional["_models.RetentionPolicy"] = None,
+        **kwargs: Any
+    ) -> None:
         """
-        :keyword version: Required. The version of Storage Analytics to configure.
+        :keyword version: The version of Storage Analytics to configure. Required.
         :paramtype version: str
-        :keyword enabled: Required. Indicates whether metrics are enabled for the File service.
+        :keyword enabled: Indicates whether metrics are enabled for the File service. Required.
         :paramtype enabled: bool
         :keyword include_apis: Indicates whether metrics should generate summary statistics for called
          API operations.
         :paramtype include_apis: bool
         :keyword retention_policy: The retention policy.
         :paramtype retention_policy: ~azure.storage.fileshare.models.RetentionPolicy
         """
-        super(Metrics, self).__init__(**kwargs)
-        self.version = kwargs['version']
-        self.enabled = kwargs['enabled']
-        self.include_apis = kwargs.get('include_apis', None)
-        self.retention_policy = kwargs.get('retention_policy', None)
+        super().__init__(**kwargs)
+        self.version = version
+        self.enabled = enabled
+        self.include_apis = include_apis
+        self.retention_policy = retention_policy
 
 
-class RetentionPolicy(msrest.serialization.Model):
+class RetentionPolicy(_serialization.Model):
     """The retention policy.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar enabled: Required. Indicates whether a retention policy is enabled for the File service.
-     If false, metrics data is retained, and the user is responsible for deleting it.
+    :ivar enabled: Indicates whether a retention policy is enabled for the File service. If false,
+     metrics data is retained, and the user is responsible for deleting it. Required.
     :vartype enabled: bool
     :ivar days: Indicates the number of days that metrics data should be retained. All data older
      than this value will be deleted. Metrics data is deleted on a best-effort basis after the
      retention period expires.
     :vartype days: int
     """
 
     _validation = {
-        'enabled': {'required': True},
-        'days': {'maximum': 365, 'minimum': 1},
+        "enabled": {"required": True},
+        "days": {"maximum": 365, "minimum": 1},
     }
 
     _attribute_map = {
-        'enabled': {'key': 'Enabled', 'type': 'bool'},
-        'days': {'key': 'Days', 'type': 'int'},
+        "enabled": {"key": "Enabled", "type": "bool"},
+        "days": {"key": "Days", "type": "int"},
     }
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, enabled: bool, days: Optional[int] = None, **kwargs: Any) -> None:
         """
-        :keyword enabled: Required. Indicates whether a retention policy is enabled for the File
-         service. If false, metrics data is retained, and the user is responsible for deleting it.
+        :keyword enabled: Indicates whether a retention policy is enabled for the File service. If
+         false, metrics data is retained, and the user is responsible for deleting it. Required.
         :paramtype enabled: bool
         :keyword days: Indicates the number of days that metrics data should be retained. All data
          older than this value will be deleted. Metrics data is deleted on a best-effort basis after the
          retention period expires.
         :paramtype days: int
         """
-        super(RetentionPolicy, self).__init__(**kwargs)
-        self.enabled = kwargs['enabled']
-        self.days = kwargs.get('days', None)
+        super().__init__(**kwargs)
+        self.enabled = enabled
+        self.days = days
 
 
-class ShareFileRangeList(msrest.serialization.Model):
+class ShareFileRangeList(_serialization.Model):
     """The list of file ranges.
 
     :ivar ranges:
     :vartype ranges: list[~azure.storage.fileshare.models.FileRange]
     :ivar clear_ranges:
     :vartype clear_ranges: list[~azure.storage.fileshare.models.ClearRange]
     """
 
     _attribute_map = {
-        'ranges': {'key': 'Ranges', 'type': '[FileRange]'},
-        'clear_ranges': {'key': 'ClearRanges', 'type': '[ClearRange]'},
+        "ranges": {"key": "Ranges", "type": "[FileRange]", "xml": {"itemsName": "Range"}},
+        "clear_ranges": {"key": "ClearRanges", "type": "[ClearRange]", "xml": {"itemsName": "ClearRange"}},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        ranges: Optional[List["_models.FileRange"]] = None,
+        clear_ranges: Optional[List["_models.ClearRange"]] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword ranges:
         :paramtype ranges: list[~azure.storage.fileshare.models.FileRange]
         :keyword clear_ranges:
         :paramtype clear_ranges: list[~azure.storage.fileshare.models.ClearRange]
         """
-        super(ShareFileRangeList, self).__init__(**kwargs)
-        self.ranges = kwargs.get('ranges', None)
-        self.clear_ranges = kwargs.get('clear_ranges', None)
+        super().__init__(**kwargs)
+        self.ranges = ranges
+        self.clear_ranges = clear_ranges
 
 
-class ShareItemInternal(msrest.serialization.Model):
+class ShareItemInternal(_serialization.Model):
     """A listed Azure Storage share item.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar name: Required.
     :vartype name: str
     :ivar snapshot:
     :vartype snapshot: str
     :ivar deleted:
     :vartype deleted: bool
     :ivar version:
     :vartype version: str
-    :ivar properties: Required. Properties of a share.
+    :ivar properties: Properties of a share. Required.
     :vartype properties: ~azure.storage.fileshare.models.SharePropertiesInternal
     :ivar metadata: Dictionary of :code:`<string>`.
     :vartype metadata: dict[str, str]
     """
 
     _validation = {
-        'name': {'required': True},
-        'properties': {'required': True},
+        "name": {"required": True},
+        "properties": {"required": True},
     }
 
     _attribute_map = {
-        'name': {'key': 'Name', 'type': 'str'},
-        'snapshot': {'key': 'Snapshot', 'type': 'str'},
-        'deleted': {'key': 'Deleted', 'type': 'bool'},
-        'version': {'key': 'Version', 'type': 'str'},
-        'properties': {'key': 'Properties', 'type': 'SharePropertiesInternal'},
-        'metadata': {'key': 'Metadata', 'type': '{str}'},
-    }
-    _xml_map = {
-        'name': 'Share'
+        "name": {"key": "Name", "type": "str"},
+        "snapshot": {"key": "Snapshot", "type": "str"},
+        "deleted": {"key": "Deleted", "type": "bool"},
+        "version": {"key": "Version", "type": "str"},
+        "properties": {"key": "Properties", "type": "SharePropertiesInternal"},
+        "metadata": {"key": "Metadata", "type": "{str}"},
     }
+    _xml_map = {"name": "Share"}
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        name: str,
+        properties: "_models.SharePropertiesInternal",
+        snapshot: Optional[str] = None,
+        deleted: Optional[bool] = None,
+        version: Optional[str] = None,
+        metadata: Optional[Dict[str, str]] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: Required.
         :paramtype name: str
         :keyword snapshot:
         :paramtype snapshot: str
         :keyword deleted:
         :paramtype deleted: bool
         :keyword version:
         :paramtype version: str
-        :keyword properties: Required. Properties of a share.
+        :keyword properties: Properties of a share. Required.
         :paramtype properties: ~azure.storage.fileshare.models.SharePropertiesInternal
         :keyword metadata: Dictionary of :code:`<string>`.
         :paramtype metadata: dict[str, str]
         """
-        super(ShareItemInternal, self).__init__(**kwargs)
-        self.name = kwargs['name']
-        self.snapshot = kwargs.get('snapshot', None)
-        self.deleted = kwargs.get('deleted', None)
-        self.version = kwargs.get('version', None)
-        self.properties = kwargs['properties']
-        self.metadata = kwargs.get('metadata', None)
+        super().__init__(**kwargs)
+        self.name = name
+        self.snapshot = snapshot
+        self.deleted = deleted
+        self.version = version
+        self.properties = properties
+        self.metadata = metadata
 
 
-class SharePermission(msrest.serialization.Model):
+class SharePermission(_serialization.Model):
     """A permission (a security descriptor) at the share level.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar permission: Required. The permission in the Security Descriptor Definition Language
-     (SDDL).
+    :ivar permission: The permission in the Security Descriptor Definition Language (SDDL).
+     Required.
     :vartype permission: str
     """
 
     _validation = {
-        'permission': {'required': True},
+        "permission": {"required": True},
     }
 
     _attribute_map = {
-        'permission': {'key': 'permission', 'type': 'str'},
+        "permission": {"key": "permission", "type": "str"},
     }
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, permission: str, **kwargs: Any) -> None:
         """
-        :keyword permission: Required. The permission in the Security Descriptor Definition Language
-         (SDDL).
+        :keyword permission: The permission in the Security Descriptor Definition Language (SDDL).
+         Required.
         :paramtype permission: str
         """
-        super(SharePermission, self).__init__(**kwargs)
-        self.permission = kwargs['permission']
+        super().__init__(**kwargs)
+        self.permission = permission
 
 
-class SharePropertiesInternal(msrest.serialization.Model):
+class SharePropertiesInternal(_serialization.Model):  # pylint: disable=too-many-instance-attributes
     """Properties of a share.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar last_modified: Required.
     :vartype last_modified: ~datetime.datetime
     :ivar etag: Required.
@@ -1137,60 +1207,79 @@
     :vartype remaining_retention_days: int
     :ivar access_tier:
     :vartype access_tier: str
     :ivar access_tier_change_time:
     :vartype access_tier_change_time: ~datetime.datetime
     :ivar access_tier_transition_state:
     :vartype access_tier_transition_state: str
-    :ivar lease_status: The current lease status of the share. Possible values include: "locked",
+    :ivar lease_status: The current lease status of the share. Known values are: "locked" and
      "unlocked".
     :vartype lease_status: str or ~azure.storage.fileshare.models.LeaseStatusType
-    :ivar lease_state: Lease state of the share. Possible values include: "available", "leased",
-     "expired", "breaking", "broken".
+    :ivar lease_state: Lease state of the share. Known values are: "available", "leased",
+     "expired", "breaking", and "broken".
     :vartype lease_state: str or ~azure.storage.fileshare.models.LeaseStateType
     :ivar lease_duration: When a share is leased, specifies whether the lease is of infinite or
-     fixed duration. Possible values include: "infinite", "fixed".
+     fixed duration. Known values are: "infinite" and "fixed".
     :vartype lease_duration: str or ~azure.storage.fileshare.models.LeaseDurationType
     :ivar enabled_protocols:
     :vartype enabled_protocols: str
-    :ivar root_squash: Possible values include: "NoRootSquash", "RootSquash", "AllSquash".
+    :ivar root_squash: Known values are: "NoRootSquash", "RootSquash", and "AllSquash".
     :vartype root_squash: str or ~azure.storage.fileshare.models.ShareRootSquash
     """
 
     _validation = {
-        'last_modified': {'required': True},
-        'etag': {'required': True},
-        'quota': {'required': True},
+        "last_modified": {"required": True},
+        "etag": {"required": True},
+        "quota": {"required": True},
     }
 
     _attribute_map = {
-        'last_modified': {'key': 'Last-Modified', 'type': 'rfc-1123'},
-        'etag': {'key': 'Etag', 'type': 'str'},
-        'quota': {'key': 'Quota', 'type': 'int'},
-        'provisioned_iops': {'key': 'ProvisionedIops', 'type': 'int'},
-        'provisioned_ingress_m_bps': {'key': 'ProvisionedIngressMBps', 'type': 'int'},
-        'provisioned_egress_m_bps': {'key': 'ProvisionedEgressMBps', 'type': 'int'},
-        'provisioned_bandwidth_mi_bps': {'key': 'ProvisionedBandwidthMiBps', 'type': 'int'},
-        'next_allowed_quota_downgrade_time': {'key': 'NextAllowedQuotaDowngradeTime', 'type': 'rfc-1123'},
-        'deleted_time': {'key': 'DeletedTime', 'type': 'rfc-1123'},
-        'remaining_retention_days': {'key': 'RemainingRetentionDays', 'type': 'int'},
-        'access_tier': {'key': 'AccessTier', 'type': 'str'},
-        'access_tier_change_time': {'key': 'AccessTierChangeTime', 'type': 'rfc-1123'},
-        'access_tier_transition_state': {'key': 'AccessTierTransitionState', 'type': 'str'},
-        'lease_status': {'key': 'LeaseStatus', 'type': 'str'},
-        'lease_state': {'key': 'LeaseState', 'type': 'str'},
-        'lease_duration': {'key': 'LeaseDuration', 'type': 'str'},
-        'enabled_protocols': {'key': 'EnabledProtocols', 'type': 'str'},
-        'root_squash': {'key': 'RootSquash', 'type': 'str'},
+        "last_modified": {"key": "Last-Modified", "type": "rfc-1123"},
+        "etag": {"key": "Etag", "type": "str"},
+        "quota": {"key": "Quota", "type": "int"},
+        "provisioned_iops": {"key": "ProvisionedIops", "type": "int"},
+        "provisioned_ingress_m_bps": {"key": "ProvisionedIngressMBps", "type": "int"},
+        "provisioned_egress_m_bps": {"key": "ProvisionedEgressMBps", "type": "int"},
+        "provisioned_bandwidth_mi_bps": {"key": "ProvisionedBandwidthMiBps", "type": "int"},
+        "next_allowed_quota_downgrade_time": {"key": "NextAllowedQuotaDowngradeTime", "type": "rfc-1123"},
+        "deleted_time": {"key": "DeletedTime", "type": "rfc-1123"},
+        "remaining_retention_days": {"key": "RemainingRetentionDays", "type": "int"},
+        "access_tier": {"key": "AccessTier", "type": "str"},
+        "access_tier_change_time": {"key": "AccessTierChangeTime", "type": "rfc-1123"},
+        "access_tier_transition_state": {"key": "AccessTierTransitionState", "type": "str"},
+        "lease_status": {"key": "LeaseStatus", "type": "str"},
+        "lease_state": {"key": "LeaseState", "type": "str"},
+        "lease_duration": {"key": "LeaseDuration", "type": "str"},
+        "enabled_protocols": {"key": "EnabledProtocols", "type": "str"},
+        "root_squash": {"key": "RootSquash", "type": "str"},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        last_modified: datetime.datetime,
+        etag: str,
+        quota: int,
+        provisioned_iops: Optional[int] = None,
+        provisioned_ingress_m_bps: Optional[int] = None,
+        provisioned_egress_m_bps: Optional[int] = None,
+        provisioned_bandwidth_mi_bps: Optional[int] = None,
+        next_allowed_quota_downgrade_time: Optional[datetime.datetime] = None,
+        deleted_time: Optional[datetime.datetime] = None,
+        remaining_retention_days: Optional[int] = None,
+        access_tier: Optional[str] = None,
+        access_tier_change_time: Optional[datetime.datetime] = None,
+        access_tier_transition_state: Optional[str] = None,
+        lease_status: Optional[Union[str, "_models.LeaseStatusType"]] = None,
+        lease_state: Optional[Union[str, "_models.LeaseStateType"]] = None,
+        lease_duration: Optional[Union[str, "_models.LeaseDurationType"]] = None,
+        enabled_protocols: Optional[str] = None,
+        root_squash: Optional[Union[str, "_models.ShareRootSquash"]] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword last_modified: Required.
         :paramtype last_modified: ~datetime.datetime
         :keyword etag: Required.
         :paramtype etag: str
         :keyword quota: Required.
         :paramtype quota: int
@@ -1210,273 +1299,255 @@
         :paramtype remaining_retention_days: int
         :keyword access_tier:
         :paramtype access_tier: str
         :keyword access_tier_change_time:
         :paramtype access_tier_change_time: ~datetime.datetime
         :keyword access_tier_transition_state:
         :paramtype access_tier_transition_state: str
-        :keyword lease_status: The current lease status of the share. Possible values include:
-         "locked", "unlocked".
+        :keyword lease_status: The current lease status of the share. Known values are: "locked" and
+         "unlocked".
         :paramtype lease_status: str or ~azure.storage.fileshare.models.LeaseStatusType
-        :keyword lease_state: Lease state of the share. Possible values include: "available", "leased",
-         "expired", "breaking", "broken".
+        :keyword lease_state: Lease state of the share. Known values are: "available", "leased",
+         "expired", "breaking", and "broken".
         :paramtype lease_state: str or ~azure.storage.fileshare.models.LeaseStateType
         :keyword lease_duration: When a share is leased, specifies whether the lease is of infinite or
-         fixed duration. Possible values include: "infinite", "fixed".
+         fixed duration. Known values are: "infinite" and "fixed".
         :paramtype lease_duration: str or ~azure.storage.fileshare.models.LeaseDurationType
         :keyword enabled_protocols:
         :paramtype enabled_protocols: str
-        :keyword root_squash: Possible values include: "NoRootSquash", "RootSquash", "AllSquash".
+        :keyword root_squash: Known values are: "NoRootSquash", "RootSquash", and "AllSquash".
         :paramtype root_squash: str or ~azure.storage.fileshare.models.ShareRootSquash
         """
-        super(SharePropertiesInternal, self).__init__(**kwargs)
-        self.last_modified = kwargs['last_modified']
-        self.etag = kwargs['etag']
-        self.quota = kwargs['quota']
-        self.provisioned_iops = kwargs.get('provisioned_iops', None)
-        self.provisioned_ingress_m_bps = kwargs.get('provisioned_ingress_m_bps', None)
-        self.provisioned_egress_m_bps = kwargs.get('provisioned_egress_m_bps', None)
-        self.provisioned_bandwidth_mi_bps = kwargs.get('provisioned_bandwidth_mi_bps', None)
-        self.next_allowed_quota_downgrade_time = kwargs.get('next_allowed_quota_downgrade_time', None)
-        self.deleted_time = kwargs.get('deleted_time', None)
-        self.remaining_retention_days = kwargs.get('remaining_retention_days', None)
-        self.access_tier = kwargs.get('access_tier', None)
-        self.access_tier_change_time = kwargs.get('access_tier_change_time', None)
-        self.access_tier_transition_state = kwargs.get('access_tier_transition_state', None)
-        self.lease_status = kwargs.get('lease_status', None)
-        self.lease_state = kwargs.get('lease_state', None)
-        self.lease_duration = kwargs.get('lease_duration', None)
-        self.enabled_protocols = kwargs.get('enabled_protocols', None)
-        self.root_squash = kwargs.get('root_squash', None)
+        super().__init__(**kwargs)
+        self.last_modified = last_modified
+        self.etag = etag
+        self.quota = quota
+        self.provisioned_iops = provisioned_iops
+        self.provisioned_ingress_m_bps = provisioned_ingress_m_bps
+        self.provisioned_egress_m_bps = provisioned_egress_m_bps
+        self.provisioned_bandwidth_mi_bps = provisioned_bandwidth_mi_bps
+        self.next_allowed_quota_downgrade_time = next_allowed_quota_downgrade_time
+        self.deleted_time = deleted_time
+        self.remaining_retention_days = remaining_retention_days
+        self.access_tier = access_tier
+        self.access_tier_change_time = access_tier_change_time
+        self.access_tier_transition_state = access_tier_transition_state
+        self.lease_status = lease_status
+        self.lease_state = lease_state
+        self.lease_duration = lease_duration
+        self.enabled_protocols = enabled_protocols
+        self.root_squash = root_squash
 
 
-class ShareProtocolSettings(msrest.serialization.Model):
+class ShareProtocolSettings(_serialization.Model):
     """Protocol settings.
 
     :ivar smb: Settings for SMB protocol.
     :vartype smb: ~azure.storage.fileshare.models.ShareSmbSettings
     """
 
     _attribute_map = {
-        'smb': {'key': 'Smb', 'type': 'ShareSmbSettings'},
-    }
-    _xml_map = {
-        'name': 'ProtocolSettings'
+        "smb": {"key": "Smb", "type": "ShareSmbSettings"},
     }
+    _xml_map = {"name": "ProtocolSettings"}
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, smb: Optional["_models.ShareSmbSettings"] = None, **kwargs: Any) -> None:
         """
         :keyword smb: Settings for SMB protocol.
         :paramtype smb: ~azure.storage.fileshare.models.ShareSmbSettings
         """
-        super(ShareProtocolSettings, self).__init__(**kwargs)
-        self.smb = kwargs.get('smb', None)
+        super().__init__(**kwargs)
+        self.smb = smb
 
 
-class ShareSmbSettings(msrest.serialization.Model):
+class ShareSmbSettings(_serialization.Model):
     """Settings for SMB protocol.
 
     :ivar multichannel: Settings for SMB Multichannel.
     :vartype multichannel: ~azure.storage.fileshare.models.SmbMultichannel
     """
 
     _attribute_map = {
-        'multichannel': {'key': 'Multichannel', 'type': 'SmbMultichannel'},
-    }
-    _xml_map = {
-        'name': 'SMB'
+        "multichannel": {"key": "Multichannel", "type": "SmbMultichannel"},
     }
+    _xml_map = {"name": "SMB"}
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, multichannel: Optional["_models.SmbMultichannel"] = None, **kwargs: Any) -> None:
         """
         :keyword multichannel: Settings for SMB Multichannel.
         :paramtype multichannel: ~azure.storage.fileshare.models.SmbMultichannel
         """
-        super(ShareSmbSettings, self).__init__(**kwargs)
-        self.multichannel = kwargs.get('multichannel', None)
+        super().__init__(**kwargs)
+        self.multichannel = multichannel
 
 
-class ShareStats(msrest.serialization.Model):
+class ShareStats(_serialization.Model):
     """Stats for the share.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar share_usage_bytes: Required. The approximate size of the data stored in bytes. Note that
-     this value may not include all recently created or recently resized files.
+    :ivar share_usage_bytes: The approximate size of the data stored in bytes. Note that this value
+     may not include all recently created or recently resized files. Required.
     :vartype share_usage_bytes: int
     """
 
     _validation = {
-        'share_usage_bytes': {'required': True},
+        "share_usage_bytes": {"required": True},
     }
 
     _attribute_map = {
-        'share_usage_bytes': {'key': 'ShareUsageBytes', 'type': 'int'},
+        "share_usage_bytes": {"key": "ShareUsageBytes", "type": "int"},
     }
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, share_usage_bytes: int, **kwargs: Any) -> None:
         """
-        :keyword share_usage_bytes: Required. The approximate size of the data stored in bytes. Note
-         that this value may not include all recently created or recently resized files.
+        :keyword share_usage_bytes: The approximate size of the data stored in bytes. Note that this
+         value may not include all recently created or recently resized files. Required.
         :paramtype share_usage_bytes: int
         """
-        super(ShareStats, self).__init__(**kwargs)
-        self.share_usage_bytes = kwargs['share_usage_bytes']
+        super().__init__(**kwargs)
+        self.share_usage_bytes = share_usage_bytes
 
 
-class SignedIdentifier(msrest.serialization.Model):
+class SignedIdentifier(_serialization.Model):
     """Signed identifier.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Required. A unique id.
+    :ivar id: A unique id. Required.
     :vartype id: str
     :ivar access_policy: The access policy.
     :vartype access_policy: ~azure.storage.fileshare.models.AccessPolicy
     """
 
     _validation = {
-        'id': {'required': True},
+        "id": {"required": True},
     }
 
     _attribute_map = {
-        'id': {'key': 'Id', 'type': 'str'},
-        'access_policy': {'key': 'AccessPolicy', 'type': 'AccessPolicy'},
+        "id": {"key": "Id", "type": "str"},
+        "access_policy": {"key": "AccessPolicy", "type": "AccessPolicy"},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        id: str,  # pylint: disable=redefined-builtin
+        access_policy: Optional["_models.AccessPolicy"] = None,
+        **kwargs: Any
+    ) -> None:
         """
-        :keyword id: Required. A unique id.
+        :keyword id: A unique id. Required.
         :paramtype id: str
         :keyword access_policy: The access policy.
         :paramtype access_policy: ~azure.storage.fileshare.models.AccessPolicy
         """
-        super(SignedIdentifier, self).__init__(**kwargs)
-        self.id = kwargs['id']
-        self.access_policy = kwargs.get('access_policy', None)
+        super().__init__(**kwargs)
+        self.id = id
+        self.access_policy = access_policy
 
 
-class SmbMultichannel(msrest.serialization.Model):
+class SmbMultichannel(_serialization.Model):
     """Settings for SMB multichannel.
 
     :ivar enabled: If SMB multichannel is enabled.
     :vartype enabled: bool
     """
 
     _attribute_map = {
-        'enabled': {'key': 'Enabled', 'type': 'bool'},
-    }
-    _xml_map = {
-        'name': 'Multichannel'
+        "enabled": {"key": "Enabled", "type": "bool"},
     }
+    _xml_map = {"name": "Multichannel"}
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, enabled: Optional[bool] = None, **kwargs: Any) -> None:
         """
         :keyword enabled: If SMB multichannel is enabled.
         :paramtype enabled: bool
         """
-        super(SmbMultichannel, self).__init__(**kwargs)
-        self.enabled = kwargs.get('enabled', None)
+        super().__init__(**kwargs)
+        self.enabled = enabled
 
 
-class SourceLeaseAccessConditions(msrest.serialization.Model):
+class SourceLeaseAccessConditions(_serialization.Model):
     """Parameter group.
 
     :ivar source_lease_id: Required if the source file has an active infinite lease.
     :vartype source_lease_id: str
     """
 
     _attribute_map = {
-        'source_lease_id': {'key': 'sourceLeaseId', 'type': 'str'},
+        "source_lease_id": {"key": "sourceLeaseId", "type": "str"},
     }
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, source_lease_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword source_lease_id: Required if the source file has an active infinite lease.
         :paramtype source_lease_id: str
         """
-        super(SourceLeaseAccessConditions, self).__init__(**kwargs)
-        self.source_lease_id = kwargs.get('source_lease_id', None)
+        super().__init__(**kwargs)
+        self.source_lease_id = source_lease_id
 
 
-class SourceModifiedAccessConditions(msrest.serialization.Model):
+class SourceModifiedAccessConditions(_serialization.Model):
     """Parameter group.
 
     :ivar source_if_match_crc64: Specify the crc64 value to operate only on range with a matching
      crc64 checksum.
-    :vartype source_if_match_crc64: bytearray
+    :vartype source_if_match_crc64: bytes
     :ivar source_if_none_match_crc64: Specify the crc64 value to operate only on range without a
      matching crc64 checksum.
-    :vartype source_if_none_match_crc64: bytearray
+    :vartype source_if_none_match_crc64: bytes
     """
 
     _attribute_map = {
-        'source_if_match_crc64': {'key': 'sourceIfMatchCrc64', 'type': 'bytearray'},
-        'source_if_none_match_crc64': {'key': 'sourceIfNoneMatchCrc64', 'type': 'bytearray'},
+        "source_if_match_crc64": {"key": "sourceIfMatchCrc64", "type": "bytearray"},
+        "source_if_none_match_crc64": {"key": "sourceIfNoneMatchCrc64", "type": "bytearray"},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        source_if_match_crc64: Optional[bytes] = None,
+        source_if_none_match_crc64: Optional[bytes] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword source_if_match_crc64: Specify the crc64 value to operate only on range with a
          matching crc64 checksum.
-        :paramtype source_if_match_crc64: bytearray
+        :paramtype source_if_match_crc64: bytes
         :keyword source_if_none_match_crc64: Specify the crc64 value to operate only on range without a
          matching crc64 checksum.
-        :paramtype source_if_none_match_crc64: bytearray
+        :paramtype source_if_none_match_crc64: bytes
         """
-        super(SourceModifiedAccessConditions, self).__init__(**kwargs)
-        self.source_if_match_crc64 = kwargs.get('source_if_match_crc64', None)
-        self.source_if_none_match_crc64 = kwargs.get('source_if_none_match_crc64', None)
+        super().__init__(**kwargs)
+        self.source_if_match_crc64 = source_if_match_crc64
+        self.source_if_none_match_crc64 = source_if_none_match_crc64
 
 
-class StorageError(msrest.serialization.Model):
+class StorageError(_serialization.Model):
     """StorageError.
 
     :ivar message:
     :vartype message: str
     """
 
     _attribute_map = {
-        'message': {'key': 'Message', 'type': 'str'},
+        "message": {"key": "Message", "type": "str"},
     }
 
-    def __init__(
-        self,
-        **kwargs
-    ):
+    def __init__(self, *, message: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword message:
         :paramtype message: str
         """
-        super(StorageError, self).__init__(**kwargs)
-        self.message = kwargs.get('message', None)
+        super().__init__(**kwargs)
+        self.message = message
 
 
-class StorageServiceProperties(msrest.serialization.Model):
+class StorageServiceProperties(_serialization.Model):
     """Storage service properties.
 
     :ivar hour_metrics: A summary of request statistics grouped by API in hourly aggregates for
      files.
     :vartype hour_metrics: ~azure.storage.fileshare.models.Metrics
     :ivar minute_metrics: A summary of request statistics grouped by API in minute aggregates for
      files.
@@ -1484,34 +1555,65 @@
     :ivar cors: The set of CORS rules.
     :vartype cors: list[~azure.storage.fileshare.models.CorsRule]
     :ivar protocol: Protocol settings.
     :vartype protocol: ~azure.storage.fileshare.models.ShareProtocolSettings
     """
 
     _attribute_map = {
-        'hour_metrics': {'key': 'HourMetrics', 'type': 'Metrics'},
-        'minute_metrics': {'key': 'MinuteMetrics', 'type': 'Metrics'},
-        'cors': {'key': 'Cors', 'type': '[CorsRule]', 'xml': {'wrapped': True}},
-        'protocol': {'key': 'Protocol', 'type': 'ShareProtocolSettings'},
+        "hour_metrics": {"key": "HourMetrics", "type": "Metrics"},
+        "minute_metrics": {"key": "MinuteMetrics", "type": "Metrics"},
+        "cors": {"key": "Cors", "type": "[CorsRule]", "xml": {"wrapped": True}},
+        "protocol": {"key": "Protocol", "type": "ShareProtocolSettings"},
     }
 
     def __init__(
         self,
-        **kwargs
-    ):
+        *,
+        hour_metrics: Optional["_models.Metrics"] = None,
+        minute_metrics: Optional["_models.Metrics"] = None,
+        cors: Optional[List["_models.CorsRule"]] = None,
+        protocol: Optional["_models.ShareProtocolSettings"] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword hour_metrics: A summary of request statistics grouped by API in hourly aggregates for
          files.
         :paramtype hour_metrics: ~azure.storage.fileshare.models.Metrics
         :keyword minute_metrics: A summary of request statistics grouped by API in minute aggregates
          for files.
         :paramtype minute_metrics: ~azure.storage.fileshare.models.Metrics
         :keyword cors: The set of CORS rules.
         :paramtype cors: list[~azure.storage.fileshare.models.CorsRule]
         :keyword protocol: Protocol settings.
         :paramtype protocol: ~azure.storage.fileshare.models.ShareProtocolSettings
         """
-        super(StorageServiceProperties, self).__init__(**kwargs)
-        self.hour_metrics = kwargs.get('hour_metrics', None)
-        self.minute_metrics = kwargs.get('minute_metrics', None)
-        self.cors = kwargs.get('cors', None)
-        self.protocol = kwargs.get('protocol', None)
+        super().__init__(**kwargs)
+        self.hour_metrics = hour_metrics
+        self.minute_metrics = minute_metrics
+        self.cors = cors
+        self.protocol = protocol
+
+
+class StringEncoded(_serialization.Model):
+    """StringEncoded.
+
+    :ivar encoded:
+    :vartype encoded: bool
+    :ivar content:
+    :vartype content: str
+    """
+
+    _attribute_map = {
+        "encoded": {"key": "Encoded", "type": "bool", "xml": {"name": "Encoded", "attr": True}},
+        "content": {"key": "content", "type": "str", "xml": {"text": True}},
+    }
+
+    def __init__(self, *, encoded: Optional[bool] = None, content: Optional[str] = None, **kwargs: Any) -> None:
+        """
+        :keyword encoded:
+        :paramtype encoded: bool
+        :keyword content:
+        :paramtype content: str
+        """
+        super().__init__(**kwargs)
+        self.encoded = encoded
+        self.content = content
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from ._service_operations import ServiceOperations
 from ._share_operations import ShareOperations
 from ._directory_operations import DirectoryOperations
 from ._file_operations import FileOperations
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "ServiceOperations",
     "ShareOperations",
     "DirectoryOperations",
     "FileOperations",
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_directory_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_directory_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,33 +2,39 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, List, Optional, TypeVar, Union
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -39,111 +45,138 @@
     metadata: Optional[Dict[str, str]] = None,
     file_permission: str = "inherit",
     file_permission_key: Optional[str] = None,
     file_attributes: str = "none",
     file_creation_time: str = "now",
     file_last_write_time: str = "now",
     file_change_time: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
     if metadata is not None:
         _headers["x-ms-meta"] = _SERIALIZER.header("metadata", metadata, "{str}")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if file_permission is not None:
         _headers["x-ms-file-permission"] = _SERIALIZER.header("file_permission", file_permission, "str")
     if file_permission_key is not None:
         _headers["x-ms-file-permission-key"] = _SERIALIZER.header("file_permission_key", file_permission_key, "str")
     _headers["x-ms-file-attributes"] = _SERIALIZER.header("file_attributes", file_attributes, "str")
     if file_creation_time is not None:
         _headers["x-ms-file-creation-time"] = _SERIALIZER.header("file_creation_time", file_creation_time, "str")
     if file_last_write_time is not None:
         _headers["x-ms-file-last-write-time"] = _SERIALIZER.header("file_last_write_time", file_last_write_time, "str")
     if file_change_time is not None:
         _headers["x-ms-file-change-time"] = _SERIALIZER.header("file_change_time", file_change_time, "str")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_properties_request(
-    url: str, *, sharesnapshot: Optional[str] = None, timeout: Optional[int] = None, **kwargs: Any
+    url: str,
+    *,
+    sharesnapshot: Optional[str] = None,
+    timeout: Optional[int] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if sharesnapshot is not None:
         _params["sharesnapshot"] = _SERIALIZER.query("sharesnapshot", sharesnapshot, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_delete_request(url: str, *, timeout: Optional[int] = None, **kwargs: Any) -> HttpRequest:
+def build_delete_request(
+    url: str,
+    *,
+    timeout: Optional[int] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
+    **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_properties_request(
     url: str,
@@ -151,31 +184,33 @@
     timeout: Optional[int] = None,
     file_permission: str = "inherit",
     file_permission_key: Optional[str] = None,
     file_attributes: str = "none",
     file_creation_time: str = "now",
     file_last_write_time: str = "now",
     file_change_time: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+    comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -188,80 +223,96 @@
     _headers["x-ms-file-attributes"] = _SERIALIZER.header("file_attributes", file_attributes, "str")
     if file_creation_time is not None:
         _headers["x-ms-file-creation-time"] = _SERIALIZER.header("file_creation_time", file_creation_time, "str")
     if file_last_write_time is not None:
         _headers["x-ms-file-last-write-time"] = _SERIALIZER.header("file_last_write_time", file_last_write_time, "str")
     if file_change_time is not None:
         _headers["x-ms-file-change-time"] = _SERIALIZER.header("file_change_time", file_change_time, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_metadata_request(
-    url: str, *, timeout: Optional[int] = None, metadata: Optional[Dict[str, str]] = None, **kwargs: Any
+    url: str,
+    *,
+    timeout: Optional[int] = None,
+    metadata: Optional[Dict[str, str]] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "metadata"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+    comp: Literal["metadata"] = kwargs.pop("comp", _params.pop("comp", "metadata"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
     if metadata is not None:
         _headers["x-ms-meta"] = _SERIALIZER.header("metadata", metadata, "{str}")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_files_and_directories_segment_request(
     url: str,
     *,
     prefix: Optional[str] = None,
     sharesnapshot: Optional[str] = None,
     marker: Optional[str] = None,
     maxresults: Optional[int] = None,
     timeout: Optional[int] = None,
-    include: Optional[List[Union[str, "_models.ListFilesIncludeType"]]] = None,
+    include: Optional[List[Union[str, _models.ListFilesIncludeType]]] = None,
     include_extended_info: Optional[bool] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "list"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+    comp: Literal["list"] = kwargs.pop("comp", _params.pop("comp", "list"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if prefix is not None:
         _params["prefix"] = _SERIALIZER.query("prefix", prefix, "str")
     if sharesnapshot is not None:
@@ -275,43 +326,49 @@
     if include is not None:
         _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
 
     # Construct headers
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if include_extended_info is not None:
         _headers["x-ms-file-extended-info"] = _SERIALIZER.header("include_extended_info", include_extended_info, "bool")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_handles_request(
     url: str,
     *,
     marker: Optional[str] = None,
     maxresults: Optional[int] = None,
     timeout: Optional[int] = None,
     sharesnapshot: Optional[str] = None,
     recursive: Optional[bool] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "listhandles"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["listhandles"] = kwargs.pop("comp", _params.pop("comp", "listhandles"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if marker is not None:
         _params["marker"] = _SERIALIZER.query("marker", marker, "str")
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", minimum=1)
@@ -320,43 +377,49 @@
     if sharesnapshot is not None:
         _params["sharesnapshot"] = _SERIALIZER.query("sharesnapshot", sharesnapshot, "str")
 
     # Construct headers
     if recursive is not None:
         _headers["x-ms-recursive"] = _SERIALIZER.header("recursive", recursive, "bool")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_force_close_handles_request(
     url: str,
     *,
     handle_id: str,
     timeout: Optional[int] = None,
     marker: Optional[str] = None,
     sharesnapshot: Optional[str] = None,
     recursive: Optional[bool] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["forceclosehandles"] = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
     if marker is not None:
         _params["marker"] = _SERIALIZER.query("marker", marker, "str")
@@ -364,14 +427,18 @@
         _params["sharesnapshot"] = _SERIALIZER.query("sharesnapshot", sharesnapshot, "str")
 
     # Construct headers
     _headers["x-ms-handle-id"] = _SERIALIZER.header("handle_id", handle_id, "str")
     if recursive is not None:
         _headers["x-ms-recursive"] = _SERIALIZER.header("recursive", recursive, "bool")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_rename_request(
     url: str,
@@ -385,31 +452,34 @@
     file_attributes: Optional[str] = None,
     file_creation_time: Optional[str] = None,
     file_last_write_time: Optional[str] = None,
     file_change_time: Optional[str] = None,
     file_permission: str = "inherit",
     file_permission_key: Optional[str] = None,
     metadata: Optional[Dict[str, str]] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    allow_source_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "rename"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+    comp: Literal["rename"] = kwargs.pop("comp", _params.pop("comp", "rename"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -436,14 +506,22 @@
         _headers["x-ms-file-change-time"] = _SERIALIZER.header("file_change_time", file_change_time, "str")
     if file_permission is not None:
         _headers["x-ms-file-permission"] = _SERIALIZER.header("file_permission", file_permission, "str")
     if file_permission_key is not None:
         _headers["x-ms-file-permission-key"] = _SERIALIZER.header("file_permission_key", file_permission_key, "str")
     if metadata is not None:
         _headers["x-ms-meta"] = _SERIALIZER.header("metadata", metadata, "{str}")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if allow_source_trailing_dot is not None:
+        _headers["x-ms-source-allow-trailing-dot"] = _SERIALIZER.header(
+            "allow_source_trailing_dot", allow_source_trailing_dot, "bool"
+        )
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class DirectoryOperations:
     """
@@ -514,43 +592,50 @@
          value may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_create_request(
             url=self._config.url,
             timeout=timeout,
             metadata=metadata,
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             file_attributes=file_attributes,
             file_creation_time=file_creation_time,
             file_last_write_time=file_last_write_time,
             file_change_time=file_change_time,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             version=self._config.version,
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -583,15 +668,15 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    create.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    create.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace
     def get_properties(  # pylint: disable=inconsistent-return-statements
         self, sharesnapshot: Optional[str] = None, timeout: Optional[int] = None, **kwargs: Any
     ) -> None:
         """Returns all system properties for the specified directory, and can also be used to check the
         existence of a directory. The data returned does not include the files in the directory or any
@@ -609,37 +694,44 @@
          value may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_get_properties_request(
             url=self._config.url,
             sharesnapshot=sharesnapshot,
             timeout=timeout,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             version=self._config.version,
             template_url=self.get_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -673,15 +765,15 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    get_properties.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    get_properties.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace
     def delete(  # pylint: disable=inconsistent-return-statements
         self, timeout: Optional[int] = None, **kwargs: Any
     ) -> None:
         """Removes the specified empty directory. Note that the directory must be empty before it can be
         deleted.
@@ -695,36 +787,43 @@
          value may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             url=self._config.url,
             timeout=timeout,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             version=self._config.version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -735,15 +834,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    delete.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    delete.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace
     def set_properties(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         file_permission: str = "inherit",
         file_permission_key: Optional[str] = None,
@@ -790,44 +889,51 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_set_properties_request(
             url=self._config.url,
             timeout=timeout,
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             file_attributes=file_attributes,
             file_creation_time=file_creation_time,
             file_last_write_time=file_last_write_time,
             file_change_time=file_change_time,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.set_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -860,15 +966,15 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_properties.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    set_properties.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace
     def set_metadata(  # pylint: disable=inconsistent-return-statements
         self, timeout: Optional[int] = None, metadata: Optional[Dict[str, str]] = None, **kwargs: Any
     ) -> None:
         """Updates user defined metadata for the specified directory.
 
@@ -887,39 +993,46 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "metadata"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        comp: Literal["metadata"] = kwargs.pop("comp", _params.pop("comp", "metadata"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_set_metadata_request(
             url=self._config.url,
             timeout=timeout,
             metadata=metadata,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.set_metadata.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -934,25 +1047,25 @@
         response_headers["x-ms-request-server-encrypted"] = self._deserialize(
             "bool", response.headers.get("x-ms-request-server-encrypted")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_metadata.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    set_metadata.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace
     def list_files_and_directories_segment(
         self,
         prefix: Optional[str] = None,
         sharesnapshot: Optional[str] = None,
         marker: Optional[str] = None,
         maxresults: Optional[int] = None,
         timeout: Optional[int] = None,
-        include: Optional[List[Union[str, "_models.ListFilesIncludeType"]]] = None,
+        include: Optional[List[Union[str, _models.ListFilesIncludeType]]] = None,
         include_extended_info: Optional[bool] = None,
         **kwargs: Any
     ) -> _models.ListFilesAndDirectoriesSegmentResponse:
         """Returns a list of files or directories under the specified share or directory. It lists the
         contents only for a single level of the directory hierarchy.
 
         :param prefix: Filters the results to return only entries whose name begins with the specified
@@ -987,44 +1100,51 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ListFilesAndDirectoriesSegmentResponse or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ListFilesAndDirectoriesSegmentResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "list"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ListFilesAndDirectoriesSegmentResponse]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        comp: Literal["list"] = kwargs.pop("comp", _params.pop("comp", "list"))
+        cls: ClsType[_models.ListFilesAndDirectoriesSegmentResponse] = kwargs.pop("cls", None)
 
         request = build_list_files_and_directories_segment_request(
             url=self._config.url,
             prefix=prefix,
             sharesnapshot=sharesnapshot,
             marker=marker,
             maxresults=maxresults,
             timeout=timeout,
             include=include,
             include_extended_info=include_extended_info,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.list_files_and_directories_segment.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1040,15 +1160,15 @@
         deserialized = self._deserialize("ListFilesAndDirectoriesSegmentResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    list_files_and_directories_segment.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    list_files_and_directories_segment.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace
     def list_handles(
         self,
         marker: Optional[str] = None,
         maxresults: Optional[int] = None,
         timeout: Optional[int] = None,
@@ -1082,40 +1202,47 @@
          may result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ListHandlesResponse or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ListHandlesResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "listhandles"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ListHandlesResponse]
+        comp: Literal["listhandles"] = kwargs.pop("comp", _params.pop("comp", "listhandles"))
+        cls: ClsType[_models.ListHandlesResponse] = kwargs.pop("cls", None)
 
         request = build_list_handles_request(
             url=self._config.url,
             marker=marker,
             maxresults=maxresults,
             timeout=timeout,
             sharesnapshot=sharesnapshot,
             recursive=recursive,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.list_handles.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1131,15 +1258,15 @@
         deserialized = self._deserialize("ListHandlesResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    list_handles.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    list_handles.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace
     def force_close_handles(  # pylint: disable=inconsistent-return-statements
         self,
         handle_id: str,
         timeout: Optional[int] = None,
         marker: Optional[str] = None,
@@ -1172,40 +1299,47 @@
          value may result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["forceclosehandles"] = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_force_close_handles_request(
             url=self._config.url,
             handle_id=handle_id,
             timeout=timeout,
             marker=marker,
             sharesnapshot=sharesnapshot,
             recursive=recursive,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.force_close_handles.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1223,15 +1357,15 @@
         response_headers["x-ms-number-of-handles-failed"] = self._deserialize(
             "int", response.headers.get("x-ms-number-of-handles-failed")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    force_close_handles.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    force_close_handles.metadata = {"url": "{url}/{shareName}/{directory}"}
 
     @distributed_trace
     def rename(  # pylint: disable=inconsistent-return-statements
         self,
         rename_source: str,
         timeout: Optional[int] = None,
         replace_if_exists: Optional[bool] = None,
@@ -1294,23 +1428,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "directory"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "rename"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["directory"] = kwargs.pop("restype", _params.pop("restype", "directory"))
+        comp: Literal["rename"] = kwargs.pop("comp", _params.pop("comp", "rename"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _source_lease_id = None
         _destination_lease_id = None
         _file_attributes = None
         _file_creation_time = None
         _file_last_write_time = None
         _file_change_time = None
@@ -1335,25 +1474,28 @@
             file_attributes=_file_attributes,
             file_creation_time=_file_creation_time,
             file_last_write_time=_file_last_write_time,
             file_change_time=_file_change_time,
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             metadata=metadata,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            allow_source_trailing_dot=self._config.allow_source_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.rename.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1386,8 +1528,8 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    rename.metadata = {"url": "{url}/{shareName}/{directory}"}  # type: ignore
+    rename.metadata = {"url": "{url}/{shareName}/{directory}"}
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_file_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_file_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,33 +2,39 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterator, Optional, TypeVar, Union
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -47,36 +53,40 @@
     file_permission: str = "inherit",
     file_permission_key: Optional[str] = None,
     file_attributes: str = "none",
     file_creation_time: str = "now",
     file_last_write_time: str = "now",
     file_change_time: Optional[str] = None,
     lease_id: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    file_type_constant = kwargs.pop("file_type_constant", _headers.pop("x-ms-type", "file"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    file_type_constant: Literal["file"] = kwargs.pop("file_type_constant", _headers.pop("x-ms-type", "file"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     _headers["x-ms-content-length"] = _SERIALIZER.header("file_content_length", file_content_length, "int")
     _headers["x-ms-type"] = _SERIALIZER.header("file_type_constant", file_type_constant, "str")
     if file_content_type is not None:
         _headers["x-ms-content-type"] = _SERIALIZER.header("file_content_type", file_content_type, "str")
     if file_content_encoding is not None:
         _headers["x-ms-content-encoding"] = _SERIALIZER.header("file_content_encoding", file_content_encoding, "str")
@@ -101,123 +111,147 @@
         _headers["x-ms-file-creation-time"] = _SERIALIZER.header("file_creation_time", file_creation_time, "str")
     if file_last_write_time is not None:
         _headers["x-ms-file-last-write-time"] = _SERIALIZER.header("file_last_write_time", file_last_write_time, "str")
     if file_change_time is not None:
         _headers["x-ms-file-change-time"] = _SERIALIZER.header("file_change_time", file_change_time, "str")
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_download_request(
     url: str,
     *,
     timeout: Optional[int] = None,
     range: Optional[str] = None,
     range_get_content_md5: Optional[bool] = None,
     lease_id: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if range is not None:
         _headers["x-ms-range"] = _SERIALIZER.header("range", range, "str")
     if range_get_content_md5 is not None:
         _headers["x-ms-range-get-content-md5"] = _SERIALIZER.header(
             "range_get_content_md5", range_get_content_md5, "bool"
         )
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_properties_request(
     url: str,
     *,
     sharesnapshot: Optional[str] = None,
     timeout: Optional[int] = None,
     lease_id: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if sharesnapshot is not None:
         _params["sharesnapshot"] = _SERIALIZER.query("sharesnapshot", sharesnapshot, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="HEAD", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    url: str, *, timeout: Optional[int] = None, lease_id: Optional[str] = None, **kwargs: Any
+    url: str,
+    *,
+    timeout: Optional[int] = None,
+    lease_id: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_http_headers_request(
     url: str,
@@ -233,30 +267,32 @@
     file_permission: str = "inherit",
     file_permission_key: Optional[str] = None,
     file_attributes: str = "none",
     file_creation_time: str = "now",
     file_last_write_time: str = "now",
     file_change_time: Optional[str] = None,
     lease_id: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
@@ -286,82 +322,94 @@
         _headers["x-ms-file-creation-time"] = _SERIALIZER.header("file_creation_time", file_creation_time, "str")
     if file_last_write_time is not None:
         _headers["x-ms-file-last-write-time"] = _SERIALIZER.header("file_last_write_time", file_last_write_time, "str")
     if file_change_time is not None:
         _headers["x-ms-file-change-time"] = _SERIALIZER.header("file_change_time", file_change_time, "str")
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_metadata_request(
     url: str,
     *,
     timeout: Optional[int] = None,
     metadata: Optional[Dict[str, str]] = None,
     lease_id: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "metadata"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["metadata"] = kwargs.pop("comp", _params.pop("comp", "metadata"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
     if metadata is not None:
         _headers["x-ms-meta"] = _SERIALIZER.header("metadata", metadata, "{str}")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_acquire_lease_request(
     url: str,
     *,
     timeout: Optional[int] = None,
     duration: Optional[int] = None,
     proposed_lease_id: Optional[str] = None,
     request_id_parameter: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-    action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+    action: Literal["acquire"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
@@ -369,166 +417,195 @@
     if duration is not None:
         _headers["x-ms-lease-duration"] = _SERIALIZER.header("duration", duration, "int")
     if proposed_lease_id is not None:
         _headers["x-ms-proposed-lease-id"] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, "str")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if request_id_parameter is not None:
         _headers["x-ms-client-request-id"] = _SERIALIZER.header("request_id_parameter", request_id_parameter, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_release_lease_request(
-    url: str, *, lease_id: str, timeout: Optional[int] = None, request_id_parameter: Optional[str] = None, **kwargs: Any
+    url: str,
+    *,
+    lease_id: str,
+    timeout: Optional[int] = None,
+    request_id_parameter: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-    action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+    action: Literal["release"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
     _headers["x-ms-lease-action"] = _SERIALIZER.header("action", action, "str")
     _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if request_id_parameter is not None:
         _headers["x-ms-client-request-id"] = _SERIALIZER.header("request_id_parameter", request_id_parameter, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_change_lease_request(
     url: str,
     *,
     lease_id: str,
     timeout: Optional[int] = None,
     proposed_lease_id: Optional[str] = None,
     request_id_parameter: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-    action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+    action: Literal["change"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
     _headers["x-ms-lease-action"] = _SERIALIZER.header("action", action, "str")
     _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
     if proposed_lease_id is not None:
         _headers["x-ms-proposed-lease-id"] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, "str")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if request_id_parameter is not None:
         _headers["x-ms-client-request-id"] = _SERIALIZER.header("request_id_parameter", request_id_parameter, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_break_lease_request(
     url: str,
     *,
     timeout: Optional[int] = None,
     lease_id: Optional[str] = None,
     request_id_parameter: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-    action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+    action: Literal["break"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
     _headers["x-ms-lease-action"] = _SERIALIZER.header("action", action, "str")
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if request_id_parameter is not None:
         _headers["x-ms-client-request-id"] = _SERIALIZER.header("request_id_parameter", request_id_parameter, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_upload_range_request(
     url: str,
     *,
     range: str,
     content_length: int,
     timeout: Optional[int] = None,
-    file_range_write: Union[str, "_models.FileRangeWriteType"] = "update",
+    file_range_write: Union[str, _models.FileRangeWriteType] = "update",
     content_md5: Optional[bytes] = None,
     lease_id: Optional[str] = None,
-    file_last_written_mode: Optional[Union[str, "_models.FileLastWrittenMode"]] = None,
+    file_last_written_mode: Optional[Union[str, _models.FileLastWrittenMode]] = None,
     content: Optional[IO] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "range"))  # type: str
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["range"] = kwargs.pop("comp", _params.pop("comp", "range"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
@@ -540,14 +617,18 @@
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
     if file_last_written_mode is not None:
         _headers["x-ms-file-last-write-time"] = _SERIALIZER.header(
             "file_last_written_mode", file_last_written_mode, "str"
         )
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, content=content, **kwargs)
 
 
@@ -560,34 +641,36 @@
     timeout: Optional[int] = None,
     source_range: Optional[str] = None,
     source_content_crc64: Optional[bytes] = None,
     source_if_match_crc64: Optional[bytes] = None,
     source_if_none_match_crc64: Optional[bytes] = None,
     lease_id: Optional[str] = None,
     copy_source_authorization: Optional[str] = None,
-    file_last_written_mode: Optional[Union[str, "_models.FileLastWrittenMode"]] = None,
+    file_last_written_mode: Optional[Union[str, _models.FileLastWrittenMode]] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    allow_source_trailing_dot: Optional[bool] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "range"))  # type: str
-    file_range_write_from_url = kwargs.pop(
+    comp: Literal["range"] = kwargs.pop("comp", _params.pop("comp", "range"))
+    file_range_write_from_url: Literal["update"] = kwargs.pop(
         "file_range_write_from_url", _headers.pop("x-ms-write", "update")
-    )  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    )
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
@@ -616,43 +699,51 @@
         _headers["x-ms-copy-source-authorization"] = _SERIALIZER.header(
             "copy_source_authorization", copy_source_authorization, "str"
         )
     if file_last_written_mode is not None:
         _headers["x-ms-file-last-write-time"] = _SERIALIZER.header(
             "file_last_written_mode", file_last_written_mode, "str"
         )
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if allow_source_trailing_dot is not None:
+        _headers["x-ms-source-allow-trailing-dot"] = _SERIALIZER.header(
+            "allow_source_trailing_dot", allow_source_trailing_dot, "bool"
+        )
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_range_list_request(
     url: str,
     *,
     sharesnapshot: Optional[str] = None,
     prevsharesnapshot: Optional[str] = None,
     timeout: Optional[int] = None,
     range: Optional[str] = None,
     lease_id: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "rangelist"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["rangelist"] = kwargs.pop("comp", _params.pop("comp", "rangelist"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if sharesnapshot is not None:
         _params["sharesnapshot"] = _SERIALIZER.query("sharesnapshot", sharesnapshot, "str")
     if prevsharesnapshot is not None:
         _params["prevsharesnapshot"] = _SERIALIZER.query("prevsharesnapshot", prevsharesnapshot, "str")
@@ -661,50 +752,57 @@
 
     # Construct headers
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if range is not None:
         _headers["x-ms-range"] = _SERIALIZER.header("range", range, "str")
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_start_copy_request(
     url: str,
     *,
     copy_source: str,
     timeout: Optional[int] = None,
     metadata: Optional[Dict[str, str]] = None,
     file_permission: str = "inherit",
     file_permission_key: Optional[str] = None,
-    file_permission_copy_mode: Optional[Union[str, "_models.PermissionCopyModeType"]] = None,
+    file_permission_copy_mode: Optional[Union[str, _models.PermissionCopyModeType]] = None,
     ignore_read_only: Optional[bool] = None,
     file_attributes: Optional[str] = None,
     file_creation_time: Optional[str] = None,
     file_last_write_time: Optional[str] = None,
     file_change_time: Optional[str] = None,
     set_archive_attribute: Optional[bool] = None,
     lease_id: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    allow_source_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
@@ -731,134 +829,165 @@
         _headers["x-ms-file-change-time"] = _SERIALIZER.header("file_change_time", file_change_time, "str")
     if set_archive_attribute is not None:
         _headers["x-ms-file-copy-set-archive"] = _SERIALIZER.header(
             "set_archive_attribute", set_archive_attribute, "bool"
         )
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if allow_source_trailing_dot is not None:
+        _headers["x-ms-source-allow-trailing-dot"] = _SERIALIZER.header(
+            "allow_source_trailing_dot", allow_source_trailing_dot, "bool"
+        )
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_abort_copy_request(
-    url: str, *, copy_id: str, timeout: Optional[int] = None, lease_id: Optional[str] = None, **kwargs: Any
+    url: str,
+    *,
+    copy_id: str,
+    timeout: Optional[int] = None,
+    lease_id: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "copy"))  # type: str
-    copy_action_abort_constant = kwargs.pop(
+    comp: Literal["copy"] = kwargs.pop("comp", _params.pop("comp", "copy"))
+    copy_action_abort_constant: Literal["abort"] = kwargs.pop(
         "copy_action_abort_constant", _headers.pop("x-ms-copy-action", "abort")
-    )  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    )
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     _params["copyid"] = _SERIALIZER.query("copy_id", copy_id, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
     _headers["x-ms-copy-action"] = _SERIALIZER.header("copy_action_abort_constant", copy_action_abort_constant, "str")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     if lease_id is not None:
         _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_handles_request(
     url: str,
     *,
     marker: Optional[str] = None,
     maxresults: Optional[int] = None,
     timeout: Optional[int] = None,
     sharesnapshot: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "listhandles"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["listhandles"] = kwargs.pop("comp", _params.pop("comp", "listhandles"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if marker is not None:
         _params["marker"] = _SERIALIZER.query("marker", marker, "str")
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", minimum=1)
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
     if sharesnapshot is not None:
         _params["sharesnapshot"] = _SERIALIZER.query("sharesnapshot", sharesnapshot, "str")
 
     # Construct headers
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_force_close_handles_request(
     url: str,
     *,
     handle_id: str,
     timeout: Optional[int] = None,
     marker: Optional[str] = None,
     sharesnapshot: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["forceclosehandles"] = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
     if marker is not None:
         _params["marker"] = _SERIALIZER.query("marker", marker, "str")
     if sharesnapshot is not None:
         _params["sharesnapshot"] = _SERIALIZER.query("sharesnapshot", sharesnapshot, "str")
 
     # Construct headers
     _headers["x-ms-handle-id"] = _SERIALIZER.header("handle_id", handle_id, "str")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_rename_request(
     url: str,
@@ -873,30 +1002,33 @@
     file_creation_time: Optional[str] = None,
     file_last_write_time: Optional[str] = None,
     file_change_time: Optional[str] = None,
     file_permission: str = "inherit",
     file_permission_key: Optional[str] = None,
     metadata: Optional[Dict[str, str]] = None,
     file_content_type: Optional[str] = None,
+    allow_trailing_dot: Optional[bool] = None,
+    allow_source_trailing_dot: Optional[bool] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "rename"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["rename"] = kwargs.pop("comp", _params.pop("comp", "rename"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}/{directory}/{fileName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
@@ -924,14 +1056,22 @@
         _headers["x-ms-file-permission"] = _SERIALIZER.header("file_permission", file_permission, "str")
     if file_permission_key is not None:
         _headers["x-ms-file-permission-key"] = _SERIALIZER.header("file_permission_key", file_permission_key, "str")
     if metadata is not None:
         _headers["x-ms-meta"] = _SERIALIZER.header("metadata", metadata, "{str}")
     if file_content_type is not None:
         _headers["x-ms-content-type"] = _SERIALIZER.header("file_content_type", file_content_type, "str")
+    if allow_trailing_dot is not None:
+        _headers["x-ms-allow-trailing-dot"] = _SERIALIZER.header("allow_trailing_dot", allow_trailing_dot, "bool")
+    if allow_source_trailing_dot is not None:
+        _headers["x-ms-source-allow-trailing-dot"] = _SERIALIZER.header(
+            "allow_source_trailing_dot", allow_source_trailing_dot, "bool"
+        )
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class FileOperations:
     """
@@ -1011,22 +1151,27 @@
          value is "file". Note that overriding this default value may result in unsupported behavior.
         :paramtype file_type_constant: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
-        file_type_constant = kwargs.pop("file_type_constant", _headers.pop("x-ms-type", "file"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        file_type_constant: Literal["file"] = kwargs.pop("file_type_constant", _headers.pop("x-ms-type", "file"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _file_content_type = None
         _file_content_encoding = None
         _file_content_language = None
         _file_cache_control = None
         _file_content_md5 = None
         _file_content_disposition = None
@@ -1055,24 +1200,26 @@
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             file_attributes=file_attributes,
             file_creation_time=file_creation_time,
             file_last_write_time=file_last_write_time,
             file_change_time=file_change_time,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             file_type_constant=file_type_constant,
             version=self._config.version,
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1105,15 +1252,15 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    create.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    create.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def download(
         self,
         timeout: Optional[int] = None,
         range: Optional[str] = None,
         range_get_content_md5: Optional[bool] = None,
@@ -1136,41 +1283,48 @@
         :param lease_access_conditions: Parameter group. Default value is None.
         :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Iterator of the response bytes or the result of cls(response)
         :rtype: Iterator[bytes]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
-        cls = kwargs.pop("cls", None)  # type: ClsType[Iterator[bytes]]
+        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_download_request(
             url=self._config.url,
             timeout=timeout,
             range=range,
             range_get_content_md5=range_get_content_md5,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             version=self._config.version,
             template_url=self.download.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=True, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 206]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1301,19 +1455,19 @@
             )
             response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
             response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
 
             deserialized = response.stream_download(self._client._pipeline)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    download.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    download.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def get_properties(  # pylint: disable=inconsistent-return-statements
         self,
         sharesnapshot: Optional[str] = None,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -1333,40 +1487,47 @@
         :param lease_access_conditions: Parameter group. Default value is None.
         :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_get_properties_request(
             url=self._config.url,
             sharesnapshot=sharesnapshot,
             timeout=timeout,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             version=self._config.version,
             template_url=self.get_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1421,15 +1582,15 @@
         response_headers["x-ms-lease-duration"] = self._deserialize("str", response.headers.get("x-ms-lease-duration"))
         response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
         response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    get_properties.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    get_properties.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def delete(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
@@ -1444,39 +1605,46 @@
         :param lease_access_conditions: Parameter group. Default value is None.
         :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_delete_request(
             url=self._config.url,
             timeout=timeout,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             version=self._config.version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1487,15 +1655,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    delete.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    delete.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def set_http_headers(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         file_content_length: Optional[int] = None,
         file_permission: str = "inherit",
@@ -1550,22 +1718,27 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _file_content_type = None
         _file_content_encoding = None
         _file_content_language = None
         _file_cache_control = None
         _file_content_md5 = None
         _file_content_disposition = None
@@ -1593,24 +1766,26 @@
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             file_attributes=file_attributes,
             file_creation_time=file_creation_time,
             file_last_write_time=file_last_write_time,
             file_change_time=file_change_time,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.set_http_headers.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1643,15 +1818,15 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_http_headers.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    set_http_headers.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def set_metadata(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         metadata: Optional[Dict[str, str]] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -1673,42 +1848,49 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "metadata"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["metadata"] = kwargs.pop("comp", _params.pop("comp", "metadata"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_set_metadata_request(
             url=self._config.url,
             timeout=timeout,
             metadata=metadata,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.set_metadata.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1723,15 +1905,15 @@
         response_headers["x-ms-request-server-encrypted"] = self._deserialize(
             "bool", response.headers.get("x-ms-request-server-encrypted")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_metadata.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    set_metadata.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def acquire_lease(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         duration: Optional[int] = None,
         proposed_lease_id: Optional[str] = None,
@@ -1765,41 +1947,48 @@
          overriding this default value may result in unsupported behavior.
         :paramtype action: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["acquire"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_acquire_lease_request(
             url=self._config.url,
             timeout=timeout,
             duration=duration,
             proposed_lease_id=proposed_lease_id,
             request_id_parameter=request_id_parameter,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             action=action,
             version=self._config.version,
             template_url=self.acquire_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1816,15 +2005,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    acquire_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    acquire_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def release_lease(  # pylint: disable=inconsistent-return-statements
         self, lease_id: str, timeout: Optional[int] = None, request_id_parameter: Optional[str] = None, **kwargs: Any
     ) -> None:
         """[Update] The Lease File operation establishes and manages a lock on a file for write and delete
         operations.
@@ -1847,40 +2036,47 @@
          overriding this default value may result in unsupported behavior.
         :paramtype action: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["release"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_release_lease_request(
             url=self._config.url,
             lease_id=lease_id,
             timeout=timeout,
             request_id_parameter=request_id_parameter,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             action=action,
             version=self._config.version,
             template_url=self.release_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1896,15 +2092,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    release_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    release_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def change_lease(  # pylint: disable=inconsistent-return-statements
         self,
         lease_id: str,
         timeout: Optional[int] = None,
         proposed_lease_id: Optional[str] = None,
@@ -1936,41 +2132,48 @@
          overriding this default value may result in unsupported behavior.
         :paramtype action: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["change"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_change_lease_request(
             url=self._config.url,
             lease_id=lease_id,
             timeout=timeout,
             proposed_lease_id=proposed_lease_id,
             request_id_parameter=request_id_parameter,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             action=action,
             version=self._config.version,
             template_url=self.change_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1987,15 +2190,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    change_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    change_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def break_lease(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         request_id_parameter: Optional[str] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -2022,44 +2225,51 @@
          overriding this default value may result in unsupported behavior.
         :paramtype action: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["break"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_break_lease_request(
             url=self._config.url,
             timeout=timeout,
             lease_id=_lease_id,
             request_id_parameter=request_id_parameter,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             action=action,
             version=self._config.version,
             template_url=self.break_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2076,25 +2286,25 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    break_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    break_lease.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def upload_range(  # pylint: disable=inconsistent-return-statements
         self,
         range: str,
         content_length: int,
         timeout: Optional[int] = None,
-        file_range_write: Union[str, "_models.FileRangeWriteType"] = "update",
+        file_range_write: Union[str, _models.FileRangeWriteType] = "update",
         content_md5: Optional[bytes] = None,
-        file_last_written_mode: Optional[Union[str, "_models.FileLastWrittenMode"]] = None,
+        file_last_written_mode: Optional[Union[str, _models.FileLastWrittenMode]] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         optionalbody: Optional[IO] = None,
         **kwargs: Any
     ) -> None:
         """Upload a range of bytes to a file.
 
         :param range: Specifies the range of bytes to be written. Both the start and end of the range
@@ -2135,23 +2345,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "range"))  # type: str
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["range"] = kwargs.pop("comp", _params.pop("comp", "range"))
+        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
         _content = optionalbody
 
         request = build_upload_range_request(
@@ -2159,26 +2374,28 @@
             range=range,
             content_length=content_length,
             timeout=timeout,
             file_range_write=file_range_write,
             content_md5=content_md5,
             lease_id=_lease_id,
             file_last_written_mode=file_last_written_mode,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             content_type=content_type,
             version=self._config.version,
             content=_content,
             template_url=self.upload_range.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2198,27 +2415,27 @@
         response_headers["x-ms-file-last-write-time"] = self._deserialize(
             "str", response.headers.get("x-ms-file-last-write-time")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    upload_range.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    upload_range.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def upload_range_from_url(  # pylint: disable=inconsistent-return-statements
         self,
         range: str,
         copy_source: str,
         content_length: int,
         timeout: Optional[int] = None,
         source_range: Optional[str] = None,
         source_content_crc64: Optional[bytes] = None,
         copy_source_authorization: Optional[str] = None,
-        file_last_written_mode: Optional[Union[str, "_models.FileLastWrittenMode"]] = None,
+        file_last_written_mode: Optional[Union[str, _models.FileLastWrittenMode]] = None,
         source_modified_access_conditions: Optional[_models.SourceModifiedAccessConditions] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
     ) -> None:
         """Upload a range of bytes to a file where the contents are read from a URL.
 
         :param range: Writes data to the specified byte range in the file. Required.
@@ -2260,22 +2477,27 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "range"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["range"] = kwargs.pop("comp", _params.pop("comp", "range"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _source_if_match_crc64 = None
         _source_if_none_match_crc64 = None
         _lease_id = None
         if source_modified_access_conditions is not None:
             _source_if_match_crc64 = source_modified_access_conditions.source_if_match_crc64
             _source_if_none_match_crc64 = source_modified_access_conditions.source_if_none_match_crc64
@@ -2291,25 +2513,27 @@
             source_range=source_range,
             source_content_crc64=source_content_crc64,
             source_if_match_crc64=_source_if_match_crc64,
             source_if_none_match_crc64=_source_if_none_match_crc64,
             lease_id=_lease_id,
             copy_source_authorization=copy_source_authorization,
             file_last_written_mode=file_last_written_mode,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            allow_source_trailing_dot=self._config.allow_source_trailing_dot,
             comp=comp,
             file_range_write_from_url=self._config.file_range_write_from_url,
             version=self._config.version,
             template_url=self.upload_range_from_url.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2331,15 +2555,15 @@
         response_headers["x-ms-file-last-write-time"] = self._deserialize(
             "str", response.headers.get("x-ms-file-last-write-time")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    upload_range_from_url.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    upload_range_from_url.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def get_range_list(
         self,
         sharesnapshot: Optional[str] = None,
         prevsharesnapshot: Optional[str] = None,
         timeout: Optional[int] = None,
@@ -2369,44 +2593,51 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShareFileRangeList or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ShareFileRangeList
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "rangelist"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ShareFileRangeList]
+        comp: Literal["rangelist"] = kwargs.pop("comp", _params.pop("comp", "rangelist"))
+        cls: ClsType[_models.ShareFileRangeList] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_get_range_list_request(
             url=self._config.url,
             sharesnapshot=sharesnapshot,
             prevsharesnapshot=prevsharesnapshot,
             timeout=timeout,
             range=range,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.get_range_list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2424,15 +2655,15 @@
         deserialized = self._deserialize("ShareFileRangeList", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    get_range_list.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    get_range_list.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def start_copy(  # pylint: disable=inconsistent-return-statements
         self,
         copy_source: str,
         timeout: Optional[int] = None,
         metadata: Optional[Dict[str, str]] = None,
@@ -2475,21 +2706,26 @@
         :param lease_access_conditions: Parameter group. Default value is None.
         :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _file_permission_copy_mode = None
         _ignore_read_only = None
         _file_attributes = None
         _file_creation_time = None
         _file_last_write_time = None
         _file_change_time = None
@@ -2517,23 +2753,26 @@
             ignore_read_only=_ignore_read_only,
             file_attributes=_file_attributes,
             file_creation_time=_file_creation_time,
             file_last_write_time=_file_last_write_time,
             file_change_time=_file_change_time,
             set_archive_attribute=_set_archive_attribute,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            allow_source_trailing_dot=self._config.allow_source_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             version=self._config.version,
             template_url=self.start_copy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2548,15 +2787,15 @@
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
         response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
         response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    start_copy.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    start_copy.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def abort_copy(  # pylint: disable=inconsistent-return-statements
         self,
         copy_id: str,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -2582,46 +2821,53 @@
          default value may result in unsupported behavior.
         :paramtype copy_action_abort_constant: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "copy"))  # type: str
-        copy_action_abort_constant = kwargs.pop(
+        comp: Literal["copy"] = kwargs.pop("comp", _params.pop("comp", "copy"))
+        copy_action_abort_constant: Literal["abort"] = kwargs.pop(
             "copy_action_abort_constant", _headers.pop("x-ms-copy-action", "abort")
-        )  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        )
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_abort_copy_request(
             url=self._config.url,
             copy_id=copy_id,
             timeout=timeout,
             lease_id=_lease_id,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             copy_action_abort_constant=copy_action_abort_constant,
             version=self._config.version,
             template_url=self.abort_copy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2632,15 +2878,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    abort_copy.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    abort_copy.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def list_handles(
         self,
         marker: Optional[str] = None,
         maxresults: Optional[int] = None,
         timeout: Optional[int] = None,
@@ -2670,39 +2916,46 @@
          may result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ListHandlesResponse or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ListHandlesResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "listhandles"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ListHandlesResponse]
+        comp: Literal["listhandles"] = kwargs.pop("comp", _params.pop("comp", "listhandles"))
+        cls: ClsType[_models.ListHandlesResponse] = kwargs.pop("cls", None)
 
         request = build_list_handles_request(
             url=self._config.url,
             marker=marker,
             maxresults=maxresults,
             timeout=timeout,
             sharesnapshot=sharesnapshot,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.list_handles.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2718,15 +2971,15 @@
         deserialized = self._deserialize("ListHandlesResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    list_handles.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    list_handles.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def force_close_handles(  # pylint: disable=inconsistent-return-statements
         self,
         handle_id: str,
         timeout: Optional[int] = None,
         marker: Optional[str] = None,
@@ -2755,39 +3008,46 @@
          value may result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["forceclosehandles"] = kwargs.pop("comp", _params.pop("comp", "forceclosehandles"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_force_close_handles_request(
             url=self._config.url,
             handle_id=handle_id,
             timeout=timeout,
             marker=marker,
             sharesnapshot=sharesnapshot,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.force_close_handles.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2805,15 +3065,15 @@
         response_headers["x-ms-number-of-handles-failed"] = self._deserialize(
             "int", response.headers.get("x-ms-number-of-handles-failed")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    force_close_handles.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    force_close_handles.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
 
     @distributed_trace
     def rename(  # pylint: disable=inconsistent-return-statements
         self,
         rename_source: str,
         timeout: Optional[int] = None,
         replace_if_exists: Optional[bool] = None,
@@ -2876,22 +3136,27 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "rename"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["rename"] = kwargs.pop("comp", _params.pop("comp", "rename"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _source_lease_id = None
         _destination_lease_id = None
         _file_attributes = None
         _file_creation_time = None
         _file_last_write_time = None
         _file_change_time = None
@@ -2920,24 +3185,27 @@
             file_creation_time=_file_creation_time,
             file_last_write_time=_file_last_write_time,
             file_change_time=_file_change_time,
             file_permission=file_permission,
             file_permission_key=file_permission_key,
             metadata=metadata,
             file_content_type=_file_content_type,
+            allow_trailing_dot=self._config.allow_trailing_dot,
+            allow_source_trailing_dot=self._config.allow_source_trailing_dot,
+            file_request_intent=self._config.file_request_intent,
             comp=comp,
             version=self._config.version,
             template_url=self.rename.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2970,8 +3238,8 @@
         )
         response_headers["x-ms-file-id"] = self._deserialize("str", response.headers.get("x-ms-file-id"))
         response_headers["x-ms-file-parent-id"] = self._deserialize("str", response.headers.get("x-ms-file-parent-id"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    rename.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}  # type: ignore
+    rename.metadata = {"url": "{url}/{shareName}/{directory}/{fileName}"}
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_service_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,59 +2,65 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, List, Optional, TypeVar, Union
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_set_properties_request(
     url: str, *, content: Any, timeout: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "service"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["service"] = kwargs.pop("restype", _params.pop("restype", "service"))
+    comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -67,26 +73,26 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, content=content, **kwargs)
 
 
 def build_get_properties_request(url: str, *, timeout: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "service"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["service"] = kwargs.pop("restype", _params.pop("restype", "service"))
+    comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -99,32 +105,32 @@
 
 def build_list_shares_segment_request(
     url: str,
     *,
     prefix: Optional[str] = None,
     marker: Optional[str] = None,
     maxresults: Optional[int] = None,
-    include: Optional[List[Union[str, "_models.ListSharesIncludeType"]]] = None,
+    include: Optional[List[Union[str, _models.ListSharesIncludeType]]] = None,
     timeout: Optional[int] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "list"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["list"] = kwargs.pop("comp", _params.pop("comp", "list"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if prefix is not None:
         _params["prefix"] = _SERIALIZER.query("prefix", prefix, "str")
     if marker is not None:
         _params["marker"] = _SERIALIZER.query("marker", marker, "str")
@@ -182,24 +188,29 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "service"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["service"] = kwargs.pop("restype", _params.pop("restype", "service"))
+        comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _content = self._serialize.body(storage_service_properties, "StorageServiceProperties", is_xml=True)
 
         request = build_set_properties_request(
             url=self._config.url,
             timeout=timeout,
             restype=restype,
@@ -208,17 +219,17 @@
             version=self._config.version,
             content=_content,
             template_url=self.set_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -228,15 +239,15 @@
         response_headers = {}
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_properties.metadata = {"url": "{url}"}  # type: ignore
+    set_properties.metadata = {"url": "{url}"}
 
     @distributed_trace
     def get_properties(self, timeout: Optional[int] = None, **kwargs: Any) -> _models.StorageServiceProperties:
         """Gets the properties of a storage account's File service, including properties for Storage
         Analytics metrics and CORS (Cross-Origin Resource Sharing) rules.
 
         :param timeout: The timeout parameter is expressed in seconds. For more information, see
@@ -251,38 +262,43 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageServiceProperties or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.StorageServiceProperties
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "service"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageServiceProperties]
+        restype: Literal["service"] = kwargs.pop("restype", _params.pop("restype", "service"))
+        comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+        cls: ClsType[_models.StorageServiceProperties] = kwargs.pop("cls", None)
 
         request = build_get_properties_request(
             url=self._config.url,
             timeout=timeout,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.get_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -296,23 +312,23 @@
         deserialized = self._deserialize("StorageServiceProperties", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    get_properties.metadata = {"url": "{url}"}  # type: ignore
+    get_properties.metadata = {"url": "{url}"}
 
     @distributed_trace
     def list_shares_segment(
         self,
         prefix: Optional[str] = None,
         marker: Optional[str] = None,
         maxresults: Optional[int] = None,
-        include: Optional[List[Union[str, "_models.ListSharesIncludeType"]]] = None,
+        include: Optional[List[Union[str, _models.ListSharesIncludeType]]] = None,
         timeout: Optional[int] = None,
         **kwargs: Any
     ) -> _models.ListSharesResponse:
         """The List Shares Segment operation returns a list of the shares and share snapshots under the
         specified account.
 
         :param prefix: Filters the results to return only entries whose name begins with the specified
@@ -339,22 +355,27 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ListSharesResponse or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ListSharesResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "list"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ListSharesResponse]
+        comp: Literal["list"] = kwargs.pop("comp", _params.pop("comp", "list"))
+        cls: ClsType[_models.ListSharesResponse] = kwargs.pop("cls", None)
 
         request = build_list_shares_segment_request(
             url=self._config.url,
             prefix=prefix,
             marker=marker,
             maxresults=maxresults,
             include=include,
@@ -362,17 +383,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.list_shares_segment.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -386,8 +407,8 @@
         deserialized = self._deserialize("ListSharesResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    list_shares_segment.metadata = {"url": "{url}"}  # type: ignore
+    list_shares_segment.metadata = {"url": "{url}"}
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_share_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_share_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,65 +2,71 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(
     url: str,
     *,
     timeout: Optional[int] = None,
     metadata: Optional[Dict[str, str]] = None,
     quota: Optional[int] = None,
-    access_tier: Optional[Union[str, "_models.ShareAccessTier"]] = None,
+    access_tier: Optional[Union[str, _models.ShareAccessTier]] = None,
     enabled_protocols: Optional[str] = None,
-    root_squash: Optional[Union[str, "_models.ShareRootSquash"]] = None,
+    root_squash: Optional[Union[str, _models.ShareRootSquash]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
@@ -87,25 +93,25 @@
     timeout: Optional[int] = None,
     lease_id: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if sharesnapshot is not None:
         _params["sharesnapshot"] = _SERIALIZER.query("sharesnapshot", sharesnapshot, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
@@ -120,32 +126,32 @@
 
 
 def build_delete_request(
     url: str,
     *,
     sharesnapshot: Optional[str] = None,
     timeout: Optional[int] = None,
-    delete_snapshots: Optional[Union[str, "_models.DeleteSnapshotsOptionType"]] = None,
+    delete_snapshots: Optional[Union[str, _models.DeleteSnapshotsOptionType]] = None,
     lease_id: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if sharesnapshot is not None:
         _params["sharesnapshot"] = _SERIALIZER.query("sharesnapshot", sharesnapshot, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
@@ -170,27 +176,27 @@
     sharesnapshot: Optional[str] = None,
     request_id_parameter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-    action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))  # type: str
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+    action: Literal["acquire"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
     if sharesnapshot is not None:
@@ -218,27 +224,27 @@
     sharesnapshot: Optional[str] = None,
     request_id_parameter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-    action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))  # type: str
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+    action: Literal["release"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
     if sharesnapshot is not None:
@@ -264,27 +270,27 @@
     sharesnapshot: Optional[str] = None,
     request_id_parameter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-    action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))  # type: str
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+    action: Literal["change"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
     if sharesnapshot is not None:
@@ -311,27 +317,27 @@
     sharesnapshot: Optional[str] = None,
     request_id_parameter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-    action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "renew"))  # type: str
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+    action: Literal["renew"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "renew"))
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
     if sharesnapshot is not None:
@@ -357,27 +363,27 @@
     request_id_parameter: Optional[str] = None,
     sharesnapshot: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-    action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))  # type: str
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+    action: Literal["break"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
     if sharesnapshot is not None:
@@ -399,26 +405,26 @@
 
 def build_create_snapshot_request(
     url: str, *, timeout: Optional[int] = None, metadata: Optional[Dict[str, str]] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "snapshot"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    comp: Literal["snapshot"] = kwargs.pop("comp", _params.pop("comp", "snapshot"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -427,105 +433,120 @@
         _headers["x-ms-meta"] = _SERIALIZER.header("metadata", metadata, "{str}")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_create_permission_request(url: str, *, timeout: Optional[int] = None, **kwargs: Any) -> HttpRequest:
+def build_create_permission_request(
+    url: str,
+    *,
+    timeout: Optional[int] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
+    **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "filepermission"))  # type: str
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    comp: Literal["filepermission"] = kwargs.pop("comp", _params.pop("comp", "filepermission"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_permission_request(
-    url: str, *, file_permission_key: str, timeout: Optional[int] = None, **kwargs: Any
+    url: str,
+    *,
+    file_permission_key: str,
+    timeout: Optional[int] = None,
+    file_request_intent: Optional[Union[str, _models.ShareTokenIntent]] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "filepermission"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    comp: Literal["filepermission"] = kwargs.pop("comp", _params.pop("comp", "filepermission"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
     # Construct headers
     _headers["x-ms-file-permission-key"] = _SERIALIZER.header("file_permission_key", file_permission_key, "str")
     _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
+    if file_request_intent is not None:
+        _headers["x-ms-file-request-intent"] = _SERIALIZER.header("file_request_intent", file_request_intent, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_properties_request(
     url: str,
     *,
     timeout: Optional[int] = None,
     quota: Optional[int] = None,
-    access_tier: Optional[Union[str, "_models.ShareAccessTier"]] = None,
+    access_tier: Optional[Union[str, _models.ShareAccessTier]] = None,
     lease_id: Optional[str] = None,
-    root_squash: Optional[Union[str, "_models.ShareRootSquash"]] = None,
+    root_squash: Optional[Union[str, _models.ShareRootSquash]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -551,26 +572,26 @@
     metadata: Optional[Dict[str, str]] = None,
     lease_id: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "metadata"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    comp: Literal["metadata"] = kwargs.pop("comp", _params.pop("comp", "metadata"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -587,26 +608,26 @@
 
 def build_get_access_policy_request(
     url: str, *, timeout: Optional[int] = None, lease_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "acl"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    comp: Literal["acl"] = kwargs.pop("comp", _params.pop("comp", "acl"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -621,27 +642,27 @@
 
 def build_set_access_policy_request(
     url: str, *, timeout: Optional[int] = None, lease_id: Optional[str] = None, content: Any = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "acl"))  # type: str
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    comp: Literal["acl"] = kwargs.pop("comp", _params.pop("comp", "acl"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -658,26 +679,26 @@
 
 def build_get_statistics_request(
     url: str, *, timeout: Optional[int] = None, lease_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "stats"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    comp: Literal["stats"] = kwargs.pop("comp", _params.pop("comp", "stats"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -698,26 +719,26 @@
     deleted_share_name: Optional[str] = None,
     deleted_share_version: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-    comp = kwargs.pop("comp", _params.pop("comp", "undelete"))  # type: str
-    version = kwargs.pop("version", _headers.pop("x-ms-version", "2021-06-08"))  # type: str
+    restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+    comp: Literal["undelete"] = kwargs.pop("comp", _params.pop("comp", "undelete"))
+    version: Literal["2022-11-02"] = kwargs.pop("version", _headers.pop("x-ms-version", "2022-11-02"))
     accept = _headers.pop("Accept", "application/xml")
 
     # Construct URL
     _url = kwargs.pop("template_url", "{url}/{shareName}")
     path_format_arguments = {
         "url": _SERIALIZER.url("url", url, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["restype"] = _SERIALIZER.query("restype", restype, "str")
     _params["comp"] = _SERIALIZER.query("comp", comp, "str")
     if timeout is not None:
         _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int", minimum=0)
 
@@ -757,17 +778,17 @@
 
     @distributed_trace
     def create(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         metadata: Optional[Dict[str, str]] = None,
         quota: Optional[int] = None,
-        access_tier: Optional[Union[str, "_models.ShareAccessTier"]] = None,
+        access_tier: Optional[Union[str, _models.ShareAccessTier]] = None,
         enabled_protocols: Optional[str] = None,
-        root_squash: Optional[Union[str, "_models.ShareRootSquash"]] = None,
+        root_squash: Optional[Union[str, _models.ShareRootSquash]] = None,
         **kwargs: Any
     ) -> None:
         """Creates a new share under the specified account. If the share with the same name already
         exists, the operation fails.
 
         :param timeout: The timeout parameter is expressed in seconds. For more information, see
          :code:`<a
@@ -791,22 +812,27 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_create_request(
             url=self._config.url,
             timeout=timeout,
             metadata=metadata,
             quota=quota,
             access_tier=access_tier,
@@ -815,17 +841,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -838,15 +864,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    create.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    create.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def get_properties(  # pylint: disable=inconsistent-return-statements
         self,
         sharesnapshot: Optional[str] = None,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -869,22 +895,27 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_get_properties_request(
             url=self._config.url,
@@ -894,17 +925,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.get_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -948,22 +979,22 @@
             "str", response.headers.get("x-ms-enabled-protocols")
         )
         response_headers["x-ms-root-squash"] = self._deserialize("str", response.headers.get("x-ms-root-squash"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    get_properties.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    get_properties.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def delete(  # pylint: disable=inconsistent-return-statements
         self,
         sharesnapshot: Optional[str] = None,
         timeout: Optional[int] = None,
-        delete_snapshots: Optional[Union[str, "_models.DeleteSnapshotsOptionType"]] = None,
+        delete_snapshots: Optional[Union[str, _models.DeleteSnapshotsOptionType]] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
     ) -> None:
         """Operation marks the specified share or share snapshot for deletion. The share or share snapshot
         and any files contained within it are later deleted during garbage collection.
 
         :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
@@ -983,22 +1014,27 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_delete_request(
             url=self._config.url,
@@ -1009,17 +1045,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1030,15 +1066,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    delete.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    delete.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def acquire_lease(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         duration: Optional[int] = None,
         proposed_lease_id: Optional[str] = None,
@@ -1079,24 +1115,29 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))  # type: str
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["acquire"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "acquire"))
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_acquire_lease_request(
             url=self._config.url,
             timeout=timeout,
             duration=duration,
             proposed_lease_id=proposed_lease_id,
             sharesnapshot=sharesnapshot,
@@ -1106,17 +1147,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.acquire_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1133,15 +1174,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    acquire_lease.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    acquire_lease.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def release_lease(  # pylint: disable=inconsistent-return-statements
         self,
         lease_id: str,
         timeout: Optional[int] = None,
         sharesnapshot: Optional[str] = None,
@@ -1175,24 +1216,29 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))  # type: str
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["release"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "release"))
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_release_lease_request(
             url=self._config.url,
             lease_id=lease_id,
             timeout=timeout,
             sharesnapshot=sharesnapshot,
             request_id_parameter=request_id_parameter,
@@ -1201,17 +1247,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.release_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1227,15 +1273,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    release_lease.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    release_lease.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def change_lease(  # pylint: disable=inconsistent-return-statements
         self,
         lease_id: str,
         timeout: Optional[int] = None,
         proposed_lease_id: Optional[str] = None,
@@ -1274,24 +1320,29 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))  # type: str
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["change"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "change"))
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_change_lease_request(
             url=self._config.url,
             lease_id=lease_id,
             timeout=timeout,
             proposed_lease_id=proposed_lease_id,
             sharesnapshot=sharesnapshot,
@@ -1301,17 +1352,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.change_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1328,15 +1379,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    change_lease.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    change_lease.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def renew_lease(  # pylint: disable=inconsistent-return-statements
         self,
         lease_id: str,
         timeout: Optional[int] = None,
         sharesnapshot: Optional[str] = None,
@@ -1370,24 +1421,29 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "renew"))  # type: str
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["renew"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "renew"))
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_renew_lease_request(
             url=self._config.url,
             lease_id=lease_id,
             timeout=timeout,
             sharesnapshot=sharesnapshot,
             request_id_parameter=request_id_parameter,
@@ -1396,17 +1452,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.renew_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1423,15 +1479,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    renew_lease.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    renew_lease.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def break_lease(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         break_period: Optional[int] = None,
         request_id_parameter: Optional[str] = None,
@@ -1474,24 +1530,29 @@
          may result in unsupported behavior.
         :paramtype restype: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        comp = kwargs.pop("comp", _params.pop("comp", "lease"))  # type: str
-        action = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))  # type: str
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        comp: Literal["lease"] = kwargs.pop("comp", _params.pop("comp", "lease"))
+        action: Literal["break"] = kwargs.pop("action", _headers.pop("x-ms-lease-action", "break"))
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_break_lease_request(
             url=self._config.url,
@@ -1505,17 +1566,17 @@
             restype=restype,
             version=self._config.version,
             template_url=self.break_lease.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1533,15 +1594,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    break_lease.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    break_lease.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def create_snapshot(  # pylint: disable=inconsistent-return-statements
         self, timeout: Optional[int] = None, metadata: Optional[Dict[str, str]] = None, **kwargs: Any
     ) -> None:
         """Creates a read-only snapshot of a share.
 
@@ -1560,39 +1621,44 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "snapshot"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["snapshot"] = kwargs.pop("comp", _params.pop("comp", "snapshot"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_create_snapshot_request(
             url=self._config.url,
             timeout=timeout,
             metadata=metadata,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.create_snapshot.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1606,15 +1672,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    create_snapshot.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    create_snapshot.metadata = {"url": "{url}/{shareName}"}
 
     @overload
     def create_permission(  # pylint: disable=inconsistent-return-statements
         self,
         share_permission: _models.SharePermission,
         timeout: Optional[int] = None,
         *,
@@ -1681,15 +1747,15 @@
     @distributed_trace
     def create_permission(  # pylint: disable=inconsistent-return-statements
         self, share_permission: Union[_models.SharePermission, IO], timeout: Optional[int] = None, **kwargs: Any
     ) -> None:
         """Create a permission (a security descriptor).
 
         :param share_permission: A permission (a security descriptor) at the share level. Is either a
-         model type or a IO type. Required.
+         SharePermission type or a IO type. Required.
         :type share_permission: ~azure.storage.fileshare.models.SharePermission or IO
         :param timeout: The timeout parameter is expressed in seconds. For more information, see
          :code:`<a
          href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
          Timeouts for File Service Operations.</a>`. Default value is None.
         :type timeout: int
         :keyword restype: restype. Default value is "share". Note that overriding this default value
@@ -1702,50 +1768,56 @@
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "filepermission"))  # type: str
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["filepermission"] = kwargs.pop("comp", _params.pop("comp", "filepermission"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(share_permission, (IO, bytes)):
             _content = share_permission
         else:
             _json = self._serialize.body(share_permission, "SharePermission")
 
         request = build_create_permission_request(
             url=self._config.url,
             timeout=timeout,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             content_type=content_type,
             version=self._config.version,
             json=_json,
             content=_content,
             template_url=self.create_permission.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1759,15 +1831,15 @@
         response_headers["x-ms-file-permission-key"] = self._deserialize(
             "str", response.headers.get("x-ms-file-permission-key")
         )
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    create_permission.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    create_permission.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def get_permission(
         self, file_permission_key: str, timeout: Optional[int] = None, **kwargs: Any
     ) -> _models.SharePermission:
         """Returns the permission (security descriptor) for a given key.
 
@@ -1785,39 +1857,45 @@
          may result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SharePermission or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.SharePermission
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "filepermission"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SharePermission]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["filepermission"] = kwargs.pop("comp", _params.pop("comp", "filepermission"))
+        cls: ClsType[_models.SharePermission] = kwargs.pop("cls", None)
 
         request = build_get_permission_request(
             url=self._config.url,
             file_permission_key=file_permission_key,
             timeout=timeout,
+            file_request_intent=self._config.file_request_intent,
             restype=restype,
             comp=comp,
             version=self._config.version,
             template_url=self.get_permission.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1832,23 +1910,23 @@
         deserialized = self._deserialize("SharePermission", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    get_permission.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    get_permission.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def set_properties(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         quota: Optional[int] = None,
-        access_tier: Optional[Union[str, "_models.ShareAccessTier"]] = None,
-        root_squash: Optional[Union[str, "_models.ShareRootSquash"]] = None,
+        access_tier: Optional[Union[str, _models.ShareAccessTier]] = None,
+        root_squash: Optional[Union[str, _models.ShareRootSquash]] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
     ) -> None:
         """Sets properties for the specified share.
 
         :param timeout: The timeout parameter is expressed in seconds. For more information, see
          :code:`<a
@@ -1872,23 +1950,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["properties"] = kwargs.pop("comp", _params.pop("comp", "properties"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_set_properties_request(
             url=self._config.url,
@@ -1901,17 +1984,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.set_properties.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1924,15 +2007,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_properties.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    set_properties.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def set_metadata(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         metadata: Optional[Dict[str, str]] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
@@ -1957,23 +2040,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "metadata"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["metadata"] = kwargs.pop("comp", _params.pop("comp", "metadata"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_set_metadata_request(
             url=self._config.url,
@@ -1984,17 +2072,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.set_metadata.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2007,15 +2095,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_metadata.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    set_metadata.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def get_access_policy(
         self,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
@@ -2036,23 +2124,28 @@
          in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: list of SignedIdentifier or the result of cls(response)
         :rtype: list[~azure.storage.fileshare.models.SignedIdentifier]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "acl"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[List[_models.SignedIdentifier]]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["acl"] = kwargs.pop("comp", _params.pop("comp", "acl"))
+        cls: ClsType[List[_models.SignedIdentifier]] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_get_access_policy_request(
             url=self._config.url,
@@ -2062,17 +2155,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.get_access_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2089,15 +2182,15 @@
         deserialized = self._deserialize("[SignedIdentifier]", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    get_access_policy.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    get_access_policy.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def set_access_policy(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         share_acl: Optional[List[_models.SignedIdentifier]] = None,
@@ -2121,24 +2214,29 @@
          in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "acl"))  # type: str
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["acl"] = kwargs.pop("comp", _params.pop("comp", "acl"))
+        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
         serialization_ctxt = {"xml": {"name": "SignedIdentifiers", "wrapped": True}}
         if share_acl is not None:
             _content = self._serialize.body(
@@ -2157,17 +2255,17 @@
             version=self._config.version,
             content=_content,
             template_url=self.set_access_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2180,15 +2278,15 @@
         response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    set_access_policy.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    set_access_policy.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def get_statistics(
         self,
         timeout: Optional[int] = None,
         lease_access_conditions: Optional[_models.LeaseAccessConditions] = None,
         **kwargs: Any
@@ -2209,23 +2307,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShareStats or the result of cls(response)
         :rtype: ~azure.storage.fileshare.models.ShareStats
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "stats"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ShareStats]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["stats"] = kwargs.pop("comp", _params.pop("comp", "stats"))
+        cls: ClsType[_models.ShareStats] = kwargs.pop("cls", None)
 
         _lease_id = None
         if lease_access_conditions is not None:
             _lease_id = lease_access_conditions.lease_id
 
         request = build_get_statistics_request(
             url=self._config.url,
@@ -2235,17 +2338,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.get_statistics.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2262,15 +2365,15 @@
         deserialized = self._deserialize("ShareStats", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    get_statistics.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    get_statistics.metadata = {"url": "{url}/{shareName}"}
 
     @distributed_trace
     def restore(  # pylint: disable=inconsistent-return-statements
         self,
         timeout: Optional[int] = None,
         request_id_parameter: Optional[str] = None,
         deleted_share_name: Optional[str] = None,
@@ -2301,23 +2404,28 @@
          result in unsupported behavior.
         :paramtype comp: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        restype = kwargs.pop("restype", _params.pop("restype", "share"))  # type: str
-        comp = kwargs.pop("comp", _params.pop("comp", "undelete"))  # type: str
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        restype: Literal["share"] = kwargs.pop("restype", _params.pop("restype", "share"))
+        comp: Literal["undelete"] = kwargs.pop("comp", _params.pop("comp", "undelete"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_restore_request(
             url=self._config.url,
             timeout=timeout,
             request_id_parameter=request_id_parameter,
             deleted_share_name=deleted_share_name,
             deleted_share_version=deleted_share_version,
@@ -2325,17 +2433,17 @@
             comp=comp,
             version=self._config.version,
             template_url=self.restore.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2351,8 +2459,8 @@
         )
         response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
         response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
-    restore.metadata = {"url": "{url}/{shareName}"}  # type: ignore
+    restore.metadata = {"url": "{url}/{shareName}"}
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_lease.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_lease.py`

 * *Files 14% similar despite different names*

```diff
@@ -82,15 +82,19 @@
         :keyword int lease_duration:
             Specifies the duration of the lease, in seconds, or negative one
             (-1) for a lease that never expires. File leases never expire. A non-infinite share lease can be
             between 15 and 60 seconds. A share lease duration cannot be changed
             using renew or change. Default is -1 (infinite share lease).
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
         """
         try:
             lease_duration = kwargs.pop('lease_duration', -1)
             if self._snapshot:
                 kwargs['sharesnapshot'] = self._snapshot
             response = self._client.acquire_lease(
@@ -115,15 +119,19 @@
         the lease may be renewed even if it has expired as long as the share
         has not been leased again since the expiration of that lease. When you
         renew a lease, the lease duration clock resets.
 
         .. versionadded:: 12.6.0
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :return: None
         """
         if isinstance(self._client, FileOperations):
             raise TypeError("Lease renewal operations are only valid for ShareClient.")
         try:
             response = self._client.renew_lease(
                 lease_id=self.id,
@@ -141,15 +149,19 @@
     def release(self, **kwargs):
         # type: (Any) -> None
         """Releases the lease. The lease may be released if the lease ID specified on the request matches
         that associated with the share or file. Releasing the lease allows another client to immediately acquire
         the lease for the share or file as soon as the release is complete.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :return: None
         """
         try:
             if self._snapshot:
                 kwargs['sharesnapshot'] = self._snapshot
             response = self._client.release_lease(
                 lease_id=self.id,
@@ -168,15 +180,19 @@
         """ Changes the lease ID of an active lease. A change must include the current lease ID in x-ms-lease-id and
         a new lease ID in x-ms-proposed-lease-id.
 
         :param str proposed_lease_id:
             Proposed lease ID, in a GUID string format. The File or Share service will raise an error
             (Invalid request) if the proposed lease ID is not in the correct format.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :return: None
         """
         try:
             if self._snapshot:
                 kwargs['sharesnapshot'] = self._snapshot
             response = self._client.change_lease(
                 lease_id=self.id,
@@ -211,15 +227,19 @@
             period. If this header does not appear with a break
             operation, a fixed-duration share lease breaks after the remaining share lease
             period elapses, and an infinite share lease breaks immediately.
 
             .. versionadded:: 12.6.0
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :return: Approximate time remaining in the lease period, in seconds.
         :rtype: int
         """
         try:
             lease_break_period = kwargs.pop('lease_break_period', None)
             if self._snapshot:
                 kwargs['sharesnapshot'] = self._snapshot
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_models.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=too-few-public-methods, too-many-instance-attributes
 # pylint: disable=super-init-not-called, too-many-lines
-
+from urllib.parse import unquote
 from enum import Enum
 
 from azure.core import CaseInsensitiveEnumMeta
 from azure.core.paging import PageIterator
 from azure.core.exceptions import HttpResponseError
 
 from ._parser import _parse_datetime_from_str
@@ -477,15 +477,15 @@
         self.open_time = kwargs.get('open_time')
         self.last_reconnect_time = kwargs.get('last_reconnect_time')
 
     @classmethod
     def _from_generated(cls, generated):
         handle = cls()
         handle.id = generated.handle_id
-        handle.path = generated.path
+        handle.path = unquote(generated.path.content) if generated.path.encoded else generated.path.content
         handle.file_id = generated.file_id
         handle.parent_id = generated.parent_id
         handle.session_id = generated.session_id
         handle.client_ip = generated.client_ip
         handle.open_time = generated.open_time
         handle.last_reconnect_time = generated.last_reconnect_time
         return handle
@@ -586,15 +586,15 @@
         self.file_id = kwargs.get('x-ms-file-id')
         self.parent_id = kwargs.get('x-ms-file-parent-id')
         self.is_directory = True
 
     @classmethod
     def _from_generated(cls, generated):
         props = cls()
-        props.name = generated.name
+        props.name = unquote(generated.name.content) if generated.name.encoded else generated.name.content
         props.file_id = generated.file_id
         props.file_attributes = generated.attributes
         props.last_modified = generated.properties.last_modified
         props.creation_time = generated.properties.creation_time
         props.last_access_time = generated.properties.last_access_time
         props.last_write_time = generated.properties.last_write_time
         props.change_time = generated.properties.change_time
@@ -724,15 +724,15 @@
         self.file_id = kwargs.get('x-ms-file-id')
         self.parent_id = kwargs.get('x-ms-file-parent-id')
         self.is_directory = False
 
     @classmethod
     def _from_generated(cls, generated):
         props = cls()
-        props.name = generated.name
+        props.name = unquote(generated.name.content) if generated.name.encoded else generated.name.content
         props.file_id = generated.file_id
         props.etag = generated.properties.etag
         props.file_attributes = generated.attributes
         props.last_modified = generated.properties.last_modified
         props.creation_time = generated.properties.creation_time
         props.last_access_time = generated.properties.last_access_time
         props.last_write_time = generated.properties.last_write_time
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_parser.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_parser.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_serialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_serialize.py`

 * *Files 1% similar despite different names*

```diff
@@ -28,15 +28,18 @@
     '2020-02-10',
     '2020-04-08',
     '2020-06-12',
     '2020-08-04',
     '2020-10-02',
     '2021-02-12',
     '2021-04-10',
-    '2021-06-08'
+    '2021-06-08',
+    '2021-08-06',
+    '2021-12-02',
+    '2022-11-02'
 ]
 
 
 def _get_match_headers(kwargs, match_param, etag_param):
     # type: (Dict[str, Any], str, str) -> Tuple(Optional[str], Optional[str])
     # TODO: extract this method to shared folder also add some comments, so that share, datalake and blob can use it.
     if_match = None
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_share_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_share_client_async.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,61 +1,58 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
-
-from typing import (  # pylint: disable=unused-import
+# pylint: disable=invalid-overridden-method
+import warnings
+import sys
+from typing import ( # pylint: disable=unused-import
     Optional, Union, Dict, Any, Iterable, TYPE_CHECKING
 )
 
-
-try:
-    from urllib.parse import urlparse, quote, unquote
-except ImportError:
-    from urlparse import urlparse # type: ignore
-    from urllib2 import quote, unquote # type: ignore
-
-import six
 from azure.core.exceptions import HttpResponseError
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.pipeline import Pipeline
-from ._shared.base_client import StorageAccountHostsMixin, TransportWrapper, parse_connection_str, parse_query
-from ._shared.request_handlers import add_metadata_headers, serialize_iso
-from ._shared.response_handlers import (
+from azure.core.tracing.decorator_async import distributed_trace_async
+from azure.core.pipeline import AsyncPipeline
+from .._shared.policies_async import ExponentialRetry
+from .._shared.base_client_async import AsyncStorageAccountHostsMixin, AsyncTransportWrapper
+from .._shared.request_handlers import add_metadata_headers, serialize_iso
+from .._shared.response_handlers import (
     return_response_headers,
     process_storage_error,
     return_headers_and_deserialized)
-from ._generated import AzureFileStorage
-from ._generated.models import (
+from .._generated.aio import AzureFileStorage
+from .._generated.models import (
     SignedIdentifier,
-    DeleteSnapshotsOptionType,
-    SharePermission)
-from ._deserialize import deserialize_share_properties, deserialize_permission_key, deserialize_permission
-from ._serialize import get_api_version, get_access_conditions
-from ._directory_client import ShareDirectoryClient
-from ._file_client import ShareFileClient
-from ._lease import ShareLeaseClient
-from ._models import ShareProtocols
-
+    DeleteSnapshotsOptionType)
+from .._deserialize import deserialize_share_properties, deserialize_permission
+from .._serialize import get_api_version, get_access_conditions
+from .._share_client import ShareClient as ShareClientBase
+from ._directory_client_async import ShareDirectoryClient
+from ._file_client_async import ShareFileClient
+from ..aio._lease_async import ShareLeaseClient
+from .._models import ShareProtocols
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # pylint: disable=ungrouped-imports
 
 if TYPE_CHECKING:
-    from ._models import ShareProperties, AccessPolicy
+    from azure.core.credentials import AzureNamedKeyCredential, AzureSasCredential, TokenCredential
+    from .._models import ShareProperties, AccessPolicy
 
 
-class ShareClient(StorageAccountHostsMixin): # pylint: disable=too-many-public-methods
+class ShareClient(AsyncStorageAccountHostsMixin, ShareClientBase):
     """A client to interact with a specific share, although that share may not yet exist.
 
     For operations relating to a specific directory or file in this share, the clients for
     those entities can also be retrieved using the :func:`get_directory_client` and :func:`get_file_client` functions.
 
-    For more optional configuration, please click
-    `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
-    #optional-configuration>`_.
-
     :param str account_url:
         The URI to the storage account. In order to create a client given the full URI to the share,
         use the :func:`from_share_url` classmethod.
     :param share_name:
         The name of the share with which to interact.
     :type share_name: str
     :param str snapshot:
@@ -66,225 +63,107 @@
         account URL already has a SAS token. The value can be a SAS token string,
         an instance of a AzureSasCredential or AzureNamedKeyCredential from azure.core.credentials,
         an account shared access key, or an instance of a TokenCredentials class from azure.identity.
         If the resource URI already contains a SAS token, this will be ignored in favor of an explicit credential
         - except in the case of AzureSasCredential, where the conflicting SAS tokens will raise a ValueError.
         If using an instance of AzureNamedKeyCredential, "name" should be the storage account name, and "key"
         should be the storage account key.
+    :keyword token_intent:
+        Required when using `TokenCredential` for authentication and ignored for other forms of authentication.
+        Specifies the intent for all requests when using `TokenCredential` authentication. Possible values are:
+
+        backup - Specifies requests are intended for backup/admin type operations, meaning that all file/directory
+                 ACLs are bypassed and full permissions are granted. User must also have required RBAC permission.
+
+    :paramtype token_intent: Literal['backup']
+    :keyword bool allow_trailing_dot: If true, the trailing dot will not be trimmed from the target URI.
+    :keyword bool allow_source_trailing_dot: If true, the trailing dot will not be trimmed from the source URI.
     :keyword str api_version:
         The Storage API version to use for requests. Default value is the most recent service version that is
         compatible with the current SDK. Setting to an older version may result in reduced feature compatibility.
 
         .. versionadded:: 12.1.0
 
     :keyword str secondary_hostname:
         The hostname of the secondary endpoint.
     :keyword int max_range_size: The maximum range size used for a file upload. Defaults to 4*1024*1024.
     """
-    def __init__( # type: ignore
-            self, account_url,  # type: str
-            share_name,  # type: str
-            snapshot=None,  # type: Optional[Union[str, Dict[str, Any]]]
-            credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs  # type: Any
-        ):
-        # type: (...) -> None
-        try:
-            if not account_url.lower().startswith('http'):
-                account_url = "https://" + account_url
-        except AttributeError:
-            raise ValueError("Account URL must be a string.")
-        parsed_url = urlparse(account_url.rstrip('/'))
-        if not share_name:
-            raise ValueError("Please specify a share name.")
-        if not parsed_url.netloc:
-            raise ValueError("Invalid URL: {}".format(account_url))
-        if hasattr(credential, 'get_token'):
-            raise ValueError("Token credentials not supported by the File service.")
-
-        path_snapshot = None
-        path_snapshot, sas_token = parse_query(parsed_url.query)
-        if not sas_token and not credential:
-            raise ValueError(
-                'You need to provide either an account shared key or SAS token when creating a storage service.')
-        try:
-            self.snapshot = snapshot.snapshot # type: ignore
-        except AttributeError:
-            try:
-                self.snapshot = snapshot['snapshot'] # type: ignore
-            except TypeError:
-                self.snapshot = snapshot or path_snapshot
-
-        self.share_name = share_name
-        self._query_str, credential = self._format_query_string(
-            sas_token, credential, share_snapshot=self.snapshot)
-        super(ShareClient, self).__init__(parsed_url, service='file-share', credential=credential, **kwargs)
-        self._client = AzureFileStorage(url=self.url, base_url=self.url, pipeline=self._pipeline)
-        self._client._config.version = get_api_version(kwargs) # pylint: disable=protected-access
-
-    @classmethod
-    def from_share_url(cls, share_url,  # type: str
-                       snapshot=None,  # type: Optional[Union[str, Dict[str, Any]]]
-                       credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-                       **kwargs  # type: Any
-                       ):
-        # type: (...) -> ShareClient
-        """
-        :param str share_url: The full URI to the share.
-        :param str snapshot:
-            An optional share snapshot on which to operate. This can be the snapshot ID string
-            or the response returned from :func:`create_snapshot`.
-        :param credential:
-            The credentials with which to authenticate. This is optional if the
-            account URL already has a SAS token. The value can be a SAS token string,
-            an instance of a AzureSasCredential or AzureNamedKeyCredential from azure.core.credentials,
-            an account shared access key, or an instance of a TokenCredentials class from azure.identity.
-            If the resource URI already contains a SAS token, this will be ignored in favor of an explicit credential
-            - except in the case of AzureSasCredential, where the conflicting SAS tokens will raise a ValueError.
-            If using an instance of AzureNamedKeyCredential, "name" should be the storage account name, and "key"
-            should be the storage account key.
-        :returns: A share client.
-        :rtype: ~azure.storage.fileshare.ShareClient
-        """
-        try:
-            if not share_url.lower().startswith('http'):
-                share_url = "https://" + share_url
-        except AttributeError:
-            raise ValueError("Share URL must be a string.")
-        parsed_url = urlparse(share_url.rstrip('/'))
-        if not (parsed_url.path and parsed_url.netloc):
-            raise ValueError("Invalid URL: {}".format(share_url))
-
-        share_path = parsed_url.path.lstrip('/').split('/')
-        account_path = ""
-        if len(share_path) > 1:
-            account_path = "/" + "/".join(share_path[:-1])
-        account_url = "{}://{}{}?{}".format(
-            parsed_url.scheme,
-            parsed_url.netloc.rstrip('/'),
-            account_path,
-            parsed_url.query)
-
-        share_name = unquote(share_path[-1])
-        path_snapshot, _ = parse_query(parsed_url.query)
-        if snapshot:
-            try:
-                path_snapshot = snapshot.snapshot # type: ignore
-            except AttributeError:
-                try:
-                    path_snapshot = snapshot['snapshot'] # type: ignore
-                except TypeError:
-                    path_snapshot = snapshot
-
-        if not share_name:
-            raise ValueError("Invalid URL. Please provide a URL with a valid share name")
-        return cls(account_url, share_name, path_snapshot, credential, **kwargs)
-
-    def _format_url(self, hostname):
-        """Format the endpoint URL according to the current location
-        mode hostname.
-        """
-        share_name = self.share_name
-        if isinstance(share_name, six.text_type):
-            share_name = share_name.encode('UTF-8')
-        return "{}://{}/{}{}".format(
-            self.scheme,
-            hostname,
-            quote(share_name),
-            self._query_str)
-
-    @classmethod
-    def from_connection_string(
-            cls, conn_str,  # type: str
-            share_name, # type: str
-            snapshot=None,  # type: Optional[str]
-            credential=None, # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs # type: Any
-        ):
-        # type: (...) -> ShareClient
-        """Create ShareClient from a Connection String.
-
-        :param str conn_str:
-            A connection string to an Azure Storage account.
-        :param share_name: The name of the share.
-        :type share_name: str
-        :param str snapshot:
-            The optional share snapshot on which to operate. This can be the snapshot ID string
-            or the response returned from :func:`create_snapshot`.
-        :param credential:
-            The credentials with which to authenticate. This is optional if the
-            account URL already has a SAS token. The value can be a SAS token string,
-            an instance of a AzureSasCredential or AzureNamedKeyCredential from azure.core.credentials,
-            an account shared access key, or an instance of a TokenCredentials class from azure.identity.
-            If the resource URI already contains a SAS token, this will be ignored in favor of an explicit credential
-            - except in the case of AzureSasCredential, where the conflicting SAS tokens will raise a ValueError.
-            If using an instance of AzureNamedKeyCredential, "name" should be the storage account name, and "key"
-            should be the storage account key.
-        :returns: A share client.
-        :rtype: ~azure.storage.fileshare.ShareClient
-
-        .. admonition:: Example:
-
-            .. literalinclude:: ../samples/file_samples_share.py
-                :start-after: [START create_share_client_from_conn_string]
-                :end-before: [END create_share_client_from_conn_string]
-                :language: python
-                :dedent: 8
-                :caption: Gets the share client from connection string.
-        """
-        account_url, secondary, credential = parse_connection_str(conn_str, credential, 'file')
-        if 'secondary_hostname' not in kwargs:
-            kwargs['secondary_hostname'] = secondary
-        return cls(
-            account_url, share_name=share_name, snapshot=snapshot, credential=credential, **kwargs)
+    def __init__(
+            self, account_url: str,
+            share_name: str,
+            snapshot: Optional[Union[str, Dict[str, Any]]] = None,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            *,
+            token_intent: Optional[Literal['backup']] = None,
+            **kwargs: Any
+        ) -> None:
+        kwargs['retry_policy'] = kwargs.get('retry_policy') or ExponentialRetry(**kwargs)
+        loop = kwargs.pop('loop', None)
+        if loop and sys.version_info >= (3, 8):
+            warnings.warn("The 'loop' parameter was deprecated from asyncio's high-level"
+            "APIs in Python 3.8 and is no longer supported.", DeprecationWarning)
+        super(ShareClient, self).__init__(
+            account_url,
+            share_name=share_name,
+            snapshot=snapshot,
+            credential=credential,
+            **kwargs)
+        self.allow_trailing_dot = kwargs.pop('allow_trailing_dot', None)
+        self.allow_source_trailing_dot = kwargs.pop('allow_source_trailing_dot', None)
+        self.file_request_intent = token_intent
+        self._client = AzureFileStorage(url=self.url, base_url=self.url, pipeline=self._pipeline,
+                                        allow_trailing_dot=self.allow_trailing_dot,
+                                        allow_source_trailing_dot=self.allow_source_trailing_dot,
+                                        file_request_intent=self.file_request_intent)
+        self._client._config.version = get_api_version(kwargs)  # pylint: disable=protected-access
 
     def get_directory_client(self, directory_path=None):
         # type: (Optional[str]) -> ShareDirectoryClient
         """Get a client to interact with the specified directory.
         The directory need not already exist.
 
         :param str directory_path:
             Path to the specified directory.
         :returns: A Directory Client.
-        :rtype: ~azure.storage.fileshare.ShareDirectoryClient
+        :rtype: ~azure.storage.fileshare.aio.ShareDirectoryClient
         """
-        _pipeline = Pipeline(
-            transport=TransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
+        _pipeline = AsyncPipeline(
+            transport=AsyncTransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
             policies=self._pipeline._impl_policies # pylint: disable = protected-access
         )
 
         return ShareDirectoryClient(
             self.url, share_name=self.share_name, directory_path=directory_path or "", snapshot=self.snapshot,
-            credential=self.credential, api_version=self.api_version,
-            _hosts=self._hosts, _configuration=self._config, _pipeline=_pipeline,
-            _location_mode=self._location_mode)
+            credential=self.credential, api_version=self.api_version, _hosts=self._hosts, _configuration=self._config,
+            _pipeline=_pipeline, _location_mode=self._location_mode, allow_trailing_dot=self.allow_trailing_dot,
+            allow_source_trailing_dot=self.allow_source_trailing_dot, token_intent=self.file_request_intent)
 
     def get_file_client(self, file_path):
         # type: (str) -> ShareFileClient
         """Get a client to interact with the specified file.
         The file need not already exist.
 
         :param str file_path:
             Path to the specified file.
         :returns: A File Client.
-        :rtype: ~azure.storage.fileshare.ShareFileClient
+        :rtype: ~azure.storage.fileshare.aio.ShareFileClient
         """
-        _pipeline = Pipeline(
-            transport=TransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
+        _pipeline = AsyncPipeline(
+            transport=AsyncTransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
             policies=self._pipeline._impl_policies # pylint: disable = protected-access
         )
 
         return ShareFileClient(
             self.url, share_name=self.share_name, file_path=file_path, snapshot=self.snapshot,
-            credential=self.credential, api_version=self.api_version,
-            _hosts=self._hosts, _configuration=self._config,
-            _pipeline=_pipeline, _location_mode=self._location_mode)
+            credential=self.credential, api_version=self.api_version, _hosts=self._hosts, _configuration=self._config,
+            _pipeline=_pipeline, _location_mode=self._location_mode, allow_trailing_dot=self.allow_trailing_dot,
+            allow_source_trailing_dot=self.allow_source_trailing_dot, token_intent=self.file_request_intent)
 
-    @distributed_trace
-    def acquire_lease(self, **kwargs):
+    @distributed_trace_async()
+    async def acquire_lease(self, **kwargs):
         # type: (**Any) -> ShareLeaseClient
         """Requests a new lease.
 
         If the share does not have an active lease, the Share
         Service creates a lease on the share and returns a new lease.
 
         .. versionadded:: 12.5.0
@@ -295,35 +174,39 @@
             between 15 and 60 seconds. A lease duration cannot be changed
             using renew or change. Default is -1 (infinite lease).
         :keyword str lease_id:
             Proposed lease ID, in a GUID string format. The Share Service
             returns 400 (Invalid request) if the proposed lease ID is not
             in the correct format.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: A ShareLeaseClient object.
         :rtype: ~azure.storage.fileshare.ShareLeaseClient
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_share.py
-                :start-after: [START acquire_and_release_lease_on_share]
-                :end-before: [END acquire_and_release_lease_on_share]
+                :start-after: [START acquire_lease_on_share]
+                :end-before: [END acquire_lease_on_share]
                 :language: python
                 :dedent: 8
                 :caption: Acquiring a lease on a share.
         """
         kwargs['lease_duration'] = kwargs.pop('lease_duration', -1)
         lease_id = kwargs.pop('lease_id', None)
         lease = ShareLeaseClient(self, lease_id=lease_id)  # type: ignore
-        lease.acquire(**kwargs)
+        await lease.acquire(**kwargs)
         return lease
 
-    @distributed_trace
-    def create_share(self, **kwargs):
+    @distributed_trace_async
+    async def create_share(self, **kwargs):
         # type: (Any) -> Dict[str, Any]
         """Creates a new Share under the account. If a share with the
         same name already exists, the operation fails.
 
         :keyword dict(str,str) metadata:
             Name-value pairs associated with the share as metadata.
         :keyword int quota:
@@ -332,32 +215,36 @@
             Specifies the access tier of the share.
             Possible values: 'TransactionOptimized', 'Hot', 'Cool'
         :paramtype access_tier: str or ~azure.storage.fileshare.models.ShareAccessTier
 
             .. versionadded:: 12.4.0
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword protocols:
             Protocols to enable on the share. Only one protocol can be enabled on the share.
         :paramtype protocols: str or ~azure.storage.fileshare.ShareProtocols
         :keyword root_squash:
             Root squash to set on the share.
             Only valid for NFS shares. Possible values include: 'NoRootSquash', 'RootSquash', 'AllSquash'.
         :paramtype root_squash: str or ~azure.storage.fileshare.ShareRootSquash
         :returns: Share-updated property dict (Etag and last modified).
         :rtype: Dict[str, Any]
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share.py
+            .. literalinclude:: ../samples/file_samples_share_async.py
                 :start-after: [START create_share]
                 :end-before: [END create_share]
                 :language: python
-                :dedent: 8
+                :dedent: 12
                 :caption: Creates a file share.
         """
         metadata = kwargs.pop('metadata', None)
         quota = kwargs.pop('quota', None)
         access_tier = kwargs.pop('access_tier', None)
         timeout = kwargs.pop('timeout', None)
         root_squash = kwargs.pop('root_squash', None)
@@ -366,29 +253,29 @@
             raise ValueError("The enabled protocol must be set to either SMB or NFS.")
         if root_squash and protocols not in ['NFS', ShareProtocols.NFS]:
             raise ValueError("The 'root_squash' keyword can only be used on NFS enabled shares.")
         headers = kwargs.pop('headers', {})
         headers.update(add_metadata_headers(metadata)) # type: ignore
 
         try:
-            return self._client.share.create( # type: ignore
+            return await self._client.share.create( # type: ignore
                 timeout=timeout,
                 metadata=metadata,
                 quota=quota,
                 access_tier=access_tier,
                 root_squash=root_squash,
                 enabled_protocols=protocols,
                 cls=return_response_headers,
                 headers=headers,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
-    @distributed_trace
-    def create_snapshot( # type: ignore
+    @distributed_trace_async
+    async def create_snapshot( # type: ignore
             self,
             **kwargs # type: Optional[Any]
         ):
         # type: (...) -> Dict[str, Any]
         """Creates a snapshot of the share.
 
         A snapshot is a read-only version of a share that's taken at a point in time.
@@ -398,318 +285,348 @@
         A snapshot of a share has the same name as the base share from which the snapshot
         is taken, with a DateTime value appended to indicate the time at which the
         snapshot was taken.
 
         :keyword dict(str,str) metadata:
             Name-value pairs associated with the share as metadata.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: Share-updated property dict (Snapshot ID, Etag, and last modified).
         :rtype: dict[str, Any]
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share.py
+            .. literalinclude:: ../samples/file_samples_share_async.py
                 :start-after: [START create_share_snapshot]
                 :end-before: [END create_share_snapshot]
                 :language: python
-                :dedent: 12
+                :dedent: 16
                 :caption: Creates a snapshot of the file share.
         """
         metadata = kwargs.pop('metadata', None)
         timeout = kwargs.pop('timeout', None)
         headers = kwargs.pop('headers', {})
         headers.update(add_metadata_headers(metadata)) # type: ignore
         try:
-            return self._client.share.create_snapshot( # type: ignore
+            return await self._client.share.create_snapshot( # type: ignore
                 timeout=timeout,
                 cls=return_response_headers,
                 headers=headers,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
-    @distributed_trace
-    def delete_share(
+    @distributed_trace_async
+    async def delete_share(
             self, delete_snapshots=False, # type: Optional[bool]
             **kwargs
         ):
         # type: (...) -> None
         """Marks the specified share for deletion. The share is
         later deleted during garbage collection.
 
         :param bool delete_snapshots:
             Indicates if snapshots are to be deleted.
+        :keyword int timeout:
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword lease:
             Required if the share has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.5.0
             This keyword argument was introduced in API version '2020-08-04'.
 
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share.py
+            .. literalinclude:: ../samples/file_samples_share_async.py
                 :start-after: [START delete_share]
                 :end-before: [END delete_share]
                 :language: python
-                :dedent: 12
+                :dedent: 16
                 :caption: Deletes the share and any snapshots.
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         delete_include = None
         if delete_snapshots:
             delete_include = DeleteSnapshotsOptionType.include
         try:
-            self._client.share.delete(
+            await self._client.share.delete(
                 timeout=timeout,
                 sharesnapshot=self.snapshot,
-                lease_access_conditions=access_conditions,
                 delete_snapshots=delete_include,
+                lease_access_conditions=access_conditions,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
-    @distributed_trace
-    def get_share_properties(self, **kwargs):
+    @distributed_trace_async
+    async def get_share_properties(self, **kwargs):
         # type: (Any) -> ShareProperties
         """Returns all user-defined metadata and system properties for the
         specified share. The data returned does not include the shares's
         list of files or directories.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword lease:
             Required if the share has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.5.0
             This keyword argument was introduced in API version '2020-08-04'.
 
         :returns: The share properties.
         :rtype: ~azure.storage.fileshare.ShareProperties
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_hello_world.py
+            .. literalinclude:: ../samples/file_samples_hello_world_async.py
                 :start-after: [START get_share_properties]
                 :end-before: [END get_share_properties]
                 :language: python
-                :dedent: 12
+                :dedent: 16
                 :caption: Gets the share properties.
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
-            props = self._client.share.get_properties(
+            props = await self._client.share.get_properties(
                 timeout=timeout,
                 sharesnapshot=self.snapshot,
                 cls=deserialize_share_properties,
                 lease_access_conditions=access_conditions,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
         props.name = self.share_name
         props.snapshot = self.snapshot
         return props # type: ignore
 
-    @distributed_trace
-    def set_share_quota(self, quota, **kwargs):
+    @distributed_trace_async
+    async def set_share_quota(self, quota, **kwargs):
         # type: (int, Any) ->  Dict[str, Any]
         """Sets the quota for the share.
 
         :param int quota:
             Specifies the maximum size of the share, in gigabytes.
             Must be greater than 0, and less than or equal to 5TB.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword lease:
             Required if the share has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.5.0
             This keyword argument was introduced in API version '2020-08-04'.
 
         :returns: Share-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share.py
+            .. literalinclude:: ../samples/file_samples_share_async.py
                 :start-after: [START set_share_quota]
                 :end-before: [END set_share_quota]
                 :language: python
-                :dedent: 12
+                :dedent: 16
                 :caption: Sets the share quota.
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
-            return self._client.share.set_properties( # type: ignore
+            return await self._client.share.set_properties( # type: ignore
                 timeout=timeout,
                 quota=quota,
                 access_tier=None,
-                lease_access_conditions=access_conditions,
                 cls=return_response_headers,
+                lease_access_conditions=access_conditions,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
-    @distributed_trace
-    def set_share_properties(self, **kwargs):
+    async def set_share_properties(self, **kwargs):
         # type: (Any) ->  Dict[str, Any]
         """Sets the share properties.
 
-        .. versionadded:: 12.4.0
+        .. versionadded:: 12.3.0
 
         :keyword access_tier:
             Specifies the access tier of the share.
             Possible values: 'TransactionOptimized', 'Hot', and 'Cool'
         :paramtype access_tier: str or ~azure.storage.fileshare.models.ShareAccessTier
         :keyword int quota:
             Specifies the maximum size of the share, in gigabytes.
             Must be greater than 0, and less than or equal to 5TB.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword root_squash:
             Root squash to set on the share.
-            Only valid for NFS shares. Possible values include: 'NoRootSquash', 'RootSquash', 'AllSquash'.
+            Only valid for NFS shares. Possible values include: 'NoRootSquash', 'RootSquash', 'AllSquash'
         :paramtype root_squash: str or ~azure.storage.fileshare.ShareRootSquash
         :keyword lease:
             Required if the share has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
         :returns: Share-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share.py
+            .. literalinclude:: ../samples/file_samples_share_async.py
                 :start-after: [START set_share_properties]
                 :end-before: [END set_share_properties]
                 :language: python
-                :dedent: 12
+                :dedent: 16
                 :caption: Sets the share properties.
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         access_tier = kwargs.pop('access_tier', None)
         quota = kwargs.pop('quota', None)
         root_squash = kwargs.pop('root_squash', None)
         if all(parameter is None for parameter in [access_tier, quota, root_squash]):
             raise ValueError("set_share_properties should be called with at least one parameter.")
         try:
-            return self._client.share.set_properties( # type: ignore
+            return await self._client.share.set_properties( # type: ignore
                 timeout=timeout,
                 quota=quota,
                 access_tier=access_tier,
                 root_squash=root_squash,
                 lease_access_conditions=access_conditions,
                 cls=return_response_headers,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
-    @distributed_trace
-    def set_share_metadata(self, metadata, **kwargs):
+    @distributed_trace_async
+    async def set_share_metadata(self, metadata, **kwargs):
         # type: (Dict[str, Any], Any) ->  Dict[str, Any]
         """Sets the metadata for the share.
 
         Each call to this operation replaces all existing metadata
         attached to the share. To remove all metadata from the share,
         call this operation with no metadata dict.
 
         :param metadata:
             Name-value pairs associated with the share as metadata.
         :type metadata: dict(str, str)
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword lease:
             Required if the share has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.5.0
             This keyword argument was introduced in API version '2020-08-04'.
 
         :returns: Share-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share.py
+            .. literalinclude:: ../samples/file_samples_share_async.py
                 :start-after: [START set_share_metadata]
                 :end-before: [END set_share_metadata]
                 :language: python
-                :dedent: 12
+                :dedent: 16
                 :caption: Sets the share metadata.
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         headers = kwargs.pop('headers', {})
         headers.update(add_metadata_headers(metadata))
         try:
-            return self._client.share.set_metadata( # type: ignore
+            return await self._client.share.set_metadata( # type: ignore
                 timeout=timeout,
                 cls=return_response_headers,
                 headers=headers,
                 lease_access_conditions=access_conditions,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
-    @distributed_trace
-    def get_share_access_policy(self, **kwargs):
+    @distributed_trace_async
+    async def get_share_access_policy(self, **kwargs):
         # type: (Any) -> Dict[str, Any]
         """Gets the permissions for the share. The permissions
         indicate whether files in a share may be accessed publicly.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword lease:
             Required if the share has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.5.0
             This keyword argument was introduced in API version '2020-08-04'.
 
         :returns: Access policy information in a dict.
         :rtype: dict[str, Any]
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
-            response, identifiers = self._client.share.get_access_policy(
+            response, identifiers = await self._client.share.get_access_policy(
                 timeout=timeout,
                 cls=return_headers_and_deserialized,
                 lease_access_conditions=access_conditions,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
         return {
             'public_access': response.get('share_public_access'),
             'signed_identifiers': identifiers or []
         }
 
-    @distributed_trace
-    def set_share_access_policy(self, signed_identifiers, **kwargs):
+    @distributed_trace_async
+    async def set_share_access_policy(self, signed_identifiers, **kwargs):
         # type: (Dict[str, AccessPolicy], Any) -> Dict[str, str]
         """Sets the permissions for the share, or stored access
         policies that may be used with Shared Access Signatures. The permissions
         indicate whether files in a share may be accessed publicly.
 
         :param signed_identifiers:
             A dictionary of access policies to associate with the share. The
             dictionary may contain up to 5 elements. An empty dictionary
             will clear the access policies set on the service.
         :type signed_identifiers: dict(str, :class:`~azure.storage.fileshare.AccessPolicy`)
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword lease:
             Required if the share has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.5.0
             This keyword argument was introduced in API version '2020-08-04'.
 
@@ -725,57 +642,62 @@
         identifiers = []
         for key, value in signed_identifiers.items():
             if value:
                 value.start = serialize_iso(value.start)
                 value.expiry = serialize_iso(value.expiry)
             identifiers.append(SignedIdentifier(id=key, access_policy=value))
         signed_identifiers = identifiers # type: ignore
+
         try:
-            return self._client.share.set_access_policy( # type: ignore
+            return await self._client.share.set_access_policy( # type: ignore
                 share_acl=signed_identifiers or None,
                 timeout=timeout,
                 cls=return_response_headers,
                 lease_access_conditions=access_conditions,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
-    @distributed_trace
-    def get_share_stats(self, **kwargs):
+    @distributed_trace_async
+    async def get_share_stats(self, **kwargs):
         # type: (Any) -> int
         """Gets the approximate size of the data stored on the share in bytes.
 
         Note that this value may not include all recently created
         or recently re-sized files.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword lease:
             Required if the share has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.5.0
             This keyword argument was introduced in API version '2020-08-04'.
 
         :return: The approximate size of the data (in bytes) stored on the share.
         :rtype: int
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
-            stats = self._client.share.get_statistics(
+            stats = await self._client.share.get_statistics(
                 timeout=timeout,
                 lease_access_conditions=access_conditions,
                 **kwargs)
             return stats.share_usage_bytes # type: ignore
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace
-    def list_directories_and_files(
+    def list_directories_and_files( # type: ignore
             self, directory_name=None,  # type: Optional[str]
             name_starts_with=None,  # type: Optional[str]
             marker=None,  # type: Optional[str]
             **kwargs  # type: Any
         ):
         # type: (...) -> Iterable[Dict[str,str]]
         """Lists the directories and files under the share.
@@ -799,123 +721,130 @@
         :keyword bool include_extended_info:
             If this is set to true, file id will be returned in listed results.
 
             .. versionadded:: 12.6.0
             This keyword argument was introduced in API version '2020-10-02'.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: An auto-paging iterable of dict-like DirectoryProperties and FileProperties
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share.py
+            .. literalinclude:: ../samples/file_samples_share_async.py
                 :start-after: [START share_list_files_in_dir]
                 :end-before: [END share_list_files_in_dir]
                 :language: python
-                :dedent: 12
+                :dedent: 16
                 :caption: List directories and files in the share.
         """
         timeout = kwargs.pop('timeout', None)
         directory = self.get_directory_client(directory_name)
-        kwargs.setdefault('merge_span', True)
         return directory.list_directories_and_files(
             name_starts_with=name_starts_with, marker=marker, timeout=timeout, **kwargs)
 
-    @staticmethod
-    def _create_permission_for_share_options(file_permission,  # type: str
-                                             **kwargs):
-        options = {
-            'share_permission': SharePermission(permission=file_permission),
-            'cls': deserialize_permission_key,
-            'timeout': kwargs.pop('timeout', None),
-        }
-        options.update(kwargs)
-        return options
-
-    @distributed_trace
-    def create_permission_for_share(self, file_permission,  # type: str
-                                    **kwargs  # type: Any
-                                    ):
+    @distributed_trace_async
+    async def create_permission_for_share(self, file_permission,  # type: str
+                                          **kwargs  # type: Any
+                                          ):
         # type: (...) -> str
         """Create a permission (a security descriptor) at the share level.
 
         This 'permission' can be used for the files/directories in the share.
         If a 'permission' already exists, it shall return the key of it, else
         creates a new permission at the share level and return its key.
 
         :param str file_permission:
             File permission, a Portable SDDL
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: A file permission key
         :rtype: str
         """
         timeout = kwargs.pop('timeout', None)
         options = self._create_permission_for_share_options(file_permission, timeout=timeout, **kwargs)
         try:
-            return self._client.share.create_permission(**options)
+            return await self._client.share.create_permission(**options)
         except HttpResponseError as error:
             process_storage_error(error)
 
-    @distributed_trace
-    def get_permission_for_share(  # type: ignore
+    @distributed_trace_async
+    async def get_permission_for_share(  # type: ignore
             self, permission_key,  # type: str
             **kwargs  # type: Any
     ):
         # type: (...) -> str
         """Get a permission (a security descriptor) for a given key.
 
         This 'permission' can be used for the files/directories in the share.
 
         :param str permission_key:
             Key of the file permission to retrieve
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: A file permission (a portable SDDL)
         :rtype: str
         """
         timeout = kwargs.pop('timeout', None)
         try:
-            return self._client.share.get_permission(  # type: ignore
+            return await self._client.share.get_permission(  # type: ignore
                 file_permission_key=permission_key,
                 cls=deserialize_permission,
                 timeout=timeout,
                 **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
-    @distributed_trace
-    def create_directory(self, directory_name, **kwargs):
+    @distributed_trace_async
+    async def create_directory(self, directory_name, **kwargs):
         # type: (str, Any) -> ShareDirectoryClient
         """Creates a directory in the share and returns a client to interact
         with the directory.
 
         :param str directory_name:
             The name of the directory.
-        :keyword metadata:
+        :keyword dict(str,str) metadata:
             Name-value pairs associated with the directory as metadata.
-        :type metadata: dict(str, str)
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: ShareDirectoryClient
-        :rtype: ~azure.storage.fileshare.ShareDirectoryClient
+        :rtype: ~azure.storage.fileshare.aio.ShareDirectoryClient
         """
         directory = self.get_directory_client(directory_name)
         kwargs.setdefault('merge_span', True)
-        directory.create_directory(**kwargs)
+        await directory.create_directory(**kwargs)
         return directory # type: ignore
 
-    @distributed_trace
-    def delete_directory(self, directory_name, **kwargs):
+    @distributed_trace_async
+    async def delete_directory(self, directory_name, **kwargs):
         # type: (str, Any) -> None
         """Marks the directory for deletion. The directory is
         later deleted during garbage collection.
 
         :param str directory_name:
             The name of the directory.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
         """
         directory = self.get_directory_client(directory_name)
-        directory.delete_directory(**kwargs)
+        await directory.delete_directory(**kwargs)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_share_service_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_share_service_client.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,24 +1,22 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 
+import sys
 import functools
-from typing import (  # pylint: disable=unused-import
+from typing import (
     Union, Optional, Any, Dict, List,
     TYPE_CHECKING
 )
+from urllib.parse import urlparse
 
-
-try:
-    from urllib.parse import urlparse
-except ImportError:
-    from urlparse import urlparse # type: ignore
+from typing_extensions import Self
 
 from azure.core.exceptions import HttpResponseError
 from azure.core.paging import ItemPaged
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.pipeline import Pipeline
 from ._shared.base_client import StorageAccountHostsMixin, TransportWrapper, parse_connection_str, parse_query
 from ._shared.response_handlers import process_storage_error
@@ -27,16 +25,21 @@
 from ._share_client import ShareClient
 from ._serialize import get_api_version
 from ._models import (
     SharePropertiesPaged,
     service_properties_deserialize,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
-    from datetime import datetime
+    from azure.core.credentials import AzureNamedKeyCredential, AzureSasCredential, TokenCredential
     from ._models import (
         ShareProperties,
         Metrics,
         CorsRule,
         ShareProtocolSettings
     )
 
@@ -62,14 +65,24 @@
         account URL already has a SAS token. The value can be a SAS token string,
         an instance of a AzureSasCredential or AzureNamedKeyCredential from azure.core.credentials,
         an account shared access key, or an instance of a TokenCredentials class from azure.identity.
         If the resource URI already contains a SAS token, this will be ignored in favor of an explicit credential
         - except in the case of AzureSasCredential, where the conflicting SAS tokens will raise a ValueError.
         If using an instance of AzureNamedKeyCredential, "name" should be the storage account name, and "key"
         should be the storage account key.
+    :keyword token_intent:
+        Required when using `TokenCredential` for authentication and ignored for other forms of authentication.
+        Specifies the intent for all requests when using `TokenCredential` authentication. Possible values are:
+
+        backup - Specifies requests are intended for backup/admin type operations, meaning that all file/directory
+                 ACLs are bypassed and full permissions are granted. User must also have required RBAC permission.
+
+    :paramtype token_intent: Literal['backup']
+    :keyword bool allow_trailing_dot: If true, the trailing dot will not be trimmed from the target URI.
+    :keyword bool allow_source_trailing_dot: If true, the trailing dot will not be trimmed from the source URI.
     :keyword str api_version:
         The Storage API version to use for requests. Default value is the most recent service version that is
         compatible with the current SDK. Setting to an older version may result in reduced feature compatibility.
 
         .. versionadded:: 12.1.0
 
     :keyword str secondary_hostname:
@@ -82,51 +95,56 @@
             :start-after: [START create_share_service_client]
             :end-before: [END create_share_service_client]
             :language: python
             :dedent: 8
             :caption: Create the share service client with url and credential.
     """
     def __init__(
-            self, account_url,  # type: str
-            credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs  # type: Any
-        ):
-        # type: (...) -> None
+            self, account_url: str,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            *,
+            token_intent: Optional[Literal['backup']] = None,
+            **kwargs: Any
+        ) -> None:
         try:
             if not account_url.lower().startswith('http'):
                 account_url = "https://" + account_url
         except AttributeError:
             raise ValueError("Account URL must be a string.")
         parsed_url = urlparse(account_url.rstrip('/'))
         if not parsed_url.netloc:
             raise ValueError("Invalid URL: {}".format(account_url))
-        if hasattr(credential, 'get_token'):
-            raise ValueError("Token credentials not supported by the File Share service.")
 
         _, sas_token = parse_query(parsed_url.query)
         if not sas_token and not credential:
             raise ValueError(
                 'You need to provide either an account shared key or SAS token when creating a storage service.')
         self._query_str, credential = self._format_query_string(sas_token, credential)
         super(ShareServiceClient, self).__init__(parsed_url, service='file-share', credential=credential, **kwargs)
-        self._client = AzureFileStorage(url=self.url, base_url=self.url, pipeline=self._pipeline)
+        self.allow_trailing_dot = kwargs.pop('allow_trailing_dot', None)
+        self.allow_source_trailing_dot = kwargs.pop('allow_source_trailing_dot', None)
+        self.file_request_intent = token_intent
+        self._client = AzureFileStorage(url=self.url, base_url=self.url, pipeline=self._pipeline,
+                                        allow_trailing_dot=self.allow_trailing_dot,
+                                        allow_source_trailing_dot=self.allow_source_trailing_dot,
+                                        file_request_intent=self.file_request_intent)
         self._client._config.version = get_api_version(kwargs) # pylint: disable=protected-access
 
     def _format_url(self, hostname):
         """Format the endpoint URL according to the current location
         mode hostname.
         """
         return "{}://{}/{}".format(self.scheme, hostname, self._query_str)
 
     @classmethod
     def from_connection_string(
-            cls, conn_str,  # type: str
-            credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs  # type: Any
-        ):  # type: (...) -> ShareServiceClient
+            cls, conn_str: str,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            **kwargs: Any
+        ) -> Self:
         """Create ShareServiceClient from a Connection String.
 
         :param str conn_str:
             A connection string to an Azure Storage account.
         :param credential:
             The credentials with which to authenticate. This is optional if the
             account URL already has a SAS token. The value can be a SAS token string,
@@ -156,15 +174,19 @@
     @distributed_trace
     def get_service_properties(self, **kwargs):
         # type: (Any) -> Dict[str, Any]
         """Gets the properties of a storage account's File Share service, including
         Azure Storage Analytics.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: A dictionary containing file service properties such as
             analytics logging, hour/minute metrics, cors rules, etc.
         :rtype: Dict[str, Any]
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_service.py
@@ -182,15 +204,15 @@
             process_storage_error(error)
 
     @distributed_trace
     def set_service_properties(
             self, hour_metrics=None,  # type: Optional[Metrics]
             minute_metrics=None,  # type: Optional[Metrics]
             cors=None,  # type: Optional[List[CorsRule]]
-            protocol=None,  # type: Optional[ShareProtocolSettings],
+            protocol=None,  # type: Optional[ShareProtocolSettings]
             **kwargs
         ):
         # type: (...) -> None
         """Sets the properties of a storage account's File Share service, including
         Azure Storage Analytics. If an element (e.g. hour_metrics) is left as None, the
         existing settings on the service for that functionality are preserved.
 
@@ -207,15 +229,19 @@
             list. If an empty list is specified, all CORS rules will be deleted,
             and CORS will be disabled for the service.
         :type cors: list(:class:`~azure.storage.fileshare.CorsRule`)
         :param protocol:
             Sets protocol settings
         :type protocol: ~azure.storage.fileshare.ShareProtocolSettings
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_service.py
                 :start-after: [START set_service_properties]
                 :end-before: [END set_service_properties]
@@ -254,15 +280,19 @@
             Specifies that share metadata be returned in the response.
         :param bool include_snapshots:
             Specifies that share snapshot be returned in the response.
         :keyword bool include_deleted:
             Specifies that deleted shares be returned in the response.
             This is only for share soft delete enabled account.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: An iterable (auto-paging) of ShareProperties.
         :rtype: ~azure.core.paging.ItemPaged[~azure.storage.fileshare.ShareProperties]
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_service.py
                 :start-after: [START fsc_list_shares]
@@ -304,15 +334,19 @@
         :param str share_name: The name of the share to create.
         :keyword dict(str,str) metadata:
             A dict with name_value pairs to associate with the
             share as metadata. Example:{'Category':'test'}
         :keyword int quota:
             Quota in bytes.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: ~azure.storage.fileshare.ShareClient
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_service.py
                 :start-after: [START fsc_create_shares]
                 :end-before: [END fsc_create_shares]
@@ -341,15 +375,19 @@
         :param share_name:
             The share to delete. This can either be the name of the share,
             or an instance of ShareProperties.
         :type share_name: str or ~azure.storage.fileshare.ShareProperties
         :param bool delete_snapshots:
             Indicates if snapshots are to be deleted.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_service.py
                 :start-after: [START fsc_delete_shares]
                 :end-before: [END fsc_delete_shares]
@@ -375,15 +413,19 @@
             This operation was introduced in API version '2019-12-12'.
 
         :param str deleted_share_name:
             Specifies the name of the deleted share to restore.
         :param str deleted_share_version:
             Specifies the version of the deleted share to restore.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: ~azure.storage.fileshare.ShareClient
         """
         share = self.get_share_client(deleted_share_name)
 
         try:
             share._client.share.restore(deleted_share_name=deleted_share_name,  # pylint: disable = protected-access
                                         deleted_share_version=deleted_share_version,
@@ -424,8 +466,10 @@
         _pipeline = Pipeline(
             transport=TransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
             policies=self._pipeline._impl_policies # pylint: disable = protected-access
         )
         return ShareClient(
             self.url, share_name=share_name, snapshot=snapshot, credential=self.credential,
             api_version=self.api_version, _hosts=self._hosts,
-            _configuration=self._config, _pipeline=_pipeline, _location_mode=self._location_mode)
+            _configuration=self._config, _pipeline=_pipeline, _location_mode=self._location_mode,
+            allow_trailing_dot=self.allow_trailing_dot, allow_source_trailing_dot=self.allow_source_trailing_dot,
+            token_intent=self.file_request_intent)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/authentication.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/authentication.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/base_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/base_client.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,27 +5,26 @@
 # --------------------------------------------------------------------------
 import logging
 import uuid
 from typing import (  # pylint: disable=unused-import
     Optional,
     Any,
     Tuple,
-    TYPE_CHECKING
 )
 
 try:
     from urllib.parse import parse_qs, quote
 except ImportError:
     from urlparse import parse_qs  # type: ignore
     from urllib2 import quote  # type: ignore
 
 import six
 
 from azure.core.configuration import Configuration
-from azure.core.credentials import AzureSasCredential, AzureNamedKeyCredential
+from azure.core.credentials import AzureSasCredential
 from azure.core.exceptions import HttpResponseError
 from azure.core.pipeline import Pipeline
 from azure.core.pipeline.transport import RequestsTransport, HttpTransport
 from azure.core.pipeline.policies import (
     RedirectPolicy,
     ContentDecodePolicy,
     BearerTokenCredentialPolicy,
@@ -50,31 +49,29 @@
     StorageHosts,
     QueueMessagePolicy,
     ExponentialRetry,
 )
 from .._version import VERSION
 from .response_handlers import process_storage_error, PartialBatchErrorException
 
-if TYPE_CHECKING:
-    from azure.core.credentials import TokenCredential
 
 _LOGGER = logging.getLogger(__name__)
 _SERVICE_PARAMS = {
     "blob": {"primary": "BLOBENDPOINT", "secondary": "BLOBSECONDARYENDPOINT"},
     "queue": {"primary": "QUEUEENDPOINT", "secondary": "QUEUESECONDARYENDPOINT"},
     "file": {"primary": "FILEENDPOINT", "secondary": "FILESECONDARYENDPOINT"},
     "dfs": {"primary": "BLOBENDPOINT", "secondary": "BLOBENDPOINT"},
 }
 
 class StorageAccountHostsMixin(object):  # pylint: disable=too-many-instance-attributes
     def __init__(
         self,
         parsed_url,  # type: Any
         service,  # type: str
-        credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
+        credential=None,  # type: Optional[Any]
         **kwargs  # type: Any
     ):
         # type: (...) -> None
         self._location_mode = kwargs.get("_location_mode", LocationMode.PRIMARY)
         self._hosts = kwargs.get("_hosts")
         self.scheme = parsed_url.scheme
 
@@ -102,14 +99,17 @@
             if len(account) > 1:
                 secondary_hostname = parsed_url.netloc.replace(account[0], account[0] + "-secondary")
             if kwargs.get("secondary_hostname"):
                 secondary_hostname = kwargs["secondary_hostname"]
             primary_hostname = (parsed_url.netloc + parsed_url.path).rstrip('/')
             self._hosts = {LocationMode.PRIMARY: primary_hostname, LocationMode.SECONDARY: secondary_hostname}
 
+        self.require_encryption = kwargs.get("require_encryption", False)
+        self.key_encryption_key = kwargs.get("key_encryption_key")
+        self.key_resolver_function = kwargs.get("key_resolver_function")
         self._config, self._pipeline = self._create_pipeline(self.credential, storage_sdk=service, **kwargs)
 
     def __enter__(self):
         self._client.__enter__()
         return self
 
     def __exit__(self, *args):
@@ -351,16 +351,14 @@
         credential = {"account_name": account_name, "account_key": credential}
     if isinstance(credential, dict):
         if "account_name" not in credential:
             raise ValueError("Shared key credential missing 'account_name")
         if "account_key" not in credential:
             raise ValueError("Shared key credential missing 'account_key")
         return SharedKeyCredentialPolicy(**credential)
-    if isinstance(credential, AzureNamedKeyCredential):
-        return SharedKeyCredentialPolicy(credential.named_key.name, credential.named_key.key)
     return credential
 
 
 def parse_connection_str(conn_str, credential, service):
     conn_str = conn_str.rstrip(";")
     conn_settings = [s.split("=", 1) for s in conn_str.split(";")]
     if any(len(tup) != 2 for tup in conn_settings):
@@ -399,16 +397,15 @@
             primary = "https://{}.{}.{}".format(
                 conn_settings["ACCOUNTNAME"], service, conn_settings.get("ENDPOINTSUFFIX", SERVICE_HOST_BASE)
             )
         except KeyError:
             raise ValueError("Connection string missing required connection details.")
     if service == "dfs":
         primary = primary.replace(".blob.", ".dfs.")
-        if secondary:
-            secondary = secondary.replace(".blob.", ".dfs.")
+        secondary = secondary.replace(".blob.", ".dfs.")
     return primary, secondary, credential
 
 
 def create_configuration(**kwargs):
     # type: (**Any) -> Configuration
     config = Configuration(**kwargs)
     config.headers_policy = StorageHeadersPolicy(**kwargs)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/base_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/base_client_async.py`

 * *Files 0% similar despite different names*

```diff
@@ -15,16 +15,15 @@
 from azure.core.async_paging import AsyncList
 from azure.core.exceptions import HttpResponseError
 from azure.core.pipeline.policies import (
     ContentDecodePolicy,
     AsyncBearerTokenCredentialPolicy,
     AsyncRedirectPolicy,
     DistributedTracingPolicy,
-    HttpLoggingPolicy,
-    AzureSasCredentialPolicy,
+    HttpLoggingPolicy, AzureSasCredentialPolicy,
 )
 from azure.core.pipeline.transport import AsyncHttpTransport
 
 from .constants import STORAGE_OAUTH_SCOPE, CONNECTION_TIMEOUT, READ_TIMEOUT
 from .authentication import SharedKeyCredentialPolicy
 from .base_client import create_configuration
 from .policies import (
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/models.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 # --------------------------------------------------------------------------
 # pylint: disable=too-many-instance-attributes
 
 from enum import Enum
 
 from azure.core import CaseInsensitiveEnumMeta
 
+
 def get_enum_value(value):
     if value is None or value in ["None", ""]:
         return None
     try:
         return value.value
     except AttributeError:
         return value
@@ -280,15 +281,15 @@
         To specify service, container, or object you need only to
         include the first letter of the word in the string. E.g. service and container,
         you would provide a string "sc".
 
         :param str string: Specify service, container, or object in
             in the string with the first letter of the word.
         :return: A ResourceTypes object
-        :rtype: ~azure.storage.fileshare.ResourceTypes
+        :rtype: ~azure.storage.queue.ResourceTypes
         """
         res_service = 's' in string
         res_container = 'c' in string
         res_object = 'o' in string
 
         parsed = cls(res_service, res_container, res_object)
         parsed._str = string  # pylint: disable = protected-access
@@ -378,15 +379,15 @@
         To specify read, write, delete, etc. permissions you need only to
         include the first letter of the word in the string. E.g. for read and write
         permissions you would provide a string "rw".
 
         :param str permission: Specify permissions in
             the string with the first letter of the word.
         :return: An AccountSasPermissions object
-        :rtype: ~azure.storage.fileshare.AccountSasPermissions
+        :rtype: ~azure.storage.queue.AccountSasPermissions
         """
         p_read = 'r' in permission
         p_write = 'w' in permission
         p_delete = 'd' in permission
         p_delete_previous_version = 'x' in permission
         p_permanent_delete = 'y' in permission
         p_list = 'l' in permission
@@ -434,15 +435,15 @@
         To specify blob, queue, or file you need only to
         include the first letter of the word in the string. E.g. for blob and queue
         you would provide a string "bq".
 
         :param str string: Specify blob, queue, or file in
             in the string with the first letter of the word.
         :return: A Services object
-        :rtype: ~azure.storage.fileshare.Services
+        :rtype: ~azure.storage.queue.Services
         """
         res_blob = 'b' in string
         res_queue = 'q' in string
         res_file = 'f' in string
 
         parsed = cls(res_blob, res_queue, res_file)
         parsed._str = string  # pylint: disable = protected-access
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/parser.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/parser.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/policies.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/policies.py`

 * *Files 2% similar despite different names*

```diff
@@ -26,30 +26,34 @@
     from urlparse import ( # type: ignore
         urlparse,
         parse_qsl,
         urlunparse,
     )
 
 from azure.core.pipeline.policies import (
+    BearerTokenCredentialPolicy,
     HeadersPolicy,
-    SansIOHTTPPolicy,
-    NetworkTraceLoggingPolicy,
     HTTPPolicy,
-    RequestHistory
+    NetworkTraceLoggingPolicy,
+    RequestHistory,
+    SansIOHTTPPolicy,
 )
 from azure.core.exceptions import AzureError, ServiceRequestError, ServiceResponseError
 
+from .authentication import StorageHttpChallenge
+from .constants import DEFAULT_OAUTH_SCOPE, STORAGE_OAUTH_SCOPE
 from .models import LocationMode
 
 try:
     _unicode_type = unicode # type: ignore
 except NameError:
     _unicode_type = str
 
 if TYPE_CHECKING:
+    from azure.core.credentials import TokenCredential
     from azure.core.pipeline import PipelineRequest, PipelineResponse
 
 
 _LOGGER = logging.getLogger(__name__)
 
 
 def encode_base64(data):
@@ -78,15 +82,15 @@
     variables such as the number of total retries to allow, whether to
     respect the Retry-After header, whether this header is present, and
     whether the returned status code is on the list of status codes to
     be retried upon on the presence of the aforementioned header)
     """
     status = response.http_response.status_code
     if 300 <= status < 500:
-        # An exception occured, but in most cases it was expected. Examples could
+        # An exception occurred, but in most cases it was expected. Examples could
         # include a 309 Conflict or 412 Precondition Failed.
         if status == 404 and mode == LocationMode.SECONDARY:
             # Response code 404 should be retried if secondary was used.
             return True
         if status == 408:
             # Response code 408 is a timeout and should be retried.
             return True
@@ -169,15 +173,15 @@
 
         # See if a specific location mode has been specified, and if so, redirect
         use_location = request.context.options.pop('use_location', None)
         if use_location:
             # Lock retries to the specific location
             request.context.options['retry_to_secondary'] = False
             if use_location not in self.hosts:
-                raise ValueError("Attempting to use undefined host location {}".format(use_location))
+                raise ValueError(f"Attempting to use undefined host location {use_location}")
             if use_location != location_mode:
                 # Update request URL to use the specified location
                 updated = parsed_url._replace(netloc=self.hosts[use_location])
                 request.http_request.url = updated.geturl()
                 location_mode = use_location
 
         request.context.options['location_mode'] = location_mode
@@ -288,34 +292,44 @@
 
     def __init__(self, **kwargs):  # pylint: disable=unused-argument
         self._response_callback = kwargs.get('raw_response_hook')
         super(StorageResponseHook, self).__init__()
 
     def send(self, request):
         # type: (PipelineRequest) -> PipelineResponse
-        data_stream_total = request.context.get('data_stream_total') or \
-            request.context.options.pop('data_stream_total', None)
-        download_stream_current = request.context.get('download_stream_current') or \
-            request.context.options.pop('download_stream_current', None)
-        upload_stream_current = request.context.get('upload_stream_current') or \
-            request.context.options.pop('upload_stream_current', None)
+        # Values could be 0
+        data_stream_total = request.context.get('data_stream_total')
+        if data_stream_total is None:
+            data_stream_total = request.context.options.pop('data_stream_total', None)
+        download_stream_current = request.context.get('download_stream_current')
+        if download_stream_current is None:
+            download_stream_current = request.context.options.pop('download_stream_current', None)
+        upload_stream_current = request.context.get('upload_stream_current')
+        if upload_stream_current is None:
+            upload_stream_current = request.context.options.pop('upload_stream_current', None)
+
         response_callback = request.context.get('response_callback') or \
             request.context.options.pop('raw_response_hook', self._response_callback)
 
         response = self.next.send(request)
+
         will_retry = is_retry(response, request.context.options.get('mode'))
-        if not will_retry and download_stream_current is not None:
+        # Auth error could come from Bearer challenge, in which case this request will be made again
+        is_auth_error = response.http_response.status_code == 401
+        should_update_counts = not (will_retry or is_auth_error)
+
+        if should_update_counts and download_stream_current is not None:
             download_stream_current += int(response.http_response.headers.get('Content-Length', 0))
             if data_stream_total is None:
                 content_range = response.http_response.headers.get('Content-Range')
                 if content_range:
                     data_stream_total = int(content_range.split(' ', 1)[1].split('/', 1)[1])
                 else:
                     data_stream_total = download_stream_current
-        elif not will_retry and upload_stream_current is not None:
+        elif should_update_counts and upload_stream_current is not None:
             upload_stream_current += int(response.http_request.headers.get('Content-Length', 0))
         for pipeline_obj in [request, response]:
             pipeline_obj.context['data_stream_total'] = data_stream_total
             pipeline_obj.context['download_stream_current'] = download_stream_current
             pipeline_obj.context['upload_stream_current'] = upload_stream_current
         if response_callback:
             response_callback(response)
@@ -369,17 +383,17 @@
         request.context['validate_content'] = validate_content
 
     def on_response(self, request, response):
         if response.context.get('validate_content', False) and response.http_response.headers.get('content-md5'):
             computed_md5 = request.context.get('validate_content_md5') or \
                 encode_base64(StorageContentValidation.get_content_md5(response.http_response.body()))
             if response.http_response.headers['content-md5'] != computed_md5:
-                raise AzureError(
-                    'MD5 mismatch. Expected value is \'{0}\', computed value is \'{1}\'.'.format(
-                        response.http_response.headers['content-md5'], computed_md5),
+                raise AzureError((
+                    f"MD5 mismatch. Expected value is '{response.http_response.headers['content-md5']}', "
+                    f"computed value is '{computed_md5}'."),
                     response=response.http_response
                 )
 
 
 class StorageRetryPolicy(HTTPPolicy):
     """
     The base class for Exponential and Linear retries containing shared code.
@@ -619,7 +633,28 @@
         random_generator = random.Random()
         # the backoff interval normally does not change, however there is the possibility
         # that it was modified by accessing the property directly after initializing the object
         random_range_start = self.backoff - self.random_jitter_range \
             if self.backoff > self.random_jitter_range else 0
         random_range_end = self.backoff + self.random_jitter_range
         return random_generator.uniform(random_range_start, random_range_end)
+
+
+class StorageBearerTokenCredentialPolicy(BearerTokenCredentialPolicy):
+    """ Custom Bearer token credential policy for following Storage Bearer challenges """
+
+    def __init__(self, credential, **kwargs):
+        # type: (TokenCredential, **Any) -> None
+        super(StorageBearerTokenCredentialPolicy, self).__init__(credential, STORAGE_OAUTH_SCOPE, **kwargs)
+
+    def on_challenge(self, request, response):
+        # type: (PipelineRequest, PipelineResponse) -> bool
+        try:
+            auth_header = response.http_response.headers.get("WWW-Authenticate")
+            challenge = StorageHttpChallenge(auth_header)
+        except ValueError:
+            return False
+
+        scope = challenge.resource_id + DEFAULT_OAUTH_SCOPE
+        self.authorize_request(request, scope, tenant_id=challenge.tenant_id)
+
+        return True
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/policies_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/policies_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/request_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/request_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/response_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/response_handlers.py`

 * *Files 1% similar despite different names*

```diff
@@ -63,15 +63,15 @@
         if key.startswith('x-ms-'):
             key = key[5:]
         normalized[key.lower().replace('-', '_')] = get_enum_value(value)
     return normalized
 
 
 def deserialize_metadata(response, obj, headers):  # pylint: disable=unused-argument
-    raw_metadata = {k: v for k, v in response.http_response.headers.items() if k.startswith("x-ms-meta-")}
+    raw_metadata = {k: v for k, v in response.headers.items() if k.startswith("x-ms-meta-")}
     return {k[10:]: v for k, v in raw_metadata.items()}
 
 
 def return_response_headers(response, deserialized, response_headers):  # pylint: disable=unused-argument
     return normalize_headers(response_headers)
 
 
@@ -82,19 +82,21 @@
 def return_context_and_deserialized(response, deserialized, response_headers):  # pylint: disable=unused-argument
     return response.http_response.location_mode, deserialized
 
 
 def process_storage_error(storage_error):   # pylint:disable=too-many-statements
     raise_error = HttpResponseError
     serialized = False
-    if not storage_error.response:
+    if not storage_error.response or storage_error.response.status_code in [200, 204]:
         raise storage_error
     # If it is one of those three then it has been serialized prior by the generated layer.
     if isinstance(storage_error, (PartialBatchErrorException,
-                                  ClientAuthenticationError, ResourceNotFoundError, ResourceExistsError)):
+                                  ClientAuthenticationError,
+                                  ResourceNotFoundError,
+                                  ResourceExistsError)):
         serialized = True
     error_code = storage_error.response.headers.get('x-ms-error-code')
     error_message = storage_error.message
     additional_data = {}
     error_dict = {}
     try:
         error_body = ContentDecodePolicy.deserialize_from_http_generics(storage_error.response)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/shared_access_signature.py`

 * *Files 1% similar despite different names*

```diff
@@ -208,15 +208,15 @@
              get_value_to_append(QueryStringConstants.SIGNED_SERVICES) +
              get_value_to_append(QueryStringConstants.SIGNED_RESOURCE_TYPES) +
              get_value_to_append(QueryStringConstants.SIGNED_START) +
              get_value_to_append(QueryStringConstants.SIGNED_EXPIRY) +
              get_value_to_append(QueryStringConstants.SIGNED_IP) +
              get_value_to_append(QueryStringConstants.SIGNED_PROTOCOL) +
              get_value_to_append(QueryStringConstants.SIGNED_VERSION) +
-             '\n'   # Signed Encryption Scope - always empty for fileshare
+             '\n'   # Signed Encryption Scope - always empty for queue
              )
 
         self._add_query(QueryStringConstants.SIGNED_SIGNATURE,
                         sign_string(account_key, string_to_sign))
 
     def get_token(self):
         return '&'.join(['{0}={1}'.format(n, url_quote(v)) for n, v in self.query_dict.items() if v is not None])
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/uploads.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/uploads.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,25 +2,27 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=no-self-use
 
 from concurrent import futures
-from io import BytesIO, IOBase, SEEK_CUR, SEEK_END, SEEK_SET, UnsupportedOperation
+from io import (BytesIO, IOBase, SEEK_CUR, SEEK_END, SEEK_SET, UnsupportedOperation)
+from threading import Lock
 from itertools import islice
 from math import ceil
-from threading import Lock
 
 import six
+
 from azure.core.tracing.common import with_current_context
 
 from . import encode_base64, url_quote
 from .request_handlers import get_length
 from .response_handlers import return_response_headers
+from .encryption import get_blob_encryptor_and_padder
 
 
 _LARGE_BLOB_UPLOAD_MAX_READ_BUFFER_SIZE = 4 * 1024 * 1024
 _ERROR_VALUE_SHOULD_BE_SEEKABLE_STREAM = "{0} should be a seekable file-like/io.IOBase type stream object."
 
 
 def _parallel_uploads(executor, uploader, pending, running):
@@ -46,17 +48,26 @@
         service=None,
         uploader_class=None,
         total_size=None,
         chunk_size=None,
         max_concurrency=None,
         stream=None,
         validate_content=None,
+        encryption_options=None,
         progress_hook=None,
         **kwargs):
 
+    if encryption_options:
+        encryptor, padder = get_blob_encryptor_and_padder(
+            encryption_options.get('cek'),
+            encryption_options.get('vector'),
+            uploader_class is not PageBlobChunkUploader)
+        kwargs['encryptor'] = encryptor
+        kwargs['padder'] = padder
+
     parallel = max_concurrency > 1
     if parallel and 'modified_access_conditions' in kwargs:
         # Access conditions do not work with parallelism
         kwargs['modified_access_conditions'] = None
 
     uploader = uploader_class(
         service=service,
@@ -134,14 +145,15 @@
         self.service = service
         self.total_size = total_size
         self.chunk_size = chunk_size
         self.stream = stream
         self.parallel = parallel
 
         # Stream management
+        self.stream_start = stream.tell() if parallel else None
         self.stream_lock = Lock() if parallel else None
 
         # Progress feedback
         self.progress_total = 0
         self.progress_lock = Lock() if parallel else None
         self.progress_hook = progress_hook
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/uploads_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/uploads_async.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,45 +2,31 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=no-self-use
 
 import asyncio
-import threading
 from asyncio import Lock
 from itertools import islice
+import threading
+
 from math import ceil
 
 import six
 
 from . import encode_base64, url_quote
 from .request_handlers import get_length
 from .response_handlers import return_response_headers
+from .encryption import get_blob_encryptor_and_padder
 from .uploads import SubStream, IterStreamer  # pylint: disable=unused-import
 
 
-async def _async_parallel_uploads(uploader, pending, running):
-    range_ids = []
-    while True:
-        # Wait for some download to finish before adding a new one
-        done, running = await asyncio.wait(running, return_when=asyncio.FIRST_COMPLETED)
-        range_ids.extend([chunk.result() for chunk in done])
-        try:
-            for _ in range(0, len(done)):
-                next_chunk = await pending.__anext__()
-                running.add(asyncio.ensure_future(uploader(next_chunk)))
-        except StopAsyncIteration:
-            break
-
-    # Wait for the remaining uploads to finish
-    if running:
-        done, _running = await asyncio.wait(running)
-        range_ids.extend([chunk.result() for chunk in done])
-    return range_ids
+_LARGE_BLOB_UPLOAD_MAX_READ_BUFFER_SIZE = 4 * 1024 * 1024
+_ERROR_VALUE_SHOULD_BE_SEEKABLE_STREAM = '{0} should be a seekable file-like/io.IOBase type stream object.'
 
 
 async def _parallel_uploads(uploader, pending, running):
     range_ids = []
     while True:
         # Wait for some download to finish before adding a new one
         done, running = await asyncio.wait(running, return_when=asyncio.FIRST_COMPLETED)
@@ -62,17 +48,26 @@
 async def upload_data_chunks(
         service=None,
         uploader_class=None,
         total_size=None,
         chunk_size=None,
         max_concurrency=None,
         stream=None,
+        encryption_options=None,
         progress_hook=None,
         **kwargs):
 
+    if encryption_options:
+        encryptor, padder = get_blob_encryptor_and_padder(
+            encryption_options.get('cek'),
+            encryption_options.get('vector'),
+            uploader_class is not PageBlobChunkUploader)
+        kwargs['encryptor'] = encryptor
+        kwargs['padder'] = padder
+
     parallel = max_concurrency > 1
     if parallel and 'modified_access_conditions' in kwargs:
         # Access conditions do not work with parallelism
         kwargs['modified_access_conditions'] = None
 
     uploader = uploader_class(
         service=service,
@@ -81,26 +76,22 @@
         stream=stream,
         parallel=parallel,
         progress_hook=progress_hook,
         **kwargs)
 
     if parallel:
         upload_tasks = uploader.get_chunk_streams()
-        running_futures = []
-        for _ in range(max_concurrency):
-            try:
-                chunk = await upload_tasks.__anext__()
-                running_futures.append(asyncio.ensure_future(uploader.process_chunk(chunk)))
-            except StopAsyncIteration:
-                break
-
-        range_ids = await _async_parallel_uploads(uploader.process_chunk, upload_tasks, running_futures)
+        running_futures = [
+            asyncio.ensure_future(uploader.process_chunk(u))
+            for u in islice(upload_tasks, 0, max_concurrency)
+        ]
+        range_ids = await _parallel_uploads(uploader.process_chunk, upload_tasks, running_futures)
     else:
         range_ids = []
-        async for chunk in uploader.get_chunk_streams():
+        for chunk in uploader.get_chunk_streams():
             range_ids.append(await uploader.process_chunk(chunk))
 
     if any(range_ids):
         return [r[1] for r in sorted(range_ids, key=lambda r: r[0])]
     return uploader.response_headers
 
 
@@ -157,14 +148,15 @@
         self.service = service
         self.total_size = total_size
         self.chunk_size = chunk_size
         self.stream = stream
         self.parallel = parallel
 
         # Stream management
+        self.stream_start = stream.tell() if parallel else None
         self.stream_lock = threading.Lock() if parallel else None
 
         # Progress feedback
         self.progress_total = 0
         self.progress_lock = Lock() if parallel else None
         self.progress_hook = progress_hook
 
@@ -172,28 +164,25 @@
         self.encryptor = encryptor
         self.padder = padder
         self.response_headers = None
         self.etag = None
         self.last_modified = None
         self.request_options = kwargs
 
-    async def get_chunk_streams(self):
+    def get_chunk_streams(self):
         index = 0
         while True:
             data = b''
             read_size = self.chunk_size
 
             # Buffer until we either reach the end of the stream or get a whole chunk.
             while True:
                 if self.total_size:
                     read_size = min(self.chunk_size - len(data), self.total_size - (index + len(data)))
-                if asyncio.iscoroutinefunction(self.stream.read):
-                    temp = await self.stream.read(read_size)
-                else:
-                    temp = self.stream.read(read_size)
+                temp = self.stream.read(read_size)
                 if not isinstance(temp, six.binary_type):
                     raise TypeError('Blob data should be of type bytes.')
                 data += temp or b""
 
                 # We have read an empty string and so are at the end
                 # of the buffer or we have read a full chunk.
                 if temp == b'' or len(data) == self.chunk_size:
@@ -224,15 +213,15 @@
         if self.progress_lock is not None:
             async with self.progress_lock:
                 self.progress_total += length
         else:
             self.progress_total += length
 
         if self.progress_hook:
-            await self.progress_hook(self.progress_total, self.total_size)
+            self.progress_hook(self.progress_total, self.total_size)
 
     async def _upload_chunk(self, chunk_offset, chunk_data):
         raise NotImplementedError("Must be implemented by child class.")
 
     async def _upload_chunk_with_progress(self, chunk_offset, chunk_data):
         range_id = await self._upload_chunk(chunk_offset, chunk_data)
         await self._update_progress(len(chunk_data))
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/_shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_directory_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_directory_client_async.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,41 +4,46 @@
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=invalid-overridden-method
 import functools
 import sys
 import time
 import warnings
-from typing import ( # pylint: disable=unused-import
-    Optional, Union, Any, Dict, TYPE_CHECKING
+from datetime import datetime
+from typing import (
+    Any, AnyStr, AsyncIterable, Dict, IO, Iterable, Optional, Union,
+    TYPE_CHECKING
 )
 
 from azure.core.async_paging import AsyncItemPaged
 from azure.core.exceptions import HttpResponseError, ResourceNotFoundError
 from azure.core.pipeline import AsyncPipeline
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 from .._parser import _get_file_permission, _datetime_to_str
 from .._shared.parser import _str
-
 from .._generated.aio import AzureFileStorage
 from .._shared.base_client_async import AsyncStorageAccountHostsMixin, AsyncTransportWrapper
 from .._shared.policies_async import ExponentialRetry
 from .._shared.request_handlers import add_metadata_headers
 from .._shared.response_handlers import return_response_headers, process_storage_error
 from .._deserialize import deserialize_directory_properties
 from .._serialize import get_api_version, get_dest_access_conditions, get_rename_smb_properties
 from .._directory_client import ShareDirectoryClient as ShareDirectoryClientBase
 from ._file_client_async import ShareFileClient
 from ._models import DirectoryPropertiesPaged, HandlesPaged
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
-    from datetime import datetime
-    from .._models import ShareProperties, DirectoryProperties, ContentSettings, NTFSAttributes
-    from .._generated.models import HandleItem
+    from azure.core.credentials import AzureNamedKeyCredential, AzureSasCredential, TokenCredential
+    from .._models import DirectoryProperties, Handle, NTFSAttributes
 
 
 class ShareDirectoryClient(AsyncStorageAccountHostsMixin, ShareDirectoryClientBase):
     """A client to interact with a specific directory, although it may not yet exist.
 
     For operations relating to a specific subdirectory or file in this share, the clients for those
     entities can also be retrieved using the :func:`get_subdirectory_client` and :func:`get_file_client` functions.
@@ -60,46 +65,63 @@
         account URL already has a SAS token. The value can be a SAS token string,
         an instance of a AzureSasCredential or AzureNamedKeyCredential from azure.core.credentials,
         an account shared access key, or an instance of a TokenCredentials class from azure.identity.
         If the resource URI already contains a SAS token, this will be ignored in favor of an explicit credential
         - except in the case of AzureSasCredential, where the conflicting SAS tokens will raise a ValueError.
         If using an instance of AzureNamedKeyCredential, "name" should be the storage account name, and "key"
         should be the storage account key.
+    :keyword token_intent:
+        Required when using `TokenCredential` for authentication and ignored for other forms of authentication.
+        Specifies the intent for all requests when using `TokenCredential` authentication. Possible values are:
+
+        backup - Specifies requests are intended for backup/admin type operations, meaning that all file/directory
+                 ACLs are bypassed and full permissions are granted. User must also have required RBAC permission.
+
+    :paramtype token_intent: Literal['backup']
+    :keyword bool allow_trailing_dot: If true, the trailing dot will not be trimmed from the target URI.
+    :keyword bool allow_source_trailing_dot: If true, the trailing dot will not be trimmed from the source URI.
     :keyword str api_version:
         The Storage API version to use for requests. Default value is the most recent service version that is
         compatible with the current SDK. Setting to an older version may result in reduced feature compatibility.
 
         .. versionadded:: 12.1.0
 
     :keyword str secondary_hostname:
         The hostname of the secondary endpoint.
     :keyword int max_range_size: The maximum range size used for a file upload. Defaults to 4*1024*1024.
     """
-    def __init__( # type: ignore
-            self, account_url,  # type: str
-            share_name, # type: str
-            directory_path, # type: str
-            snapshot=None,  # type: Optional[Union[str, Dict[str, Any]]]
-            credential=None, # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs # type: Optional[Any]
-        ):
-        # type: (...) -> None
+    def __init__(
+            self, account_url: str,
+            share_name: str,
+            directory_path: str,
+            snapshot: Optional[Union[str, Dict[str, Any]]] = None,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            *,
+            token_intent: Optional[Literal['backup']] = None,
+            **kwargs: Any
+        ) -> None:
         kwargs['retry_policy'] = kwargs.get('retry_policy') or ExponentialRetry(**kwargs)
         loop = kwargs.pop('loop', None)
         if loop and sys.version_info >= (3, 8):
             warnings.warn("The 'loop' parameter was deprecated from asyncio's high-level"
             "APIs in Python 3.8 and is no longer supported.", DeprecationWarning)
         super(ShareDirectoryClient, self).__init__(
             account_url,
             share_name=share_name,
             directory_path=directory_path,
             snapshot=snapshot,
             credential=credential,
             **kwargs)
-        self._client = AzureFileStorage(self.url, base_url=self.url, pipeline=self._pipeline)
+        self.allow_trailing_dot = kwargs.pop('allow_trailing_dot', None)
+        self.allow_source_trailing_dot = kwargs.pop('allow_source_trailing_dot', None)
+        self.file_request_intent = token_intent
+        self._client = AzureFileStorage(url=self.url, base_url=self.url, pipeline=self._pipeline,
+                                        allow_trailing_dot=self.allow_trailing_dot,
+                                        allow_source_trailing_dot=self.allow_source_trailing_dot,
+                                        file_request_intent=self.file_request_intent)
         self._client._config.version = get_api_version(kwargs) # pylint: disable=protected-access
 
     def get_file_client(self, file_name, **kwargs):
         # type: (str, Any) -> ShareFileClient
         """Get a client to interact with a specific file.
 
         The file need not already exist.
@@ -115,15 +137,17 @@
         _pipeline = AsyncPipeline(
             transport=AsyncTransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
             policies=self._pipeline._impl_policies # pylint: disable = protected-access
         )
         return ShareFileClient(
             self.url, file_path=file_name, share_name=self.share_name, snapshot=self.snapshot,
             credential=self.credential, api_version=self.api_version, _hosts=self._hosts, _configuration=self._config,
-            _pipeline=_pipeline, _location_mode=self._location_mode, **kwargs)
+            _pipeline=_pipeline, _location_mode=self._location_mode, allow_trailing_dot=self.allow_trailing_dot,
+            allow_source_trailing_dot=self.allow_source_trailing_dot, token_intent=self.file_request_intent,
+            **kwargs)
 
     def get_subdirectory_client(self, directory_name, **kwargs):
         # type: (str, Any) -> ShareDirectoryClient
         """Get a client to interact with a specific subdirectory.
 
         The subdirectory need not already exist.
 
@@ -146,15 +170,17 @@
         _pipeline = AsyncPipeline(
             transport=AsyncTransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
             policies=self._pipeline._impl_policies # pylint: disable = protected-access
         )
         return ShareDirectoryClient(
             self.url, share_name=self.share_name, directory_path=directory_path, snapshot=self.snapshot,
             credential=self.credential, api_version=self.api_version, _hosts=self._hosts, _configuration=self._config,
-            _pipeline=_pipeline, _location_mode=self._location_mode, **kwargs)
+            _pipeline=_pipeline, _location_mode=self._location_mode, allow_trailing_dot=self.allow_trailing_dot,
+            allow_source_trailing_dot=self.allow_source_trailing_dot, token_intent=self.file_request_intent,
+            **kwargs)
 
     @distributed_trace_async
     async def create_directory(self, **kwargs):
         # type: (Any) -> Dict[str, Any]
         """Creates a new directory under the directory referenced by the client.
 
         :keyword file_attributes:
@@ -184,15 +210,19 @@
             .. versionadded:: 12.8.0
                 This parameter was introduced in API version '2021-06-08'.
 
         :paramtype file_change_time: str or ~datetime.datetime
         :keyword dict(str,str) metadata:
             Name-value pairs associated with the directory as metadata.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: Directory-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory_async.py
                 :start-after: [START create_directory]
@@ -232,15 +262,19 @@
     @distributed_trace_async
     async def delete_directory(self, **kwargs):
         # type: (**Any) -> None
         """Marks the directory for deletion. The directory is
         later deleted during garbage collection.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory_async.py
                 :start-after: [START delete_directory]
                 :end-before: [END delete_directory]
@@ -262,15 +296,19 @@
         # type: (...) -> ShareDirectoryClient
         """
         Rename the source directory.
 
         :param str new_name:
             The new directory name.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword bool overwrite:
             A boolean value for if the destination file already exists, whether this request will
             overwrite the file or not. If true, the rename will succeed and will overwrite the
             destination file. If not provided or if false and the destination file does exist, the
             request will not overwrite the destination file. If provided and the destination file
             doesn't exist, the rename will succeed.
         :keyword bool ignore_read_only:
@@ -322,15 +360,16 @@
         else:
             new_dir_sas = self._query_str.strip('?')
 
         new_directory_client = ShareDirectoryClient(
             '{}://{}'.format(self.scheme, self.primary_hostname), self.share_name, new_dir_path,
             credential=new_dir_sas or self.credential, api_version=self.api_version,
             _hosts=self._hosts, _configuration=self._config, _pipeline=self._pipeline,
-            _location_mode=self._location_mode
+            _location_mode=self._location_mode, allow_trailing_dot=self.allow_trailing_dot,
+            allow_source_trailing_dot=self.allow_source_trailing_dot, token_intent=self.file_request_intent
         )
 
         kwargs.update(get_rename_smb_properties(kwargs))
 
         timeout = kwargs.pop('timeout', None)
         overwrite = kwargs.pop('overwrite', None)
         metadata = kwargs.pop('metadata', None)
@@ -370,15 +409,19 @@
         :keyword bool include_extended_info:
             If this is set to true, file id will be returned in listed results.
 
             .. versionadded:: 12.6.0
             This keyword argument was introduced in API version '2020-10-02'.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: An auto-paging iterable of dict-like DirectoryProperties and FileProperties
         :rtype: ~azure.core.async_paging.AsyncItemPaged[DirectoryProperties and FileProperties]
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory_async.py
                 :start-after: [START lists_directory]
@@ -403,17 +446,21 @@
         # type: (bool, Any) -> AsyncItemPaged
         """Lists opened handles on a directory or a file under the directory.
 
         :param bool recursive:
             Boolean that specifies if operation should apply to the directory specified by the client,
             its files, its subdirectories and their files. Default value is False.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: An auto-paging iterable of HandleItem
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.storage.fileshare.HandleItem]
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
+        :returns: An auto-paging iterable of Handle
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.storage.fileshare.Handle]
         """
         timeout = kwargs.pop('timeout', None)
         results_per_page = kwargs.pop('results_per_page', None)
         command = functools.partial(
             self._client.directory.list_handles,
             sharesnapshot=self.snapshot,
             timeout=timeout,
@@ -426,37 +473,45 @@
     @distributed_trace_async
     async def exists(self, **kwargs):
         # type: (**Any) -> bool
         """
         Returns True if a directory exists and returns False otherwise.
 
         :kwarg int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: True if the directory exists, False otherwise.
         :rtype: bool
         """
         try:
             await self._client.directory.get_properties(**kwargs)
             return True
         except HttpResponseError as error:
             try:
                 process_storage_error(error)
             except ResourceNotFoundError:
                 return False
 
     @distributed_trace_async
     async def close_handle(self, handle, **kwargs):
-        # type: (Union[str, HandleItem], Any) -> Dict[str, int]
+        # type: (Union[str, Handle], Any) -> Dict[str, int]
         """Close an open file handle.
 
         :param handle:
             A specific handle to close.
         :type handle: str or ~azure.storage.fileshare.Handle
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: The number of handles closed (this may be 0 if the specified handle was not found)
             and the number of handles failed to close in a dict.
         :rtype: dict[str, int]
         """
         try:
             handle_id = handle.id # type: ignore
         except AttributeError:
@@ -486,15 +541,19 @@
 
         This operation will block until the service has closed all open handles.
 
         :param bool recursive:
             Boolean that specifies if operation should apply to the directory specified by the client,
             its files, its subdirectories and their files. Default value is False.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: The number of handles closed (this may be 0 if the specified handle was not found)
             and the number of handles failed to close in a dict.
         :rtype: dict[str, int]
         """
         timeout = kwargs.pop('timeout', None)
         start_time = time.time()
 
@@ -530,15 +589,19 @@
     async def get_directory_properties(self, **kwargs):
         # type: (Any) -> DirectoryProperties
         """Returns all user-defined metadata and system properties for the
         specified directory. The data returned does not include the directory's
         list of files.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: DirectoryProperties
         :rtype: ~azure.storage.fileshare.DirectoryProperties
         """
         timeout = kwargs.pop('timeout', None)
         try:
             response = await self._client.directory.get_properties(
                 timeout=timeout,
@@ -557,15 +620,19 @@
         attached to the directory. To remove all metadata from the directory,
         call this operation with an empty metadata dict.
 
         :param metadata:
             Name-value pairs associated with the directory as metadata.
         :type metadata: dict(str, str)
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: Directory-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
         """
         timeout = kwargs.pop('timeout', None)
         headers = kwargs.pop('headers', {})
         headers.update(add_metadata_headers(metadata))
         try:
@@ -614,15 +681,19 @@
             Change time for the directory. If not specified, change time will be set to the current date/time.
 
             .. versionadded:: 12.8.0
                 This parameter was introduced in API version '2021-06-08'.
 
         :paramtype file_change_time: str or ~datetime.datetime
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
         """
         timeout = kwargs.pop('timeout', None)
         file_permission = _get_file_permission(file_permission, permission_key, 'preserve')
         file_change_time = kwargs.pop('file_change_time', None)
         try:
@@ -649,15 +720,19 @@
         with the subdirectory.
 
         :param str directory_name:
             The name of the subdirectory.
         :keyword dict(str,str) metadata:
             Name-value pairs associated with the subdirectory as metadata.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: ShareDirectoryClient
         :rtype: ~azure.storage.fileshare.aio.ShareDirectoryClient
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory_async.py
                 :start-after: [START create_subdirectory]
@@ -679,15 +754,19 @@
         ):
         # type: (...) -> None
         """Deletes a subdirectory.
 
         :param str directory_name:
             The name of the subdirectory.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory_async.py
                 :start-after: [START delete_subdirectory]
                 :end-before: [END delete_subdirectory]
@@ -697,26 +776,25 @@
         """
         timeout = kwargs.pop('timeout', None)
         subdir = self.get_subdirectory_client(directory_name)
         await subdir.delete_directory(timeout=timeout, **kwargs)
 
     @distributed_trace_async
     async def upload_file(
-            self, file_name,  # type: str
-            data, # type: Any
-            length=None, # type: Optional[int]
-            **kwargs # type: Any
-        ):
-        # type: (...) -> ShareFileClient
+            self, file_name: str,
+            data: Union[bytes, str, Iterable[AnyStr], AsyncIterable[AnyStr], IO[AnyStr]],
+            length: Optional[int] = None,
+            **kwargs
+        ) -> ShareFileClient:
         """Creates a new file in the directory and returns a ShareFileClient
         to interact with the file.
 
         :param str file_name:
             The name of the file.
-        :param Any data:
+        :param data:
             Content of the file.
         :param int length:
             Length of the file in bytes. Specify its maximum size, up to 1 TiB.
         :keyword dict(str,str) metadata:
             Name-value pairs associated with the file as metadata.
         :keyword ~azure.storage.fileshare.ContentSettings content_settings:
             ContentSettings object used to set file properties. Used to set content type, encoding,
@@ -732,15 +810,19 @@
             Maximum number of parallel connections to use.
         :keyword progress_hook:
             An async callback to track the progress of a long running upload. The signature is
             function(current: int, total: Optional[int]) where current is the number of bytes transferred
             so far, and total is the size of the blob or None if the size is unknown.
         :paramtype progress_hook: Callable[[int, Optional[int]], Awaitable[None]]
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword str encoding:
             Defaults to UTF-8.
         :returns: ShareFileClient
         :rtype: ~azure.storage.fileshare.aio.ShareFileClient
 
         .. admonition:: Example:
 
@@ -752,29 +834,33 @@
                 :caption: Upload a file to a directory.
         """
         file_client = self.get_file_client(file_name)
         await file_client.upload_file(
             data,
             length=length,
             **kwargs)
-        return file_client # type: ignore
+        return file_client
 
     @distributed_trace_async
     async def delete_file(
             self, file_name,  # type: str
             **kwargs  # type: Optional[Any]
         ):
         # type: (...) -> None
         """Marks the specified file for deletion. The file is later
         deleted during garbage collection.
 
         :param str file_name:
             The name of the file to delete.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_directory_async.py
                 :start-after: [START delete_file_in_directory]
                 :end-before: [END delete_file_in_directory]
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_download_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_download_async.py`

 * *Files 2% similar despite different names*

```diff
@@ -152,15 +152,15 @@
         The full path of the file.
     :ivar str share:
         The name of the share where the file is.
     :ivar ~azure.storage.fileshare.FileProperties properties:
         The properties of the file being downloaded. If only a range of the data is being
         downloaded, this will be reflected in the properties.
     :ivar int size:
-        The size of the total data in the stream. This will be the byte range if speficied,
+        The size of the total data in the stream. This will be the byte range if specified,
         otherwise the total size of the file.
     """
 
     def __init__(
             self,
             client=None,
             config=None,
@@ -260,27 +260,27 @@
             # Check the location we read from to ensure we use the same one
             # for subsequent requests.
             self._location_mode = location_mode
 
             # Parse the total file size and adjust the download size if ranges
             # were specified
             self._file_size = parse_length_from_content_range(response.properties.content_range)
-            if not self._file_size:
+            if self._file_size is None:
                 raise ValueError("Required Content-Range response header is missing or malformed.")
 
             if self._end_range is not None:
                 # Use the length unless it is over the end of the file
                 self.size = min(self._file_size, self._end_range - self._start_range + 1)
             elif self._start_range is not None:
                 self.size = self._file_size - self._start_range
             else:
                 self.size = self._file_size
 
         except HttpResponseError as error:
-            if self._start_range is None and error.response.status_code == 416:
+            if self._start_range is None and error.response and error.response.status_code == 416:
                 # Get range will fail on an empty file. If the user did not
                 # request a range, do a regular get request in order to get
                 # any properties.
                 try:
                     _, response = await self._client.download(
                         validate_content=self._validate_content,
                         data_stream_total=0,
@@ -346,34 +346,38 @@
         await self.readinto(stream)
         data = stream.getvalue()
         if self._encoding:
             return data.decode(self._encoding)
         return data
 
     async def content_as_bytes(self, max_concurrency=1):
-        """Download the contents of this file.
+        """DEPRECATED: Download the contents of this file.
 
         This operation is blocking until all data is downloaded.
 
+        This method is deprecated, use func:`readall` instead.
+
         :keyword int max_concurrency:
             The number of parallel connections with which to download.
         :rtype: bytes
         """
         warnings.warn(
             "content_as_bytes is deprecated, use readall instead",
             DeprecationWarning
         )
         self._max_concurrency = max_concurrency
         return await self.readall()
 
     async def content_as_text(self, max_concurrency=1, encoding="UTF-8"):
-        """Download the contents of this file, and decode as text.
+        """DEPRECATED: Download the contents of this file, and decode as text.
 
         This operation is blocking until all data is downloaded.
 
+        This method is deprecated, use func:`readall` instead.
+
         :keyword int max_concurrency:
             The number of parallel connections with which to download.
         :param str encoding:
             Test encoding to decode the downloaded bytes. Default is UTF-8.
         :rtype: str
         """
         warnings.warn(
@@ -454,14 +458,16 @@
             # Wait for the remaining downloads to finish
             await asyncio.wait(running_futures)
         return self.size
 
     async def download_to_stream(self, stream, max_concurrency=1):
         """Download the contents of this file to a stream.
 
+        This method is deprecated, use func:`readinto` instead.
+
         :param stream:
             The stream to download to. This can be an open file-handle,
             or any writable stream. The stream must be seekable if the download
             uses more than one parallel connection.
         :returns: The properties of the downloaded file.
         :rtype: Any
         """
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_file_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_file_client_async.py`

 * *Files 23% similar despite different names*

```diff
@@ -4,30 +4,31 @@
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=too-many-lines, invalid-overridden-method, too-many-public-methods
 import functools
 import sys
 import time
 import warnings
+from datetime import datetime
 from io import BytesIO
-from typing import Optional, Union, IO, List, Tuple, Dict, Any, Iterable, TYPE_CHECKING  # pylint: disable=unused-import
+from typing import (
+    Any, AnyStr, AsyncIterable, Dict, IO, Iterable, List, Optional, Tuple, Union,
+    TYPE_CHECKING
+)
 
-import six
 from azure.core.async_paging import AsyncItemPaged
 from azure.core.exceptions import HttpResponseError
-
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 from .._parser import _datetime_to_str, _get_file_permission
 from .._shared.parser import _str
-
 from .._generated.aio import AzureFileStorage
 from .._generated.models import FileHTTPHeaders
 from .._shared.policies_async import ExponentialRetry
-from .._shared.uploads_async import upload_data_chunks, FileChunkUploader, IterStreamer
+from .._shared.uploads_async import AsyncIterStreamer, FileChunkUploader, IterStreamer, upload_data_chunks
 from .._shared.base_client_async import AsyncStorageAccountHostsMixin
 from .._shared.request_handlers import add_metadata_headers, get_length
 from .._shared.response_handlers import return_response_headers, process_storage_error
 from .._deserialize import deserialize_file_properties, deserialize_file_stream, get_file_ranges_result
 from .._serialize import (
     get_access_conditions,
     get_api_version,
@@ -36,18 +37,22 @@
     get_smb_properties,
     get_source_access_conditions)
 from .._file_client import ShareFileClient as ShareFileClientBase
 from ._models import HandlesPaged
 from ._lease_async import ShareLeaseClient
 from ._download_async import StorageStreamDownloader
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
-    from datetime import datetime
-    from .._models import ShareProperties, ContentSettings, FileProperties, NTFSAttributes
-    from .._generated.models import HandleItem
+    from azure.core.credentials import AzureNamedKeyCredential, AzureSasCredential, TokenCredential
+    from .._models import ContentSettings, FileProperties, Handle, NTFSAttributes
 
 
 async def _upload_file_helper(
     client,
     stream,
     size,
     metadata,
@@ -117,45 +122,60 @@
         account URL already has a SAS token. The value can be a SAS token string,
         an instance of a AzureSasCredential or AzureNamedKeyCredential from azure.core.credentials,
         an account shared access key, or an instance of a TokenCredentials class from azure.identity.
         If the resource URI already contains a SAS token, this will be ignored in favor of an explicit credential
         - except in the case of AzureSasCredential, where the conflicting SAS tokens will raise a ValueError.
         If using an instance of AzureNamedKeyCredential, "name" should be the storage account name, and "key"
         should be the storage account key.
+    :keyword token_intent:
+        Required when using `TokenCredential` for authentication and ignored for other forms of authentication.
+        Specifies the intent for all requests when using `TokenCredential` authentication. Possible values are:
+
+        backup - Specifies requests are intended for backup/admin type operations, meaning that all file/directory
+                 ACLs are bypassed and full permissions are granted. User must also have required RBAC permission.
+
+    :paramtype token_intent: Literal['backup']
+    :keyword bool allow_trailing_dot: If true, the trailing dot will not be trimmed from the target URI.
+    :keyword bool allow_source_trailing_dot: If true, the trailing dot will not be trimmed from the source URI.
     :keyword str api_version:
         The Storage API version to use for requests. Default value is the most recent service version that is
         compatible with the current SDK. Setting to an older version may result in reduced feature compatibility.
 
         .. versionadded:: 12.1.0
 
     :keyword str secondary_hostname:
         The hostname of the secondary endpoint.
     :keyword int max_range_size: The maximum range size used for a file upload. Defaults to 4*1024*1024.
     """
-
-    def __init__(  # type: ignore
-        self,
-        account_url,  # type: str
-        share_name,  # type: str
-        file_path,  # type: str
-        snapshot=None,  # type: Optional[Union[str, Dict[str, Any]]]
-        credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-        **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def __init__(
+            self, account_url: str,
+            share_name: str,
+            file_path: str,
+            snapshot: Optional[Union[str, Dict[str, Any]]] = None,
+            credential: Optional[Union[str, Dict[str, str], "AzureNamedKeyCredential", "AzureSasCredential", "TokenCredential"]] = None,  # pylint: disable=line-too-long
+            *,
+            token_intent: Optional[Literal['backup']] = None,
+            **kwargs: Any
+        ) -> None:
         kwargs["retry_policy"] = kwargs.get("retry_policy") or ExponentialRetry(**kwargs)
         loop = kwargs.pop('loop', None)
         if loop and sys.version_info >= (3, 8):
             warnings.warn("The 'loop' parameter was deprecated from asyncio's high-level"
             "APIs in Python 3.8 and is no longer supported.", DeprecationWarning)
         super(ShareFileClient, self).__init__(
             account_url, share_name=share_name, file_path=file_path, snapshot=snapshot,
             credential=credential, **kwargs
         )
-        self._client = AzureFileStorage(self.url, base_url=self.url, pipeline=self._pipeline)
+        self.allow_trailing_dot = kwargs.pop('allow_trailing_dot', None)
+        self.allow_source_trailing_dot = kwargs.pop('allow_source_trailing_dot', None)
+        self.file_request_intent = token_intent
+        self._client = AzureFileStorage(url=self.url, base_url=self.url, pipeline=self._pipeline,
+                                        allow_trailing_dot=self.allow_trailing_dot,
+                                        allow_source_trailing_dot=self.allow_source_trailing_dot,
+                                        file_request_intent=self.file_request_intent)
         self._client._config.version = get_api_version(kwargs) # pylint: disable=protected-access
 
     @distributed_trace_async
     async def acquire_lease(self, lease_id=None, **kwargs):
         # type: (Optional[str], **Any) -> ShareLeaseClient
         """Requests a new lease.
 
@@ -163,15 +183,19 @@
         Service creates a lease on the blob and returns a new lease.
 
         :param str lease_id:
             Proposed lease ID, in a GUID string format. The File Service
             returns 400 (Invalid request) if the proposed lease ID is not
             in the correct format.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: A ShareLeaseClient object.
         :rtype: ~azure.storage.fileshare.aio.ShareLeaseClient
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/blob_samples_common.py
                 :start-after: [START acquire_lease_on_blob]
@@ -242,15 +266,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_client_async.py
                 :start-after: [START create_file]
@@ -295,27 +323,26 @@
                 **kwargs
             )
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def upload_file(
-        self, data,  # type: Any
-        length=None,  # type: Optional[int]
-        file_attributes="none",  # type: Union[str, NTFSAttributes]
-        file_creation_time="now",  # type: Optional[Union[str, datetime]]
-        file_last_write_time="now",  # type: Optional[Union[str, datetime]]
-        file_permission=None,  # type: Optional[str]
-        permission_key=None,  # type: Optional[str]
-        **kwargs  # type: Any
-    ):
-        # type: (...) -> Dict[str, Any]
+        self, data: Union[bytes, str, Iterable[AnyStr], AsyncIterable[AnyStr], IO[AnyStr]],
+            length: Optional[int] = None,
+            file_attributes: Union[str, "NTFSAttributes"] = "none",
+            file_creation_time: Optional[Union[str, datetime]] = "now",
+            file_last_write_time: Optional[Union[str, datetime]] = "now",
+            file_permission: Optional[str] = None,
+            permission_key: Optional[str] = None,
+            **kwargs
+        ) -> Dict[str, Any]:
         """Uploads a new file.
 
-        :param Any data:
+        :param data:
             Content of the file.
         :param int length:
             Length of the file in bytes. Specify its maximum size, up to 1 TiB.
         :param file_attributes:
             The file system attributes for files and directories.
             If not set, the default value would be "None" and the attributes will be set to "Archive".
             Here is an example for when the var type is str: 'Temporary|Archive'.
@@ -370,15 +397,19 @@
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword progress_hook:
             An async callback to track the progress of a long running upload. The signature is
             function(current: int, total: Optional[int]) where current is the number of bytes transferred
             so far, and total is the size of the blob or None if the size is unknown.
         :paramtype progress_hook: Callable[[int, Optional[int]], Awaitable[None]]
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_client_async.py
                 :start-after: [START upload_file]
@@ -391,30 +422,32 @@
         content_settings = kwargs.pop('content_settings', None)
         max_concurrency = kwargs.pop('max_concurrency', 1)
         validate_content = kwargs.pop('validate_content', False)
         progress_hook = kwargs.pop('progress_hook', None)
         timeout = kwargs.pop('timeout', None)
         encoding = kwargs.pop('encoding', 'UTF-8')
 
-        if isinstance(data, six.text_type):
+        if isinstance(data, str):
             data = data.encode(encoding)
         if length is None:
             length = get_length(data)
         if isinstance(data, bytes):
             data = data[:length]
 
         if isinstance(data, bytes):
             stream = BytesIO(data)
         elif hasattr(data, "read"):
             stream = data
         elif hasattr(data, "__iter__"):
-            stream = IterStreamer(data, encoding=encoding)  # type: ignore
+            stream = IterStreamer(data, encoding=encoding)
+        elif hasattr(data, '__aiter__'):
+            stream = AsyncIterStreamer(data, encoding=encoding)
         else:
             raise TypeError("Unsupported data type: {}".format(type(data)))
-        return await _upload_file_helper(  # type: ignore
+        return await _upload_file_helper(
             self,
             stream,
             length,
             metadata,
             content_settings,
             validate_content,
             timeout,
@@ -518,15 +551,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: dict(str, Any)
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_client_async.py
                 :start-after: [START copy_file_from_url]
                 :end-before: [END copy_file_from_url]
@@ -569,15 +606,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
             copy_id = copy_id.copy.id
         except AttributeError:
@@ -630,15 +671,19 @@
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword progress_hook:
             An async callback to track the progress of a long running download. The signature is
             function(current: int, total: int) where current is the number of bytes transferred
             so far, and total is the size of the blob or None if the size is unknown.
         :paramtype progress_hook: Callable[[int, int], Awaitable[None]]
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: A streaming object (StorageStreamDownloader)
         :rtype: ~azure.storage.fileshare.aio.StorageStreamDownloader
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_client_async.py
                 :start-after: [START download_file]
@@ -681,15 +726,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/file_samples_client_async.py
                 :start-after: [START delete_file]
                 :end-before: [END delete_file]
@@ -712,15 +761,19 @@
         # type: (...) -> ShareFileClient
         """
         Rename the source file.
 
         :param str new_name:
             The new file name.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword bool overwrite:
             A boolean value for if the destination file already exists, whether this request will
             overwrite the file or not. If true, the rename will succeed and will overwrite the
             destination file. If not provided or if false and the destination file does exist, the
             request will not overwrite the destination file. If provided and the destination file
             doesn't exist, the rename will succeed.
         :keyword bool ignore_read_only:
@@ -782,15 +835,16 @@
         else:
             new_file_sas = self._query_str.strip('?')
 
         new_file_client = ShareFileClient(
             '{}://{}'.format(self.scheme, self.primary_hostname), self.share_name, new_file_path,
             credential=new_file_sas or self.credential, api_version=self.api_version,
             _hosts=self._hosts, _configuration=self._config, _pipeline=self._pipeline,
-            _location_mode=self._location_mode
+            _location_mode=self._location_mode, allow_trailing_dot=self.allow_trailing_dot,
+            allow_source_trailing_dot=self.allow_source_trailing_dot, token_intent=self.file_request_intent
         )
 
         kwargs.update(get_rename_smb_properties(kwargs))
 
         file_http_headers = None
         content_type = kwargs.pop('content_type', None)
         if content_type:
@@ -832,15 +886,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: FileProperties
         :rtype: ~azure.storage.fileshare.FileProperties
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
             file_props = await self._client.file.get_properties(
@@ -906,15 +964,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         file_content_length = kwargs.pop("size", None)
         file_http_headers = FileHTTPHeaders(
@@ -962,15 +1024,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: dict(str, Any)
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         headers = kwargs.pop("headers", {})
         headers.update(add_metadata_headers(metadata))  # type: ignore
@@ -1021,25 +1087,29 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword str encoding:
             Defaults to UTF-8.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: Dict[str, Any]
         """
         validate_content = kwargs.pop('validate_content', False)
         timeout = kwargs.pop('timeout', None)
         encoding = kwargs.pop('encoding', 'UTF-8')
         file_last_write_mode = kwargs.pop('file_last_write_mode', None)
-        if isinstance(data, six.text_type):
+        if isinstance(data, str):
             data = data.encode(encoding)
         end_range = offset + length - 1  # Reformat to an inclusive range index
         content_range = 'bytes={0}-{1}'.format(offset, end_range)
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         try:
             return await self._client.file.upload_range(  # type: ignore
                 range=content_range,
@@ -1114,15 +1184,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :keyword str source_authorization:
             Authenticate as a service principal using a client secret to access a source blob. Ensure "bearer " is
             the prefix of the source_authorization string.
         """
         options = self._upload_range_from_url_options(
             source_url=source_url,
             offset=offset,
@@ -1153,15 +1227,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns:
             A list of valid ranges.
         :rtype: List[dict[str, int]]
         """
         options = self._get_ranges_options(
             offset=offset,
             length=length,
@@ -1195,15 +1273,19 @@
             specifies a previous file snapshot to be compared
             against a more recent snapshot or the current file.
         :keyword lease:
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
         :paramtype lease: ~azure.storage.fileshare.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns:
             A tuple of two lists of file ranges as dictionaries with 'start' and 'end' keys.
             The first element are filled file ranges, the 2nd element is cleared file ranges.
         :rtype: tuple(list(dict(str, str), list(dict(str, str))
         """
         options = self._get_ranges_options(
             offset=offset,
@@ -1237,15 +1319,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: Dict[str, Any]
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
 
         if offset is None or offset % 512 != 0:
@@ -1279,15 +1365,19 @@
             Required if the file has an active lease. Value can be a ShareLeaseClient object
             or the lease ID as a string.
 
             .. versionadded:: 12.1.0
 
         :paramtype lease: ~azure.storage.fileshare.aio.ShareLeaseClient or str
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns: File-updated property dict (Etag and last modified).
         :rtype: Dict[str, Any]
         """
         access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
             return await self._client.file.set_http_headers(  # type: ignore
@@ -1306,39 +1396,47 @@
 
     @distributed_trace
     def list_handles(self, **kwargs):
         # type: (Any) -> AsyncItemPaged
         """Lists handles for file.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: An auto-paging iterable of HandleItem
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.storage.fileshare.HandleItem]
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
+        :returns: An auto-paging iterable of Handle
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.storage.fileshare.Handle]
         """
         timeout = kwargs.pop('timeout', None)
         results_per_page = kwargs.pop("results_per_page", None)
         command = functools.partial(
             self._client.file.list_handles,
             sharesnapshot=self.snapshot,
             timeout=timeout,
             **kwargs)
         return AsyncItemPaged(
             command, results_per_page=results_per_page,
             page_iterator_class=HandlesPaged)
 
     @distributed_trace_async
     async def close_handle(self, handle, **kwargs):
-        # type: (Union[str, HandleItem], Any) -> Dict[str, int]
+        # type: (Union[str, Handle], Any) -> Dict[str, int]
         """Close an open file handle.
 
         :param handle:
             A specific handle to close.
         :type handle: str or ~azure.storage.fileshare.Handle
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns:
             The number of handles closed (this may be 0 if the specified handle was not found)
             and the number of handles failed to close in a dict.
         :rtype: dict[str, int]
         """
         try:
             handle_id = handle.id # type: ignore
@@ -1365,15 +1463,19 @@
     async def close_all_handles(self, **kwargs):
         # type: (Any) -> Dict[str, int]
         """Close any open file handles.
 
         This operation will block until the service has closed all open handles.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :returns:
             The number of handles closed (this may be 0 if the specified handle was not found)
             and the number of handles failed to close in a dict.
         :rtype: dict[str, int]
         """
         timeout = kwargs.pop('timeout', None)
         start_time = time.time()
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_lease_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_lease_async.py`

 * *Files 22% similar despite different names*

```diff
@@ -73,15 +73,19 @@
         :keyword int lease_duration:
             Specifies the duration of the lease, in seconds, or negative one
             (-1) for a lease that never expires. File leases never expire. A non-infinite share lease can be
             between 15 and 60 seconds. A share lease duration cannot be changed
             using renew or change. Default is -1 (infinite share lease).
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :rtype: None
         """
         try:
             lease_duration = kwargs.pop('lease_duration', -1)
             if self._snapshot:
                 kwargs['sharesnapshot'] = self._snapshot
             response = await self._client.acquire_lease(
@@ -106,15 +110,19 @@
         the lease may be renewed even if it has expired as long as the share
         has not been leased again since the expiration of that lease. When you
         renew a lease, the lease duration clock resets.
 
         .. versionadded:: 12.6.0
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :return: None
         """
         if isinstance(self._client, FileOperations):
             raise TypeError("Lease renewal operations are only valid for ShareClient.")
         try:
             response = await self._client.renew_lease(
                 lease_id=self.id,
@@ -132,15 +140,19 @@
     async def release(self, **kwargs):
         # type: (Any) -> None
         """Releases the lease. The lease may be released if the lease ID specified on the request matches
         that associated with the share or file. Releasing the lease allows another client to immediately acquire
         the lease for the share or file as soon as the release is complete.
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :return: None
         """
         try:
             if self._snapshot:
                 kwargs['sharesnapshot'] = self._snapshot
             response = await self._client.release_lease(
                 lease_id=self.id,
@@ -159,15 +171,19 @@
         """ Changes the lease ID of an active lease. A change must include the current lease ID in x-ms-lease-id and
         a new lease ID in x-ms-proposed-lease-id.
 
         :param str proposed_lease_id:
             Proposed lease ID, in a GUID string format. The File or Share service raises an error
             (Invalid request) if the proposed lease ID is not in the correct format.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :return: None
         """
         try:
             if self._snapshot:
                 kwargs['sharesnapshot'] = self._snapshot
             response = await self._client.change_lease(
                 lease_id=self.id,
@@ -202,15 +218,19 @@
             period. If this header does not appear with a break
             operation, a fixed-duration share lease breaks after the remaining share lease
             period elapses, and an infinite share lease breaks immediately.
 
             .. versionadded:: 12.5.0
 
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
+            Sets the server-side timeout for the operation in seconds. For more details see
+            https://learn.microsoft.com/rest/api/storageservices/setting-timeouts-for-file-service-operations.
+            This value is not tracked or validated on the client. To configure client-side network timesouts
+            see `here <https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-file-share
+            #other-client--per-operation-configuration>`_.
         :return: Approximate time remaining in the lease period, in seconds.
         :rtype: int
         """
         try:
             lease_break_period = kwargs.pop('lease_break_period', None)
             if self._snapshot:
                 kwargs['sharesnapshot'] = self._snapshot
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_models.py`

 * *Files 1% similar despite different names*

```diff
@@ -55,14 +55,15 @@
         self.current_page = []
 
     async def _get_next_cb(self, continuation_token):
         try:
             return await self._command(
                 marker=continuation_token or None,
                 maxresults=self.results_per_page,
+                prefix=self.prefix,
                 cls=return_context_and_deserialized,
                 use_location=self.location_mode)
         except HttpResponseError as error:
             process_storage_error(error)
 
     async def _extract_data_cb(self, get_next_return):
         self.location_mode, self._response = get_next_return
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_share_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_queue_client_async.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,761 +1,765 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=invalid-overridden-method
-import warnings
-import sys
-from typing import ( # pylint: disable=unused-import
-    Optional, Union, Dict, Any, Iterable, TYPE_CHECKING
+
+import functools
+from typing import (  # pylint: disable=unused-import
+    Union,
+    Optional,
+    Any,
+    IO,
+    Iterable,
+    AnyStr,
+    Dict,
+    List,
+    Tuple,
+    TYPE_CHECKING,
 )
 
+try:
+    from urllib.parse import urlparse, quote, unquote  # pylint: disable=unused-import
+except ImportError:
+    from urlparse import urlparse  # type: ignore
+    from urllib2 import quote, unquote  # type: ignore
+
 from azure.core.exceptions import HttpResponseError
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
-from azure.core.pipeline import AsyncPipeline
-from .._shared.policies_async import ExponentialRetry
-from .._shared.base_client_async import AsyncStorageAccountHostsMixin, AsyncTransportWrapper
+
+from azure.core.async_paging import AsyncItemPaged
+
+from .._serialize import get_api_version
+from .._shared.base_client_async import AsyncStorageAccountHostsMixin
 from .._shared.request_handlers import add_metadata_headers, serialize_iso
 from .._shared.response_handlers import (
     return_response_headers,
     process_storage_error,
-    return_headers_and_deserialized)
-from .._generated.aio import AzureFileStorage
-from .._generated.models import (
-    SignedIdentifier,
-    DeleteSnapshotsOptionType)
-from .._deserialize import deserialize_share_properties, deserialize_permission
-from .._serialize import get_api_version, get_access_conditions
-from .._share_client import ShareClient as ShareClientBase
-from ._directory_client_async import ShareDirectoryClient
-from ._file_client_async import ShareFileClient
-from ..aio._lease_async import ShareLeaseClient
-from .._models import ShareProtocols
+    return_headers_and_deserialized,
+)
+from .._deserialize import deserialize_queue_properties, deserialize_queue_creation
+from .._generated.aio import AzureQueueStorage
+from .._generated.models import SignedIdentifier
+from .._generated.models import QueueMessage as GenQueueMessage
 
-if TYPE_CHECKING:
-    from .._models import ShareProperties, AccessPolicy
+from .._models import QueueMessage, AccessPolicy
+from ._models import MessagesPaged
+from .._shared.policies_async import ExponentialRetry
+from .._queue_client import QueueClient as QueueClientBase
 
 
-class ShareClient(AsyncStorageAccountHostsMixin, ShareClientBase):
-    """A client to interact with a specific share, although that share may not yet exist.
+if TYPE_CHECKING:
+    from datetime import datetime
+    from azure.core.pipeline.policies import HTTPPolicy
+    from .._models import QueueSasPermissions, QueueProperties
 
-    For operations relating to a specific directory or file in this share, the clients for
-    those entities can also be retrieved using the :func:`get_directory_client` and :func:`get_file_client` functions.
+
+class QueueClient(AsyncStorageAccountHostsMixin, QueueClientBase):
+    """A client to interact with a specific Queue.
 
     :param str account_url:
-        The URI to the storage account. In order to create a client given the full URI to the share,
-        use the :func:`from_share_url` classmethod.
-    :param share_name:
-        The name of the share with which to interact.
-    :type share_name: str
-    :param str snapshot:
-        An optional share snapshot on which to operate. This can be the snapshot ID string
-        or the response returned from :func:`create_snapshot`.
+        The URL to the storage account. In order to create a client given the full URI to the queue,
+        use the :func:`from_queue_url` classmethod.
+    :param queue_name: The name of the queue.
+    :type queue_name: str
     :param credential:
         The credentials with which to authenticate. This is optional if the
         account URL already has a SAS token. The value can be a SAS token string,
-        an instance of a AzureSasCredential or AzureNamedKeyCredential from azure.core.credentials,
-        an account shared access key, or an instance of a TokenCredentials class from azure.identity.
-        If the resource URI already contains a SAS token, this will be ignored in favor of an explicit credential
-        - except in the case of AzureSasCredential, where the conflicting SAS tokens will raise a ValueError.
-        If using an instance of AzureNamedKeyCredential, "name" should be the storage account name, and "key"
-        should be the storage account key.
+        an instance of a AzureSasCredential from azure.core.credentials, an account
+        shared access key, or an instance of a TokenCredentials class from azure.identity.
     :keyword str api_version:
         The Storage API version to use for requests. Default value is the most recent service version that is
         compatible with the current SDK. Setting to an older version may result in reduced feature compatibility.
-
-        .. versionadded:: 12.1.0
-
     :keyword str secondary_hostname:
         The hostname of the secondary endpoint.
-    :keyword int max_range_size: The maximum range size used for a file upload. Defaults to 4*1024*1024.
+    :keyword message_encode_policy: The encoding policy to use on outgoing messages.
+        Default is not to encode messages. Other options include :class:`TextBase64EncodePolicy`,
+        :class:`BinaryBase64EncodePolicy` or `None`.
+    :keyword message_decode_policy: The decoding policy to use on incoming messages.
+        Default value is not to decode messages. Other options include :class:`TextBase64DecodePolicy`,
+        :class:`BinaryBase64DecodePolicy` or `None`.
+
+    .. admonition:: Example:
+
+        .. literalinclude:: ../samples/queue_samples_message_async.py
+            :start-after: [START async_create_queue_client]
+            :end-before: [END async_create_queue_client]
+            :language: python
+            :dedent: 16
+            :caption: Create the queue client with url and credential.
+
+        .. literalinclude:: ../samples/queue_samples_message_async.py
+            :start-after: [START async_create_queue_client_from_connection_string]
+            :end-before: [END async_create_queue_client_from_connection_string]
+            :language: python
+            :dedent: 8
+            :caption: Create the queue client with a connection string.
     """
-    def __init__( # type: ignore
-            self, account_url,  # type: str
-            share_name,  # type: str
-            snapshot=None,  # type: Optional[Union[str, Dict[str, Any]]]
-            credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
-            **kwargs  # type: Any
-        ):
+
+    def __init__(
+        self,
+        account_url,  # type: str
+        queue_name,  # type: str
+        credential=None,  # type: Optional[Any]
+        **kwargs  # type: Any
+    ):
         # type: (...) -> None
-        kwargs['retry_policy'] = kwargs.get('retry_policy') or ExponentialRetry(**kwargs)
+        kwargs["retry_policy"] = kwargs.get("retry_policy") or ExponentialRetry(**kwargs)
         loop = kwargs.pop('loop', None)
-        if loop and sys.version_info >= (3, 8):
-            warnings.warn("The 'loop' parameter was deprecated from asyncio's high-level"
-            "APIs in Python 3.8 and is no longer supported.", DeprecationWarning)
-        super(ShareClient, self).__init__(
-            account_url,
-            share_name=share_name,
-            snapshot=snapshot,
-            credential=credential,
-            **kwargs)
-        self._client = AzureFileStorage(self.url, base_url=self.url, pipeline=self._pipeline)
-        self._client._config.version = get_api_version(kwargs)  # pylint: disable=protected-access
-
-    def get_directory_client(self, directory_path=None):
-        # type: (Optional[str]) -> ShareDirectoryClient
-        """Get a client to interact with the specified directory.
-        The directory need not already exist.
-
-        :param str directory_path:
-            Path to the specified directory.
-        :returns: A Directory Client.
-        :rtype: ~azure.storage.fileshare.aio.ShareDirectoryClient
-        """
-        _pipeline = AsyncPipeline(
-            transport=AsyncTransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
-            policies=self._pipeline._impl_policies # pylint: disable = protected-access
+        super(QueueClient, self).__init__(
+            account_url, queue_name=queue_name, credential=credential, loop=loop, **kwargs
         )
-
-        return ShareDirectoryClient(
-            self.url, share_name=self.share_name, directory_path=directory_path or "", snapshot=self.snapshot,
-            credential=self.credential, api_version=self.api_version, _hosts=self._hosts, _configuration=self._config,
-            _pipeline=_pipeline, _location_mode=self._location_mode)
-
-    def get_file_client(self, file_path):
-        # type: (str) -> ShareFileClient
-        """Get a client to interact with the specified file.
-        The file need not already exist.
-
-        :param str file_path:
-            Path to the specified file.
-        :returns: A File Client.
-        :rtype: ~azure.storage.fileshare.aio.ShareFileClient
-        """
-        _pipeline = AsyncPipeline(
-            transport=AsyncTransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
-            policies=self._pipeline._impl_policies # pylint: disable = protected-access
-        )
-
-        return ShareFileClient(
-            self.url, share_name=self.share_name, file_path=file_path, snapshot=self.snapshot,
-            credential=self.credential, api_version=self.api_version, _hosts=self._hosts, _configuration=self._config,
-            _pipeline=_pipeline, _location_mode=self._location_mode)
-
-    @distributed_trace_async()
-    async def acquire_lease(self, **kwargs):
-        # type: (**Any) -> ShareLeaseClient
-        """Requests a new lease.
-
-        If the share does not have an active lease, the Share
-        Service creates a lease on the share and returns a new lease.
-
-        .. versionadded:: 12.5.0
-
-        :keyword int lease_duration:
-            Specifies the duration of the lease, in seconds, or negative one
-            (-1) for a lease that never expires. A non-infinite lease can be
-            between 15 and 60 seconds. A lease duration cannot be changed
-            using renew or change. Default is -1 (infinite lease).
-        :keyword str lease_id:
-            Proposed lease ID, in a GUID string format. The Share Service
-            returns 400 (Invalid request) if the proposed lease ID is not
-            in the correct format.
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: A ShareLeaseClient object.
-        :rtype: ~azure.storage.fileshare.ShareLeaseClient
-
-        .. admonition:: Example:
-
-            .. literalinclude:: ../samples/file_samples_share.py
-                :start-after: [START acquire_lease_on_share]
-                :end-before: [END acquire_lease_on_share]
-                :language: python
-                :dedent: 8
-                :caption: Acquiring a lease on a share.
-        """
-        kwargs['lease_duration'] = kwargs.pop('lease_duration', -1)
-        lease_id = kwargs.pop('lease_id', None)
-        lease = ShareLeaseClient(self, lease_id=lease_id)  # type: ignore
-        await lease.acquire(**kwargs)
-        return lease
+        self._client = AzureQueueStorage(self.url, base_url=self.url,
+                                         pipeline=self._pipeline, loop=loop)  # type: ignore
+        self._client._config.version = get_api_version(kwargs)  # pylint: disable=protected-access
+        self._loop = loop
 
     @distributed_trace_async
-    async def create_share(self, **kwargs):
-        # type: (Any) -> Dict[str, Any]
-        """Creates a new Share under the account. If a share with the
-        same name already exists, the operation fails.
+    async def create_queue(self, **kwargs):
+        # type: (Optional[Any]) -> None
+        """Creates a new queue in the storage account.
 
-        :keyword dict(str,str) metadata:
-            Name-value pairs associated with the share as metadata.
-        :keyword int quota:
-            The quota to be allotted.
-        :keyword access_tier:
-            Specifies the access tier of the share.
-            Possible values: 'TransactionOptimized', 'Hot', 'Cool'
-        :paramtype access_tier: str or ~azure.storage.fileshare.models.ShareAccessTier
-
-            .. versionadded:: 12.4.0
+        If a queue with the same name already exists, the operation fails with
+        a `ResourceExistsError`.
 
+        :keyword dict(str,str) metadata:
+            A dict containing name-value pairs to associate with the queue as
+            metadata. Note that metadata names preserve the case with which they
+            were created, but are case-insensitive when set or read.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :keyword protocols:
-            Protocols to enable on the share. Only one protocol can be enabled on the share.
-        :paramtype protocols: str or ~azure.storage.fileshare.ShareProtocols
-        :keyword root_squash:
-            Root squash to set on the share.
-            Only valid for NFS shares. Possible values include: 'NoRootSquash', 'RootSquash', 'AllSquash'.
-        :paramtype root_squash: str or ~azure.storage.fileshare.ShareRootSquash
-        :returns: Share-updated property dict (Etag and last modified).
-        :rtype: Dict[str, Any]
+            The server timeout, expressed in seconds.
+        :return: None or the result of cls(response)
+        :rtype: None
+        :raises: StorageErrorException
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share_async.py
-                :start-after: [START create_share]
-                :end-before: [END create_share]
+            .. literalinclude:: ../samples/queue_samples_hello_world_async.py
+                :start-after: [START async_create_queue]
+                :end-before: [END async_create_queue]
                 :language: python
                 :dedent: 12
-                :caption: Creates a file share.
+                :caption: Create a queue.
         """
         metadata = kwargs.pop('metadata', None)
-        quota = kwargs.pop('quota', None)
-        access_tier = kwargs.pop('access_tier', None)
         timeout = kwargs.pop('timeout', None)
-        root_squash = kwargs.pop('root_squash', None)
-        protocols = kwargs.pop('protocols', None)
-        if protocols and protocols not in ['NFS', 'SMB', ShareProtocols.SMB, ShareProtocols.NFS]:
-            raise ValueError("The enabled protocol must be set to either SMB or NFS.")
-        if root_squash and protocols not in ['NFS', ShareProtocols.NFS]:
-            raise ValueError("The 'root_squash' keyword can only be used on NFS enabled shares.")
-        headers = kwargs.pop('headers', {})
-        headers.update(add_metadata_headers(metadata)) # type: ignore
-
+        headers = kwargs.pop("headers", {})
+        headers.update(add_metadata_headers(metadata))  # type: ignore
         try:
-            return await self._client.share.create( # type: ignore
-                timeout=timeout,
-                metadata=metadata,
-                quota=quota,
-                access_tier=access_tier,
-                root_squash=root_squash,
-                enabled_protocols=protocols,
-                cls=return_response_headers,
-                headers=headers,
-                **kwargs)
+            return await self._client.queue.create(  # type: ignore
+                metadata=metadata, timeout=timeout, headers=headers, cls=deserialize_queue_creation, **kwargs
+            )
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace_async
-    async def create_snapshot( # type: ignore
-            self,
-            **kwargs # type: Optional[Any]
-        ):
-        # type: (...) -> Dict[str, Any]
-        """Creates a snapshot of the share.
+    async def delete_queue(self, **kwargs):
+        # type: (Optional[Any]) -> None
+        """Deletes the specified queue and any messages it contains.
 
-        A snapshot is a read-only version of a share that's taken at a point in time.
-        It can be read, copied, or deleted, but not modified. Snapshots provide a way
-        to back up a share as it appears at a moment in time.
+        When a queue is successfully deleted, it is immediately marked for deletion
+        and is no longer accessible to clients. The queue is later removed from
+        the Queue service during garbage collection.
 
-        A snapshot of a share has the same name as the base share from which the snapshot
-        is taken, with a DateTime value appended to indicate the time at which the
-        snapshot was taken.
+        Note that deleting a queue is likely to take at least 40 seconds to complete.
+        If an operation is attempted against the queue while it was being deleted,
+        an :class:`HttpResponseError` will be thrown.
 
-        :keyword dict(str,str) metadata:
-            Name-value pairs associated with the share as metadata.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: Share-updated property dict (Snapshot ID, Etag, and last modified).
-        :rtype: dict[str, Any]
+            The server timeout, expressed in seconds.
+        :rtype: None
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share_async.py
-                :start-after: [START create_share_snapshot]
-                :end-before: [END create_share_snapshot]
+            .. literalinclude:: ../samples/queue_samples_hello_world_async.py
+                :start-after: [START async_delete_queue]
+                :end-before: [END async_delete_queue]
                 :language: python
                 :dedent: 16
-                :caption: Creates a snapshot of the file share.
+                :caption: Delete a queue.
         """
-        metadata = kwargs.pop('metadata', None)
         timeout = kwargs.pop('timeout', None)
-        headers = kwargs.pop('headers', {})
-        headers.update(add_metadata_headers(metadata)) # type: ignore
         try:
-            return await self._client.share.create_snapshot( # type: ignore
-                timeout=timeout,
-                cls=return_response_headers,
-                headers=headers,
-                **kwargs)
+            await self._client.queue.delete(timeout=timeout, **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace_async
-    async def delete_share(
-            self, delete_snapshots=False, # type: Optional[bool]
-            **kwargs
-        ):
-        # type: (...) -> None
-        """Marks the specified share for deletion. The share is
-        later deleted during garbage collection.
+    async def get_queue_properties(self, **kwargs):
+        # type: (Optional[Any]) -> QueueProperties
+        """Returns all user-defined metadata for the specified queue.
+
+        The data returned does not include the queue's list of messages.
 
-        :param bool delete_snapshots:
-            Indicates if snapshots are to be deleted.
         :keyword int timeout:
             The timeout parameter is expressed in seconds.
-        :keyword lease:
-            Required if the share has an active lease. Value can be a ShareLeaseClient object
-            or the lease ID as a string.
-
-            .. versionadded:: 12.5.0
-            This keyword argument was introduced in API version '2020-08-04'.
+        :return: User-defined metadata for the queue.
+        :rtype: ~azure.storage.queue.QueueProperties
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share_async.py
-                :start-after: [START delete_share]
-                :end-before: [END delete_share]
+            .. literalinclude:: ../samples/queue_samples_message_async.py
+                :start-after: [START async_get_queue_properties]
+                :end-before: [END async_get_queue_properties]
                 :language: python
                 :dedent: 16
-                :caption: Deletes the share and any snapshots.
+                :caption: Get the properties on the queue.
         """
-        access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
-        delete_include = None
-        if delete_snapshots:
-            delete_include = DeleteSnapshotsOptionType.include
         try:
-            await self._client.share.delete(
-                timeout=timeout,
-                sharesnapshot=self.snapshot,
-                delete_snapshots=delete_include,
-                lease_access_conditions=access_conditions,
-                **kwargs)
+            response = await self._client.queue.get_properties(
+                timeout=timeout, cls=deserialize_queue_properties, **kwargs
+            )
         except HttpResponseError as error:
             process_storage_error(error)
+        response.name = self.queue_name
+        return response  # type: ignore
 
     @distributed_trace_async
-    async def get_share_properties(self, **kwargs):
-        # type: (Any) -> ShareProperties
-        """Returns all user-defined metadata and system properties for the
-        specified share. The data returned does not include the shares's
-        list of files or directories.
-
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :keyword lease:
-            Required if the share has an active lease. Value can be a ShareLeaseClient object
-            or the lease ID as a string.
+    async def set_queue_metadata(self, metadata=None, **kwargs):
+        # type: (Optional[Dict[str, Any]], Optional[Any]) -> None
+        """Sets user-defined metadata on the specified queue.
 
-            .. versionadded:: 12.5.0
-            This keyword argument was introduced in API version '2020-08-04'.
+        Metadata is associated with the queue as name-value pairs.
 
-        :returns: The share properties.
-        :rtype: ~azure.storage.fileshare.ShareProperties
+        :param metadata:
+            A dict containing name-value pairs to associate with the
+            queue as metadata.
+        :type metadata: dict(str, str)
+        :keyword int timeout:
+            The server timeout, expressed in seconds.
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_hello_world_async.py
-                :start-after: [START get_share_properties]
-                :end-before: [END get_share_properties]
+            .. literalinclude:: ../samples/queue_samples_message_async.py
+                :start-after: [START async_set_queue_metadata]
+                :end-before: [END async_set_queue_metadata]
                 :language: python
                 :dedent: 16
-                :caption: Gets the share properties.
+                :caption: Set metadata on the queue.
         """
-        access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
+        headers = kwargs.pop("headers", {})
+        headers.update(add_metadata_headers(metadata))  # type: ignore
         try:
-            props = await self._client.share.get_properties(
-                timeout=timeout,
-                sharesnapshot=self.snapshot,
-                cls=deserialize_share_properties,
-                lease_access_conditions=access_conditions,
-                **kwargs)
+            return await self._client.queue.set_metadata(  # type: ignore
+                timeout=timeout, headers=headers, cls=return_response_headers, **kwargs
+            )
         except HttpResponseError as error:
             process_storage_error(error)
-        props.name = self.share_name
-        props.snapshot = self.snapshot
-        return props # type: ignore
 
     @distributed_trace_async
-    async def set_share_quota(self, quota, **kwargs):
-        # type: (int, Any) ->  Dict[str, Any]
-        """Sets the quota for the share.
+    async def get_queue_access_policy(self, **kwargs):
+        # type: (Optional[Any]) -> Dict[str, Any]
+        """Returns details about any stored access policies specified on the
+        queue that may be used with Shared Access Signatures.
 
-        :param int quota:
-            Specifies the maximum size of the share, in gigabytes.
-            Must be greater than 0, and less than or equal to 5TB.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :keyword lease:
-            Required if the share has an active lease. Value can be a ShareLeaseClient object
-            or the lease ID as a string.
-
-            .. versionadded:: 12.5.0
-            This keyword argument was introduced in API version '2020-08-04'.
-
-        :returns: Share-updated property dict (Etag and last modified).
-        :rtype: dict(str, Any)
-
-        .. admonition:: Example:
-
-            .. literalinclude:: ../samples/file_samples_share_async.py
-                :start-after: [START set_share_quota]
-                :end-before: [END set_share_quota]
-                :language: python
-                :dedent: 16
-                :caption: Sets the share quota.
+            The server timeout, expressed in seconds.
+        :return: A dictionary of access policies associated with the queue.
+        :rtype: dict(str, ~azure.storage.queue.AccessPolicy)
         """
-        access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
         try:
-            return await self._client.share.set_properties( # type: ignore
-                timeout=timeout,
-                quota=quota,
-                access_tier=None,
-                cls=return_response_headers,
-                lease_access_conditions=access_conditions,
-                **kwargs)
+            _, identifiers = await self._client.queue.get_access_policy(
+                timeout=timeout, cls=return_headers_and_deserialized, **kwargs
+            )
         except HttpResponseError as error:
             process_storage_error(error)
+        return {s.id: s.access_policy or AccessPolicy() for s in identifiers}
+
+    @distributed_trace_async
+    async def set_queue_access_policy(self, signed_identifiers, **kwargs):
+        # type: (Dict[str, AccessPolicy], Optional[Any]) -> None
+        """Sets stored access policies for the queue that may be used with Shared
+        Access Signatures.
 
-    async def set_share_properties(self, **kwargs):
-        # type: (Any) ->  Dict[str, Any]
-        """Sets the share properties.
+        When you set permissions for a queue, the existing permissions are replaced.
+        To update the queue's permissions, call :func:`~get_queue_access_policy` to fetch
+        all access policies associated with the queue, modify the access policy
+        that you wish to change, and then call this function with the complete
+        set of data to perform the update.
 
-        .. versionadded:: 12.3.0
+        When you establish a stored access policy on a queue, it may take up to
+        30 seconds to take effect. During this interval, a shared access signature
+        that is associated with the stored access policy will throw an
+        :class:`HttpResponseError` until the access policy becomes active.
 
-        :keyword access_tier:
-            Specifies the access tier of the share.
-            Possible values: 'TransactionOptimized', 'Hot', and 'Cool'
-        :paramtype access_tier: str or ~azure.storage.fileshare.models.ShareAccessTier
-        :keyword int quota:
-            Specifies the maximum size of the share, in gigabytes.
-            Must be greater than 0, and less than or equal to 5TB.
+        :param signed_identifiers:
+            SignedIdentifier access policies to associate with the queue.
+            This may contain up to 5 elements. An empty dict
+            will clear the access policies set on the service.
+        :type signed_identifiers: dict(str, ~azure.storage.queue.AccessPolicy)
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :keyword root_squash:
-            Root squash to set on the share.
-            Only valid for NFS shares. Possible values include: 'NoRootSquash', 'RootSquash', 'AllSquash'
-        :paramtype root_squash: str or ~azure.storage.fileshare.ShareRootSquash
-        :keyword lease:
-            Required if the share has an active lease. Value can be a ShareLeaseClient object
-            or the lease ID as a string.
-        :returns: Share-updated property dict (Etag and last modified).
-        :rtype: dict(str, Any)
+            The server timeout, expressed in seconds.
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share_async.py
-                :start-after: [START set_share_properties]
-                :end-before: [END set_share_properties]
+            .. literalinclude:: ../samples/queue_samples_message_async.py
+                :start-after: [START async_set_access_policy]
+                :end-before: [END async_set_access_policy]
                 :language: python
                 :dedent: 16
-                :caption: Sets the share properties.
+                :caption: Set an access policy on the queue.
         """
-        access_conditions = get_access_conditions(kwargs.pop('lease', None))
         timeout = kwargs.pop('timeout', None)
-        access_tier = kwargs.pop('access_tier', None)
-        quota = kwargs.pop('quota', None)
-        root_squash = kwargs.pop('root_squash', None)
-        if all(parameter is None for parameter in [access_tier, quota, root_squash]):
-            raise ValueError("set_share_properties should be called with at least one parameter.")
+        if len(signed_identifiers) > 15:
+            raise ValueError(
+                "Too many access policies provided. The server does not support setting "
+                "more than 15 access policies on a single resource."
+            )
+        identifiers = []
+        for key, value in signed_identifiers.items():
+            if value:
+                value.start = serialize_iso(value.start)
+                value.expiry = serialize_iso(value.expiry)
+            identifiers.append(SignedIdentifier(id=key, access_policy=value))
+        signed_identifiers = identifiers  # type: ignore
         try:
-            return await self._client.share.set_properties( # type: ignore
-                timeout=timeout,
-                quota=quota,
-                access_tier=access_tier,
-                root_squash=root_squash,
-                lease_access_conditions=access_conditions,
-                cls=return_response_headers,
-                **kwargs)
+            await self._client.queue.set_access_policy(queue_acl=signed_identifiers or None, timeout=timeout, **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace_async
-    async def set_share_metadata(self, metadata, **kwargs):
-        # type: (Dict[str, Any], Any) ->  Dict[str, Any]
-        """Sets the metadata for the share.
-
-        Each call to this operation replaces all existing metadata
-        attached to the share. To remove all metadata from the share,
-        call this operation with no metadata dict.
-
-        :param metadata:
-            Name-value pairs associated with the share as metadata.
-        :type metadata: dict(str, str)
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :keyword lease:
-            Required if the share has an active lease. Value can be a ShareLeaseClient object
-            or the lease ID as a string.
-
-            .. versionadded:: 12.5.0
-            This keyword argument was introduced in API version '2020-08-04'.
+    async def send_message(  # type: ignore
+        self,
+        content,  # type: Any
+        **kwargs  # type: Optional[Any]
+    ):
+        # type: (...) -> QueueMessage
+        """Adds a new message to the back of the message queue.
 
-        :returns: Share-updated property dict (Etag and last modified).
-        :rtype: dict(str, Any)
+        The visibility timeout specifies the time that the message will be
+        invisible. After the timeout expires, the message will become visible.
+        If a visibility timeout is not specified, the default value of 0 is used.
+
+        The message time-to-live specifies how long a message will remain in the
+        queue. The message will be deleted from the queue when the time-to-live
+        period expires.
+
+        If the key-encryption-key field is set on the local service object, this method will
+        encrypt the content before uploading.
+
+        :param obj content:
+            Message content. Allowed type is determined by the encode_function
+            set on the service. Default is str. The encoded message can be up to
+            64KB in size.
+        :keyword int visibility_timeout:
+            If not specified, the default value is 0. Specifies the
+            new visibility timeout value, in seconds, relative to server time.
+            The value must be larger than or equal to 0, and cannot be
+            larger than 7 days. The visibility timeout of a message cannot be
+            set to a value later than the expiry time. visibility_timeout
+            should be set to a value smaller than the time-to-live value.
+        :keyword int time_to_live:
+            Specifies the time-to-live interval for the message, in
+            seconds. The time-to-live may be any positive number or -1 for infinity. If this
+            parameter is omitted, the default time-to-live is 7 days.
+        :keyword int timeout:
+            The server timeout, expressed in seconds.
+        :return:
+            A :class:`~azure.storage.queue.QueueMessage` object.
+            This object is also populated with the content although it is not
+            returned from the service.
+        :rtype: ~azure.storage.queue.QueueMessage
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share_async.py
-                :start-after: [START set_share_metadata]
-                :end-before: [END set_share_metadata]
+            .. literalinclude:: ../samples/queue_samples_message_async.py
+                :start-after: [START async_send_messages]
+                :end-before: [END async_send_messages]
                 :language: python
                 :dedent: 16
-                :caption: Sets the share metadata.
+                :caption: Send messages.
         """
-        access_conditions = get_access_conditions(kwargs.pop('lease', None))
+        visibility_timeout = kwargs.pop('visibility_timeout', None)
+        time_to_live = kwargs.pop('time_to_live', None)
         timeout = kwargs.pop('timeout', None)
-        headers = kwargs.pop('headers', {})
-        headers.update(add_metadata_headers(metadata))
+        self._config.message_encode_policy.configure(
+            require_encryption=self.require_encryption,
+            key_encryption_key=self.key_encryption_key,
+            resolver=self.key_resolver_function
+        )
+        encoded_content = self._config.message_encode_policy(content)
+        new_message = GenQueueMessage(message_text=encoded_content)
+
         try:
-            return await self._client.share.set_metadata( # type: ignore
-                timeout=timeout,
-                cls=return_response_headers,
-                headers=headers,
-                lease_access_conditions=access_conditions,
-                **kwargs)
+            enqueued = await self._client.messages.enqueue(
+                queue_message=new_message,
+                visibilitytimeout=visibility_timeout,
+                message_time_to_live=time_to_live,
+                timeout=timeout,
+                **kwargs
+            )
+            queue_message = QueueMessage(content=content)
+            queue_message.id = enqueued[0].message_id
+            queue_message.inserted_on = enqueued[0].insertion_time
+            queue_message.expires_on = enqueued[0].expiration_time
+            queue_message.pop_receipt = enqueued[0].pop_receipt
+            queue_message.next_visible_on = enqueued[0].time_next_visible
+            return queue_message
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace_async
-    async def get_share_access_policy(self, **kwargs):
-        # type: (Any) -> Dict[str, Any]
-        """Gets the permissions for the share. The permissions
-        indicate whether files in a share may be accessed publicly.
+    async def receive_message(self, **kwargs):
+        # type: (Optional[Any]) -> QueueMessage
+        """Removes one message from the front of the queue.
+
+        When the message is retrieved from the queue, the response includes the message
+        content and a pop_receipt value, which is required to delete the message.
+        The message is not automatically deleted from the queue, but after it has
+        been retrieved, it is not visible to other clients for the time interval
+        specified by the visibility_timeout parameter.
+
+        If the key-encryption-key or resolver field is set on the local service object, the message will be
+        decrypted before being returned.
+
+        :keyword int visibility_timeout:
+            If not specified, the default value is 0. Specifies the
+            new visibility timeout value, in seconds, relative to server time.
+            The value must be larger than or equal to 0, and cannot be
+            larger than 7 days. The visibility timeout of a message cannot be
+            set to a value later than the expiry time. visibility_timeout
+            should be set to a value smaller than the time-to-live value.
+        :keyword int timeout:
+            The server timeout, expressed in seconds.
+        :return:
+            Returns a message from the Queue.
+        :rtype: ~azure.storage.queue.QueueMessage
 
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :keyword lease:
-            Required if the share has an active lease. Value can be a ShareLeaseClient object
-            or the lease ID as a string.
-
-            .. versionadded:: 12.5.0
-            This keyword argument was introduced in API version '2020-08-04'.
+        .. admonition:: Example:
 
-        :returns: Access policy information in a dict.
-        :rtype: dict[str, Any]
+            .. literalinclude:: ../samples/queue_samples_message_async.py
+                :start-after: [START receive_one_message]
+                :end-before: [END receive_one_message]
+                :language: python
+                :dedent: 12
+                :caption: Receive one message from the queue.
         """
-        access_conditions = get_access_conditions(kwargs.pop('lease', None))
+        visibility_timeout = kwargs.pop('visibility_timeout', None)
         timeout = kwargs.pop('timeout', None)
-        try:
-            response, identifiers = await self._client.share.get_access_policy(
-                timeout=timeout,
-                cls=return_headers_and_deserialized,
-                lease_access_conditions=access_conditions,
-                **kwargs)
-        except HttpResponseError as error:
-            process_storage_error(error)
-        return {
-            'public_access': response.get('share_public_access'),
-            'signed_identifiers': identifiers or []
-        }
-
-    @distributed_trace_async
-    async def set_share_access_policy(self, signed_identifiers, **kwargs):
-        # type: (Dict[str, AccessPolicy], Any) -> Dict[str, str]
-        """Sets the permissions for the share, or stored access
-        policies that may be used with Shared Access Signatures. The permissions
-        indicate whether files in a share may be accessed publicly.
+        self._config.message_decode_policy.configure(
+            require_encryption=self.require_encryption,
+            key_encryption_key=self.key_encryption_key,
+            resolver=self.key_resolver_function)
+        try:
+            message = await self._client.messages.dequeue(
+                number_of_messages=1,
+                visibilitytimeout=visibility_timeout,
+                timeout=timeout,
+                cls=self._config.message_decode_policy,
+                **kwargs
+            )
+            wrapped_message = QueueMessage._from_generated(  # pylint: disable=protected-access
+                message[0]) if message != [] else None
+            return wrapped_message
+        except HttpResponseError as error:
+            process_storage_error(error)
 
-        :param signed_identifiers:
-            A dictionary of access policies to associate with the share. The
-            dictionary may contain up to 5 elements. An empty dictionary
-            will clear the access policies set on the service.
-        :type signed_identifiers: dict(str, :class:`~azure.storage.fileshare.AccessPolicy`)
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :keyword lease:
-            Required if the share has an active lease. Value can be a ShareLeaseClient object
-            or the lease ID as a string.
+    @distributed_trace
+    def receive_messages(self, **kwargs):
+        # type: (Optional[Any]) -> AsyncItemPaged[QueueMessage]
+        """Removes one or more messages from the front of the queue.
+
+        When a message is retrieved from the queue, the response includes the message
+        content and a pop_receipt value, which is required to delete the message.
+        The message is not automatically deleted from the queue, but after it has
+        been retrieved, it is not visible to other clients for the time interval
+        specified by the visibility_timeout parameter. The iterator will continuously
+        fetch messages until the queue is empty or max_messages is reached (if max_messages
+        is set).
+
+        If the key-encryption-key or resolver field is set on the local service object, the messages will be
+        decrypted before being returned.
+
+        :keyword int messages_per_page:
+            A nonzero integer value that specifies the number of
+            messages to retrieve from the queue, up to a maximum of 32. If
+            fewer are visible, the visible messages are returned. By default,
+            a single message is retrieved from the queue with this operation.
+            `by_page()` can be used to provide a page iterator on the AsyncItemPaged if messages_per_page is set.
+            `next()` can be used to get the next page.
+        :keyword int visibility_timeout:
+            If not specified, the default value is 30. Specifies the
+            new visibility timeout value, in seconds, relative to server time.
+            The value must be larger than or equal to 1, and cannot be
+            larger than 7 days. The visibility timeout of a message cannot be
+            set to a value later than the expiry time. visibility_timeout
+            should be set to a value smaller than the time-to-live value.
+        :keyword int timeout:
+            The server timeout, expressed in seconds.
+        :keyword int max_messages:
+            An integer that specifies the maximum number of messages to retrieve from the queue.
+        :return:
+            Returns a message iterator of dict-like Message objects.
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.storage.queue.QueueMessage]
 
-            .. versionadded:: 12.5.0
-            This keyword argument was introduced in API version '2020-08-04'.
+        .. admonition:: Example:
 
-        :returns: Share-updated property dict (Etag and last modified).
-        :rtype: dict(str, Any)
+            .. literalinclude:: ../samples/queue_samples_message_async.py
+                :start-after: [START async_receive_messages]
+                :end-before: [END async_receive_messages]
+                :language: python
+                :dedent: 16
+                :caption: Receive messages from the queue.
         """
-        access_conditions = get_access_conditions(kwargs.pop('lease', None))
+        messages_per_page = kwargs.pop('messages_per_page', None)
+        visibility_timeout = kwargs.pop('visibility_timeout', None)
         timeout = kwargs.pop('timeout', None)
-        if len(signed_identifiers) > 5:
-            raise ValueError(
-                'Too many access policies provided. The server does not support setting '
-                'more than 5 access policies on a single resource.')
-        identifiers = []
-        for key, value in signed_identifiers.items():
-            if value:
-                value.start = serialize_iso(value.start)
-                value.expiry = serialize_iso(value.expiry)
-            identifiers.append(SignedIdentifier(id=key, access_policy=value))
-        signed_identifiers = identifiers # type: ignore
-
+        max_messages = kwargs.pop('max_messages', None)
+        self._config.message_decode_policy.configure(
+            require_encryption=self.require_encryption,
+            key_encryption_key=self.key_encryption_key,
+            resolver=self.key_resolver_function
+        )
         try:
-            return await self._client.share.set_access_policy( # type: ignore
-                share_acl=signed_identifiers or None,
-                timeout=timeout,
-                cls=return_response_headers,
-                lease_access_conditions=access_conditions,
-                **kwargs)
+            command = functools.partial(
+                self._client.messages.dequeue,
+                visibilitytimeout=visibility_timeout,
+                timeout=timeout,
+                cls=self._config.message_decode_policy,
+                **kwargs
+            )
+            if max_messages is not None and messages_per_page is not None:
+                if max_messages < messages_per_page:
+                    raise ValueError("max_messages must be greater or equal to messages_per_page")
+            return AsyncItemPaged(command, results_per_page=messages_per_page,
+                                  page_iterator_class=MessagesPaged, max_messages=max_messages)
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace_async
-    async def get_share_stats(self, **kwargs):
-        # type: (Any) -> int
-        """Gets the approximate size of the data stored on the share in bytes.
-
-        Note that this value may not include all recently created
-        or recently re-sized files.
-
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :keyword lease:
-            Required if the share has an active lease. Value can be a ShareLeaseClient object
-            or the lease ID as a string.
+    async def update_message(
+        self,
+        message,
+        pop_receipt=None,
+        content=None,
+        **kwargs
+    ):
+        # type: (Any, int, Optional[str], Optional[Any], Any) -> QueueMessage
+        """Updates the visibility timeout of a message. You can also use this
+        operation to update the contents of a message.
+
+        This operation can be used to continually extend the invisibility of a
+        queue message. This functionality can be useful if you want a worker role
+        to "lease" a queue message. For example, if a worker role calls :func:`~receive_messages()`
+        and recognizes that it needs more time to process a message, it can
+        continually extend the message's invisibility until it is processed. If
+        the worker role were to fail during processing, eventually the message
+        would become visible again and another worker role could process it.
+
+        If the key-encryption-key field is set on the local service object, this method will
+        encrypt the content before uploading.
+
+        :param message:
+            The message object or id identifying the message to update.
+        :type message: str or ~azure.storage.queue.QueueMessage
+        :param str pop_receipt:
+            A valid pop receipt value returned from an earlier call
+            to the :func:`~receive_messages` or :func:`~update_message` operation.
+        :param obj content:
+            Message content. Allowed type is determined by the encode_function
+            set on the service. Default is str.
+        :keyword int visibility_timeout:
+            Specifies the new visibility timeout value, in seconds,
+            relative to server time. The new value must be larger than or equal
+            to 0, and cannot be larger than 7 days. The visibility timeout of a
+            message cannot be set to a value later than the expiry time. A
+            message can be updated until it has been deleted or has expired.
+            The message object or message id identifying the message to update.
+        :keyword int timeout:
+            The server timeout, expressed in seconds.
+        :return:
+            A :class:`~azure.storage.queue.QueueMessage` object. For convenience,
+            this object is also populated with the content, although it is not returned by the service.
+        :rtype: ~azure.storage.queue.QueueMessage
 
-            .. versionadded:: 12.5.0
-            This keyword argument was introduced in API version '2020-08-04'.
+        .. admonition:: Example:
 
-        :return: The approximate size of the data (in bytes) stored on the share.
-        :rtype: int
+            .. literalinclude:: ../samples/queue_samples_message_async.py
+                :start-after: [START async_update_message]
+                :end-before: [END async_update_message]
+                :language: python
+                :dedent: 16
+                :caption: Update a message.
         """
-        access_conditions = get_access_conditions(kwargs.pop('lease', None))
+        visibility_timeout = kwargs.pop('visibility_timeout', None)
         timeout = kwargs.pop('timeout', None)
         try:
-            stats = await self._client.share.get_statistics(
+            message_id = message.id
+            message_text = content or message.content
+            receipt = pop_receipt or message.pop_receipt
+            inserted_on = message.inserted_on
+            expires_on = message.expires_on
+            dequeue_count = message.dequeue_count
+        except AttributeError:
+            message_id = message
+            message_text = content
+            receipt = pop_receipt
+            inserted_on = None
+            expires_on = None
+            dequeue_count = None
+
+        if receipt is None:
+            raise ValueError("pop_receipt must be present")
+        if message_text is not None:
+            self._config.message_encode_policy.configure(
+                self.require_encryption, self.key_encryption_key, self.key_resolver_function
+            )
+            encoded_message_text = self._config.message_encode_policy(message_text)
+            updated = GenQueueMessage(message_text=encoded_message_text)
+        else:
+            updated = None  # type: ignore
+        try:
+            response = await self._client.message_id.update(
+                queue_message=updated,
+                visibilitytimeout=visibility_timeout or 0,
                 timeout=timeout,
-                lease_access_conditions=access_conditions,
-                **kwargs)
-            return stats.share_usage_bytes # type: ignore
+                pop_receipt=receipt,
+                cls=return_response_headers,
+                queue_message_id=message_id,
+                **kwargs
+            )
+            new_message = QueueMessage(content=message_text)
+            new_message.id = message_id
+            new_message.inserted_on = inserted_on
+            new_message.expires_on = expires_on
+            new_message.dequeue_count = dequeue_count
+            new_message.pop_receipt = response["popreceipt"]
+            new_message.next_visible_on = response["time_next_visible"]
+            return new_message
         except HttpResponseError as error:
             process_storage_error(error)
 
-    @distributed_trace
-    def list_directories_and_files( # type: ignore
-            self, directory_name=None,  # type: Optional[str]
-            name_starts_with=None,  # type: Optional[str]
-            marker=None,  # type: Optional[str]
-            **kwargs  # type: Any
-        ):
-        # type: (...) -> Iterable[Dict[str,str]]
-        """Lists the directories and files under the share.
-
-        :param str directory_name:
-            Name of a directory.
-        :param str name_starts_with:
-            Filters the results to return only directories whose names
-            begin with the specified prefix.
-        :param str marker:
-            An opaque continuation token. This value can be retrieved from the
-            next_marker field of a previous generator object. If specified,
-            this generator will begin returning results from this point.
-        :keyword list[str] include:
-            Include this parameter to specify one or more datasets to include in the response.
-            Possible str values are "timestamps", "Etag", "Attributes", "PermissionKey".
-
-            .. versionadded:: 12.6.0
-            This keyword argument was introduced in API version '2020-10-02'.
-
-        :keyword bool include_extended_info:
-            If this is set to true, file id will be returned in listed results.
-
-            .. versionadded:: 12.6.0
-            This keyword argument was introduced in API version '2020-10-02'.
-
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: An auto-paging iterable of dict-like DirectoryProperties and FileProperties
+    @distributed_trace_async
+    async def peek_messages(self, max_messages=None, **kwargs):
+        # type: (Optional[int], Optional[Any]) -> List[QueueMessage]
+        """Retrieves one or more messages from the front of the queue, but does
+        not alter the visibility of the message.
+
+        Only messages that are visible may be retrieved. When a message is retrieved
+        for the first time with a call to :func:`~receive_messages`, its dequeue_count property
+        is set to 1. If it is not deleted and is subsequently retrieved again, the
+        dequeue_count property is incremented. The client may use this value to
+        determine how many times a message has been retrieved. Note that a call
+        to peek_messages does not increment the value of dequeue_count, but returns
+        this value for the client to read.
+
+        If the key-encryption-key or resolver field is set on the local service object,
+        the messages will be decrypted before being returned.
+
+        :param int max_messages:
+            A nonzero integer value that specifies the number of
+            messages to peek from the queue, up to a maximum of 32. By default,
+            a single message is peeked from the queue with this operation.
+        :keyword int timeout:
+            The server timeout, expressed in seconds.
+        :return:
+            A list of :class:`~azure.storage.queue.QueueMessage` objects. Note that
+            next_visible_on and pop_receipt will not be populated as peek does
+            not pop the message and can only retrieve already visible messages.
+        :rtype: list(:class:`~azure.storage.queue.QueueMessage`)
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_share_async.py
-                :start-after: [START share_list_files_in_dir]
-                :end-before: [END share_list_files_in_dir]
+            .. literalinclude:: ../samples/queue_samples_message_async.py
+                :start-after: [START async_peek_message]
+                :end-before: [END async_peek_message]
                 :language: python
                 :dedent: 16
-                :caption: List directories and files in the share.
+                :caption: Peek messages.
         """
         timeout = kwargs.pop('timeout', None)
-        directory = self.get_directory_client(directory_name)
-        return directory.list_directories_and_files(
-            name_starts_with=name_starts_with, marker=marker, timeout=timeout, **kwargs)
+        if max_messages and not 1 <= max_messages <= 32:
+            raise ValueError("Number of messages to peek should be between 1 and 32")
+        self._config.message_decode_policy.configure(
+            require_encryption=self.require_encryption,
+            key_encryption_key=self.key_encryption_key,
+            resolver=self.key_resolver_function
+        )
+        try:
+            messages = await self._client.messages.peek(
+                number_of_messages=max_messages, timeout=timeout, cls=self._config.message_decode_policy, **kwargs
+            )
+            wrapped_messages = []
+            for peeked in messages:
+                wrapped_messages.append(QueueMessage._from_generated(peeked))  # pylint: disable=protected-access
+            return wrapped_messages
+        except HttpResponseError as error:
+            process_storage_error(error)
 
     @distributed_trace_async
-    async def create_permission_for_share(self, file_permission,  # type: str
-                                          **kwargs  # type: Any
-                                          ):
-        # type: (...) -> str
-        """Create a permission (a security descriptor) at the share level.
-
-        This 'permission' can be used for the files/directories in the share.
-        If a 'permission' already exists, it shall return the key of it, else
-        creates a new permission at the share level and return its key.
+    async def clear_messages(self, **kwargs):
+        # type: (Optional[Any]) -> None
+        """Deletes all messages from the specified queue.
 
-        :param str file_permission:
-            File permission, a Portable SDDL
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: A file permission key
-        :rtype: str
+            The server timeout, expressed in seconds.
+
+        .. admonition:: Example:
+
+            .. literalinclude:: ../samples/queue_samples_message_async.py
+                :start-after: [START async_clear_messages]
+                :end-before: [END async_clear_messages]
+                :language: python
+                :dedent: 16
+                :caption: Clears all messages.
         """
         timeout = kwargs.pop('timeout', None)
-        options = self._create_permission_for_share_options(file_permission, timeout=timeout, **kwargs)
         try:
-            return await self._client.share.create_permission(**options)
+            await self._client.messages.clear(timeout=timeout, **kwargs)
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace_async
-    async def get_permission_for_share(  # type: ignore
-            self, permission_key,  # type: str
-            **kwargs  # type: Any
-    ):
-        # type: (...) -> str
-        """Get a permission (a security descriptor) for a given key.
+    async def delete_message(self, message, pop_receipt=None, **kwargs):
+        # type: (Any, Optional[str], Any) -> None
+        """Deletes the specified message.
 
-        This 'permission' can be used for the files/directories in the share.
+        Normally after a client retrieves a message with the receive messages operation,
+        the client is expected to process and delete the message. To delete the
+        message, you must have the message object itself, or two items of data: id and pop_receipt.
+        The id is returned from the previous receive_messages operation. The
+        pop_receipt is returned from the most recent :func:`~receive_messages` or
+        :func:`~update_message` operation. In order for the delete_message operation
+        to succeed, the pop_receipt specified on the request must match the
+        pop_receipt returned from the :func:`~receive_messages` or :func:`~update_message`
+        operation.
 
-        :param str permission_key:
-            Key of the file permission to retrieve
+        :param message:
+            The message object or id identifying the message to delete.
+        :type message: str or ~azure.storage.queue.QueueMessage
+        :param str pop_receipt:
+            A valid pop receipt value returned from an earlier call
+            to the :func:`~receive_messages` or :func:`~update_message`.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: A file permission (a portable SDDL)
-        :rtype: str
+            The server timeout, expressed in seconds.
+
+        .. admonition:: Example:
+
+            .. literalinclude:: ../samples/queue_samples_message_async.py
+                :start-after: [START async_delete_message]
+                :end-before: [END async_delete_message]
+                :language: python
+                :dedent: 16
+                :caption: Delete a message.
         """
         timeout = kwargs.pop('timeout', None)
         try:
-            return await self._client.share.get_permission(  # type: ignore
-                file_permission_key=permission_key,
-                cls=deserialize_permission,
-                timeout=timeout,
-                **kwargs)
+            message_id = message.id
+            receipt = pop_receipt or message.pop_receipt
+        except AttributeError:
+            message_id = message
+            receipt = pop_receipt
+
+        if receipt is None:
+            raise ValueError("pop_receipt must be present")
+        try:
+            await self._client.message_id.delete(
+                pop_receipt=receipt, timeout=timeout, queue_message_id=message_id, **kwargs
+            )
         except HttpResponseError as error:
             process_storage_error(error)
-
-    @distributed_trace_async
-    async def create_directory(self, directory_name, **kwargs):
-        # type: (str, Any) -> ShareDirectoryClient
-        """Creates a directory in the share and returns a client to interact
-        with the directory.
-
-        :param str directory_name:
-            The name of the directory.
-        :keyword dict(str,str) metadata:
-            Name-value pairs associated with the directory as metadata.
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: ShareDirectoryClient
-        :rtype: ~azure.storage.fileshare.aio.ShareDirectoryClient
-        """
-        directory = self.get_directory_client(directory_name)
-        kwargs.setdefault('merge_span', True)
-        await directory.create_directory(**kwargs)
-        return directory # type: ignore
-
-    @distributed_trace_async
-    async def delete_directory(self, directory_name, **kwargs):
-        # type: (str, Any) -> None
-        """Marks the directory for deletion. The directory is
-        later deleted during garbage collection.
-
-        :param str directory_name:
-            The name of the directory.
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :rtype: None
-        """
-        directory = self.get_directory_client(directory_name)
-        await directory.delete_directory(**kwargs)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_share_service_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_queue_service_client_async.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,374 +1,387 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=invalid-overridden-method
+
 import functools
-import sys
-import warnings
 from typing import (  # pylint: disable=unused-import
     Union, Optional, Any, Iterable, Dict, List,
-    TYPE_CHECKING
-)
+    TYPE_CHECKING)
+try:
+    from urllib.parse import urlparse # pylint: disable=unused-import
+except ImportError:
+    from urlparse import urlparse # type: ignore
 
-from azure.core.async_paging import AsyncItemPaged
 from azure.core.exceptions import HttpResponseError
+from azure.core.async_paging import AsyncItemPaged
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.pipeline import AsyncPipeline
 from azure.core.tracing.decorator_async import distributed_trace_async
 
+from .._serialize import get_api_version
+from .._shared.policies_async import ExponentialRetry
+from .._queue_service_client import QueueServiceClient as QueueServiceClientBase
+from .._shared.models import LocationMode
 from .._shared.base_client_async import AsyncStorageAccountHostsMixin, AsyncTransportWrapper
 from .._shared.response_handlers import process_storage_error
-from .._shared.policies_async import ExponentialRetry
-from .._generated.aio import AzureFileStorage
+from .._generated.aio import AzureQueueStorage
 from .._generated.models import StorageServiceProperties
-from .._share_service_client import ShareServiceClient as ShareServiceClientBase
-from .._serialize import get_api_version
-from ._share_client_async import ShareClient
-from ._models import SharePropertiesPaged
-from .._models import service_properties_deserialize
+
+from ._models import QueuePropertiesPaged
+from ._queue_client_async import QueueClient
+from .._models import (
+    service_stats_deserialize,
+    service_properties_deserialize,
+)
 
 if TYPE_CHECKING:
     from datetime import datetime
-    from .._shared.models import ResourceTypes, AccountSasPermissions
+    from azure.core.configuration import Configuration
+    from azure.core.pipeline.policies import HTTPPolicy
     from .._models import (
-        ShareProperties,
+        QueueProperties,
+        QueueAnalyticsLogging,
         Metrics,
         CorsRule,
-        ShareProtocolSettings,
     )
 
 
-class ShareServiceClient(AsyncStorageAccountHostsMixin, ShareServiceClientBase):
-    """A client to interact with the File Share Service at the account level.
+class QueueServiceClient(AsyncStorageAccountHostsMixin, QueueServiceClientBase):
+    """A client to interact with the Queue Service at the account level.
 
     This client provides operations to retrieve and configure the account properties
-    as well as list, create and delete shares within the account.
-    For operations relating to a specific share, a client for that entity
-    can also be retrieved using the :func:`get_share_client` function.
+    as well as list, create and delete queues within the account.
+    For operations relating to a specific queue, a client for this entity
+    can be retrieved using the :func:`~get_queue_client` function.
 
     :param str account_url:
-        The URL to the file share storage account. Any other entities included
-        in the URL path (e.g. share or file) will be discarded. This URL can be optionally
+        The URL to the queue service endpoint. Any other entities included
+        in the URL path (e.g. queue) will be discarded. This URL can be optionally
         authenticated with a SAS token.
     :param credential:
         The credentials with which to authenticate. This is optional if the
         account URL already has a SAS token. The value can be a SAS token string,
-        an instance of a AzureSasCredential or AzureNamedKeyCredential from azure.core.credentials,
-        an account shared access key, or an instance of a TokenCredentials class from azure.identity.
-        If the resource URI already contains a SAS token, this will be ignored in favor of an explicit credential
-        - except in the case of AzureSasCredential, where the conflicting SAS tokens will raise a ValueError.
-        If using an instance of AzureNamedKeyCredential, "name" should be the storage account name, and "key"
-        should be the storage account key.
+        an instance of a AzureSasCredential from azure.core.credentials, an account
+        shared access key, or an instance of a TokenCredentials class from azure.identity.
     :keyword str api_version:
         The Storage API version to use for requests. Default value is the most recent service version that is
         compatible with the current SDK. Setting to an older version may result in reduced feature compatibility.
-
-        .. versionadded:: 12.1.0
-
     :keyword str secondary_hostname:
         The hostname of the secondary endpoint.
-    :keyword int max_range_size: The maximum range size used for a file upload. Defaults to 4*1024*1024.
 
     .. admonition:: Example:
 
-        .. literalinclude:: ../samples/file_samples_authentication_async.py
-            :start-after: [START create_share_service_client]
-            :end-before: [END create_share_service_client]
+        .. literalinclude:: ../samples/queue_samples_authentication_async.py
+            :start-after: [START async_create_queue_service_client]
+            :end-before: [END async_create_queue_service_client]
             :language: python
             :dedent: 8
-            :caption: Create the share service client with url and credential.
+            :caption: Creating the QueueServiceClient with an account url and credential.
+
+        .. literalinclude:: ../samples/queue_samples_authentication_async.py
+            :start-after: [START async_create_queue_service_client_token]
+            :end-before: [END async_create_queue_service_client_token]
+            :language: python
+            :dedent: 8
+            :caption: Creating the QueueServiceClient with Azure Identity credentials.
     """
+
     def __init__(
             self, account_url,  # type: str
-            credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
+            credential=None,  # type: Optional[Any]
             **kwargs  # type: Any
         ):
         # type: (...) -> None
         kwargs['retry_policy'] = kwargs.get('retry_policy') or ExponentialRetry(**kwargs)
         loop = kwargs.pop('loop', None)
-        if loop and sys.version_info >= (3, 8):
-            warnings.warn("The 'loop' parameter was deprecated from asyncio's high-level"
-            "APIs in Python 3.8 and is no longer supported.", DeprecationWarning)
-        super(ShareServiceClient, self).__init__(
+        super(QueueServiceClient, self).__init__( # type: ignore
             account_url,
             credential=credential,
+            loop=loop,
             **kwargs)
-        self._client = AzureFileStorage(self.url, base_url=self.url, pipeline=self._pipeline)
+        self._client = AzureQueueStorage(self.url, base_url=self.url, pipeline=self._pipeline, loop=loop) # type: ignore
         self._client._config.version = get_api_version(kwargs)  # pylint: disable=protected-access
+        self._loop = loop
+
+    @distributed_trace_async
+    async def get_service_stats(self, **kwargs):
+        # type: (Optional[Any]) -> Dict[str, Any]
+        """Retrieves statistics related to replication for the Queue service.
+
+        It is only available when read-access geo-redundant replication is enabled for
+        the storage account.
+
+        With geo-redundant replication, Azure Storage maintains your data durable
+        in two locations. In both locations, Azure Storage constantly maintains
+        multiple healthy replicas of your data. The location where you read,
+        create, update, or delete data is the primary storage account location.
+        The primary location exists in the region you choose at the time you
+        create an account via the Azure Management Azure classic portal, for
+        example, North Central US. The location to which your data is replicated
+        is the secondary location. The secondary location is automatically
+        determined based on the location of the primary; it is in a second data
+        center that resides in the same region as the primary location. Read-only
+        access is available from the secondary location, if read-access geo-redundant
+        replication is enabled for your storage account.
+
+        :keyword int timeout:
+            The timeout parameter is expressed in seconds.
+        :return: The queue service stats.
+        :rtype: Dict[str, Any]
+        """
+        timeout = kwargs.pop('timeout', None)
+        try:
+            stats = await self._client.service.get_statistics( # type: ignore
+                timeout=timeout, use_location=LocationMode.SECONDARY, **kwargs)
+            return service_stats_deserialize(stats)
+        except HttpResponseError as error:
+            process_storage_error(error)
 
     @distributed_trace_async
     async def get_service_properties(self, **kwargs):
-        # type: (Any) -> Dict[str, Any]
-        """Gets the properties of a storage account's File Share service, including
+        # type: (Optional[Any]) -> Dict[str, Any]
+        """Gets the properties of a storage account's Queue service, including
         Azure Storage Analytics.
 
         :keyword int timeout:
             The timeout parameter is expressed in seconds.
-        :returns: A dictionary containing file service properties such as
+        :returns: An object containing queue service properties such as
             analytics logging, hour/minute metrics, cors rules, etc.
         :rtype: Dict[str, Any]
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_service_async.py
-                :start-after: [START get_service_properties]
-                :end-before: [END get_service_properties]
+            .. literalinclude:: ../samples/queue_samples_service_async.py
+                :start-after: [START async_get_queue_service_properties]
+                :end-before: [END async_get_queue_service_properties]
                 :language: python
                 :dedent: 12
-                :caption: Get file share service properties.
+                :caption: Getting queue service properties.
         """
         timeout = kwargs.pop('timeout', None)
         try:
-            service_props = await self._client.service.get_properties(timeout=timeout, **kwargs)
+            service_props = await self._client.service.get_properties(timeout=timeout, **kwargs) # type: ignore
             return service_properties_deserialize(service_props)
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace_async
-    async def set_service_properties(
-            self, hour_metrics=None,  # type: Optional[Metrics]
+    async def set_service_properties( # type: ignore
+            self, analytics_logging=None,  # type: Optional[QueueAnalyticsLogging]
+            hour_metrics=None,  # type: Optional[Metrics]
             minute_metrics=None,  # type: Optional[Metrics]
             cors=None,  # type: Optional[List[CorsRule]]
-            protocol=None,  # type: Optional[ShareProtocolSettings],
             **kwargs
         ):
         # type: (...) -> None
-        """Sets the properties of a storage account's File Share service, including
-        Azure Storage Analytics. If an element (e.g. hour_metrics) is left as None, the
+        """Sets the properties of a storage account's Queue service, including
+        Azure Storage Analytics.
+
+        If an element (e.g. analytics_logging) is left as None, the
         existing settings on the service for that functionality are preserved.
 
+        :param analytics_logging:
+            Groups the Azure Analytics Logging settings.
+        :type analytics_logging: ~azure.storage.queue.QueueAnalyticsLogging
         :param hour_metrics:
             The hour metrics settings provide a summary of request
-            statistics grouped by API in hourly aggregates for files.
-        :type hour_metrics: ~azure.storage.fileshare.Metrics
+            statistics grouped by API in hourly aggregates for queues.
+        :type hour_metrics: ~azure.storage.queue.Metrics
         :param minute_metrics:
             The minute metrics settings provide request statistics
-            for each minute for files.
-        :type minute_metrics: ~azure.storage.fileshare.Metrics
+            for each minute for queues.
+        :type minute_metrics: ~azure.storage.queue.Metrics
         :param cors:
             You can include up to five CorsRule elements in the
             list. If an empty list is specified, all CORS rules will be deleted,
             and CORS will be disabled for the service.
-        :type cors: list(:class:`~azure.storage.fileshare.CorsRule`)
-        :param protocol_settings:
-            Sets protocol settings
-        :type protocol: ~azure.storage.fileshare.ShareProtocolSettings
+        :type cors: list(~azure.storage.queue.CorsRule)
         :keyword int timeout:
             The timeout parameter is expressed in seconds.
         :rtype: None
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_service_async.py
-                :start-after: [START set_service_properties]
-                :end-before: [END set_service_properties]
+            .. literalinclude:: ../samples/queue_samples_service_async.py
+                :start-after: [START async_set_queue_service_properties]
+                :end-before: [END async_set_queue_service_properties]
                 :language: python
-                :dedent: 8
-                :caption: Sets file share service properties.
+                :dedent: 12
+                :caption: Setting queue service properties.
         """
         timeout = kwargs.pop('timeout', None)
         props = StorageServiceProperties(
+            logging=analytics_logging,
             hour_metrics=hour_metrics,
             minute_metrics=minute_metrics,
-            cors=cors,
-            protocol=protocol
+            cors=cors
         )
         try:
-            await self._client.service.set_properties(props, timeout=timeout, **kwargs)
+            return await self._client.service.set_properties(props, timeout=timeout, **kwargs) # type: ignore
         except HttpResponseError as error:
             process_storage_error(error)
 
     @distributed_trace
-    def list_shares(
+    def list_queues(
             self, name_starts_with=None,  # type: Optional[str]
             include_metadata=False,  # type: Optional[bool]
-            include_snapshots=False, # type: Optional[bool]
-            **kwargs  # type: Any
+            **kwargs
         ):  # type: (...) -> AsyncItemPaged
-        """Returns auto-paging iterable of dict-like ShareProperties under the specified account.
+        """Returns a generator to list the queues under the specified account.
+
         The generator will lazily follow the continuation tokens returned by
-        the service and stop when all shares have been returned.
+        the service and stop when all queues have been returned.
 
         :param str name_starts_with:
-            Filters the results to return only shares whose names
-            begin with the specified name_starts_with.
+            Filters the results to return only queues whose names
+            begin with the specified prefix.
         :param bool include_metadata:
-            Specifies that share metadata be returned in the response.
-        :param bool include_snapshots:
-            Specifies that share snapshot be returned in the response.
-        :keyword bool include_deleted:
-            Specifies that deleted shares be returned in the response.
-            This is only for share soft delete enabled account.
+            Specifies that queue metadata be returned in the response.
+        :keyword int results_per_page:
+            The maximum number of queue names to retrieve per API
+            call. If the request does not specify the server will return up to 5,000 items.
         :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :returns: An iterable (auto-paging) of ShareProperties.
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.storage.fileshare.ShareProperties]
+            The server timeout, expressed in seconds. This function may make multiple
+            calls to the service in which case the timeout value specified will be
+            applied to each individual call.
+        :returns: An iterable (auto-paging) of QueueProperties.
+        :rtype: ~azure.core.paging.AsyncItemPaged[~azure.storage.queue.QueueProperties]
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_service_async.py
-                :start-after: [START fsc_list_shares]
-                :end-before: [END fsc_list_shares]
+            .. literalinclude:: ../samples/queue_samples_service_async.py
+                :start-after: [START async_qsc_list_queues]
+                :end-before: [END async_qsc_list_queues]
                 :language: python
                 :dedent: 16
-                :caption: List shares in the file share service.
+                :caption: List queues in the service.
         """
-        timeout = kwargs.pop('timeout', None)
-        include = []
-        if include_metadata:
-            include.append('metadata')
-        if include_snapshots:
-            include.append('snapshots')
-        include_deleted = kwargs.pop('include_deleted', None)
-        if include_deleted:
-            include.append("deleted")
-
         results_per_page = kwargs.pop('results_per_page', None)
+        timeout = kwargs.pop('timeout', None)
+        include = ['metadata'] if include_metadata else None
         command = functools.partial(
-            self._client.service.list_shares_segment,
+            self._client.service.list_queues_segment,
+            prefix=name_starts_with,
             include=include,
             timeout=timeout,
             **kwargs)
         return AsyncItemPaged(
             command, prefix=name_starts_with, results_per_page=results_per_page,
-            page_iterator_class=SharePropertiesPaged)
+            page_iterator_class=QueuePropertiesPaged
+        )
 
     @distributed_trace_async
-    async def create_share(
-            self, share_name,  # type: str
+    async def create_queue( # type: ignore
+            self, name,  # type: str
+            metadata=None,  # type: Optional[Dict[str, str]]
             **kwargs
         ):
-        # type: (...) -> ShareClient
-        """Creates a new share under the specified account. If the share
-        with the same name already exists, the operation fails. Returns a client with
-        which to interact with the newly created share.
+        # type: (...) -> QueueClient
+        """Creates a new queue under the specified account.
+
+        If a queue with the same name already exists, the operation fails.
+        Returns a client with which to interact with the newly created queue.
 
-        :param str share_name: The name of the share to create.
-        :keyword dict(str,str) metadata:
+        :param str name: The name of the queue to create.
+        :param metadata:
             A dict with name_value pairs to associate with the
-            share as metadata. Example:{'Category':'test'}
-        :keyword int quota:
-            Quota in bytes.
+            queue as metadata. Example: {'Category': 'test'}
+        :type metadata: dict(str, str)
         :keyword int timeout:
             The timeout parameter is expressed in seconds.
-        :rtype: ~azure.storage.fileshare.aio.ShareClient
+        :rtype: ~azure.storage.queue.aio.QueueClient
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_service_async.py
-                :start-after: [START fsc_create_shares]
-                :end-before: [END fsc_create_shares]
+            .. literalinclude:: ../samples/queue_samples_service_async.py
+                :start-after: [START async_qsc_create_queue]
+                :end-before: [END async_qsc_create_queue]
                 :language: python
                 :dedent: 12
-                :caption: Create a share in the file share service.
+                :caption: Create a queue in the service.
         """
-        metadata = kwargs.pop('metadata', None)
-        quota = kwargs.pop('quota', None)
         timeout = kwargs.pop('timeout', None)
-        share = self.get_share_client(share_name)
+        queue = self.get_queue_client(name)
         kwargs.setdefault('merge_span', True)
-        await share.create_share(metadata=metadata, quota=quota, timeout=timeout, **kwargs)
-        return share
+        await queue.create_queue(
+            metadata=metadata, timeout=timeout, **kwargs)
+        return queue
 
     @distributed_trace_async
-    async def delete_share(
-            self, share_name,  # type: Union[ShareProperties, str]
-            delete_snapshots=False, # type: Optional[bool]
+    async def delete_queue( # type: ignore
+            self, queue,  # type: Union[QueueProperties, str]
             **kwargs
         ):
         # type: (...) -> None
-        """Marks the specified share for deletion. The share is
-        later deleted during garbage collection.
+        """Deletes the specified queue and any messages it contains.
 
-        :param share_name:
-            The share to delete. This can either be the name of the share,
-            or an instance of ShareProperties.
-        :type share_name: str or ~azure.storage.fileshare.ShareProperties
-        :param bool delete_snapshots:
-            Indicates if snapshots are to be deleted.
+        When a queue is successfully deleted, it is immediately marked for deletion
+        and is no longer accessible to clients. The queue is later removed from
+        the Queue service during garbage collection.
+
+        Note that deleting a queue is likely to take at least 40 seconds to complete.
+        If an operation is attempted against the queue while it was being deleted,
+        an :class:`HttpResponseError` will be thrown.
+
+        :param queue:
+            The queue to delete. This can either be the name of the queue,
+            or an instance of QueueProperties.
+        :type queue: str or ~azure.storage.queue.QueueProperties
         :keyword int timeout:
             The timeout parameter is expressed in seconds.
         :rtype: None
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_service_async.py
-                :start-after: [START fsc_delete_shares]
-                :end-before: [END fsc_delete_shares]
+            .. literalinclude:: ../samples/queue_samples_service_async.py
+                :start-after: [START async_qsc_delete_queue]
+                :end-before: [END async_qsc_delete_queue]
                 :language: python
                 :dedent: 16
-                :caption: Delete a share in the file share service.
+                :caption: Delete a queue in the service.
         """
         timeout = kwargs.pop('timeout', None)
-        share = self.get_share_client(share_name)
+        queue_client = self.get_queue_client(queue)
         kwargs.setdefault('merge_span', True)
-        await share.delete_share(
-            delete_snapshots=delete_snapshots, timeout=timeout, **kwargs)
-
-    @distributed_trace_async
-    async def undelete_share(self, deleted_share_name, deleted_share_version, **kwargs):
-        # type: (str, str, **Any) -> ShareClient
-        """Restores soft-deleted share.
-
-        Operation will only be successful if used within the specified number of days
-        set in the delete retention policy.
-
-        .. versionadded:: 12.2.0
-            This operation was introduced in API version '2019-12-12'.
-
-        :param str deleted_share_name:
-            Specifies the name of the deleted share to restore.
-        :param str deleted_share_version:
-            Specifies the version of the deleted share to restore.
-        :keyword int timeout:
-            The timeout parameter is expressed in seconds.
-        :rtype: ~azure.storage.fileshare.aio.ShareClient
-        """
-        share = self.get_share_client(deleted_share_name)
-        try:
-            await share._client.share.restore(deleted_share_name=deleted_share_name,  # pylint: disable = protected-access
-                                              deleted_share_version=deleted_share_version,
-                                              timeout=kwargs.pop('timeout', None), **kwargs)
-            return share
-        except HttpResponseError as error:
-            process_storage_error(error)
+        await queue_client.delete_queue(timeout=timeout, **kwargs)
 
-    def get_share_client(self, share, snapshot=None):
-        # type: (Union[ShareProperties, str],Optional[Union[Dict[str, Any], str]]) -> ShareClient
-        """Get a client to interact with the specified share.
-        The share need not already exist.
-
-        :param share:
-            The share. This can either be the name of the share,
-            or an instance of ShareProperties.
-        :type share: str or ~azure.storage.fileshare.ShareProperties
-        :param str snapshot:
-            An optional share snapshot on which to operate. This can be the snapshot ID string
-            or the response returned from :func:`create_snapshot`.
-        :returns: A ShareClient.
-        :rtype: ~azure.storage.fileshare.aio.ShareClient
+    def get_queue_client(self, queue, **kwargs):
+        # type: (Union[QueueProperties, str], Optional[Any]) -> QueueClient
+        """Get a client to interact with the specified queue.
+
+        The queue need not already exist.
+
+        :param queue:
+            The queue. This can either be the name of the queue,
+            or an instance of QueueProperties.
+        :type queue: str or ~azure.storage.queue.QueueProperties
+        :returns: A :class:`~azure.storage.queue.aio.QueueClient` object.
+        :rtype: ~azure.storage.queue.aio.QueueClient
 
         .. admonition:: Example:
 
-            .. literalinclude:: ../samples/file_samples_service_async.py
-                :start-after: [START get_share_client]
-                :end-before: [END get_share_client]
+            .. literalinclude:: ../samples/queue_samples_service_async.py
+                :start-after: [START async_get_queue_client]
+                :end-before: [END async_get_queue_client]
                 :language: python
                 :dedent: 8
-                :caption: Gets the share client.
+                :caption: Get the queue client.
         """
         try:
-            share_name = share.name
+            queue_name = queue.name
         except AttributeError:
-            share_name = share
+            queue_name = queue
 
         _pipeline = AsyncPipeline(
             transport=AsyncTransportWrapper(self._pipeline._transport), # pylint: disable = protected-access
             policies=self._pipeline._impl_policies # pylint: disable = protected-access
         )
-        return ShareClient(
-            self.url, share_name=share_name, snapshot=snapshot, credential=self.credential,
-            api_version=self.api_version, _hosts=self._hosts, _configuration=self._config,
-            _pipeline=_pipeline, _location_mode=self._location_mode)
+
+        return QueueClient(
+            self.url, queue_name=queue_name, credential=self.credential,
+            key_resolver_function=self.key_resolver_function, require_encryption=self.require_encryption,
+            key_encryption_key=self.key_encryption_key, api_version=self.api_version, _pipeline=_pipeline,
+            _configuration=self._config, _location_mode=self._location_mode,
+            _hosts=self._hosts, loop=self._loop, **kwargs)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_deserialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_deserialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,15 +1,13 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
-# Licensed under the MIT License. See License.txt in the project root for license information.
+# Licensed under the MIT License. See License.txt in the project root for
+# license information.
+#
 # Code generated by Microsoft (R) AutoRest Code Generator.
-# Changes may cause incorrect behavior and will be lost if the code is regenerated.
+# Changes may cause incorrect behavior and will be lost if the code is
+# regenerated.
 # --------------------------------------------------------------------------
 
-from ._azure_queue_storage import AzureQueueStorage
+from ._azure_queue_storage_async import AzureQueueStorage
 __all__ = ['AzureQueueStorage']
-
-# `._patch.py` is used for handwritten extensions to the generated code
-# Example: https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/customize_code/how-to-patch-sdk-code.md
-from ._patch import patch_sdk
-patch_sdk()
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_azure_queue_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_azure_queue_storage.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_vendor.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/_vendor.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_azure_queue_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_azure_queue_storage.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_azure_queue_storage_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_azure_queue_storage_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_configuration.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_configuration.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_configuration_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/_configuration.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is
 # regenerated.
 # --------------------------------------------------------------------------
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
-from ..version import VERSION
+from .version import VERSION
 
 
 class AzureQueueStorageConfiguration(Configuration):
     """Configuration for AzureQueueStorage
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
@@ -34,20 +34,19 @@
             raise ValueError("Parameter 'url' must not be None.")
 
         super(AzureQueueStorageConfiguration, self).__init__(**kwargs)
         self._configure(**kwargs)
 
         self.user_agent_policy.add_user_agent('azsdk-python-azurequeuestorage/{}'.format(VERSION))
         self.generate_client_request_id = True
-        self.accept_language = None
 
         self.url = url
         self.version = "2018-03-28"
 
     def _configure(self, **kwargs):
         self.user_agent_policy = kwargs.get('user_agent_policy') or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get('headers_policy') or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get('proxy_policy') or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get('logging_policy') or policies.NetworkTraceLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get('retry_policy') or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get('retry_policy') or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get('custom_hook_policy') or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get('redirect_policy') or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get('redirect_policy') or policies.RedirectPolicy(**kwargs)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_patch.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_message_id_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_message_id_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_messages_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_messages_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_queue_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_queue_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_message_id_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_message_id_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_messages_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_messages_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_queue_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_queue_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_service_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/aio/operations_async/_service_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_azure_queue_storage_enums.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_azure_queue_storage_enums.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_models_py3.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/models/_models_py3.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_message_id_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_message_id_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_messages_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_messages_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_queue_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_queue_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_generated/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_message_encoding.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_message_encoding.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_queue_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_queue_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_queue_service_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_queue_service_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_serialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_serialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/authentication.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/authentication.py`

 * *Files 3% similar despite different names*

```diff
@@ -60,54 +60,48 @@
 class SharedKeyCredentialPolicy(SansIOHTTPPolicy):
 
     def __init__(self, account_name, account_key):
         self.account_name = account_name
         self.account_key = account_key
         super(SharedKeyCredentialPolicy, self).__init__()
 
-    @staticmethod
-    def _get_headers(request, headers_to_sign):
+    def _get_headers(self, request, headers_to_sign):
         headers = dict((name.lower(), value) for name, value in request.http_request.headers.items() if value)
         if 'content-length' in headers and headers['content-length'] == '0':
             del headers['content-length']
         return '\n'.join(headers.get(x, '') for x in headers_to_sign) + '\n'
 
-    @staticmethod
-    def _get_verb(request):
+    def _get_verb(self, request):
         return request.http_request.method + '\n'
 
     def _get_canonicalized_resource(self, request):
         uri_path = urlparse(request.http_request.url).path
         try:
             if isinstance(request.context.transport, AioHttpTransport) or \
-                    isinstance(getattr(request.context.transport, "_transport", None), AioHttpTransport) or \
-                    isinstance(getattr(getattr(request.context.transport, "_transport", None), "_transport", None),
-                               AioHttpTransport):
+                isinstance(getattr(request.context.transport, "_transport", None), AioHttpTransport):
                 uri_path = URL(uri_path)
                 return '/' + self.account_name + str(uri_path)
         except TypeError:
             pass
         return '/' + self.account_name + uri_path
 
-    @staticmethod
-    def _get_canonicalized_headers(request):
+    def _get_canonicalized_headers(self, request):
         string_to_sign = ''
         x_ms_headers = []
         for name, value in request.http_request.headers.items():
             if name.startswith('x-ms-'):
                 x_ms_headers.append((name.lower(), value))
         x_ms_headers.sort()
         for name, value in x_ms_headers:
             if value is not None:
                 string_to_sign += ''.join([name, ':', value, '\n'])
         return string_to_sign
 
-    @staticmethod
-    def _get_canonicalized_resource_query(request):
-        sorted_queries = list(request.http_request.query.items())
+    def _get_canonicalized_resource_query(self, request):
+        sorted_queries = [(name, value) for name, value in request.http_request.query.items()]
         sorted_queries.sort()
 
         string_to_sign = ''
         for name, value in sorted_queries:
             if value is not None:
                 string_to_sign += '\n' + name.lower() + ':' + unquote(value)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/base_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/base_client.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,114 +2,114 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 import logging
 import uuid
 from typing import (  # pylint: disable=unused-import
-    Optional,
     Any,
+    Dict,
+    Optional,
     Tuple,
+    TYPE_CHECKING,
+    Union,
 )
 
 try:
     from urllib.parse import parse_qs, quote
 except ImportError:
     from urlparse import parse_qs  # type: ignore
     from urllib2 import quote  # type: ignore
 
-import six
-
 from azure.core.configuration import Configuration
-from azure.core.credentials import AzureSasCredential
+from azure.core.credentials import AzureSasCredential, AzureNamedKeyCredential
 from azure.core.exceptions import HttpResponseError
 from azure.core.pipeline import Pipeline
 from azure.core.pipeline.transport import RequestsTransport, HttpTransport
 from azure.core.pipeline.policies import (
-    RedirectPolicy,
-    ContentDecodePolicy,
+    AzureSasCredentialPolicy,
     BearerTokenCredentialPolicy,
-    ProxyPolicy,
+    ContentDecodePolicy,
     DistributedTracingPolicy,
     HttpLoggingPolicy,
+    ProxyPolicy,
+    RedirectPolicy,
     UserAgentPolicy,
-    AzureSasCredentialPolicy
 )
 
-from .constants import STORAGE_OAUTH_SCOPE, SERVICE_HOST_BASE, CONNECTION_TIMEOUT, READ_TIMEOUT
+from .constants import CONNECTION_TIMEOUT, READ_TIMEOUT, SERVICE_HOST_BASE, STORAGE_OAUTH_SCOPE
 from .models import LocationMode
 from .authentication import SharedKeyCredentialPolicy
 from .shared_access_signature import QueryStringConstants
 from .request_handlers import serialize_batch_body, _get_batch_request_delimiter
 from .policies import (
-    StorageHeadersPolicy,
+    ExponentialRetry,
+    QueueMessagePolicy,
     StorageContentValidation,
+    StorageHeadersPolicy,
+    StorageHosts,
+    StorageLoggingPolicy,
     StorageRequestHook,
     StorageResponseHook,
-    StorageLoggingPolicy,
-    StorageHosts,
-    QueueMessagePolicy,
-    ExponentialRetry,
 )
 from .._version import VERSION
 from .response_handlers import process_storage_error, PartialBatchErrorException
 
+if TYPE_CHECKING:
+    from azure.core.credentials import TokenCredential
 
 _LOGGER = logging.getLogger(__name__)
 _SERVICE_PARAMS = {
     "blob": {"primary": "BLOBENDPOINT", "secondary": "BLOBSECONDARYENDPOINT"},
     "queue": {"primary": "QUEUEENDPOINT", "secondary": "QUEUESECONDARYENDPOINT"},
     "file": {"primary": "FILEENDPOINT", "secondary": "FILESECONDARYENDPOINT"},
     "dfs": {"primary": "BLOBENDPOINT", "secondary": "BLOBENDPOINT"},
 }
 
+
 class StorageAccountHostsMixin(object):  # pylint: disable=too-many-instance-attributes
     def __init__(
         self,
         parsed_url,  # type: Any
         service,  # type: str
-        credential=None,  # type: Optional[Any]
+        credential=None,  # type: Optional[Union[str, Dict[str, str], AzureNamedKeyCredential, AzureSasCredential, "TokenCredential"]] # pylint: disable=line-too-long
         **kwargs  # type: Any
     ):
         # type: (...) -> None
         self._location_mode = kwargs.get("_location_mode", LocationMode.PRIMARY)
         self._hosts = kwargs.get("_hosts")
         self.scheme = parsed_url.scheme
 
         if service not in ["blob", "queue", "file-share", "dfs"]:
-            raise ValueError("Invalid service: {}".format(service))
+            raise ValueError(f"Invalid service: {service}")
         service_name = service.split('-')[0]
-        account = parsed_url.netloc.split(".{}.core.".format(service_name))
+        account = parsed_url.netloc.split(f".{service_name}.core.")
 
         self.account_name = account[0] if len(account) > 1 else None
         if not self.account_name and parsed_url.netloc.startswith("localhost") \
                 or parsed_url.netloc.startswith("127.0.0.1"):
             self.account_name = parsed_url.path.strip("/")
 
         self.credential = _format_shared_key_credential(self.account_name, credential)
         if self.scheme.lower() != "https" and hasattr(self.credential, "get_token"):
             raise ValueError("Token credential is only supported with HTTPS.")
 
         secondary_hostname = None
         if hasattr(self.credential, "account_name"):
             self.account_name = self.credential.account_name
-            secondary_hostname = "{}-secondary.{}.{}".format(
-                self.credential.account_name, service_name, SERVICE_HOST_BASE)
+            secondary_hostname = f"{self.credential.account_name}-secondary.{service_name}.{SERVICE_HOST_BASE}"
 
         if not self._hosts:
             if len(account) > 1:
                 secondary_hostname = parsed_url.netloc.replace(account[0], account[0] + "-secondary")
             if kwargs.get("secondary_hostname"):
                 secondary_hostname = kwargs["secondary_hostname"]
             primary_hostname = (parsed_url.netloc + parsed_url.path).rstrip('/')
             self._hosts = {LocationMode.PRIMARY: primary_hostname, LocationMode.SECONDARY: secondary_hostname}
 
-        self.require_encryption = kwargs.get("require_encryption", False)
-        self.key_encryption_key = kwargs.get("key_encryption_key")
-        self.key_resolver_function = kwargs.get("key_resolver_function")
         self._config, self._pipeline = self._create_pipeline(self.credential, storage_sdk=service, **kwargs)
 
     def __enter__(self):
         self._client.__enter__()
         return self
 
     def __exit__(self, *args):
@@ -184,51 +184,51 @@
 
     @location_mode.setter
     def location_mode(self, value):
         if self._hosts.get(value):
             self._location_mode = value
             self._client._config.url = self.url  # pylint: disable=protected-access
         else:
-            raise ValueError("No host URL for location mode: {}".format(value))
+            raise ValueError(f"No host URL for location mode: {value}")
 
     @property
     def api_version(self):
         """The version of the Storage API used for requests.
 
         :type: str
         """
         return self._client._config.version  # pylint: disable=protected-access
 
     def _format_query_string(self, sas_token, credential, snapshot=None, share_snapshot=None):
         query_str = "?"
         if snapshot:
-            query_str += "snapshot={}&".format(self.snapshot)
+            query_str += f"snapshot={self.snapshot}&"
         if share_snapshot:
-            query_str += "sharesnapshot={}&".format(self.snapshot)
+            query_str += f"sharesnapshot={self.snapshot}&"
         if sas_token and isinstance(credential, AzureSasCredential):
             raise ValueError(
                 "You cannot use AzureSasCredential when the resource URI also contains a Shared Access Signature.")
-        if sas_token and not credential:
-            query_str += sas_token
-        elif is_credential_sastoken(credential):
+        if is_credential_sastoken(credential):
             query_str += credential.lstrip("?")
             credential = None
+        elif sas_token:
+            query_str += sas_token
         return query_str.rstrip("?&"), credential
 
     def _create_pipeline(self, credential, **kwargs):
         # type: (Any, **Any) -> Tuple[Configuration, Pipeline]
         self._credential_policy = None
         if hasattr(credential, "get_token"):
             self._credential_policy = BearerTokenCredentialPolicy(credential, STORAGE_OAUTH_SCOPE)
         elif isinstance(credential, SharedKeyCredentialPolicy):
             self._credential_policy = credential
         elif isinstance(credential, AzureSasCredential):
             self._credential_policy = AzureSasCredentialPolicy(credential)
         elif credential is not None:
-            raise TypeError("Unsupported credential: {}".format(credential))
+            raise TypeError(f"Unsupported credential: {credential}")
 
         config = kwargs.get("_configuration") or create_configuration(**kwargs)
         if kwargs.get("_pipeline"):
             return config, kwargs["_pipeline"]
         config.transport = kwargs.get("transport")  # type: ignore
         kwargs.setdefault("connection_timeout", CONNECTION_TIMEOUT)
         kwargs.setdefault("read_timeout", READ_TIMEOUT)
@@ -263,21 +263,18 @@
         """Given a series of request, do a Storage batch call.
         """
         # Pop it here, so requests doesn't feel bad about additional kwarg
         raise_on_any_failure = kwargs.pop("raise_on_any_failure", True)
         batch_id = str(uuid.uuid1())
 
         request = self._client._client.post(  # pylint: disable=protected-access
-            url='{}://{}/{}?{}comp=batch{}{}'.format(
-                self.scheme,
-                self.primary_hostname,
-                kwargs.pop('path', ""),
-                kwargs.pop('restype', ""),
-                kwargs.pop('sas', ""),
-                kwargs.pop('timeout', "")
+            url=(
+                f'{self.scheme}://{self.primary_hostname}/'
+                f"{kwargs.pop('path', '')}?{kwargs.pop('restype', '')}"
+                f"comp=batch{kwargs.pop('sas', '')}{kwargs.pop('timeout', '')}"
             ),
             headers={
                 'x-ms-version': self.api_version,
                 "Content-Type": "multipart/mixed; boundary=" + _get_batch_request_delimiter(batch_id, False, False)
             }
         )
 
@@ -341,24 +338,26 @@
         pass
 
     def __exit__(self, *args):  # pylint: disable=arguments-differ
         pass
 
 
 def _format_shared_key_credential(account_name, credential):
-    if isinstance(credential, six.string_types):
+    if isinstance(credential, str):
         if not account_name:
             raise ValueError("Unable to determine account name for shared key credential.")
         credential = {"account_name": account_name, "account_key": credential}
     if isinstance(credential, dict):
         if "account_name" not in credential:
             raise ValueError("Shared key credential missing 'account_name")
         if "account_key" not in credential:
             raise ValueError("Shared key credential missing 'account_key")
         return SharedKeyCredentialPolicy(**credential)
+    if isinstance(credential, AzureNamedKeyCredential):
+        return SharedKeyCredentialPolicy(credential.named_key.name, credential.named_key.key)
     return credential
 
 
 def parse_connection_str(conn_str, credential, service):
     conn_str = conn_str.rstrip(";")
     conn_settings = [s.split("=", 1) for s in conn_str.split(";")]
     if any(len(tup) != 2 for tup in conn_settings):
@@ -376,45 +375,46 @@
         primary = conn_settings[endpoints["primary"]]
         if endpoints["secondary"] in conn_settings:
             secondary = conn_settings[endpoints["secondary"]]
     else:
         if endpoints["secondary"] in conn_settings:
             raise ValueError("Connection string specifies only secondary endpoint.")
         try:
-            primary = "{}://{}.{}.{}".format(
-                conn_settings["DEFAULTENDPOINTSPROTOCOL"],
-                conn_settings["ACCOUNTNAME"],
-                service,
-                conn_settings["ENDPOINTSUFFIX"],
+            primary =(
+                f"{conn_settings['DEFAULTENDPOINTSPROTOCOL']}://"
+                f"{conn_settings['ACCOUNTNAME']}.{service}.{conn_settings['ENDPOINTSUFFIX']}"
             )
-            secondary = "{}-secondary.{}.{}".format(
-                conn_settings["ACCOUNTNAME"], service, conn_settings["ENDPOINTSUFFIX"]
+            secondary = (
+                f"{conn_settings['ACCOUNTNAME']}-secondary."
+                f"{service}.{conn_settings['ENDPOINTSUFFIX']}"
             )
         except KeyError:
             pass
 
     if not primary:
         try:
-            primary = "https://{}.{}.{}".format(
-                conn_settings["ACCOUNTNAME"], service, conn_settings.get("ENDPOINTSUFFIX", SERVICE_HOST_BASE)
+            primary = (
+                f"https://{conn_settings['ACCOUNTNAME']}."
+                f"{service}.{conn_settings.get('ENDPOINTSUFFIX', SERVICE_HOST_BASE)}"
             )
         except KeyError:
             raise ValueError("Connection string missing required connection details.")
     if service == "dfs":
         primary = primary.replace(".blob.", ".dfs.")
-        secondary = secondary.replace(".blob.", ".dfs.")
+        if secondary:
+            secondary = secondary.replace(".blob.", ".dfs.")
     return primary, secondary, credential
 
 
 def create_configuration(**kwargs):
     # type: (**Any) -> Configuration
     config = Configuration(**kwargs)
     config.headers_policy = StorageHeadersPolicy(**kwargs)
     config.user_agent_policy = UserAgentPolicy(
-        sdk_moniker="storage-{}/{}".format(kwargs.pop('storage_sdk'), VERSION), **kwargs)
+        sdk_moniker=f"storage-{kwargs.pop('storage_sdk')}/{VERSION}", **kwargs)
     config.retry_policy = kwargs.get("retry_policy") or ExponentialRetry(**kwargs)
     config.logging_policy = StorageLoggingPolicy(**kwargs)
     config.proxy_policy = ProxyPolicy(**kwargs)
 
     # Storage settings
     config.max_single_put_size = kwargs.get("max_single_put_size", 64 * 1024 * 1024)
     config.copy_polling_interval = 15
@@ -438,25 +438,25 @@
     config.max_range_size = kwargs.get("max_range_size", 4 * 1024 * 1024)
     return config
 
 
 def parse_query(query_str):
     sas_values = QueryStringConstants.to_list()
     parsed_query = {k: v[0] for k, v in parse_qs(query_str).items()}
-    sas_params = ["{}={}".format(k, quote(v, safe='')) for k, v in parsed_query.items() if k in sas_values]
+    sas_params = [f"{k}={quote(v, safe='')}" for k, v in parsed_query.items() if k in sas_values]
     sas_token = None
     if sas_params:
         sas_token = "&".join(sas_params)
 
     snapshot = parsed_query.get("snapshot") or parsed_query.get("sharesnapshot")
     return snapshot, sas_token
 
 
 def is_credential_sastoken(credential):
-    if not credential or not isinstance(credential, six.string_types):
+    if not credential or not isinstance(credential, str):
         return False
 
     sas_values = QueryStringConstants.to_list()
     parsed_query = parse_qs(credential.lstrip("?"))
     if parsed_query and all([k in sas_values for k in parsed_query.keys()]):
         return True
     return False
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/base_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/base_client_async.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,25 +5,23 @@
 # --------------------------------------------------------------------------
 
 from typing import (  # pylint: disable=unused-import
     Union, Optional, Any, Iterable, Dict, List, Type, Tuple,
     TYPE_CHECKING
 )
 import logging
-
-from azure.core.credentials import AzureSasCredential
 from azure.core.pipeline import AsyncPipeline
 from azure.core.async_paging import AsyncList
 from azure.core.exceptions import HttpResponseError
 from azure.core.pipeline.policies import (
     ContentDecodePolicy,
     AsyncBearerTokenCredentialPolicy,
     AsyncRedirectPolicy,
     DistributedTracingPolicy,
-    HttpLoggingPolicy, AzureSasCredentialPolicy,
+    HttpLoggingPolicy,
 )
 from azure.core.pipeline.transport import AsyncHttpTransport
 
 from .constants import STORAGE_OAUTH_SCOPE, CONNECTION_TIMEOUT, READ_TIMEOUT
 from .authentication import SharedKeyCredentialPolicy
 from .base_client import create_configuration
 from .policies import (
@@ -31,14 +29,15 @@
     StorageRequestHook,
     StorageHosts,
     StorageHeadersPolicy,
     QueueMessagePolicy
 )
 from .policies_async import AsyncStorageResponseHook
 
+from .._generated.models import StorageErrorException
 from .response_handlers import process_storage_error, PartialBatchErrorException
 
 if TYPE_CHECKING:
     from azure.core.pipeline import Pipeline
     from azure.core.pipeline.transport import HttpRequest
     from azure.core.configuration import Configuration
 _LOGGER = logging.getLogger(__name__)
@@ -68,16 +67,14 @@
     def _create_pipeline(self, credential, **kwargs):
         # type: (Any, **Any) -> Tuple[Configuration, Pipeline]
         self._credential_policy = None
         if hasattr(credential, 'get_token'):
             self._credential_policy = AsyncBearerTokenCredentialPolicy(credential, STORAGE_OAUTH_SCOPE)
         elif isinstance(credential, SharedKeyCredentialPolicy):
             self._credential_policy = credential
-        elif isinstance(credential, AzureSasCredential):
-            self._credential_policy = AzureSasCredentialPolicy(credential)
         elif credential is not None:
             raise TypeError("Unsupported credential: {}".format(credential))
         config = kwargs.get('_configuration') or create_configuration(**kwargs)
         if kwargs.get('_pipeline'):
             return config, kwargs['_pipeline']
         config.transport = kwargs.get('transport')  # type: ignore
         kwargs.setdefault("connection_timeout", CONNECTION_TIMEOUT)
@@ -101,16 +98,14 @@
             StorageHosts(hosts=self._hosts, **kwargs), # type: ignore
             config.retry_policy,
             config.logging_policy,
             AsyncStorageResponseHook(**kwargs),
             DistributedTracingPolicy(**kwargs),
             HttpLoggingPolicy(**kwargs),
         ]
-        if kwargs.get("_additional_pipeline_policies"):
-            policies = policies + kwargs.get("_additional_pipeline_policies")
         return config, AsyncPipeline(config.transport, policies=policies)
 
     async def _batch_send(
         self, *reqs: 'HttpRequest',
         **kwargs
     ):
         """Given a series of request, do a Storage batch call.
@@ -125,16 +120,15 @@
         )
 
         request.set_multipart_mixed(
             *reqs,
             policies=[
                 StorageHeadersPolicy(),
                 self._credential_policy
-            ],
-            enforce_https=False
+            ]
         )
 
         pipeline_response = await self._pipeline.run(
             request, **kwargs
         )
         response = pipeline_response.http_response
 
@@ -150,15 +144,15 @@
                     error = PartialBatchErrorException(
                         message="There is a partial failure in the batch operation.",
                         response=response, parts=parts_list
                     )
                     raise error
                 return AsyncList(parts_list)
             return parts
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
 
 class AsyncTransportWrapper(AsyncHttpTransport):
     """Wrapper class that ensures that an inner client created
     by a `get_client` method does not close the outer transport for the parent
     when used in a context manager.
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/encryption.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/encryption.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/models.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=too-many-instance-attributes
-
 from enum import Enum
 
 from azure.core import CaseInsensitiveEnumMeta
 
 
 def get_enum_value(value):
     if value is None or value in ["None", ""]:
@@ -81,15 +80,17 @@
     CONTAINER_DISABLED = "ContainerDisabled"
     CONTAINER_NOT_FOUND = "ContainerNotFound"
     CONTENT_LENGTH_LARGER_THAN_TIER_LIMIT = "ContentLengthLargerThanTierLimit"
     COPY_ACROSS_ACCOUNTS_NOT_SUPPORTED = "CopyAcrossAccountsNotSupported"
     COPY_ID_MISMATCH = "CopyIdMismatch"
     FEATURE_VERSION_MISMATCH = "FeatureVersionMismatch"
     INCREMENTAL_COPY_BLOB_MISMATCH = "IncrementalCopyBlobMismatch"
-    INCREMENTAL_COPY_OF_ERALIER_VERSION_SNAPSHOT_NOT_ALLOWED = "IncrementalCopyOfEralierVersionSnapshotNotAllowed"
+    INCREMENTAL_COPY_OF_EARLIER_VERSION_SNAPSHOT_NOT_ALLOWED = "IncrementalCopyOfEarlierVersionSnapshotNotAllowed"
+    #: Deprecated: Please use INCREMENTAL_COPY_OF_EARLIER_VERSION_SNAPSHOT_NOT_ALLOWED instead.
+    INCREMENTAL_COPY_OF_ERALIER_VERSION_SNAPSHOT_NOT_ALLOWED = "IncrementalCopyOfEarlierVersionSnapshotNotAllowed"
     INCREMENTAL_COPY_SOURCE_MUST_BE_SNAPSHOT = "IncrementalCopySourceMustBeSnapshot"
     INFINITE_LEASE_DURATION_REQUIRED = "InfiniteLeaseDurationRequired"
     INVALID_BLOB_OR_BLOCK = "InvalidBlobOrBlock"
     INVALID_BLOB_TIER = "InvalidBlobTier"
     INVALID_BLOB_TYPE = "InvalidBlobType"
     INVALID_BLOCK_ID = "InvalidBlockId"
     INVALID_BLOCK_LIST = "InvalidBlockList"
@@ -117,15 +118,17 @@
     PENDING_COPY_OPERATION = "PendingCopyOperation"
     PREVIOUS_SNAPSHOT_CANNOT_BE_NEWER = "PreviousSnapshotCannotBeNewer"
     PREVIOUS_SNAPSHOT_NOT_FOUND = "PreviousSnapshotNotFound"
     PREVIOUS_SNAPSHOT_OPERATION_NOT_SUPPORTED = "PreviousSnapshotOperationNotSupported"
     SEQUENCE_NUMBER_CONDITION_NOT_MET = "SequenceNumberConditionNotMet"
     SEQUENCE_NUMBER_INCREMENT_TOO_LARGE = "SequenceNumberIncrementTooLarge"
     SNAPSHOT_COUNT_EXCEEDED = "SnapshotCountExceeded"
-    SNAPHOT_OPERATION_RATE_EXCEEDED = "SnaphotOperationRateExceeded"
+    SNAPSHOT_OPERATION_RATE_EXCEEDED = "SnapshotOperationRateExceeded"
+    #: Deprecated: Please use SNAPSHOT_OPERATION_RATE_EXCEEDED instead.
+    SNAPHOT_OPERATION_RATE_EXCEEDED = "SnapshotOperationRateExceeded"
     SNAPSHOTS_PRESENT = "SnapshotsPresent"
     SOURCE_CONDITION_NOT_MET = "SourceConditionNotMet"
     SYSTEM_IN_USE = "SystemInUse"
     TARGET_CONDITION_NOT_MET = "TargetConditionNotMet"
     UNAUTHORIZED_BLOB_OVERWRITE = "UnauthorizedBlobOverwrite"
     BLOB_BEING_REHYDRATED = "BlobBeingRehydrated"
     BLOB_ARCHIVED = "BlobArchived"
@@ -281,15 +284,15 @@
         To specify service, container, or object you need only to
         include the first letter of the word in the string. E.g. service and container,
         you would provide a string "sc".
 
         :param str string: Specify service, container, or object in
             in the string with the first letter of the word.
         :return: A ResourceTypes object
-        :rtype: ~azure.storage.queue.ResourceTypes
+        :rtype: ~azure.storage.fileshare.ResourceTypes
         """
         res_service = 's' in string
         res_container = 'c' in string
         res_object = 'o' in string
 
         parsed = cls(res_service, res_container, res_object)
         parsed._str = string  # pylint: disable = protected-access
@@ -379,15 +382,15 @@
         To specify read, write, delete, etc. permissions you need only to
         include the first letter of the word in the string. E.g. for read and write
         permissions you would provide a string "rw".
 
         :param str permission: Specify permissions in
             the string with the first letter of the word.
         :return: An AccountSasPermissions object
-        :rtype: ~azure.storage.queue.AccountSasPermissions
+        :rtype: ~azure.storage.fileshare.AccountSasPermissions
         """
         p_read = 'r' in permission
         p_write = 'w' in permission
         p_delete = 'd' in permission
         p_delete_previous_version = 'x' in permission
         p_permanent_delete = 'y' in permission
         p_list = 'l' in permission
@@ -435,15 +438,15 @@
         To specify blob, queue, or file you need only to
         include the first letter of the word in the string. E.g. for blob and queue
         you would provide a string "bq".
 
         :param str string: Specify blob, queue, or file in
             in the string with the first letter of the word.
         :return: A Services object
-        :rtype: ~azure.storage.queue.Services
+        :rtype: ~azure.storage.fileshare.Services
         """
         res_blob = 'b' in string
         res_queue = 'q' in string
         res_file = 'f' in string
 
         parsed = cls(res_blob, res_queue, res_file)
         parsed._str = string  # pylint: disable = protected-access
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/parser.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/parser.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/policies.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/policies.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/policies_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/policies_async.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
-# pylint: disable=invalid-overridden-method
 
 import asyncio
 import random
 import logging
 from typing import Any, TYPE_CHECKING
 
 from azure.core.pipeline.policies import AsyncHTTPPolicy
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/request_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/request_handlers.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,14 +7,15 @@
 from typing import (  # pylint: disable=unused-import
     Union, Optional, Any, Iterable, Dict, List, Type, Tuple,
     TYPE_CHECKING
 )
 
 import logging
 from os import fstat
+import stat
 from io import (SEEK_END, SEEK_SET, UnsupportedOperation)
 
 import isodate
 
 from azure.core.exceptions import raise_with_traceback
 
 
@@ -66,15 +67,19 @@
         # If so, calculate the size using the file descriptor.
         try:
             fileno = data.fileno()
         except (AttributeError, UnsupportedOperation):
             pass
         else:
             try:
-                return fstat(fileno).st_size
+                mode = fstat(fileno).st_mode
+                if stat.S_ISREG(mode) or stat.S_ISLNK(mode):
+                    #st_size only meaningful if regular file or symlink, other types
+                    # e.g. sockets may return misleading sizes like 0
+                    return fstat(fileno).st_size
             except OSError:
                 # Not a valid fileno, may be possible requests returned
                 # a socket number?
                 pass
 
         # If the stream is seekable and tell() is implemented, calculate the stream size.
         try:
@@ -113,45 +118,45 @@
         raise ValueError("start_range value cannot be None.")
     if end_range_required and end_range is None:
         raise ValueError("end_range value cannot be None.")
 
     # Page ranges must be 512 aligned
     if align_to_page:
         if start_range is not None and start_range % 512 != 0:
-            raise ValueError("Invalid page blob start_range: {0}. "
-                             "The size must be aligned to a 512-byte boundary.".format(start_range))
+            raise ValueError(f"Invalid page blob start_range: {start_range}. "
+                             "The size must be aligned to a 512-byte boundary.")
         if end_range is not None and end_range % 512 != 511:
-            raise ValueError("Invalid page blob end_range: {0}. "
-                             "The size must be aligned to a 512-byte boundary.".format(end_range))
+            raise ValueError(f"Invalid page blob end_range: {end_range}. "
+                             "The size must be aligned to a 512-byte boundary.")
 
     # Format based on whether end_range is present
     range_header = None
     if end_range is not None:
-        range_header = 'bytes={0}-{1}'.format(start_range, end_range)
+        range_header = f'bytes={start_range}-{end_range}'
     elif start_range is not None:
-        range_header = "bytes={0}-".format(start_range)
+        range_header = f"bytes={start_range}-"
 
     # Content MD5 can only be provided for a complete range less than 4MB in size
     range_validation = None
     if check_content_md5:
         if start_range is None or end_range is None:
-            raise ValueError("Both start and end range requied for MD5 content validation.")
+            raise ValueError("Both start and end range required for MD5 content validation.")
         if end_range - start_range > 4 * 1024 * 1024:
             raise ValueError("Getting content MD5 for a range greater than 4MB is not supported.")
         range_validation = 'true'
 
     return range_header, range_validation
 
 
 def add_metadata_headers(metadata=None):
     # type: (Optional[Dict[str, str]]) -> Dict[str, str]
     headers = {}
     if metadata:
         for key, value in metadata.items():
-            headers['x-ms-meta-{}'.format(key.strip())] = value.strip() if value else value
+            headers[f'x-ms-meta-{key.strip()}'] = value.strip() if value else value
     return headers
 
 
 def serialize_batch_body(requests, batch_id):
     """
     --<delimiter>
     <subrequest>
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/response_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/response_handlers.py`

 * *Files 3% similar despite different names*

```diff
@@ -63,15 +63,18 @@
         if key.startswith('x-ms-'):
             key = key[5:]
         normalized[key.lower().replace('-', '_')] = get_enum_value(value)
     return normalized
 
 
 def deserialize_metadata(response, obj, headers):  # pylint: disable=unused-argument
-    raw_metadata = {k: v for k, v in response.headers.items() if k.startswith("x-ms-meta-")}
+    try:
+        raw_metadata = {k: v for k, v in response.http_response.headers.items() if k.startswith("x-ms-meta-")}
+    except AttributeError:
+        raw_metadata = {k: v for k, v in response.headers.items() if k.startswith("x-ms-meta-")}
     return {k[10:]: v for k, v in raw_metadata.items()}
 
 
 def return_response_headers(response, deserialized, response_headers):  # pylint: disable=unused-argument
     return normalize_headers(response_headers)
 
 
@@ -79,24 +82,26 @@
     return normalize_headers(response_headers), deserialized
 
 
 def return_context_and_deserialized(response, deserialized, response_headers):  # pylint: disable=unused-argument
     return response.http_response.location_mode, deserialized
 
 
+def return_raw_deserialized(response, *_):
+    return response.http_response.location_mode, response.context[ContentDecodePolicy.CONTEXT_NAME]
+
+
 def process_storage_error(storage_error):   # pylint:disable=too-many-statements
     raise_error = HttpResponseError
     serialized = False
-    if not storage_error.response or storage_error.response.status_code in [200, 204]:
+    if not storage_error.response:
         raise storage_error
     # If it is one of those three then it has been serialized prior by the generated layer.
     if isinstance(storage_error, (PartialBatchErrorException,
-                                  ClientAuthenticationError,
-                                  ResourceNotFoundError,
-                                  ResourceExistsError)):
+                                  ClientAuthenticationError, ResourceNotFoundError, ResourceExistsError)):
         serialized = True
     error_code = storage_error.response.headers.get('x-ms-error-code')
     error_message = storage_error.message
     additional_data = {}
     error_dict = {}
     try:
         error_body = ContentDecodePolicy.deserialize_from_http_generics(storage_error.response)
@@ -158,19 +163,19 @@
                 raise_error = ResourceExistsError
     except ValueError:
         # Got an unknown error code
         pass
 
     # Error message should include all the error properties
     try:
-        error_message += "\nErrorCode:{}".format(error_code.value)
+        error_message += f"\nErrorCode:{error_code.value}"
     except AttributeError:
-        error_message += "\nErrorCode:{}".format(error_code)
+        error_message += f"\nErrorCode:{error_code}"
     for name, info in additional_data.items():
-        error_message += "\n{}:{}".format(name, info)
+        error_message += f"\n{name}:{info}"
 
     # No need to create an instance if it has already been serialized by the generated layer
     if serialized:
         storage_error.message = error_message
         error = storage_error
     else:
         error = raise_error(message=error_message, response=storage_error.response)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/shared_access_signature.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,20 +35,14 @@
     SIGNED_OID = 'skoid'
     SIGNED_TID = 'sktid'
     SIGNED_KEY_START = 'skt'
     SIGNED_KEY_EXPIRY = 'ske'
     SIGNED_KEY_SERVICE = 'sks'
     SIGNED_KEY_VERSION = 'skv'
 
-    # for ADLS
-    SIGNED_AUTHORIZED_OID = 'saoid'
-    SIGNED_UNAUTHORIZED_OID = 'suoid'
-    SIGNED_CORRELATION_ID = 'scid'
-    SIGNED_DIRECTORY_DEPTH = 'sdd'
-
     @staticmethod
     def to_list():
         return [
             QueryStringConstants.SIGNED_SIGNATURE,
             QueryStringConstants.SIGNED_PERMISSION,
             QueryStringConstants.SIGNED_START,
             QueryStringConstants.SIGNED_EXPIRY,
@@ -70,19 +64,14 @@
             QueryStringConstants.SIGNED_SERVICES,
             QueryStringConstants.SIGNED_OID,
             QueryStringConstants.SIGNED_TID,
             QueryStringConstants.SIGNED_KEY_START,
             QueryStringConstants.SIGNED_KEY_EXPIRY,
             QueryStringConstants.SIGNED_KEY_SERVICE,
             QueryStringConstants.SIGNED_KEY_VERSION,
-            # for ADLS
-            QueryStringConstants.SIGNED_AUTHORIZED_OID,
-            QueryStringConstants.SIGNED_UNAUTHORIZED_OID,
-            QueryStringConstants.SIGNED_CORRELATION_ID,
-            QueryStringConstants.SIGNED_DIRECTORY_DEPTH,
         ]
 
 
 class SharedAccessSignature(object):
     '''
     Provides a factory for creating account access
     signature tokens with an account name and account key. Users can either
@@ -207,16 +196,14 @@
              get_value_to_append(QueryStringConstants.SIGNED_PERMISSION) +
              get_value_to_append(QueryStringConstants.SIGNED_SERVICES) +
              get_value_to_append(QueryStringConstants.SIGNED_RESOURCE_TYPES) +
              get_value_to_append(QueryStringConstants.SIGNED_START) +
              get_value_to_append(QueryStringConstants.SIGNED_EXPIRY) +
              get_value_to_append(QueryStringConstants.SIGNED_IP) +
              get_value_to_append(QueryStringConstants.SIGNED_PROTOCOL) +
-             get_value_to_append(QueryStringConstants.SIGNED_VERSION) +
-             '\n'   # Signed Encryption Scope - always empty for queue
-             )
+             get_value_to_append(QueryStringConstants.SIGNED_VERSION))
 
         self._add_query(QueryStringConstants.SIGNED_SIGNATURE,
                         sign_string(account_key, string_to_sign))
 
     def get_token(self):
         return '&'.join(['{0}={1}'.format(n, url_quote(v)) for n, v in self.query_dict.items() if v is not None])
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/uploads.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/uploads.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,27 +2,24 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=no-self-use
 
 from concurrent import futures
-from io import (BytesIO, IOBase, SEEK_CUR, SEEK_END, SEEK_SET, UnsupportedOperation)
-from threading import Lock
+from io import BytesIO, IOBase, SEEK_CUR, SEEK_END, SEEK_SET, UnsupportedOperation
 from itertools import islice
 from math import ceil
-
-import six
+from threading import Lock
 
 from azure.core.tracing.common import with_current_context
 
 from . import encode_base64, url_quote
 from .request_handlers import get_length
 from .response_handlers import return_response_headers
-from .encryption import get_blob_encryptor_and_padder
 
 
 _LARGE_BLOB_UPLOAD_MAX_READ_BUFFER_SIZE = 4 * 1024 * 1024
 _ERROR_VALUE_SHOULD_BE_SEEKABLE_STREAM = "{0} should be a seekable file-like/io.IOBase type stream object."
 
 
 def _parallel_uploads(executor, uploader, pending, running):
@@ -48,26 +45,17 @@
         service=None,
         uploader_class=None,
         total_size=None,
         chunk_size=None,
         max_concurrency=None,
         stream=None,
         validate_content=None,
-        encryption_options=None,
         progress_hook=None,
         **kwargs):
 
-    if encryption_options:
-        encryptor, padder = get_blob_encryptor_and_padder(
-            encryption_options.get('cek'),
-            encryption_options.get('vector'),
-            uploader_class is not PageBlobChunkUploader)
-        kwargs['encryptor'] = encryptor
-        kwargs['padder'] = padder
-
     parallel = max_concurrency > 1
     if parallel and 'modified_access_conditions' in kwargs:
         # Access conditions do not work with parallelism
         kwargs['modified_access_conditions'] = None
 
     uploader = uploader_class(
         service=service,
@@ -145,15 +133,14 @@
         self.service = service
         self.total_size = total_size
         self.chunk_size = chunk_size
         self.stream = stream
         self.parallel = parallel
 
         # Stream management
-        self.stream_start = stream.tell() if parallel else None
         self.stream_lock = Lock() if parallel else None
 
         # Progress feedback
         self.progress_total = 0
         self.progress_lock = Lock() if parallel else None
         self.progress_hook = progress_hook
 
@@ -172,15 +159,15 @@
             read_size = self.chunk_size
 
             # Buffer until we either reach the end of the stream or get a whole chunk.
             while True:
                 if self.total_size:
                     read_size = min(self.chunk_size - len(data), self.total_size - (index + len(data)))
                 temp = self.stream.read(read_size)
-                if not isinstance(temp, six.binary_type):
+                if not isinstance(temp, bytes):
                     raise TypeError("Blob data should be of type bytes.")
                 data += temp or b""
 
                 # We have read an empty string and so are at the end
                 # of the buffer or we have read a full chunk.
                 if temp == b"" or len(data) == self.chunk_size:
                     break
@@ -263,29 +250,29 @@
     def __init__(self, *args, **kwargs):
         kwargs.pop("modified_access_conditions", None)
         super(BlockBlobChunkUploader, self).__init__(*args, **kwargs)
         self.current_length = None
 
     def _upload_chunk(self, chunk_offset, chunk_data):
         # TODO: This is incorrect, but works with recording.
-        index = '{0:032d}'.format(chunk_offset)
+        index = f'{chunk_offset:032d}'
         block_id = encode_base64(url_quote(encode_base64(index)))
         self.service.stage_block(
             block_id,
             len(chunk_data),
             chunk_data,
             data_stream_total=self.total_size,
             upload_stream_current=self.progress_total,
             **self.request_options
         )
         return index, block_id
 
     def _upload_substream_block(self, index, block_stream):
         try:
-            block_id = 'BlockId{}'.format("%05d" % (index/self.chunk_size))
+            block_id = f'BlockId{"%05d" % (index/self.chunk_size)}'
             self.service.stage_block(
                 block_id,
                 len(block_stream),
                 block_stream,
                 data_stream_total=self.total_size,
                 upload_stream_current=self.progress_total,
                 **self.request_options
@@ -302,15 +289,15 @@
         # if reached the end without returning, then chunk_data is all 0's
         return not any(bytearray(chunk_data))
 
     def _upload_chunk(self, chunk_offset, chunk_data):
         # avoid uploading the empty pages
         if not self._is_chunk_empty(chunk_data):
             chunk_end = chunk_offset + len(chunk_data) - 1
-            content_range = "bytes={0}-{1}".format(chunk_offset, chunk_end)
+            content_range = f"bytes={chunk_offset}-{chunk_end}"
             computed_md5 = None
             self.response_headers = self.service.upload_pages(
                 body=chunk_data,
                 content_length=len(chunk_data),
                 transactional_content_md5=computed_md5,
                 range=content_range,
                 cls=return_response_headers,
@@ -400,15 +387,15 @@
             chunk_data,
             chunk_offset,
             length,
             data_stream_total=self.total_size,
             upload_stream_current=self.progress_total,
             **self.request_options
         )
-        return 'bytes={0}-{1}'.format(chunk_offset, chunk_end), response
+        return f'bytes={chunk_offset}-{chunk_end}', response
 
     # TODO: Implement this method.
     def _upload_substream_block(self, index, block_stream):
         pass
 
 
 class SubStream(IOBase):
@@ -594,23 +581,23 @@
 
     next = __next__  # Python 2 compatibility.
 
     def tell(self, *args, **kwargs):
         raise UnsupportedOperation("Data generator does not support tell.")
 
     def seek(self, *args, **kwargs):
-        raise UnsupportedOperation("Data generator is unseekable.")
+        raise UnsupportedOperation("Data generator is not seekable.")
 
     def read(self, size):
         data = self.leftover
         count = len(self.leftover)
         try:
             while count < size:
                 chunk = self.__next__()
-                if isinstance(chunk, six.text_type):
+                if isinstance(chunk, str):
                     chunk = chunk.encode(self.encoding)
                 data += chunk
                 count += len(chunk)
         except StopIteration:
             pass
 
         if count > size:
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared/uploads_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/uploads_async.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,31 +2,46 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
 # pylint: disable=no-self-use
 
 import asyncio
+import inspect
+import threading
 from asyncio import Lock
+from io import UnsupportedOperation
 from itertools import islice
-import threading
-
 from math import ceil
-
-import six
+from typing import AsyncGenerator, Union
 
 from . import encode_base64, url_quote
 from .request_handlers import get_length
 from .response_handlers import return_response_headers
-from .encryption import get_blob_encryptor_and_padder
 from .uploads import SubStream, IterStreamer  # pylint: disable=unused-import
 
 
-_LARGE_BLOB_UPLOAD_MAX_READ_BUFFER_SIZE = 4 * 1024 * 1024
-_ERROR_VALUE_SHOULD_BE_SEEKABLE_STREAM = '{0} should be a seekable file-like/io.IOBase type stream object.'
+async def _async_parallel_uploads(uploader, pending, running):
+    range_ids = []
+    while True:
+        # Wait for some download to finish before adding a new one
+        done, running = await asyncio.wait(running, return_when=asyncio.FIRST_COMPLETED)
+        range_ids.extend([chunk.result() for chunk in done])
+        try:
+            for _ in range(0, len(done)):
+                next_chunk = await pending.__anext__()
+                running.add(asyncio.ensure_future(uploader(next_chunk)))
+        except StopAsyncIteration:
+            break
+
+    # Wait for the remaining uploads to finish
+    if running:
+        done, _running = await asyncio.wait(running)
+        range_ids.extend([chunk.result() for chunk in done])
+    return range_ids
 
 
 async def _parallel_uploads(uploader, pending, running):
     range_ids = []
     while True:
         # Wait for some download to finish before adding a new one
         done, running = await asyncio.wait(running, return_when=asyncio.FIRST_COMPLETED)
@@ -48,26 +63,17 @@
 async def upload_data_chunks(
         service=None,
         uploader_class=None,
         total_size=None,
         chunk_size=None,
         max_concurrency=None,
         stream=None,
-        encryption_options=None,
         progress_hook=None,
         **kwargs):
 
-    if encryption_options:
-        encryptor, padder = get_blob_encryptor_and_padder(
-            encryption_options.get('cek'),
-            encryption_options.get('vector'),
-            uploader_class is not PageBlobChunkUploader)
-        kwargs['encryptor'] = encryptor
-        kwargs['padder'] = padder
-
     parallel = max_concurrency > 1
     if parallel and 'modified_access_conditions' in kwargs:
         # Access conditions do not work with parallelism
         kwargs['modified_access_conditions'] = None
 
     uploader = uploader_class(
         service=service,
@@ -76,22 +82,26 @@
         stream=stream,
         parallel=parallel,
         progress_hook=progress_hook,
         **kwargs)
 
     if parallel:
         upload_tasks = uploader.get_chunk_streams()
-        running_futures = [
-            asyncio.ensure_future(uploader.process_chunk(u))
-            for u in islice(upload_tasks, 0, max_concurrency)
-        ]
-        range_ids = await _parallel_uploads(uploader.process_chunk, upload_tasks, running_futures)
+        running_futures = []
+        for _ in range(max_concurrency):
+            try:
+                chunk = await upload_tasks.__anext__()
+                running_futures.append(asyncio.ensure_future(uploader.process_chunk(chunk)))
+            except StopAsyncIteration:
+                break
+
+        range_ids = await _async_parallel_uploads(uploader.process_chunk, upload_tasks, running_futures)
     else:
         range_ids = []
-        for chunk in uploader.get_chunk_streams():
+        async for chunk in uploader.get_chunk_streams():
             range_ids.append(await uploader.process_chunk(chunk))
 
     if any(range_ids):
         return [r[1] for r in sorted(range_ids, key=lambda r: r[0])]
     return uploader.response_headers
 
 
@@ -148,15 +158,14 @@
         self.service = service
         self.total_size = total_size
         self.chunk_size = chunk_size
         self.stream = stream
         self.parallel = parallel
 
         # Stream management
-        self.stream_start = stream.tell() if parallel else None
         self.stream_lock = threading.Lock() if parallel else None
 
         # Progress feedback
         self.progress_total = 0
         self.progress_lock = Lock() if parallel else None
         self.progress_hook = progress_hook
 
@@ -164,26 +173,28 @@
         self.encryptor = encryptor
         self.padder = padder
         self.response_headers = None
         self.etag = None
         self.last_modified = None
         self.request_options = kwargs
 
-    def get_chunk_streams(self):
+    async def get_chunk_streams(self):
         index = 0
         while True:
             data = b''
             read_size = self.chunk_size
 
             # Buffer until we either reach the end of the stream or get a whole chunk.
             while True:
                 if self.total_size:
                     read_size = min(self.chunk_size - len(data), self.total_size - (index + len(data)))
                 temp = self.stream.read(read_size)
-                if not isinstance(temp, six.binary_type):
+                if inspect.isawaitable(temp):
+                    temp = await temp
+                if not isinstance(temp, bytes):
                     raise TypeError('Blob data should be of type bytes.')
                 data += temp or b""
 
                 # We have read an empty string and so are at the end
                 # of the buffer or we have read a full chunk.
                 if temp == b'' or len(data) == self.chunk_size:
                     break
@@ -213,15 +224,15 @@
         if self.progress_lock is not None:
             async with self.progress_lock:
                 self.progress_total += length
         else:
             self.progress_total += length
 
         if self.progress_hook:
-            self.progress_hook(self.progress_total, self.total_size)
+            await self.progress_hook(self.progress_total, self.total_size)
 
     async def _upload_chunk(self, chunk_offset, chunk_data):
         raise NotImplementedError("Must be implemented by child class.")
 
     async def _upload_chunk_with_progress(self, chunk_offset, chunk_data):
         range_id = await self._upload_chunk(chunk_offset, chunk_data)
         await self._update_progress(len(chunk_data))
@@ -266,28 +277,28 @@
     def __init__(self, *args, **kwargs):
         kwargs.pop('modified_access_conditions', None)
         super(BlockBlobChunkUploader, self).__init__(*args, **kwargs)
         self.current_length = None
 
     async def _upload_chunk(self, chunk_offset, chunk_data):
         # TODO: This is incorrect, but works with recording.
-        index = '{0:032d}'.format(chunk_offset)
+        index = f'{chunk_offset:032d}'
         block_id = encode_base64(url_quote(encode_base64(index)))
         await self.service.stage_block(
             block_id,
             len(chunk_data),
             body=chunk_data,
             data_stream_total=self.total_size,
             upload_stream_current=self.progress_total,
             **self.request_options)
         return index, block_id
 
     async def _upload_substream_block(self, index, block_stream):
         try:
-            block_id = 'BlockId{}'.format("%05d" % (index/self.chunk_size))
+            block_id = f'BlockId{"%05d" % (index/self.chunk_size)}'
             await self.service.stage_block(
                 block_id,
                 len(block_stream),
                 block_stream,
                 data_stream_total=self.total_size,
                 upload_stream_current=self.progress_total,
                 **self.request_options)
@@ -306,15 +317,15 @@
                 return False
         return True
 
     async def _upload_chunk(self, chunk_offset, chunk_data):
         # avoid uploading the empty pages
         if not self._is_chunk_empty(chunk_data):
             chunk_end = chunk_offset + len(chunk_data) - 1
-            content_range = 'bytes={0}-{1}'.format(chunk_offset, chunk_end)
+            content_range = f'bytes={chunk_offset}-{chunk_end}'
             computed_md5 = None
             self.response_headers = await self.service.upload_pages(
                 body=chunk_data,
                 content_length=len(chunk_data),
                 transactional_content_md5=computed_md5,
                 range=content_range,
                 cls=return_response_headers,
@@ -400,13 +411,51 @@
             chunk_data,
             chunk_offset,
             length,
             data_stream_total=self.total_size,
             upload_stream_current=self.progress_total,
             **self.request_options
         )
-        range_id = 'bytes={0}-{1}'.format(chunk_offset, chunk_end)
+        range_id = f'bytes={chunk_offset}-{chunk_end}'
         return range_id, response
 
     # TODO: Implement this method.
     async def _upload_substream_block(self, index, block_stream):
         pass
+
+
+class AsyncIterStreamer():
+    """
+    File-like streaming object for AsyncGenerators.
+    """
+    def __init__(self, generator: AsyncGenerator[Union[bytes, str], None], encoding: str = "UTF-8"):
+        self.iterator = generator.__aiter__()
+        self.leftover = b""
+        self.encoding = encoding
+
+    def seekable(self):
+        return False
+
+    def tell(self, *args, **kwargs):
+        raise UnsupportedOperation("Data generator does not support tell.")
+
+    def seek(self, *args, **kwargs):
+        raise UnsupportedOperation("Data generator is not seekable.")
+
+    async def read(self, size: int) -> bytes:
+        data = self.leftover
+        count = len(self.leftover)
+        try:
+            while count < size:
+                chunk = await self.iterator.__anext__()
+                if isinstance(chunk, str):
+                    chunk = chunk.encode(self.encoding)
+                data += chunk
+                count += len(chunk)
+        # This means count < size and what's leftover will be returned in this call.
+        except StopAsyncIteration:
+            self.leftover = b""
+
+        if count >= size:
+            self.leftover = data[size:]
+
+        return data[:size]
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/_shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_queue_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/_queue_client_async.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
-# pylint: disable=invalid-overridden-method
 
 import functools
 from typing import (  # pylint: disable=unused-import
     Union,
     Optional,
     Any,
     IO,
@@ -21,31 +20,30 @@
 
 try:
     from urllib.parse import urlparse, quote, unquote  # pylint: disable=unused-import
 except ImportError:
     from urlparse import urlparse  # type: ignore
     from urllib2 import quote, unquote  # type: ignore
 
-from azure.core.exceptions import HttpResponseError
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 
 from azure.core.async_paging import AsyncItemPaged
 
-from .._serialize import get_api_version
 from .._shared.base_client_async import AsyncStorageAccountHostsMixin
 from .._shared.request_handlers import add_metadata_headers, serialize_iso
 from .._shared.response_handlers import (
     return_response_headers,
     process_storage_error,
     return_headers_and_deserialized,
 )
 from .._deserialize import deserialize_queue_properties, deserialize_queue_creation
+from .._generated.version import VERSION
 from .._generated.aio import AzureQueueStorage
-from .._generated.models import SignedIdentifier
+from .._generated.models import StorageErrorException, SignedIdentifier
 from .._generated.models import QueueMessage as GenQueueMessage
 
 from .._models import QueueMessage, AccessPolicy
 from ._models import MessagesPaged
 from .._shared.policies_async import ExponentialRetry
 from .._queue_client import QueueClient as QueueClientBase
 
@@ -62,26 +60,25 @@
     :param str account_url:
         The URL to the storage account. In order to create a client given the full URI to the queue,
         use the :func:`from_queue_url` classmethod.
     :param queue_name: The name of the queue.
     :type queue_name: str
     :param credential:
         The credentials with which to authenticate. This is optional if the
-        account URL already has a SAS token. The value can be a SAS token string,
-        an instance of a AzureSasCredential from azure.core.credentials, an account
+        account URL already has a SAS token. The value can be a SAS token string, an account
         shared access key, or an instance of a TokenCredentials class from azure.identity.
     :keyword str api_version:
-        The Storage API version to use for requests. Default value is the most recent service version that is
-        compatible with the current SDK. Setting to an older version may result in reduced feature compatibility.
+        The Storage API version to use for requests. Default value is '2019-07-07'.
+        Setting to an older version may result in reduced feature compatibility.
     :keyword str secondary_hostname:
         The hostname of the secondary endpoint.
-    :keyword message_encode_policy: The encoding policy to use on outgoing messages.
+    :keyword encode_policy: The encoding policy to use on outgoing messages.
         Default is not to encode messages. Other options include :class:`TextBase64EncodePolicy`,
         :class:`BinaryBase64EncodePolicy` or `None`.
-    :keyword message_decode_policy: The decoding policy to use on incoming messages.
+    :keyword decode_policy: The decoding policy to use on incoming messages.
         Default value is not to decode messages. Other options include :class:`TextBase64DecodePolicy`,
         :class:`BinaryBase64DecodePolicy` or `None`.
 
     .. admonition:: Example:
 
         .. literalinclude:: ../samples/queue_samples_message_async.py
             :start-after: [START async_create_queue_client]
@@ -107,17 +104,16 @@
     ):
         # type: (...) -> None
         kwargs["retry_policy"] = kwargs.get("retry_policy") or ExponentialRetry(**kwargs)
         loop = kwargs.pop('loop', None)
         super(QueueClient, self).__init__(
             account_url, queue_name=queue_name, credential=credential, loop=loop, **kwargs
         )
-        self._client = AzureQueueStorage(self.url, base_url=self.url,
-                                         pipeline=self._pipeline, loop=loop)  # type: ignore
-        self._client._config.version = get_api_version(kwargs)  # pylint: disable=protected-access
+        self._client = AzureQueueStorage(self.url, pipeline=self._pipeline, loop=loop)  # type: ignore
+        self._client._config.version = kwargs.get('api_version', VERSION)  # pylint: disable=protected-access
         self._loop = loop
 
     @distributed_trace_async
     async def create_queue(self, **kwargs):
         # type: (Optional[Any]) -> None
         """Creates a new queue in the storage account.
 
@@ -147,15 +143,15 @@
         timeout = kwargs.pop('timeout', None)
         headers = kwargs.pop("headers", {})
         headers.update(add_metadata_headers(metadata))  # type: ignore
         try:
             return await self._client.queue.create(  # type: ignore
                 metadata=metadata, timeout=timeout, headers=headers, cls=deserialize_queue_creation, **kwargs
             )
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def delete_queue(self, **kwargs):
         # type: (Optional[Any]) -> None
         """Deletes the specified queue and any messages it contains.
 
@@ -179,15 +175,15 @@
                 :language: python
                 :dedent: 16
                 :caption: Delete a queue.
         """
         timeout = kwargs.pop('timeout', None)
         try:
             await self._client.queue.delete(timeout=timeout, **kwargs)
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def get_queue_properties(self, **kwargs):
         # type: (Optional[Any]) -> QueueProperties
         """Returns all user-defined metadata for the specified queue.
 
@@ -208,15 +204,15 @@
                 :caption: Get the properties on the queue.
         """
         timeout = kwargs.pop('timeout', None)
         try:
             response = await self._client.queue.get_properties(
                 timeout=timeout, cls=deserialize_queue_properties, **kwargs
             )
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
         response.name = self.queue_name
         return response  # type: ignore
 
     @distributed_trace_async
     async def set_queue_metadata(self, metadata=None, **kwargs):
         # type: (Optional[Dict[str, Any]], Optional[Any]) -> None
@@ -243,15 +239,15 @@
         timeout = kwargs.pop('timeout', None)
         headers = kwargs.pop("headers", {})
         headers.update(add_metadata_headers(metadata))  # type: ignore
         try:
             return await self._client.queue.set_metadata(  # type: ignore
                 timeout=timeout, headers=headers, cls=return_response_headers, **kwargs
             )
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def get_queue_access_policy(self, **kwargs):
         # type: (Optional[Any]) -> Dict[str, Any]
         """Returns details about any stored access policies specified on the
         queue that may be used with Shared Access Signatures.
@@ -262,15 +258,15 @@
         :rtype: dict(str, ~azure.storage.queue.AccessPolicy)
         """
         timeout = kwargs.pop('timeout', None)
         try:
             _, identifiers = await self._client.queue.get_access_policy(
                 timeout=timeout, cls=return_headers_and_deserialized, **kwargs
             )
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
         return {s.id: s.access_policy or AccessPolicy() for s in identifiers}
 
     @distributed_trace_async
     async def set_queue_access_policy(self, signed_identifiers, **kwargs):
         # type: (Dict[str, AccessPolicy], Optional[Any]) -> None
         """Sets stored access policies for the queue that may be used with Shared
@@ -315,15 +311,15 @@
             if value:
                 value.start = serialize_iso(value.start)
                 value.expiry = serialize_iso(value.expiry)
             identifiers.append(SignedIdentifier(id=key, access_policy=value))
         signed_identifiers = identifiers  # type: ignore
         try:
             await self._client.queue.set_access_policy(queue_acl=signed_identifiers or None, timeout=timeout, **kwargs)
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def send_message(  # type: ignore
         self,
         content,  # type: Any
         **kwargs  # type: Optional[Any]
@@ -378,125 +374,63 @@
         time_to_live = kwargs.pop('time_to_live', None)
         timeout = kwargs.pop('timeout', None)
         self._config.message_encode_policy.configure(
             require_encryption=self.require_encryption,
             key_encryption_key=self.key_encryption_key,
             resolver=self.key_resolver_function
         )
-        encoded_content = self._config.message_encode_policy(content)
-        new_message = GenQueueMessage(message_text=encoded_content)
+        content = self._config.message_encode_policy(content)
+        new_message = GenQueueMessage(message_text=content)
 
         try:
             enqueued = await self._client.messages.enqueue(
                 queue_message=new_message,
                 visibilitytimeout=visibility_timeout,
                 message_time_to_live=time_to_live,
                 timeout=timeout,
                 **kwargs
             )
-            queue_message = QueueMessage(content=content)
+            queue_message = QueueMessage(content=new_message.message_text)
             queue_message.id = enqueued[0].message_id
             queue_message.inserted_on = enqueued[0].insertion_time
             queue_message.expires_on = enqueued[0].expiration_time
             queue_message.pop_receipt = enqueued[0].pop_receipt
             queue_message.next_visible_on = enqueued[0].time_next_visible
             return queue_message
-        except HttpResponseError as error:
-            process_storage_error(error)
-
-    @distributed_trace_async
-    async def receive_message(self, **kwargs):
-        # type: (Optional[Any]) -> QueueMessage
-        """Removes one message from the front of the queue.
-
-        When the message is retrieved from the queue, the response includes the message
-        content and a pop_receipt value, which is required to delete the message.
-        The message is not automatically deleted from the queue, but after it has
-        been retrieved, it is not visible to other clients for the time interval
-        specified by the visibility_timeout parameter.
-
-        If the key-encryption-key or resolver field is set on the local service object, the message will be
-        decrypted before being returned.
-
-        :keyword int visibility_timeout:
-            If not specified, the default value is 0. Specifies the
-            new visibility timeout value, in seconds, relative to server time.
-            The value must be larger than or equal to 0, and cannot be
-            larger than 7 days. The visibility timeout of a message cannot be
-            set to a value later than the expiry time. visibility_timeout
-            should be set to a value smaller than the time-to-live value.
-        :keyword int timeout:
-            The server timeout, expressed in seconds.
-        :return:
-            Returns a message from the Queue.
-        :rtype: ~azure.storage.queue.QueueMessage
-
-        .. admonition:: Example:
-
-            .. literalinclude:: ../samples/queue_samples_message_async.py
-                :start-after: [START receive_one_message]
-                :end-before: [END receive_one_message]
-                :language: python
-                :dedent: 12
-                :caption: Receive one message from the queue.
-        """
-        visibility_timeout = kwargs.pop('visibility_timeout', None)
-        timeout = kwargs.pop('timeout', None)
-        self._config.message_decode_policy.configure(
-            require_encryption=self.require_encryption,
-            key_encryption_key=self.key_encryption_key,
-            resolver=self.key_resolver_function)
-        try:
-            message = await self._client.messages.dequeue(
-                number_of_messages=1,
-                visibilitytimeout=visibility_timeout,
-                timeout=timeout,
-                cls=self._config.message_decode_policy,
-                **kwargs
-            )
-            wrapped_message = QueueMessage._from_generated(  # pylint: disable=protected-access
-                message[0]) if message != [] else None
-            return wrapped_message
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace
     def receive_messages(self, **kwargs):
         # type: (Optional[Any]) -> AsyncItemPaged[QueueMessage]
         """Removes one or more messages from the front of the queue.
 
         When a message is retrieved from the queue, the response includes the message
         content and a pop_receipt value, which is required to delete the message.
         The message is not automatically deleted from the queue, but after it has
         been retrieved, it is not visible to other clients for the time interval
-        specified by the visibility_timeout parameter. The iterator will continuously
-        fetch messages until the queue is empty or max_messages is reached (if max_messages
-        is set).
+        specified by the visibility_timeout parameter.
 
         If the key-encryption-key or resolver field is set on the local service object, the messages will be
         decrypted before being returned.
 
         :keyword int messages_per_page:
             A nonzero integer value that specifies the number of
             messages to retrieve from the queue, up to a maximum of 32. If
             fewer are visible, the visible messages are returned. By default,
             a single message is retrieved from the queue with this operation.
-            `by_page()` can be used to provide a page iterator on the AsyncItemPaged if messages_per_page is set.
-            `next()` can be used to get the next page.
         :keyword int visibility_timeout:
-            If not specified, the default value is 30. Specifies the
+            If not specified, the default value is 0. Specifies the
             new visibility timeout value, in seconds, relative to server time.
-            The value must be larger than or equal to 1, and cannot be
+            The value must be larger than or equal to 0, and cannot be
             larger than 7 days. The visibility timeout of a message cannot be
             set to a value later than the expiry time. visibility_timeout
             should be set to a value smaller than the time-to-live value.
         :keyword int timeout:
             The server timeout, expressed in seconds.
-        :keyword int max_messages:
-            An integer that specifies the maximum number of messages to retrieve from the queue.
         :return:
             Returns a message iterator of dict-like Message objects.
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.storage.queue.QueueMessage]
 
         .. admonition:: Example:
 
             .. literalinclude:: ../samples/queue_samples_message_async.py
@@ -505,34 +439,29 @@
                 :language: python
                 :dedent: 16
                 :caption: Receive messages from the queue.
         """
         messages_per_page = kwargs.pop('messages_per_page', None)
         visibility_timeout = kwargs.pop('visibility_timeout', None)
         timeout = kwargs.pop('timeout', None)
-        max_messages = kwargs.pop('max_messages', None)
         self._config.message_decode_policy.configure(
             require_encryption=self.require_encryption,
             key_encryption_key=self.key_encryption_key,
             resolver=self.key_resolver_function
         )
         try:
             command = functools.partial(
                 self._client.messages.dequeue,
                 visibilitytimeout=visibility_timeout,
                 timeout=timeout,
                 cls=self._config.message_decode_policy,
                 **kwargs
             )
-            if max_messages is not None and messages_per_page is not None:
-                if max_messages < messages_per_page:
-                    raise ValueError("max_messages must be greater or equal to messages_per_page")
-            return AsyncItemPaged(command, results_per_page=messages_per_page,
-                                  page_iterator_class=MessagesPaged, max_messages=max_messages)
-        except HttpResponseError as error:
+            return AsyncItemPaged(command, results_per_page=messages_per_page, page_iterator_class=MessagesPaged)
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def update_message(
         self,
         message,
         pop_receipt=None,
@@ -605,16 +534,16 @@
 
         if receipt is None:
             raise ValueError("pop_receipt must be present")
         if message_text is not None:
             self._config.message_encode_policy.configure(
                 self.require_encryption, self.key_encryption_key, self.key_resolver_function
             )
-            encoded_message_text = self._config.message_encode_policy(message_text)
-            updated = GenQueueMessage(message_text=encoded_message_text)
+            message_text = self._config.message_encode_policy(message_text)
+            updated = GenQueueMessage(message_text=message_text)
         else:
             updated = None  # type: ignore
         try:
             response = await self._client.message_id.update(
                 queue_message=updated,
                 visibilitytimeout=visibility_timeout or 0,
                 timeout=timeout,
@@ -627,15 +556,15 @@
             new_message.id = message_id
             new_message.inserted_on = inserted_on
             new_message.expires_on = expires_on
             new_message.dequeue_count = dequeue_count
             new_message.pop_receipt = response["popreceipt"]
             new_message.next_visible_on = response["time_next_visible"]
             return new_message
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def peek_messages(self, max_messages=None, **kwargs):
         # type: (Optional[int], Optional[Any]) -> List[QueueMessage]
         """Retrieves one or more messages from the front of the queue, but does
         not alter the visibility of the message.
@@ -684,15 +613,15 @@
             messages = await self._client.messages.peek(
                 number_of_messages=max_messages, timeout=timeout, cls=self._config.message_decode_policy, **kwargs
             )
             wrapped_messages = []
             for peeked in messages:
                 wrapped_messages.append(QueueMessage._from_generated(peeked))  # pylint: disable=protected-access
             return wrapped_messages
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def clear_messages(self, **kwargs):
         # type: (Optional[Any]) -> None
         """Deletes all messages from the specified queue.
 
@@ -707,15 +636,15 @@
                 :language: python
                 :dedent: 16
                 :caption: Clears all messages.
         """
         timeout = kwargs.pop('timeout', None)
         try:
             await self._client.messages.clear(timeout=timeout, **kwargs)
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def delete_message(self, message, pop_receipt=None, **kwargs):
         # type: (Any, Optional[str], Any) -> None
         """Deletes the specified message.
 
@@ -757,9 +686,9 @@
 
         if receipt is None:
             raise ValueError("pop_receipt must be present")
         try:
             await self._client.message_id.delete(
                 pop_receipt=receipt, timeout=timeout, queue_message_id=message_id, **kwargs
             )
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2018_03_28/aio/_queue_service_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/_queue_service_client_async.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,37 +1,35 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
-# pylint: disable=invalid-overridden-method
 
 import functools
 from typing import (  # pylint: disable=unused-import
     Union, Optional, Any, Iterable, Dict, List,
     TYPE_CHECKING)
 try:
     from urllib.parse import urlparse # pylint: disable=unused-import
 except ImportError:
     from urlparse import urlparse # type: ignore
 
-from azure.core.exceptions import HttpResponseError
 from azure.core.async_paging import AsyncItemPaged
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.pipeline import AsyncPipeline
 from azure.core.tracing.decorator_async import distributed_trace_async
 
-from .._serialize import get_api_version
 from .._shared.policies_async import ExponentialRetry
 from .._queue_service_client import QueueServiceClient as QueueServiceClientBase
 from .._shared.models import LocationMode
 from .._shared.base_client_async import AsyncStorageAccountHostsMixin, AsyncTransportWrapper
 from .._shared.response_handlers import process_storage_error
+from .._generated.version import VERSION
 from .._generated.aio import AzureQueueStorage
-from .._generated.models import StorageServiceProperties
+from .._generated.models import StorageServiceProperties, StorageErrorException
 
 from ._models import QueuePropertiesPaged
 from ._queue_client_async import QueueClient
 from .._models import (
     service_stats_deserialize,
     service_properties_deserialize,
 )
@@ -58,20 +56,19 @@
 
     :param str account_url:
         The URL to the queue service endpoint. Any other entities included
         in the URL path (e.g. queue) will be discarded. This URL can be optionally
         authenticated with a SAS token.
     :param credential:
         The credentials with which to authenticate. This is optional if the
-        account URL already has a SAS token. The value can be a SAS token string,
-        an instance of a AzureSasCredential from azure.core.credentials, an account
+        account URL already has a SAS token. The value can be a SAS token string, an account
         shared access key, or an instance of a TokenCredentials class from azure.identity.
     :keyword str api_version:
-        The Storage API version to use for requests. Default value is the most recent service version that is
-        compatible with the current SDK. Setting to an older version may result in reduced feature compatibility.
+        The Storage API version to use for requests. Default value is '2019-07-07'.
+        Setting to an older version may result in reduced feature compatibility.
     :keyword str secondary_hostname:
         The hostname of the secondary endpoint.
 
     .. admonition:: Example:
 
         .. literalinclude:: ../samples/queue_samples_authentication_async.py
             :start-after: [START async_create_queue_service_client]
@@ -97,16 +94,16 @@
         kwargs['retry_policy'] = kwargs.get('retry_policy') or ExponentialRetry(**kwargs)
         loop = kwargs.pop('loop', None)
         super(QueueServiceClient, self).__init__( # type: ignore
             account_url,
             credential=credential,
             loop=loop,
             **kwargs)
-        self._client = AzureQueueStorage(self.url, base_url=self.url, pipeline=self._pipeline, loop=loop) # type: ignore
-        self._client._config.version = get_api_version(kwargs)  # pylint: disable=protected-access
+        self._client = AzureQueueStorage(url=self.url, pipeline=self._pipeline, loop=loop) # type: ignore
+        self._client._config.version = kwargs.get('api_version', VERSION)  # pylint: disable=protected-access
         self._loop = loop
 
     @distributed_trace_async
     async def get_service_stats(self, **kwargs):
         # type: (Optional[Any]) -> Dict[str, Any]
         """Retrieves statistics related to replication for the Queue service.
 
@@ -132,15 +129,15 @@
         :rtype: Dict[str, Any]
         """
         timeout = kwargs.pop('timeout', None)
         try:
             stats = await self._client.service.get_statistics( # type: ignore
                 timeout=timeout, use_location=LocationMode.SECONDARY, **kwargs)
             return service_stats_deserialize(stats)
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def get_service_properties(self, **kwargs):
         # type: (Optional[Any]) -> Dict[str, Any]
         """Gets the properties of a storage account's Queue service, including
         Azure Storage Analytics.
@@ -160,15 +157,15 @@
                 :dedent: 12
                 :caption: Getting queue service properties.
         """
         timeout = kwargs.pop('timeout', None)
         try:
             service_props = await self._client.service.get_properties(timeout=timeout, **kwargs) # type: ignore
             return service_properties_deserialize(service_props)
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace_async
     async def set_service_properties( # type: ignore
             self, analytics_logging=None,  # type: Optional[QueueAnalyticsLogging]
             hour_metrics=None,  # type: Optional[Metrics]
             minute_metrics=None,  # type: Optional[Metrics]
@@ -216,15 +213,15 @@
             logging=analytics_logging,
             hour_metrics=hour_metrics,
             minute_metrics=minute_metrics,
             cors=cors
         )
         try:
             return await self._client.service.set_properties(props, timeout=timeout, **kwargs) # type: ignore
-        except HttpResponseError as error:
+        except StorageErrorException as error:
             process_storage_error(error)
 
     @distributed_trace
     def list_queues(
             self, name_starts_with=None,  # type: Optional[str]
             include_metadata=False,  # type: Optional[bool]
             **kwargs
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_deserialize.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_deserialize.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/_azure_queue_storage.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/_azure_queue_storage.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/_azure_queue_storage_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/_azure_queue_storage_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_message_id_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_message_id_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_messages_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_messages_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_queue_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_queue_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/aio/operations_async/_service_operations_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_azure_queue_storage_enums.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_azure_queue_storage_enums.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_models_py3.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/models/_models_py3.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_message_id_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_message_id_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_messages_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_messages_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_queue_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_queue_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_service_operations.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_generated/operations/_service_operations.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_message_encoding.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_message_encoding.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_queue_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_queue_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_queue_service_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_queue_service_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/__init__.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,48 +9,46 @@
 import hmac
 
 try:
     from urllib.parse import quote, unquote
 except ImportError:
     from urllib2 import quote, unquote # type: ignore
 
-import six
-
 
 def url_quote(url):
     return quote(url)
 
 
 def url_unquote(url):
     return unquote(url)
 
 
 def encode_base64(data):
-    if isinstance(data, six.text_type):
+    if isinstance(data, str):
         data = data.encode('utf-8')
     encoded = base64.b64encode(data)
     return encoded.decode('utf-8')
 
 
 def decode_base64_to_bytes(data):
-    if isinstance(data, six.text_type):
+    if isinstance(data, str):
         data = data.encode('utf-8')
     return base64.b64decode(data)
 
 
 def decode_base64_to_text(data):
     decoded_bytes = decode_base64_to_bytes(data)
     return decoded_bytes.decode('utf-8')
 
 
 def sign_string(key, string_to_sign, key_is_base64=True):
     if key_is_base64:
         key = decode_base64_to_bytes(key)
     else:
-        if isinstance(key, six.text_type):
+        if isinstance(key, str):
             key = key.encode('utf-8')
-    if isinstance(string_to_sign, six.text_type):
+    if isinstance(string_to_sign, str):
         string_to_sign = string_to_sign.encode('utf-8')
     signed_hmac_sha256 = hmac.HMAC(key, string_to_sign, hashlib.sha256)
     digest = signed_hmac_sha256.digest()
     encoded_digest = encode_base64(digest)
     return encoded_digest
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/base_client.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/base_client.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/base_client_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/base_client_async.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,39 +5,41 @@
 # --------------------------------------------------------------------------
 
 from typing import (  # pylint: disable=unused-import
     Union, Optional, Any, Iterable, Dict, List, Type, Tuple,
     TYPE_CHECKING
 )
 import logging
+
+from azure.core.credentials import AzureSasCredential
 from azure.core.pipeline import AsyncPipeline
 from azure.core.async_paging import AsyncList
 from azure.core.exceptions import HttpResponseError
 from azure.core.pipeline.policies import (
-    ContentDecodePolicy,
     AsyncBearerTokenCredentialPolicy,
     AsyncRedirectPolicy,
+    AzureSasCredentialPolicy,
+    ContentDecodePolicy,
     DistributedTracingPolicy,
     HttpLoggingPolicy,
 )
 from azure.core.pipeline.transport import AsyncHttpTransport
 
-from .constants import STORAGE_OAUTH_SCOPE, CONNECTION_TIMEOUT, READ_TIMEOUT
+from .constants import CONNECTION_TIMEOUT, READ_TIMEOUT, STORAGE_OAUTH_SCOPE
 from .authentication import SharedKeyCredentialPolicy
 from .base_client import create_configuration
 from .policies import (
+    QueueMessagePolicy,
     StorageContentValidation,
-    StorageRequestHook,
-    StorageHosts,
     StorageHeadersPolicy,
-    QueueMessagePolicy
+    StorageHosts,
+    StorageRequestHook,
 )
 from .policies_async import AsyncStorageResponseHook
 
-from .._generated.models import StorageErrorException
 from .response_handlers import process_storage_error, PartialBatchErrorException
 
 if TYPE_CHECKING:
     from azure.core.pipeline import Pipeline
     from azure.core.pipeline.transport import HttpRequest
     from azure.core.configuration import Configuration
 _LOGGER = logging.getLogger(__name__)
@@ -67,16 +69,18 @@
     def _create_pipeline(self, credential, **kwargs):
         # type: (Any, **Any) -> Tuple[Configuration, Pipeline]
         self._credential_policy = None
         if hasattr(credential, 'get_token'):
             self._credential_policy = AsyncBearerTokenCredentialPolicy(credential, STORAGE_OAUTH_SCOPE)
         elif isinstance(credential, SharedKeyCredentialPolicy):
             self._credential_policy = credential
+        elif isinstance(credential, AzureSasCredential):
+            self._credential_policy = AzureSasCredentialPolicy(credential)
         elif credential is not None:
-            raise TypeError("Unsupported credential: {}".format(credential))
+            raise TypeError(f"Unsupported credential: {credential}")
         config = kwargs.get('_configuration') or create_configuration(**kwargs)
         if kwargs.get('_pipeline'):
             return config, kwargs['_pipeline']
         config.transport = kwargs.get('transport')  # type: ignore
         kwargs.setdefault("connection_timeout", CONNECTION_TIMEOUT)
         kwargs.setdefault("read_timeout", READ_TIMEOUT)
         if not config.transport:
@@ -98,37 +102,46 @@
             StorageHosts(hosts=self._hosts, **kwargs), # type: ignore
             config.retry_policy,
             config.logging_policy,
             AsyncStorageResponseHook(**kwargs),
             DistributedTracingPolicy(**kwargs),
             HttpLoggingPolicy(**kwargs),
         ]
+        if kwargs.get("_additional_pipeline_policies"):
+            policies = policies + kwargs.get("_additional_pipeline_policies")
         return config, AsyncPipeline(config.transport, policies=policies)
 
     async def _batch_send(
-        self, *reqs: 'HttpRequest',
+        self,
+        *reqs,  # type: HttpRequest
         **kwargs
     ):
         """Given a series of request, do a Storage batch call.
         """
         # Pop it here, so requests doesn't feel bad about additional kwarg
         raise_on_any_failure = kwargs.pop("raise_on_any_failure", True)
         request = self._client._client.post(  # pylint: disable=protected-access
-            url='https://{}/?comp=batch'.format(self.primary_hostname),
+            url=(
+                f'{self.scheme}://{self.primary_hostname}/'
+                f"{kwargs.pop('path', '')}?{kwargs.pop('restype', '')}"
+                f"comp=batch{kwargs.pop('sas', '')}{kwargs.pop('timeout', '')}"
+            ),
             headers={
                 'x-ms-version': self.api_version
             }
         )
 
+        policies = [StorageHeadersPolicy()]
+        if self._credential_policy:
+            policies.append(self._credential_policy)
+
         request.set_multipart_mixed(
             *reqs,
-            policies=[
-                StorageHeadersPolicy(),
-                self._credential_policy
-            ]
+            policies=policies,
+            enforce_https=False
         )
 
         pipeline_response = await self._pipeline.run(
             request, **kwargs
         )
         response = pipeline_response.http_response
 
@@ -144,15 +157,15 @@
                     error = PartialBatchErrorException(
                         message="There is a partial failure in the batch operation.",
                         response=response, parts=parts_list
                     )
                     raise error
                 return AsyncList(parts_list)
             return parts
-        except StorageErrorException as error:
+        except HttpResponseError as error:
             process_storage_error(error)
 
 
 class AsyncTransportWrapper(AsyncHttpTransport):
     """Wrapper class that ensures that an inner client created
     by a `get_client` method does not close the outer transport for the parent
     when used in a context manager.
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/constants.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/constants.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/policies.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/policies.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/policies_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/policies_async.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,24 +1,28 @@
 # -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
 # --------------------------------------------------------------------------
+# pylint: disable=invalid-overridden-method
 
 import asyncio
 import random
 import logging
 from typing import Any, TYPE_CHECKING
 
-from azure.core.pipeline.policies import AsyncHTTPPolicy
+from azure.core.pipeline.policies import AsyncBearerTokenCredentialPolicy, AsyncHTTPPolicy
 from azure.core.exceptions import AzureError
 
+from .authentication import StorageHttpChallenge
+from .constants import DEFAULT_OAUTH_SCOPE, STORAGE_OAUTH_SCOPE
 from .policies import is_retry, StorageRetryPolicy
 
 if TYPE_CHECKING:
+    from azure.core.credentials_async import AsyncTokenCredential
     from azure.core.pipeline import PipelineRequest, PipelineResponse
 
 
 _LOGGER = logging.getLogger(__name__)
 
 
 async def retry_hook(settings, **kwargs):
@@ -39,36 +43,45 @@
 
     def __init__(self, **kwargs):  # pylint: disable=unused-argument
         self._response_callback = kwargs.get('raw_response_hook')
         super(AsyncStorageResponseHook, self).__init__()
 
     async def send(self, request):
         # type: (PipelineRequest) -> PipelineResponse
-        data_stream_total = request.context.get('data_stream_total') or \
-            request.context.options.pop('data_stream_total', None)
-        download_stream_current = request.context.get('download_stream_current') or \
-            request.context.options.pop('download_stream_current', None)
-        upload_stream_current = request.context.get('upload_stream_current') or \
-            request.context.options.pop('upload_stream_current', None)
+        # Values could be 0
+        data_stream_total = request.context.get('data_stream_total')
+        if data_stream_total is None:
+            data_stream_total = request.context.options.pop('data_stream_total', None)
+        download_stream_current = request.context.get('download_stream_current')
+        if download_stream_current is None:
+            download_stream_current = request.context.options.pop('download_stream_current', None)
+        upload_stream_current = request.context.get('upload_stream_current')
+        if upload_stream_current is None:
+            upload_stream_current = request.context.options.pop('upload_stream_current', None)
+
         response_callback = request.context.get('response_callback') or \
             request.context.options.pop('raw_response_hook', self._response_callback)
 
         response = await self.next.send(request)
         await response.http_response.load_body()
 
         will_retry = is_retry(response, request.context.options.get('mode'))
-        if not will_retry and download_stream_current is not None:
+        # Auth error could come from Bearer challenge, in which case this request will be made again
+        is_auth_error = response.http_response.status_code == 401
+        should_update_counts = not (will_retry or is_auth_error)
+
+        if should_update_counts and download_stream_current is not None:
             download_stream_current += int(response.http_response.headers.get('Content-Length', 0))
             if data_stream_total is None:
                 content_range = response.http_response.headers.get('Content-Range')
                 if content_range:
                     data_stream_total = int(content_range.split(' ', 1)[1].split('/', 1)[1])
                 else:
                     data_stream_total = download_stream_current
-        elif not will_retry and upload_stream_current is not None:
+        elif should_update_counts and upload_stream_current is not None:
             upload_stream_current += int(response.http_request.headers.get('Content-Length', 0))
         for pipeline_obj in [request, response]:
             pipeline_obj.context['data_stream_total'] = data_stream_total
             pipeline_obj.context['download_stream_current'] = download_stream_current
             pipeline_obj.context['upload_stream_current'] = upload_stream_current
         if response_callback:
             if asyncio.iscoroutine(response_callback):
@@ -213,7 +226,28 @@
         random_generator = random.Random()
         # the backoff interval normally does not change, however there is the possibility
         # that it was modified by accessing the property directly after initializing the object
         random_range_start = self.backoff - self.random_jitter_range \
             if self.backoff > self.random_jitter_range else 0
         random_range_end = self.backoff + self.random_jitter_range
         return random_generator.uniform(random_range_start, random_range_end)
+
+
+class AsyncStorageBearerTokenCredentialPolicy(AsyncBearerTokenCredentialPolicy):
+    """ Custom Bearer token credential policy for following Storage Bearer challenges """
+
+    def __init__(self, credential, **kwargs):
+        # type: (AsyncTokenCredential, **Any) -> None
+        super(AsyncStorageBearerTokenCredentialPolicy, self).__init__(credential, STORAGE_OAUTH_SCOPE, **kwargs)
+
+    async def on_challenge(self, request, response):
+        # type: (PipelineRequest, PipelineResponse) -> bool
+        try:
+            auth_header = response.http_response.headers.get("WWW-Authenticate")
+            challenge = StorageHttpChallenge(auth_header)
+        except ValueError:
+            return False
+
+        scope = challenge.resource_id + DEFAULT_OAUTH_SCOPE
+        await self.authorize_request(request, scope, tenant_id=challenge.tenant_id)
+
+        return True
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/request_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/request_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/response_handlers.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/response_handlers.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/shared_access_signature.py`

 * *Files 7% similar despite different names*

```diff
@@ -6,15 +6,16 @@
 
 from datetime import date
 
 from .parser import _str, _to_utc_datetime
 from .constants import X_MS_VERSION
 from . import sign_string, url_quote
 
-
+# cspell:ignoreRegExp rsc.
+# cspell:ignoreRegExp s..?id
 class QueryStringConstants(object):
     SIGNED_SIGNATURE = 'sig'
     SIGNED_PERMISSION = 'sp'
     SIGNED_START = 'st'
     SIGNED_EXPIRY = 'se'
     SIGNED_RESOURCE = 'sr'
     SIGNED_IDENTIFIER = 'si'
@@ -35,14 +36,20 @@
     SIGNED_OID = 'skoid'
     SIGNED_TID = 'sktid'
     SIGNED_KEY_START = 'skt'
     SIGNED_KEY_EXPIRY = 'ske'
     SIGNED_KEY_SERVICE = 'sks'
     SIGNED_KEY_VERSION = 'skv'
 
+    # for ADLS
+    SIGNED_AUTHORIZED_OID = 'saoid'
+    SIGNED_UNAUTHORIZED_OID = 'suoid'
+    SIGNED_CORRELATION_ID = 'scid'
+    SIGNED_DIRECTORY_DEPTH = 'sdd'
+
     @staticmethod
     def to_list():
         return [
             QueryStringConstants.SIGNED_SIGNATURE,
             QueryStringConstants.SIGNED_PERMISSION,
             QueryStringConstants.SIGNED_START,
             QueryStringConstants.SIGNED_EXPIRY,
@@ -64,14 +71,19 @@
             QueryStringConstants.SIGNED_SERVICES,
             QueryStringConstants.SIGNED_OID,
             QueryStringConstants.SIGNED_TID,
             QueryStringConstants.SIGNED_KEY_START,
             QueryStringConstants.SIGNED_KEY_EXPIRY,
             QueryStringConstants.SIGNED_KEY_SERVICE,
             QueryStringConstants.SIGNED_KEY_VERSION,
+            # for ADLS
+            QueryStringConstants.SIGNED_AUTHORIZED_OID,
+            QueryStringConstants.SIGNED_UNAUTHORIZED_OID,
+            QueryStringConstants.SIGNED_CORRELATION_ID,
+            QueryStringConstants.SIGNED_DIRECTORY_DEPTH,
         ]
 
 
 class SharedAccessSignature(object):
     '''
     Provides a factory for creating account access
     signature tokens with an account name and account key. Users can either
@@ -196,14 +208,16 @@
              get_value_to_append(QueryStringConstants.SIGNED_PERMISSION) +
              get_value_to_append(QueryStringConstants.SIGNED_SERVICES) +
              get_value_to_append(QueryStringConstants.SIGNED_RESOURCE_TYPES) +
              get_value_to_append(QueryStringConstants.SIGNED_START) +
              get_value_to_append(QueryStringConstants.SIGNED_EXPIRY) +
              get_value_to_append(QueryStringConstants.SIGNED_IP) +
              get_value_to_append(QueryStringConstants.SIGNED_PROTOCOL) +
-             get_value_to_append(QueryStringConstants.SIGNED_VERSION))
+             get_value_to_append(QueryStringConstants.SIGNED_VERSION) +
+             '\n'   # Signed Encryption Scope - always empty for fileshare
+             )
 
         self._add_query(QueryStringConstants.SIGNED_SIGNATURE,
                         sign_string(account_key, string_to_sign))
 
     def get_token(self):
-        return '&'.join(['{0}={1}'.format(n, url_quote(v)) for n, v in self.query_dict.items() if v is not None])
+        return '&'.join([f'{n}={url_quote(v)}' for n, v in self.query_dict.items() if v is not None])
```

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/uploads.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/uploads.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/uploads_async.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared/uploads_async.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared_access_signature.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/_shared_access_signature.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/_models.py` & `azure-multiapi-storage-1.1.0/azure/multiapi/storagev2/queue/v2019_07_07/aio/_models.py`

 * *Files identical despite different names*

### Comparing `azure-multiapi-storage-1.0.0/azure_multiapi_storage.egg-info/PKG-INFO` & `azure-multiapi-storage-1.1.0/azure_multiapi_storage.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-multiapi-storage
-Version: 1.0.0
+Version: 1.1.0
 Summary: Microsoft Azure Storage Client Library for Python with multi API version support.
 Home-page: https://github.com/Azure/azure-multiapi-storage-python
 Author: Microsoft Corporation
 Author-email: azpycli@microsoft.com
 License: MIT
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python
@@ -35,14 +35,18 @@
 
 - The official Azure CosmosDB Table SDK is at https://github.com/Azure/azure-cosmosdb-python/tree/master/azure-cosmosdb-table.
 
 - **Please file issues at the appropriate repository above.**
 
 Change Log
 ----------
+1.1.0
+++++++
+* fileshare: Support v2022-11-02(12.12.0b1) and remove v2021-06-08
+
 1.0.0
 ++++++
 * storageV1:
     - Keep only v2018-11-09, v2017-11-09, v2017-04-17, v2015-04-05
 * blob:
     - Keep only v2021-08-06, v2021-06-08, v2019-07-07
 * fileshare:
```

### Comparing `azure-multiapi-storage-1.0.0/azure_multiapi_storage.egg-info/SOURCES.txt` & `azure-multiapi-storage-1.1.0/azure_multiapi_storage.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -614,77 +614,75 @@
 azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_directory_client_async.py
 azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_download_async.py
 azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_file_client_async.py
 azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_lease_async.py
 azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_models.py
 azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_share_client_async.py
 azure/multiapi/storagev2/fileshare/v2019_07_07/aio/_share_service_client_async.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/__init__.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_deserialize.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_directory_client.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_download.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_file_client.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_lease.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_models.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_parser.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_serialize.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_share_client.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_share_service_client.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared_access_signature.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_version.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/__init__.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_azure_file_storage.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_configuration.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_patch.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_serialization.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/_vendor.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/__init__.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/_azure_file_storage.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/_configuration.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/_patch.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/__init__.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_directory_operations.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_file_operations.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_patch.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_service_operations.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/aio/operations/_share_operations.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/__init__.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_azure_file_storage_enums.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_models.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_models_py3.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/models/_patch.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/__init__.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_directory_operations.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_file_operations.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_patch.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_service_operations.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_generated/operations/_share_operations.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/__init__.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/authentication.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/base_client.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/base_client_async.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/constants.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/encryption.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/models.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/parser.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/policies.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/policies_async.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/request_handlers.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/response_handlers.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/shared_access_signature.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/uploads.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/_shared/uploads_async.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/aio/__init__.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_directory_client_async.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_download_async.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_file_client_async.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_lease_async.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_models.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_share_client_async.py
-azure/multiapi/storagev2/fileshare/v2021_06_08/aio/_share_service_client_async.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/__init__.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_deserialize.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_directory_client.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_download.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_file_client.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_lease.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_models.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_parser.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_serialize.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_share_client.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_share_service_client.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared_access_signature.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_version.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/__init__.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_azure_file_storage.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_configuration.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_patch.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_serialization.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/_vendor.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/__init__.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/_azure_file_storage.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/_configuration.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/_patch.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/__init__.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_directory_operations.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_file_operations.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_patch.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_service_operations.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/aio/operations/_share_operations.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/__init__.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/_azure_file_storage_enums.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/_models_py3.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/models/_patch.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/__init__.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_directory_operations.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_file_operations.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_patch.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_service_operations.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_generated/operations/_share_operations.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/__init__.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/authentication.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/base_client.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/base_client_async.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/constants.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/models.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/parser.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/policies.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/policies_async.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/request_handlers.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/response_handlers.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/shared_access_signature.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/uploads.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/_shared/uploads_async.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/aio/__init__.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_directory_client_async.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_download_async.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_file_client_async.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_lease_async.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_models.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_share_client_async.py
+azure/multiapi/storagev2/fileshare/v2022_11_02/aio/_share_service_client_async.py
 azure/multiapi/storagev2/queue/__init__.py
 azure/multiapi/storagev2/queue/v2018_03_28/__init__.py
 azure/multiapi/storagev2/queue/v2018_03_28/_deserialize.py
 azure/multiapi/storagev2/queue/v2018_03_28/_message_encoding.py
 azure/multiapi/storagev2/queue/v2018_03_28/_models.py
 azure/multiapi/storagev2/queue/v2018_03_28/_queue_client.py
 azure/multiapi/storagev2/queue/v2018_03_28/_queue_service_client.py
```

### Comparing `azure-multiapi-storage-1.0.0/setup.py` & `azure-multiapi-storage-1.1.0/setup.py`

 * *Files 0% similar despite different names*

```diff
@@ -31,15 +31,15 @@
     except AttributeError:
         pass
 except ImportError:
     pass
 
 setup(
     name='azure-multiapi-storage',
-    version='1.0.0',
+    version='1.1.0',
     description='Microsoft Azure Storage Client Library for Python with multi API version support.',
     long_description=open('README.rst', 'r').read(),
     license='MIT',
     author='Microsoft Corporation',
     author_email='azpycli@microsoft.com',
     url='https://github.com/Azure/azure-multiapi-storage-python',
     classifiers=[
```

