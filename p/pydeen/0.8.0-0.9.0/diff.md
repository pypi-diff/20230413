# Comparing `tmp/pydeen-0.8.0-py3-none-any.whl.zip` & `tmp/pydeen-0.9.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,27 +1,28 @@
-Zip file size: 41861 bytes, number of entries: 25
--rw-rw-rw-  2.0 fat     1265 b- defN 22-Sep-08 16:07 pydeen/__init__.py
+Zip file size: 47141 bytes, number of entries: 26
+-rw-rw-rw-  2.0 fat     1186 b- defN 22-Oct-05 05:30 pydeen/__init__.py
 -rw-rw-rw-  2.0 fat    11067 b- defN 22-Sep-08 13:00 pydeen/auth.py
 -rw-rw-rw-  2.0 fat    11503 b- defN 22-Sep-07 07:35 pydeen/cloudevents.py
 -rw-rw-rw-  2.0 fat      228 b- defN 22-Jun-10 02:10 pydeen/const.py
--rw-rw-rw-  2.0 fat     2347 b- defN 22-Sep-08 15:57 pydeen/core.py
+-rw-rw-rw-  2.0 fat     2405 b- defN 22-Sep-10 16:09 pydeen/core.py
+-rw-rw-rw-  2.0 fat      899 b- defN 22-Sep-23 00:53 pydeen/exits.py
 -rw-rw-rw-  2.0 fat      596 b- defN 22-Jun-10 01:43 pydeen/files.py
 -rw-rw-rw-  2.0 fat       34 b- defN 22-Sep-08 16:10 pydeen/globals.py
--rw-rw-rw-  2.0 fat     8038 b- defN 22-Aug-22 07:00 pydeen/http.py
--rw-rw-rw-  2.0 fat     7115 b- defN 22-Sep-08 13:06 pydeen/menu.py
+-rw-rw-rw-  2.0 fat     9407 b- defN 22-Sep-30 08:46 pydeen/http.py
+-rw-rw-rw-  2.0 fat     7811 b- defN 22-Sep-23 11:42 pydeen/menu.py
 -rw-rw-rw-  2.0 fat     9941 b- defN 22-Aug-22 07:01 pydeen/odata.py
--rw-rw-rw-  2.0 fat     4665 b- defN 22-Sep-08 16:52 pydeen/pandas.py
+-rw-rw-rw-  2.0 fat     9962 b- defN 22-Sep-30 06:23 pydeen/pandas.py
 -rw-rw-rw-  2.0 fat     3010 b- defN 22-Jul-20 15:47 pydeen/pyodata.py
--rw-rw-rw-  2.0 fat    34924 b- defN 22-Sep-08 16:22 pydeen/sap_abap.py
--rw-rw-rw-  2.0 fat    11181 b- defN 22-Aug-22 07:02 pydeen/sap_deeb.py
+-rw-rw-rw-  2.0 fat    34932 b- defN 22-Sep-23 01:26 pydeen/sap_abap.py
+-rw-rw-rw-  2.0 fat    22616 b- defN 22-Sep-30 13:57 pydeen/sap_deeb.py
 -rw-rw-rw-  2.0 fat      966 b- defN 22-Jul-21 06:56 pydeen/sap_nwod.py
 -rw-rw-rw-  2.0 fat    11116 b- defN 22-Aug-22 07:02 pydeen/service.py
--rw-rw-rw-  2.0 fat    30551 b- defN 22-Sep-08 16:52 pydeen/types.py
--rw-rw-rw-  2.0 fat     5854 b- defN 22-Sep-08 06:48 pydeen/utils.py
--rw-rw-rw-  2.0 fat     5100 b- defN 22-Sep-07 09:23 pydeen/websocket.py
+-rw-rw-rw-  2.0 fat    33694 b- defN 22-Sep-30 07:28 pydeen/types.py
+-rw-rw-rw-  2.0 fat     7601 b- defN 22-Sep-25 03:31 pydeen/utils.py
+-rw-rw-rw-  2.0 fat     5380 b- defN 22-Sep-08 20:45 pydeen/websocket.py
 -rw-rw-rw-  2.0 fat     4919 b- defN 22-Jun-30 21:01 pydeen/wsocket.py
--rw-rw-rw-  2.0 fat     1085 b- defN 22-Sep-08 16:55 pydeen-0.8.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     2950 b- defN 22-Sep-08 16:55 pydeen-0.8.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 22-Sep-08 16:55 pydeen-0.8.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 22-Sep-08 16:55 pydeen-0.8.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1848 b- defN 22-Sep-08 16:55 pydeen-0.8.0.dist-info/RECORD
-25 files, 170402 bytes uncompressed, 38977 bytes compressed:  77.1%
+-rw-rw-rw-  2.0 fat     1085 b- defN 22-Oct-05 05:30 pydeen-0.9.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     3150 b- defN 22-Oct-05 05:30 pydeen-0.9.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 22-Oct-05 05:30 pydeen-0.9.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 22-Oct-05 05:30 pydeen-0.9.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     1919 b- defN 22-Oct-05 05:30 pydeen-0.9.0.dist-info/RECORD
+26 files, 195526 bytes uncompressed, 44151 bytes compressed:  77.4%
```

## zipnote {}

```diff
@@ -9,14 +9,17 @@
 
 Filename: pydeen/const.py
 Comment: 
 
 Filename: pydeen/core.py
 Comment: 
 
+Filename: pydeen/exits.py
+Comment: 
+
 Filename: pydeen/files.py
 Comment: 
 
 Filename: pydeen/globals.py
 Comment: 
 
 Filename: pydeen/http.py
@@ -54,23 +57,23 @@
 
 Filename: pydeen/websocket.py
 Comment: 
 
 Filename: pydeen/wsocket.py
 Comment: 
 
-Filename: pydeen-0.8.0.dist-info/LICENSE
+Filename: pydeen-0.9.0.dist-info/LICENSE
 Comment: 
 
-Filename: pydeen-0.8.0.dist-info/METADATA
+Filename: pydeen-0.9.0.dist-info/METADATA
 Comment: 
 
-Filename: pydeen-0.8.0.dist-info/WHEEL
+Filename: pydeen-0.9.0.dist-info/WHEEL
 Comment: 
 
-Filename: pydeen-0.8.0.dist-info/top_level.txt
+Filename: pydeen-0.9.0.dist-info/top_level.txt
 Comment: 
 
-Filename: pydeen-0.8.0.dist-info/RECORD
+Filename: pydeen-0.9.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pydeen/__init__.py

```diff
@@ -1,14 +1,13 @@
 """
 PyDEEN init module. Defines main types and include sub modules
 """
-
+__version__ = "0.9.0"
 
 # import sub modules
-import pydeen.globals as globals
 import pydeen.core as core
 import pydeen.types as types
 
 import pydeen.menu as menu
 import pydeen.service as service
 import pydeen.auth as auth
 import pydeen.odata as odata
@@ -38,12 +37,11 @@
 from pydeen.service import ServiceActionCommands
 from pydeen.service import ServiceCommand
 
 
 # local service support
 from pydeen.websocket import WebSocketService
 
-globals.PYDEEN_DATAHUB = types.DataHub("Central PyDEEN Datahub")
 
 def menu():
     print("menu not implemented yet")
```

## pydeen/core.py

```diff
@@ -1,12 +1,13 @@
 """
 PyDEEN Core functionality with some global features and exits for the framework
 """
 
 import logging
+from pydeen import __version__
 
 class PyDEEN:
     
     logging_initialized:bool=False
     logger_cache:dict={}
     logger_level = logging.INFO
     logger_filename = 'pydeen.log'
@@ -29,27 +30,27 @@
 
     @classmethod
     def init_logging(cls) -> bool:
         if cls.is_logging_initialized():
             return True
         try:
             logging.basicConfig(level=cls.logger_level, filename=cls.logger_filename, format=cls.logger_format) #filemode='w', 
-            logging.info('PyDEEN logger initialized')
+            logging.info(f"PyDEEN logger initialized")
             cls.logging_initialized = True
             return True    
         except Exception as exc:
             print(f"Error while initializig pydeen logging: {type(exc)} - {exc}")
             return False
 
     @classmethod
     def get_logger(cls, logging_id:str, create:bool=True, console_out:bool=True):
         if cls.is_logging_initialized() == False:
             cls.init_logging()
             if console_out == True:
-                print("PyDEEN logging initialized")
+                print(f"PyDEEN logging initialized (version {__version__})")
         
         
         if cls.is_logger_available(logging_id) == True:
             return cls.logger_cache[logging_id]
 
         if create == False:
             return None
```

## pydeen/http.py

```diff
@@ -1,20 +1,23 @@
 """
-    HTTP features for HTTP based backends    
+    HTTP features for HTTP based backends and requests 
 """
 
 import requests
-from pathlib import Path
+import ssl
+import pathlib
 from pydeen.types import Request, Connector, Result, Backend, Auth
 
 class HTTPRequest(Request):
 
     def __init__(self, connector: Connector) -> None:
         super().__init__()
-        self.headers = {}
+        self.headers = {
+            'user-agent': 'python-request (pydeen)'
+        }
         self.params  = {}
         self.result  = None
         self.http_request = None
         self.status_code = 0
         self.connector = connector
         self.payload:str = None
 
@@ -108,15 +111,15 @@
         self.trace(f"request get result: {self.status_code}")    
         self.set_result_from_request()    
         return self.status_code
 
     def load_payload(self, filename:str) -> bool:
         try:
            self.payload = None
-           self.payload = Path(filename).read_text()
+           self.payload = pathlib.Path(filename).read_text()
            if self.payload != None:
             self.trace(f"request payload loaded from file {filename}")
             return True
            else:
             self.error(f"Error while loading payload from file {filename}")
             return False 
         except Exception as exc:
@@ -125,15 +128,44 @@
 
 class HTTPBackend(Backend):
 
     def __init__(self, name:str, url:str, auth:Auth=None):
         super().__init__(name, auth)
         self.type = "pydeen.HTTPBackend"
         self.set_property(Backend.BACKEND_PROP_URL, url)
+        self.ssl_verify_mode:ssl.VerifyMode=None
 
+    def get_ssl_verify_mode(self) -> ssl.VerifyMode:
+        return self.ssl_verify_mode
+
+    def set_ssl_verify_mode(self, ssl_verify_mode:ssl.VerifyMode):
+        self.ssl_verify_mode = ssl_verify_mode
+        self.trace(f"SSL Verify mode set to: {self.ssl_verify_mode}")    
+
+
+    def set_ssl_verify_mode_none(self):
+        self.ssl_verify_mode = ssl.CERT_NONE
+        self.trace("SSL Verify mode deactivated")    
+
+    def set_ssl_verify_mode_client_with_pem(self, path_to_pem:str, ssl_method:ssl._SSLMethod=ssl.PROTOCOL_TLS_CLIENT) -> bool:
+        try:
+            ssl_context = ssl.SSLContext(ssl_method)
+            pem_file = pathlib.Path(path_to_pem)
+            ssl_context.load_verify_locations(cafile=pem_file)
+            self.set_ssl_verify_mode(ssl_context)
+            return True               
+        except Exception as exc:
+            self.error(f"Error while setting SSL context: {type(exc)} - {exc}")    
+            return False
+
+    def set_ssl_verify_mode_ignore_all(self, protocol:ssl._SSLMethod=None) -> bool:
+        ssl_context = ssl.SSLContext(protocol=protocol)
+        ssl_context.check_hostname = False
+        ssl_context.verify_mode = ssl.CERT_NONE
+        return True
 
 class HTTPConnector(Connector):
     """
         Connector for HTTP Calls
     """
     def __init__(self, backend:Backend=None, url_or_endpoint:str="") -> None:
```

## pydeen/menu.py

```diff
@@ -92,14 +92,36 @@
                     answer = None
                 if max != None and max < result:
                     answer = None
             else:
                 answer = None    
         return result     
 
+    def get_input_yes_no(self, default_yes:bool=True) -> bool:
+        label = self.label
+        if default_yes:
+            label += f"(Yes/no): "
+        else:
+            label += f"(yes/No): "
+
+        answer = None
+        while answer == None or answer == "":
+            answer = input(label)
+            if answer == "" or answer == None:
+                if default_yes:
+                    return True
+                else:
+                    return False    
+            if answer == "Y" or answer == "y":
+                return True
+            elif answer == "N" or "n":
+                return False
+            else: 
+                answer = None    
+
 
 class MenuAction:
     def __init__(self, menu, selected, cancel_entered:bool=False, quit_entered:bool=False):
         self.menu = menu
         self.selected = selected
         self.cancel_entered = cancel_entered
         self.quit_entered = quit_entered
@@ -209,14 +231,17 @@
         prompt = msg
         if prompt == None:
             prompt = self.title
         
         print()    
         input(f"{prompt} - Please confirm (with Enter)")
 
+
+
+
 if __name__ == "__main__":
     entries = {
         "selection1" : "selection1",
         "selection2" : "selection2",
         "selection3" : "selection3",
         "selection4" : "selection4",
         "selection5" : "selection5",
```

## pydeen/pandas.py

```diff
@@ -1,73 +1,122 @@
 """
 This module contains functions for integrating the pandas library
 """
 
 
+import pandas as pd
 from pandas import DataFrame
+
 from pydeen.menu import UserInput
-from pydeen.types import Result, Factory
+from pydeen.types import Result, Factory, Base
 from pydeen.utils import FileTransferUtil
 
 class PandasResultDataframe(Result):
     
     MENU_PANDAS_DISPLAY         = "pandas_display"
     MENU_PANDAS_INFO            = "pandas_info"
+    MENU_PANDAS_RESULT_NAME     = "pandas_result_name"
+    MENU_PANDAS_SET_DESC        = "pandas_set_desc"
     MENU_PANDAS_HEAD_TAIL       = "pandas_head_tail"
     MENU_PANDAS_DESCRIBE        = "pandas_describe"
     MENU_PANDAS_DATATYPES       = "pandas_datatypes"
     MENU_PANDAS_VALUE_DIST      = "pandas_value_dist"
     MENU_PANDAS_SAVE_CSV        = "pandas_save_csv"
+    MENU_PANDAS_LOAD_CSV        = "pandas_load_csv"
+    MENU_PANDAS_SAVE_PICKLE     = "pandas_save_pickle"
+    MENU_PANDAS_LOAD_PICKLE     = "pandas_load_pickle"
     MENU_PANDAS_DATAHUB_EXPORT  = "pandas_export_datahub"
+    MENU_PANDAS_DATAHUB_IMPORT  = "pandas_import_datahub"
+
 
 
-    def __init__(self, df:DataFrame, name:str) -> None:
+    def __init__(self, name:str, df:DataFrame=None) -> None:
         super().__init__(df)
         self.type = "pydeen.PandasResultDataframe"
         self.result_df:DataFrame = df 
         self.result_name:str = name
         self.menu_title = "Pandas Dataframe - Menu"
 
+    def get_dataframe(self) -> DataFrame:
+        return self.result_df
+        
+    def get_description(self) -> str:
+        if self.result_name != None:
+            super_desc = super().get_description()
+            if super_desc == None:
+                return f"{self.result_name}"
+            else:
+                return f"{self.result_name} {super_desc}"    
+        else:
+            return super().get_description()
+
+    def get_default_filename(self, default:str=None) -> str:
+        result = self.result_name
+        if result == None or result == "":
+            result = default
+        if result == None or result == "":
+            result = "dataframe"
+        return result.replace("/", "x")
+
     def get_columns(self) -> list:
         try:
             return self.result_df.columns.tolist()
         except Exception as exc:
             self.trace(f"Error occured while determing columns of dataframe: {type(exc)} - {exc}")
             return super().get_columns()
 
     def is_empty(self) -> bool:
         try:
-            if type(self.result_df) != None:
-                return False
+            if type(self.result_df) == DataFrame:
+                return self.result_df.empty
             else:
                 return True
         except Exception as exc:
-            print(type(exc), exc)
+            print("Error: ",type(exc), exc)
             return True
 
     def menu_get_entries(self, prefilled: dict = None) -> dict:
-        entries = {} # NO SUPER MENU - super().menu_get_entries(prefilled)
+        entries = Base.menu_get_entries(self,prefilled)
         try:
-            if self.is_empty() == False:
+            if type(self.result_df) == DataFrame:
+                entries[PandasResultDataframe.MENU_PANDAS_RESULT_NAME] = f"Rename dataframe ({self.result_name})"
+                entries[PandasResultDataframe.MENU_PANDAS_SET_DESC] = f"Set description dataframe ({super().get_description()})"
                 entries[PandasResultDataframe.MENU_PANDAS_DISPLAY] = "Display dataframe"
                 entries[PandasResultDataframe.MENU_PANDAS_INFO] = "Display dataframe info"
-                entries[PandasResultDataframe.MENU_PANDAS_HEAD_TAIL] = "Display dataframe head/tail"
-                entries[PandasResultDataframe.MENU_PANDAS_DESCRIBE] = "Describe dataframe"
-                entries[PandasResultDataframe.MENU_PANDAS_DATATYPES] = "Display dataframe types"
-                entries[PandasResultDataframe.MENU_PANDAS_VALUE_DIST] = "Show value distribution of column"
-                entries[PandasResultDataframe.MENU_PANDAS_SAVE_CSV] = "Save dataframe to csv"
-                entries[PandasResultDataframe.MENU_PANDAS_DATAHUB_EXPORT] = "Export to Datahub"
-        except:
-            self.trace("errors occured in pandas df menu")
-        finally:
-            return entries
+
+                if not self.is_empty():
+                    entries[PandasResultDataframe.MENU_PANDAS_HEAD_TAIL] = "Display dataframe head/tail"
+                    entries[PandasResultDataframe.MENU_PANDAS_DESCRIBE] = "Describe dataframe"
+                    entries[PandasResultDataframe.MENU_PANDAS_DATATYPES] = "Display dataframe types"
+                    entries[PandasResultDataframe.MENU_PANDAS_VALUE_DIST] = "Show value distribution of column"
+                    entries[PandasResultDataframe.MENU_PANDAS_SAVE_CSV] = "Save dataframe to csv file"
+                    entries[PandasResultDataframe.MENU_PANDAS_SAVE_PICKLE] = "Save dataframe to pickle file"
+                    entries[PandasResultDataframe.MENU_PANDAS_DATAHUB_EXPORT] = "Export to Datahub"
+            else:
+                entries[PandasResultDataframe.MENU_PANDAS_LOAD_CSV] = "Load csv file"
+                entries[PandasResultDataframe.MENU_PANDAS_LOAD_PICKLE] = "Load from dataframe pickle file"
+                entries[PandasResultDataframe.MENU_PANDAS_DATAHUB_EXPORT] = "Import from Datahub"
+        except Exception as exc:
+            self.error(f"errors occured in pandas df menu {exc}")
+        
+        return entries
 
     def menu_process_selection(self, selected: str, text: str = None):
         if selected == PandasResultDataframe.MENU_PANDAS_DISPLAY:
             print(self.result_df)
+        elif selected == PandasResultDataframe.MENU_PANDAS_RESULT_NAME:
+            new_name = UserInput("Enter new name for dataframe", self.result_name).get_input(empty_allowed=True)
+            if new_name != None and len(new_name) > 0 and self.result_name != new_name:
+                self.result_name = new_name
+                print(f"Dataframe renamed to {new_name}")
+        elif selected == PandasResultDataframe.MENU_PANDAS_SET_DESC:
+            new_desc = UserInput("Enter new description for dataframe", super().get_description()).get_input(empty_allowed=True)
+            if new_desc != None and len(new_desc) > 0:
+                self.set_description(new_desc)
+                print(f"Dataframe description set to {new_desc}")
         elif selected == PandasResultDataframe.MENU_PANDAS_INFO:
             print(self.result_df.info())
         elif selected == PandasResultDataframe.MENU_PANDAS_HEAD_TAIL:
             print(self.result_df.head())
             print(self.result_df.tail())
         elif selected == PandasResultDataframe.MENU_PANDAS_DESCRIBE:
             print(self.result_df.describe())
@@ -76,23 +125,62 @@
         elif selected == PandasResultDataframe.MENU_PANDAS_VALUE_DIST:
             columns = self.get_columns()
             selected = UserInput("Select column").get_selection_from_list("Show value distribution for dataframe column", columns)
             if selected != None:
                 print(f"values of column {selected}:")
                 print(self.result_df[selected].value_counts())   
         elif selected == PandasResultDataframe.MENU_PANDAS_SAVE_CSV:
-            result_name = "dataframe"
-            if self.result_name != None:
-                result_name = result_name + "_" + self.result_name
-            result_name = result_name.replace("/","x")
-                
-            filename = FileTransferUtil().enter_filename_to_save("save current dataframe to csv", result_name, "csv", use_datetime_prefix=True)
+            result_name = self.get_default_filename()
+            filename = FileTransferUtil().enter_filename_to_save("Save current dataframe to csv", result_name, "csv", use_datetime_prefix=True)
             if filename != None:
                 self.result_df.to_csv(filename,sep="\t")
+                print(f"Dataframe saved to csv file {filename}")
+        elif selected == PandasResultDataframe.MENU_PANDAS_SAVE_PICKLE:
+            result_name = self.get_default_filename("dataframe_pickle")                
+            filename = FileTransferUtil().enter_filename_to_save("Save current dataframe as pickle file", result_name, "pkl", use_datetime_prefix=True)
+            if filename != None:
+                print(f"Start save dataframe pickle file as {filename}...", self.result_df, type(self.result_df))    
+                self.result_df.to_pickle(filename)
+                print(f"Dataframe pickle file saved as {filename}")    
+        
+        elif selected == PandasResultDataframe.MENU_PANDAS_LOAD_PICKLE:                
+            result_name = self.get_default_filename()
+            filename = FileTransferUtil().enter_filename_to_load("Load dataframe from pickle file", name=result_name, extension="pkl")
+            if filename != None:
+                new_df = pd.read_pickle(filename)
+                if type(new_df) != DataFrame:
+                    print("Loading pandas pickle file failed or cancelled")
+                else:
+                    self.result_df = new_df
+                    print(f"Dataframe pickle file loaded from {filename}")    
+        elif selected == PandasResultDataframe.MENU_PANDAS_LOAD_CSV:                
+            result_name = self.get_default_filename()
+            filename = FileTransferUtil().enter_filename_to_load("Load dataframe from csv file", name=result_name, extension="csv")
+            if filename != None:
+                new_df = pd.read_csv(filename, sep="\t")
+                if type(new_df) != DataFrame:
+                    print("Loading csv file into pandas dataframe failed or cancelled")
+                else:
+                    self.result_df = new_df
+                    print(f"Dataframe loaded from csv file {filename}")    
         elif selected == PandasResultDataframe.MENU_PANDAS_DATAHUB_EXPORT:
                 if Factory.get_datahub().register_object_with_userinput(self) == True:
-                    print("Pandas Dataframe Result exported to Datahub.")
+                    print("Pandas dataframe result exported to datahub.")
                 else:
-                    print("Pandas Dataframe Result not exported to Datahub.")        
+                    print("Pandas dataframe result not exported to datahub.")        
+        elif selected == PandasResultDataframe.MENU_PANDAS_DATAHUB_IMPORT:
+                try:
+                    dh = Factory.get_datahub()
+                    df_key = dh.menu_select_key("Select dataframe result object", PandasResultDataframe)
+                    if df_key != None and df_key != "":
+                        dh_object = dh.get_object(df_key)
+                        self.result_df = PandasResultDataframe.get_dataframe(dh_object)
+                        if self.result_df != None:
+                            print("Pandas dataframe loaded from datahub.")
+                            print(self.result_df.info())
+                        else:
+                            print("Pandas dataframe not loaded from datahub.")        
+                except Exception as exc:
+                    print(f"Loading from datahub failed: {type(exc)} - {exc}")    
+
         else:    
             return super().menu_process_selection(selected, text)    
-
```

## pydeen/sap_abap.py

```diff
@@ -365,26 +365,27 @@
 
         # result options
         if self.menu_result != None:
             result_count = self.menu_result.get_count()
             entries[
                 SAPAbapODataConnector.MENU_RESULT_MENU] = f"Enter current result menu (entity {self.menu_entity}, endpoint {self.endpoint}, records {result_count})"
             if result_count > 0:
-                entries[
-                    SAPAbapODataConnector.MENU_RESULT_RAW] = f"Display current as raw data (entity {self.menu_entity}, endpoint {self.endpoint})"
+                #entries[
+                #    SAPAbapODataConnector.MENU_RESULT_RAW] = f"Display current as raw data (entity {self.menu_entity}, endpoint {self.endpoint})"
                 entries[
                     SAPAbapODataConnector.MENU_RESULT_SINGLE_CHOOSE] = f"Choose single record from current result (entity {self.menu_entity}, endpoint {self.endpoint})"
                 # single result support
                 if self.menu_result_single != None:
                     entries[
                         SAPAbapODataConnector.MENU_RESULT_SINGLE_MENU] = f"Enter single record menu (record {self.menu_result_single.get_description()})"
                 
                 # pandas transformation                    
-                entries[
-                    SAPAbapODataConnector.MENU_RESULT_PANDAS] = f"Get current result as pandas dataframe (entity {self.menu_entity}, endpoint {self.endpoint})"
+                if self.menu_pandas_df == None:
+                    entries[
+                        SAPAbapODataConnector.MENU_RESULT_PANDAS] = f"Get current result as pandas dataframe (entity {self.menu_entity}, endpoint {self.endpoint})"
 
         # pandas support
         if self.menu_pandas_df != None:
             entries[
                 SAPAbapODataConnector.MENU_PANDAS_MENU] = f"Open menu for current pandas dataframe {self.menu_pandas_df.get_name()}"
 
         
@@ -422,20 +423,19 @@
             elif selected == SAPAbapODataConnector.MENU_RESULT_SINGLE_MENU:
                 self.menu_result_single.menu()
             elif selected == SAPAbapODataConnector.MENU_RESULT_RAW:
                 print(self.menu_result.get_result_raw())
             elif selected == SAPAbapODataConnector.MENU_RESULT_PANDAS:
                 df = self.menu_result.get_result_as_pandas_df()
                 self.menu_pandas_df = PandasResultDataframe(
-                    df, self.menu_result.result_name)
+                    name=self.menu_result.result_name, df=df)
                 print(df)
             elif selected == SAPAbapODataConnector.MENU_RESULT_MENU:
                 self.menu_result.menu()
             elif selected == SAPAbapODataConnector.MENU_PANDAS_MENU:
-                print("PANDAS MENU", self.menu_pandas_df)
                 self.menu_pandas_df.menu()
             elif selected == SAPAbapODataConnector.MENU_DATAHUB:
                 Factory.get_datahub().menu()
             elif selected == SAPAbapODataConnector.MENU_RESET:
                 self.menu_action_reset()
             else:
                 super().menu_process_selection(selected, text)
```

## pydeen/sap_deeb.py

```diff
@@ -1,53 +1,191 @@
 """
     SAP NetWeaver ABAP features based on abapGit Addon DEEB
 """
 
-from pydeen.types import Backend, Connector, Auth, Result
-from pydeen.http import HTTPConnector, HTTPBackend, HTTPRequest
-from pydeen.menu import  MenuSelection, MenuAction, UserInput
+from pydeen.types import Backend, Factory, Result
+from pydeen.http import HTTPConnector
+from pydeen.menu import  UserInput
 from pydeen.sap_abap import SAPAbapHttpBackend
-from datetime import datetime, timedelta, timezone
+from pydeen.pandas import PandasResultDataframe
+from pydeen.exits import MenuExit, MenuExitCallback
+from pandas import DataFrame
+import numpy
+#from datetime import datetime, timedelta, timezone
 
 import pandas as pd 
 import json
 
 class SAPAbapDeebResult(Result):
     def __init__(self, result, metainfo=None) -> None:
         super().__init__(result)
         self.type = "pydeen.SAPAbapDeebResult"
         self.metainfo = metainfo
 
 
-class SAPAbapDeebConnector(HTTPConnector):
+class SAPAbapDeebConnector(HTTPConnector, MenuExitCallback):
     
     # static constants
     MENU_PING               = "ping"
     MENU_SEARCH_TABLE       = "search_table"
     MENU_SEARCH_VIEW        = "search_view"
     MENU_SEARCH_CDS         = "search_cds"
     MENU_SQL_SELECT         = "sql_select"
     MENU_RESULT_RAW         = "result_raw"
+    MENU_RESULT_MENU        = "result_menu"
     MENU_RESULT_PANDAS      = "result_pandas"
+    MENU_PANDAS_MENU        = "pandas_menu"
+    MENU_PANDAS_TEMPLATE    = "pandas_create_template"
+    MENU_PANDAS_EXPORT_ZTAB = "pandas_export_ztab"
+    MENU_PANDAS_IMPORT      = "pandas_import"
+    MENU_DATAHUB_MENU       = "datahub_menu"
+    MENU_DATAHUB_IMPORT     = "datahub_import"
     MENU_RESET              = "reset"
     
     def __init__(self, backend:Backend=None, url_or_endpoint:str=""):
         url = url_or_endpoint
         if url == None or len(url) == 0:
             url = '/sap/bc/bsp/sap/zdeeb_ws'
             
         super().__init__(backend, url)
         self.type = "pydeen.SAPAbapDeebConnector"
-        self.menu_result   = None
+        self.menu_result:Result   = None
+        self.menu_title = "SAP ABAP DEEB Connector - Menu"
+        self.menu_result_pd:PandasResultDataframe = None
         self.max_rec = 10000
         self.last_input = None
         
+    def get_sap_fieldname(self, column_name:str) -> str:
+        """generates a SAP fieldname from given column name. CamelCase will be transformed to typical sap name convention
+
+        :param column_name: a colum name like MyColumnName
+        :type column_name: str
+        :return: a field name for SAP usage
+        :rtype: str
+        """
+        result = ""
+        last_char_lower = False
+        for char in column_name:
+            upper_char = char.upper()
+            if upper_char == char:
+                char_is_lower = False
+            else:
+                char_is_lower = True
+
+            if last_char_lower == True and char_is_lower == False:
+                result += "_"
+
+            result += upper_char
+            last_char_lower = char_is_lower
+        
+        result = result.replace("__", "_")
+        return result    
+
+    def get_df_result_as_list_of_dict(self, result_df:PandasResultDataframe, map_fieldname_to_sap:bool=True) -> list:
+        # prepare access
+        result = []
+        df = result_df.get_dataframe()
+        cols = result_df.get_columns()
+
+        # prepare mapping
+        cols_map = {}
+        for col in cols:
+            col_mapped = col
+            if map_fieldname_to_sap:
+                col_mapped = self.get_sap_fieldname(col)
+            cols_map[col] = col_mapped    
+
+        # loop rows
+        for i in range(len(df)):
+            record = {}
+            for col in cols:
+                value_raw = df[col].loc[i]
+                key   = cols_map[col]
+                
+                value_type = type(value_raw)
+                if value_type == numpy.int64:
+                    value = int(value_raw)
+                elif value_type == numpy.float64:
+                    value = float(value_raw)
+                elif value_type == numpy.bool_:
+                    value = bool(numpy)        
+                else:                    
+                    value = value_raw
+
+                #print(value_type, value_raw)
+
+                record[key] = value
+            result.append(record)
+
+        return result
+
+    def get_table_template_from_pandas_df(self, tabname:str, df:pd.DataFrame, label:str=None, 
+        key_count:int=1,  min_char_len_if_empty:int=10, dec_length:int=23, decimals:int=3, 
+        enhancementCategory:str="#NOT_EXTENSIBLE", tableCategory:str="#TRANSPARENT", deliveryClass:str="#A", dataMaintenance:str="#ALLOWED", 
+        with_client_key:bool=True, with_timestamp_key:bool=False, skip_unnamed:bool=True) -> str:
+
+        # prepare columns
+        cols = df.columns.values.tolist()
+        cols_list = []
+        
+        for col in cols:
+            if col == "Unnamed" and skip_unnamed:
+                continue
+
+            col_max_len = 0
+            col_type = df.dtypes[col].__repr__() #columns[col].to_native_types()
+            if col_type.find("'O'") >= 0:
+                col_max_len = df[col].str.len().max()           
+                if col_max_len == 0:
+                    col_max_len = min_char_len_if_empty
+                col_type_abap = f"abap.char({col_max_len})"
+            else:
+                col_type_abap = f"abap.dec({dec_length},{decimals})"    
+
+            col_tupel = (col, self.get_sap_fieldname(col), col_type, col_max_len, col_type_abap)
+            cols_list.append(col_tupel)
+
+        if label == None:
+            tab_label = "table template generated by PyDEEN"
+        else:
+            tab_label = label
+
+
+        # table header
+        result = ""
+        result += f"@EndUserText.label : '{tab_label}'\n"
+        result += f"@AbapCatalog.enhancementCategory : {enhancementCategory}\n"
+        result += f"@AbapCatalog.tableCategory : {tableCategory}\n"
+        result += f"@AbapCatalog.deliveryClass : {deliveryClass}\n"
+        result += f"@AbapCatalog.dataMaintenance : {dataMaintenance}\n"        
+
+        # table start and keys
+        result += f"define table {tabname} " + "{\n"
+        
+        if with_client_key:
+            result += f"  key CLIENT : abap.clnt not null;\n"
+        if with_timestamp_key:
+            result += "  key TIMESTAMP : timestampl not null;\n"
+
+        col_index = 0
+        for col_tupel in cols_list:
+            if col_index < key_count:
+                key_include = "key "
+            else:
+                key_include = ""
+
+            result += f"  {key_include}{col_tupel[1]} : {col_tupel[4]};\n"
+            col_index += 1
+            
+        result += "}"
+        return result
 
     def menu_action_reset(self):
         self.menu_result = None
+        self.menu_result_pd = None
         print("Menu context cleared.")
 
     def menu_action_ping(self):
         
         success, response, http_code = self.ping()
 
         if success == True:
@@ -102,57 +240,165 @@
             count = self.menu_result.get_count()
             cols  = self.menu_result.get_columns()
             print(f"SQL select finished: {count} records in {len(cols)} columns")
             print(cols)
         else:
             print(f"SQL select failed: http code {http_code} - {response}")   
 
-    def menu(self):        
-        valid = True
-        while valid == True:
-            
-            # build main menu    
-            entries = {}
-            entries[SAPAbapDeebConnector.MENU_PING] = "Ping ABAP Backend DEEB Service"
-            entries[SAPAbapDeebConnector.MENU_SEARCH_TABLE] = "Search table"
-            entries[SAPAbapDeebConnector.MENU_SEARCH_CDS] = "Search cds view"
-            entries[SAPAbapDeebConnector.MENU_SQL_SELECT] = "Excecute SQL Select Statement"
+    def menu_action_generate_sap_template(self, result_df:PandasResultDataframe) -> bool:
+        # enter table name
+        table_name = UserInput("Enter a name for the Z-Table", "ZMYTABLE").get_input()
+        if table_name == None:
+            return True
+
+        # Default Options
+        #if UserInput("Open extended options").get_input_yes_no(False) == True:
+        #    print("extended Option not implemented yet")
+
+        # generate    
+        tab_template = self.get_table_template_from_pandas_df(table_name, PandasResultDataframe.get_dataframe(result_df))
+        if tab_template != None:
+            print(f"\n\nUse this as eclipse table template:\n\n{tab_template}")
+            return True
+        else:
+            return False
+
+    def exit_menu_get_entries_top(self, exit, owner) -> dict:
+        result = {}
+        if type(owner) == PandasResultDataframe:
+            result[SAPAbapDeebConnector.MENU_PANDAS_TEMPLATE] = "Generate SAP table template"
+            return result
+        else:
+            return super().exit_menu_get_entries_top(exit, owner)
+    
+    def exit_menu_get_entries_bottom(self, exit, owner) -> dict:
+        result = {}        
+        if type(owner) == PandasResultDataframe:
+            result[SAPAbapDeebConnector.MENU_PANDAS_EXPORT_ZTAB] = "Export to SAP Backend as Z-Table"
+            return result
+        else:
+            return super().exit_menu_get_entries_top(exit, owner)
+
+    def menu_get_entries(self, prefilled: dict = None) -> dict:
+        entries = super().menu_get_entries(prefilled)
 
+        entries[SAPAbapDeebConnector.MENU_PING] = "Ping ABAP Backend DEEB Service"
+        entries[SAPAbapDeebConnector.MENU_SEARCH_TABLE] = "Search table"
+        entries[SAPAbapDeebConnector.MENU_SEARCH_CDS] = "Search cds view"
+        entries[SAPAbapDeebConnector.MENU_SQL_SELECT] = "Excecute SQL Select Statement"
+
+        if self.menu_result != None:
+            entries[SAPAbapDeebConnector.MENU_RESULT_MENU] = f"Open menu for current result"
+            
+        if type(self.menu_result_pd) == PandasResultDataframe:
+            entries[SAPAbapDeebConnector.MENU_PANDAS_MENU] = f"Open menu for pandas dataframe"
+        else:
             if self.menu_result != None:
-                    entries[SAPAbapDeebConnector.MENU_RESULT_RAW] = f"Display current result as raw data"
-                    entries[SAPAbapDeebConnector.MENU_RESULT_PANDAS] = f"Display current result as pandas dataframe"
+                entries[SAPAbapDeebConnector.MENU_RESULT_PANDAS] = f"Get current result as pandas dataframe"
+
+        if type(self.menu_result_pd) != PandasResultDataframe:
+            if Factory.get_datahub().get_count(PandasResultDataframe) > 0:
+                entries[SAPAbapDeebConnector.MENU_DATAHUB_IMPORT] = "Import pandas dataframe from Datahub"
+            else:
+                entries[SAPAbapDeebConnector.MENU_PANDAS_IMPORT] = "Import pandas dataframe"
+ 
+        if Factory.get_datahub().get_count() > 0:
+            entries[SAPAbapDeebConnector.MENU_DATAHUB_MENU] = "Open Datahub menu"
+
+
+        entries[SAPAbapDeebConnector.MENU_RESET] = "Reset menu context"
+
+        return entries
+
+    def execute_table_update(self, tabname:str, data, with_timestamp:bool=False, delete:bool=True, interactive:bool=True, timestamp=None, all_namespaces:bool=False):
+                    # prepare payload
+                    data_str = json.dumps(data) 
+                    data_len = len(data_str)
+
+                    payload = {
+                        'table' : tabname.upper(),
+                        'data' : data_str,
+                        'with_timestamp' : with_timestamp,
+                        'timestamp' : timestamp,
+                        'delete' : delete,
+                        'all_namespaces' : all_namespaces
+                    }
+
+                    # status
+                    if interactive:
+                        print(f"Sending data with {data_len} bytes to SAP backend...")
+
+                    # call deeb api table update
+                    success, response, http_code = self.execute_request(payload, "table_update")
+                    if interactive:                    
+                        if success:
+                            print(f"Success: {response}")
+                        else:
+                            print(f"Error: {http_code} - {response}")                    
+                    
+                    return success, response, http_code
+
+    def exit_menu_process_selection(self, exit, owner, selected: str, text: str = None) -> True:
+        
+        if isinstance(owner, PandasResultDataframe):
+            if selected == SAPAbapDeebConnector.MENU_PANDAS_TEMPLATE:
+                return self.menu_action_generate_sap_template(owner)
+            elif selected == SAPAbapDeebConnector.MENU_PANDAS_EXPORT_ZTAB:
+                tab_name = UserInput("Enter table name").get_input(empty_allowed=True)
+                if tab_name != None and tab_name != "":
+                    print("Preparing data...")
+                    data = self.get_df_result_as_list_of_dict(self.menu_result_pd)
+                    self.execute_table_update(tab_name, data, interactive=True)
+            return True
+        else:    
+            return super().exit_menu_process_selection(exit, owner, selected, text)
 
-            entries[SAPAbapDeebConnector.MENU_RESET] = "Reset menu context"
 
-            # show menu            
-            action = MenuSelection("SAP NetWeaver ABAP DEEB Connector - Menu", entries, True, False).show_menu()
-            if action.is_quit_entered():
-                valid = False
+    def menu_process_selection(self, selected: str, text: str = None):
+        try:
+            if selected == SAPAbapDeebConnector.MENU_RESULT_MENU:
+                self.menu_result.menu()
+            elif selected == SAPAbapDeebConnector.MENU_RESULT_PANDAS:
+                df:pd.DataFrame = self.menu_result.get_result_as_pandas_df()
+                self.menu_result_pd = PandasResultDataframe(name=self.menu_result.result_name, df=df)
+                print(df)    
+            elif selected == SAPAbapDeebConnector.MENU_PANDAS_MENU:
+                self.menu_result_pd.menu(menu_exit=self)
+            elif selected == SAPAbapDeebConnector.MENU_RESET:
+                self.menu_action_reset()
+            elif selected == SAPAbapDeebConnector.MENU_PING:
+                self.menu_action_ping()    
+            elif selected == SAPAbapDeebConnector.MENU_SEARCH_TABLE:
+                self.menu_action_search_table()
+            elif selected == SAPAbapDeebConnector.MENU_SEARCH_CDS:
+                self.menu_action_search_cds()
+            elif selected == SAPAbapDeebConnector.MENU_SQL_SELECT:
+                self.menu_action_sql_select()    
+            elif selected == SAPAbapDeebConnector.MENU_DATAHUB_MENU:
+                Factory.get_datahub().menu() 
+            elif selected == SAPAbapDeebConnector.MENU_DATAHUB_IMPORT:
+                dh_key = Factory.get_datahub().menu_select_key("Enter the key for pandas dataframe object", PandasResultDataframe)        
+                if dh_key != None:
+                    object = Factory.get_datahub().get_object(dh_key)
+                    if object != None:
+                        self.menu_result_pd = object
+                        print("Panadas dataframe object imported.")
+                        print(self.menu_result_pd.get_dataframe())
+
+            elif selected == SAPAbapDeebConnector.MENU_PANDAS_IMPORT:
+                df_import = PandasResultDataframe(name="dataframe")
+                df_import.menu()
+                if not df_import .is_empty():
+                    self.menu_result_pd = df_import
+                    print("Imported:\n", self.menu_result_pd)
             else:
-                try:
-                    selected = action.get_selection()
-                    if selected == SAPAbapDeebConnector.MENU_RESULT_RAW:
-                        print(self.menu_result.get_result_raw())
-                    elif selected == SAPAbapDeebConnector.MENU_RESULT_PANDAS:
-                        df:pd.DataFrame = self.menu_result.get_result_as_pandas_df()
-                        print(df)    
-                    elif selected == SAPAbapDeebConnector.MENU_RESET:
-                        self.menu_action_reset()
-                    elif selected == SAPAbapDeebConnector.MENU_PING:
-                        self.menu_action_ping()    
-                    elif selected == SAPAbapDeebConnector.MENU_SEARCH_TABLE:
-                        self.menu_action_search_table()
-                    elif selected == SAPAbapDeebConnector.MENU_SEARCH_CDS:
-                        self.menu_action_search_cds()
-                    elif selected == SAPAbapDeebConnector.MENU_SQL_SELECT:
-                        self.menu_action_sql_select()    
-                    else:
-                        print("unknown menu action")
-                except Exception as exc:
-                    print("Errors occured:", type(exc), exc)
+                return super().menu_process_selection(selected, text)
+        except Exception as exc:
+            print("Errors occured:", type(exc), exc)
+
 
     def ping(self):
         # build a new request
         request = self.create_request()        
         # prepare params
         params = {}
 
@@ -207,14 +453,38 @@
         if http_code < 200 or http_code > 299:
             self.trace(f"invalid answer - return code {http_code}") 
             return False, response, http_code
         else:
             self.trace("SQL Select OK")
             return True, response, http_code   
 
+    def execute_request(self, payload:dict, deeb_service:str, params:dict=None):
+        # build a new request
+        request = self.create_request()        
+        
+        # prepare params
+        req_params = {}
+        client  = self.backend.get_client()
+        if client != None:
+            req_params[SAPAbapHttpBackend.HTTP_PARAM_SAPCLIENT] = client
+        if params != None:
+            req_params.update(params)    
+
+        # call sap service api
+        self.trace(f"Call sap for deeb request service {deeb_service}")
+        
+        http_code = request.post(json.dumps(payload), f"{self.endpoint}/{deeb_service}", req_params)
+        response = request.get_response_text()
+        if http_code < 200 or http_code > 299:
+            self.trace(f"deeb service {deeb_service} - invalid answer - return code {http_code}") 
+            return False, response, http_code
+        else:
+            self.trace(f"deeb request {deeb_service} OK")
+            return True, response, http_code   
+
     def search_tables(self, wildcard:str) -> list:
         try:
             if wildcard == None:
                 return None
             search_str = wildcard.replace("*", "%")
 
             #sql_request = f"SELECT m~tabname as table_name, t~ddtext  as description, t~DDLANGUAGE as language FROM dd02l AS m LEFT OUTER JOIN dd02t AS t ON m~tabname = t~tabname and m~as4local = t~as4local and m~as4vers = t~as4vers WHERE m~tabname LIKE '{search_str}' OR t~ddtext LIKE '{search_str}' ORDER BY m~tabname"
```

## pydeen/types.py

```diff
@@ -2,15 +2,17 @@
 main types defintions and functionality for the framework
 """
 
 import json
 import pandas as pd
 
 from requests import Session
+
 from pydeen.utils import CryptUtil, CryptEngine, FileTransferUtil
+from pydeen.exits import MenuExit, MenuExitCallback
 from pydeen.menu import  MenuSelection, MenuAction, UserInput
 from pydeen.core import PyDEEN
 
 class Base:
     """
         Abstract base class
     """
@@ -23,14 +25,15 @@
     def __init__(self) -> None:
         self.type = "pydeen.Base"
         self._properties = {}
         self.debug = False
         self.interactive = False
         self.last_error = None
         self.menu_title:str="PyDEEN Menu"
+        self.menu_exit:MenuExit = None
 
     def __repr__(self) -> str:
         return self.type
 
     def get_type(self) -> str:
         if self.type == None:
             return type(self)
@@ -105,20 +108,25 @@
 
     def get_type(self) -> str:
         return self.type
 
     def get_key(self) -> str:
         return self.get_property(Base.BASE_PROP_KEY)
 
-    def get_description(self) -> str:
-        return self.get_property(Base.BASE_PROP_DESCRIPTION)
-
     def set_key(self, desc:str):
         self.set_property(Base.BASE_PROP_DESCRIPTION, desc)    
 
+    def get_description(self) -> str:
+        prop = self.get_property(Base.BASE_PROP_DESCRIPTION, None)
+        return prop    
+
+
+    def set_description(self, desc:str):
+        self.set_property(Base.BASE_PROP_DESCRIPTION, desc)
+
     def get_config(self):
         return self._properties
 
     def get_config_file_name(self, filename) -> str:
         if filename.find(".") > 0:
             return filename
         else:
@@ -164,70 +172,119 @@
         else:    
             return "PyDEEN Menu"
 
     def menu_get_entries(self, prefilled:dict=None) -> dict:
         """
         Creates a context oriented menu for 'menu()'
         """
-        if prefilled == None:
-            return {}
-        else:
-            return prefilled        
+        # prepare and prefill
+        result = {}
+        if prefilled != None:
+            result.update(prefilled)
+            self.trace("menu has prefilled entries")
+
+        # check menu exit
+        if self.menu_exit != None:
+            if self.menu_exit.entries_top != None:
+                result.update(self.menu_exit.entries_top)
+                self.trace("Menu extended at top level by menuexit static")
+            
+            entries_top = self.menu_exit.callback.exit_menu_get_entries_top(self.menu_exit, self)
+            if entries_top != None:
+                result.update(entries_top)
+                self.trace("Menu extended at top level by menuexit callback")
+        # return
+        return result            
 
-    def menu_process_selection(self, selected:str, text:str=None):
+    def menu_process_selection(self, selected:str, text:str=None) -> bool:
         """
         Processes the user input from 'menu()'
         """
+#        if self.menu_exit != None:
+#            if self.menu_exit.callback.exit_menu_process_selection(self, selected, text) == True:
+#                return True
+#            else:
         if text == None:
             print(f"Selected menu {selected} not handled")
         else:    
-            print(f"Selected menu '{text}' (code:{selected} not handled")
+            print(f"Selected menu '{text}' (code:{selected}) not handled")
+        return False    
 
-    def menu(self):
+    def menu(self, menu_exit:any=None):
         """
         This function created an individual menu for the context object.
         See function 'menu_get_entries' and 'menu_process_selection' too.
         """
 
-
         # prepare      
         title = self.menu_get_title()
         self.trace(f"Menu {title} entered")
         saved_interactive = self.interactive
         self.interactive = True
+        
+        self.menu_exit = None
+        if isinstance(menu_exit, MenuExit):
+            self.menu_exit = menu_exit
+            self.trace(f"menuexit {menu_exit} detected")
+        elif isinstance(menu_exit, MenuExitCallback):
+            menu_exit_proxy = MenuExit(menu_exit) 
+            self.menu_exit = menu_exit_proxy
+            self.trace(f"menuexit callback {menu_exit} detected")
 
         # menu loop
         valid = True
         while valid == True:
-            
             # build main menu    
             entries = self.menu_get_entries()
+
+            # check menu exit
+            if self.menu_exit != None:
+                if self.menu_exit.entries_bottom != None:
+                    entries.update(self.menu_exit.entries_bottom)
+                    self.trace("menu extended at bottom by menuexit static")
+                
+                entries_bottom = self.menu_exit.callback.exit_menu_get_entries_bottom(menu_exit, self)    
+                if entries_bottom != None:
+                    entries.update(entries_bottom)
+                    self.trace("menu extended at bottom by menuexit static")
+
+            # check menu exists
             if entries == None or len(entries) == 0:
-                print("This object has no menu")
+                print(f"This object has no menu {self}")
                 return False
 
             # show menu            
             action = MenuSelection(title, entries, True, False).show_menu()
             if action.is_quit_entered():
                 valid = False
             else:
                 try:
                     selected = action.get_selection()
                     menu_text = entries[selected]
-                    self.menu_process_selection(selected, menu_text)    
+                    handled = False
+
+                    if self.menu_exit != None and self.menu_exit.callback != None:
+                        handled = self.menu_exit.callback.exit_menu_process_selection(menu_exit, self, selected, text=menu_text)
+                    
+                    if handled == True:
+                        self.trace(f"selection {selected} was handled by menu_exit")
+                    else:       
+                        self.menu_process_selection(selected, menu_text)    
                 except Exception as exc:
                     print("Errors occured:", type(exc), exc)
             
         # cleanup and exit
         self.interactive = saved_interactive
+        self.menu_exit = None
 
 
 class DataHub(Base):
 
     MENU_DISPLAY_LIST       = "display_list"
+    MENU_CHANGE_DESCRIPTION = "change_description"
     MENU_DELETE_ALL         = "delete_all"
     MENU_DELETE_SINGLE      = "delete_single"
     MENU_OPEN_MENU          = "open_menu"
 
     def __init__(self, title:str=None) -> None:
         super().__init__()
         self.type = "pydeen.DataHub"
@@ -245,18 +302,16 @@
     def register_object(self, key:str, object):
         self.hubdata[key] = object
 
     def unregister_object(self, key:str):
         del self.hubdata[key]
 
     def get_object(self, key:str):
-        print("GET_OBJECT: ", key)
         if self.is_key_available(key) == True:
             object = self.hubdata[key]
-            print("Object:", object)
             return object
         else:
             return None
 
     def get_count(self, data_type:type=None) -> int:
         if data_type == None:
             count = len(self.hubdata.keys())
@@ -293,28 +348,42 @@
         for key in self.hubdata:
             object = self.hubdata[key]
             data_type = type(object)
             if not data_type in result:
                 result.append(data_type)
         return result  
 
+    def get_object_description(self, object, with_type:bool=False) -> str:
+        if isinstance(object, Base):
+            desc = object.get_description()
+            if desc == None:
+                desc = type(object)
+            else:
+                if with_type:    
+                    desc = f"{desc} ({type(object)})"
+        else:    
+            desc = type(object)
+        return desc    
+
     def menu_select_key(self, title:str=None, data_type:type=None) -> str:
         # check
         if self.get_count(data_type) == 0:
             return None
         
         # prepare title
         title_used = title
         if title_used == None:
             title_used = "Select datahub object"
         
         # get entries
         entries = {}
         for key in self.hubdata:
-            entries[key] = f"{key} - {str(type(self.hubdata[key]))}"
+            object = self.hubdata[key]
+            desc = self.get_object_description(object)
+            entries[key] = f"{key} - {desc}"
 
         # open menu
         action = MenuSelection(title_used, entries, quit=False, cancel=True).show_menu()
         if action.is_cancel_entered():
             return None
         else:
             return action.get_selection()
@@ -339,34 +408,48 @@
 
 
     def menu_get_entries(self, prefilled: dict = None) -> dict:
         entries = super().menu_get_entries(prefilled)
         count = self.get_count() 
         if count > 0:
             entries[DataHub.MENU_DISPLAY_LIST] = f"Display list of objects in datahub ({count})"
+            entries[DataHub.MENU_CHANGE_DESCRIPTION] = f"Change object description"
             entries[DataHub.MENU_OPEN_MENU] = f"Open object menu"
             entries[DataHub.MENU_DELETE_SINGLE] = f"Delete single object"
             entries[DataHub.MENU_DELETE_ALL] = f"Delete all objects from datahub"
-
-
         
         return entries
 
     def menu_process_selection(self, selected: str, text: str = None):
         try:
             if selected == DataHub.MENU_DISPLAY_LIST:
-                obj_list = self.get_key_and_type_list()
-                for entry in obj_list:
-                    print(f"{entry[0]} - {entry[1]}")
+                for key in self.hubdata:
+                    object = self.hubdata[key]
+                    desc   = self.get_object_description(object)
+                    objtype = type(object)
+                    print(f"{key} - {desc} ({objtype})")
             elif selected == DataHub.MENU_OPEN_MENU:
                 selected = self.menu_select_key(title="Select object by key")
                 if selected != None:
                     object = self.get_object(selected)
                     print(f"Open menu for: ", selected, object)
                     Base.menu(object)
+            elif selected == DataHub.MENU_CHANGE_DESCRIPTION:
+                selected = self.menu_select_key(title="Select object by key")
+                if selected != None:
+                    object = self.get_object(selected)
+                    if isinstance(object, Base):
+                        obj_desc = Base.get_description(object)
+                        new_obj_desc = UserInput("Set description", obj_desc).get_input(empty_allowed=True)
+                        if new_obj_desc != None and len(new_obj_desc) > 0:
+                            Base.set_description(object, new_obj_desc)
+                            print(f"New description set for object: {new_obj_desc}")
+                    else:
+                        print(f"selected object has an unsupported type: {type(object)}")
+
             elif selected == DataHub.MENU_DELETE_SINGLE:
                 selected = self.menu_select_key(title="Select object by key")
                 if selected != None:
                     self.unregister_object(selected)
                     print(f"object with key {selected} removed from datahub")    
             elif selected == DataHub.MENU_DELETE_ALL:
                 self.hubdata={}
@@ -382,14 +465,15 @@
 class Factory:
     PYDEEN_DATAHUB = DataHub("Central PyDEEN Datahub") 
 
     @classmethod
     def get_datahub(cls) -> DataHub:
         return cls.PYDEEN_DATAHUB
 
+
 class Auth(Base):
     """
         abstract authentification
     """
 
     AUTH_TYPE_NONE  = "None"
     AUTH_TYPE_BASIC = "Basic"
@@ -633,14 +717,15 @@
         except Exception as exc:
             print("Errors occured:", type(exc), exc)
 
 
 class Result(Base):
 
     MENU_DISPLAY_RAW        = "result_display_raw"
+    MENU_CHANGE_DESC        = "result_change_description"
     MENU_SAVE_RAW           = "result_save_raw"
     MENU_DISPLAY_COLS       = "result_display_cols"
     MENU_DATAHUB_EXPORT     = "export_datahub"
 
     def __init__(self, result, name:str=None) -> None:
         super().__init__()
         self.result = result 
@@ -844,28 +929,35 @@
         if self.is_empty( ) == True:
             return entries
         
         # prepare
         count = self.get_count()
         columns = self.get_columns()
 
+        entries[Result.MENU_CHANGE_DESC] = f"Change description ({self.get_description()})"
         entries[Result.MENU_DISPLAY_RAW] = "Display raw data"
         entries[Result.MENU_SAVE_RAW] = "Save raw data"
         if columns != None and len(columns) > 0:
             entries[Result.MENU_DISPLAY_COLS] = "Display column names"
         
         entries[Result.MENU_DATAHUB_EXPORT] = "Export to Datahub"
         
+        self.trace(f"{count} menu entries created for {self}")
         return entries
 
 
     def menu_process_selection(self, selected: str, text: str = None):
         try:
             if selected == Result.MENU_DISPLAY_RAW:
                 print(self.get_result_raw())
+            elif selected == Result.MENU_CHANGE_DESC:
+                new_desc = UserInput("Set description", self.get_description()).get_input(empty_allowed=True)
+                if new_desc != None and len(new_desc) > 0:
+                    self.set_description(new_desc)
+                    print(f"Description set to {new_desc}")
             elif selected == Result.MENU_SAVE_RAW:
                 content = json.dumps(self.result)
                 if self.result_name != None:
                     name = self.result_name
                 else:
                     name = "result"    
                 FileTransferUtil().enter_filename_and_save_text("Save result as text", name, content, with_datetime_prefix=True, extension="txt")
@@ -881,55 +973,14 @@
                     print("Result not exported to Datahub.")
             else:
                 return super().menu_process_selection(selected, text)
         except Exception as exc:
             print("Errors occured:", type(exc), exc)
 
 
-    # def menu(self):
-    #     # check
-    #     if self.is_empty( ) == True:
-    #         print("Empty result - no menu possible")
-    #         return False
-    #     else:
-    #         count = self.get_count()
-    #         columns = self.get_columns()
-
-    #     # build menu
-    #     entries = {}
-    #     entries[Result.MENU_DISPLAY_RAW] = "Display raw data"
-    #     if columns != None and len(columns) > 0:
-    #         entries[Result.MENU_DISPLAY_COLS] = "Display column names"
-
-
-    #     # show menu            
-    #     valid = True
-    #     while valid:
-    #         action = MenuSelection(f"Result (count {count})- Menu", entries, True, False).show_menu()
-    #         if action.is_quit_entered():
-    #             valid = False
-    #         else:
-    #             try:
-    #                 selected = action.get_selection()
-    #                 if selected == Result.MENU_DISPLAY_RAW:
-    #                     print(self.get_result_raw())
-    #                 if selected == Result.MENU_DISPLAY_COLS:
-    #                     print(f"columns: {len(columns)}")
-    #                     for col in columns:
-    #                         print(col)
-    #                 else:
-    #                     print("unknown menu action")
-    #             except Exception as exc:
-    #                 print("Errors occured:", type(exc), exc)
-    #                 return False
-        
-    #     return True
-
-
-
 
 class Request(Base):
 
     def __init__(self) -> None:
         super().__init__()
         self.result = None
         self.type = "pydeen.Request"
```

## pydeen/utils.py

```diff
@@ -1,15 +1,18 @@
 """
     some utils for PyDEEN
 """
 
+from multiprocessing.spawn import import_main_path
 import pathlib
 import hashlib
 import base64
 import sys
+import os
+import re
 
 from cryptography.fernet import Fernet
 from pydeen.menu import UserInput
 from datetime import datetime
 
 class CryptEngine():
     
@@ -130,28 +133,67 @@
         else:
             myformat = "%Y%m%d"
             if with_time == True:
                 myformat = myformat + "_%H%M%S"
 
         return now.strftime(myformat)        
 
-    def enter_filename_to_save(self, title:str, name:str, extension:str="txt", use_datetime_prefix:bool=True) -> str:
+    def enter_filename_to_save(self, title:str, name:str, extension:str="txt", use_datetime_prefix:bool=True, show_current_path:bool=True) -> str:
+        # current path
+        if show_current_path:
+            cur_path = pathlib.Path().resolve()
+            print(f"Current working directory is {cur_path}")        
+        
+        # prepare filename
         filename = f"{name}"
         if use_datetime_prefix == True:
             filename = self.get_datetime_prefix() + "_" + filename
 
         if filename.find(".") < 0:
             filename = f"{filename}.{extension}"
 
         filename = UserInput(title,filename).get_input(empty_allowed=True)
         if filename == None or len(filename) == 0:
             return None
 
         return filename      
 
+    def enter_filename_to_load(self, title:str, name:str=None, extension:str="txt", show_current_path:bool=True, show_files_with_ext:bool=True) -> str:
+        # current path
+        if show_current_path:
+            cur_path = pathlib.Path().resolve()
+            print(f"Current working directory is {cur_path}")
+
+            if show_files_with_ext and extension != None:
+                relevant_path = str(cur_path)
+                included_extensions = []
+                included_extensions.append(extension.lower())
+                included_extensions.append(extension.upper())
+                file_names = [fn for fn in os.listdir(relevant_path)
+                    if any(fn.endswith(ext) for ext in included_extensions)]
+                
+                if file_names != None and len(file_names) > 0:
+                    print(f"Files found in {cur_path}:\n")
+                    for file_name in file_names:
+                        print(file_name)
+                else:
+                    print(f"No files with extension {extension} found in {cur_path}.")
+
+        # prepare filename    
+        filename = f"{name}"
+        if filename.find(".") < 0:
+            filename = f"{filename}.{extension}"
+
+        filename = UserInput(title,filename).get_input(empty_allowed=True)
+        if filename == None or len(filename) == 0:
+            return None
+
+        return filename      
+
+
     def save_file(self, filename:str, content:str, print_msg:bool=True) -> bool:
         try:
             with open(filename, "w") as text_file:
                 text_file.write(content)
             if print_msg == True:
                 print(f"File saved as {filename}")
             return True
```

## pydeen/websocket.py

```diff
@@ -5,14 +5,15 @@
 from pydeen.types import Auth
 from pydeen.types import Backend
 from pydeen.service import Service
 from pydeen.http import HTTPBackend
 import asyncio
 import websockets
 import time
+import ssl
 
 
 class WebSocketService(Service):
 
     def __init__(self, backend:HTTPBackend, client_id:str=""):
         super().__init__()
         self.type = "pydeen.WebSocketService"
@@ -34,17 +35,23 @@
         # build headers (auth)
         headers = self.headers
         if self.backend.is_auth_info_available() == True:
             auth_headers = self.backend.get_auth_info().get_auth_headers()
             if auth_headers != None:
                 headers = {**headers, **auth_headers}    
 
+        # ssl
+        ssl_ctx = self.backend.get_ssl_verify_mode()
+        if ssl_ctx != None:
+            self.trace(f"SSL context available: {ssl_ctx}")
+
         # connect
         self.trace(f"Start connection to websocket URL {url}...")
-        async with websockets.connect(url, extra_headers=headers) as websocket:
+        # ws = websocket.WebSocket(sslopt={"cert_reqs": ssl.CERT_NONE})
+        async with websockets.connect(url, extra_headers=headers, ssl=ssl_ctx) as websocket:  # vorher websockets
             # save my context
             self.websocket = websocket
             self.trace(f"Connected to Websocket: {url}")            
             self.trace(f"{len(self.actions)} actions and {len(self.commands)} commands are registered")
 
             # send 
             if self.send_connect_msg == True:
```

## Comparing `pydeen-0.8.0.dist-info/LICENSE` & `pydeen-0.9.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pydeen-0.8.0.dist-info/METADATA` & `pydeen-0.9.0.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pydeen
-Version: 0.8.0
+Version: 0.9.0
 Summary: Python Data Engineer Enterprise Notebook
 Author: MDJoerg (Joerg Mueller)
 Author-email: <mdjoerg@joomp.de>
 License: UNKNOWN
 Keywords: python,data,data science,enterprise,analysis,toolbox,notebook
 Platform: UNKNOWN
 Classifier: Development Status :: 2 - Pre-Alpha
@@ -45,14 +45,26 @@
 
 
 This library is still experimental at the moment and is currently being tested by selected people in practical scenarios. A release under an open source license is planned.
 
 
 # CHANGELOG
 
+
+
+0.9.0: 2022-10-05 pandas dataframe integration 
+
+- datahub optimizations (description, integration)
+
+- pandas dataframe file export/import for pickle, csv
+
+- http backend ssl verify mode support
+
+
+
 0.8.0: 2022-09-08 Datahub feature
 
 - NEW: Datahub feature for store multiple data objects in one session 
 
 - NEW: select single entry from record list
 
 - SAPAbapHttpBackend replaces HttpBackend in sap abap scenarios
```

## Comparing `pydeen-0.8.0.dist-info/RECORD` & `pydeen-0.9.0.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,25 +1,26 @@
-pydeen/__init__.py,sha256=ywiWqbR2OmIBHMn_vVJKj93Gjo-TcS9vQnCl9GcXGqE,1265
+pydeen/__init__.py,sha256=QwAEgJmPCx-CUjZ6On8nytNLdnPM6M8pA3p4PcVhckA,1186
 pydeen/auth.py,sha256=F_Tz8ENPJ3yJW7PsE7csI-3s7YoU7ji9JV4HHCdMNEE,11067
 pydeen/cloudevents.py,sha256=fyLLygC-MU3FTOkeWLfZp0rrAzgrFufJeKSyw2BdpzE,11503
 pydeen/const.py,sha256=2UaQwyPtISG38fK6vpVPkfT04bCTrIaGSk1yuw5aMnk,228
-pydeen/core.py,sha256=FVyiV5d77L6NtnIgKVGRRTP8YCu1weK4nK0tec7s8No,2347
+pydeen/core.py,sha256=yzstxMH4iLOq5GhLZx0OZzD_IEHdLsi90jYobSi5iRE,2405
+pydeen/exits.py,sha256=HvQt-03bhe3BnkyWJIxO-4wN-vMPCYUJQNXnOIUMPxM,899
 pydeen/files.py,sha256=z-iqsCEjW2Oey4oZ0Qi07M6xzPjH7LDjBcxrUJw-PlA,596
 pydeen/globals.py,sha256=nWwa813zdhPUxDtHiWzTXdAHRJTmx3jEmyFSgwemLE0,34
-pydeen/http.py,sha256=Lx5uUy45qm3IM3gHlfxza9bAGaf0vitcWizXON-ORog,8038
-pydeen/menu.py,sha256=6dS6J7Y3dr9n2TnyyMu8wmri9PuZiLVJJYuGBjXyMIs,7115
+pydeen/http.py,sha256=X5leN94VzJXdxUklmTb4wQrvcRyykNrbhEK9T5wWi4c,9407
+pydeen/menu.py,sha256=REqH7hola0GkdfItfMEgJrgRKaRuqNXb9qk_IB15KnU,7811
 pydeen/odata.py,sha256=jGzuq-MvYG0xVdpizMbkKkWDOozVgBMDXRo1dyAI-MM,9941
-pydeen/pandas.py,sha256=uXZErXVqUvgvEs8iZcl2Rq_hvnisn3uP8_3acoX57dw,4665
+pydeen/pandas.py,sha256=N4lZLLhVWRX5WHorOlif7kkb6JHDarY_6rW29SkwMtQ,9962
 pydeen/pyodata.py,sha256=btfT5ngkoIzwnS222U7v0ROU5W8shY97L4dv5uiJ7BU,3010
-pydeen/sap_abap.py,sha256=ZFo3VP3G3vB6tIznOcFD6FCpjaFo0Oc-hfetOjZqDcA,34924
-pydeen/sap_deeb.py,sha256=7_ZPzEKfz0noTT6nX6ymoCESnTSfewmoqf5zB7ee3b4,11181
+pydeen/sap_abap.py,sha256=q-Y4wOVH3sDd463b9wJGuO_WensDVFzfjrXI_kzgkes,34932
+pydeen/sap_deeb.py,sha256=pyK0HAl-Ps5Bm9AEhjKat4u8PTFr4mFjhEYfLTklkA0,22616
 pydeen/sap_nwod.py,sha256=e1pZ8kteUCTNNmR3AccOeZRS3Kn_Jr6LB8hW2DV7EB0,966
 pydeen/service.py,sha256=CWbonkG3ntJET1ysjVuFtfGDDvjeFqprKG346lXLeZo,11116
-pydeen/types.py,sha256=4173oudWderrMwaJg7sw8Hd8hlpsn6I5JsnDotAuHec,30551
-pydeen/utils.py,sha256=Dpclk-IAUEIj3NadbP0gF3brkQ_tsYl0lAF_Ro8MFCE,5854
-pydeen/websocket.py,sha256=VOnSNkffmqH_7xunLlruKS7jr1t6LxgKuMTdfXHnIFY,5100
+pydeen/types.py,sha256=Kn0ysDjezAxsRvixjDW05iwOGPhOa-Gj-DffopA0i20,33694
+pydeen/utils.py,sha256=5yD1vlf2mJEHOXI92SDCYDAbVB_xD1V3RU8RgUnCv6g,7601
+pydeen/websocket.py,sha256=5laOocsshtJF3XnasblqW4P5uVdkLBNL7rjqD-21EYI,5380
 pydeen/wsocket.py,sha256=WW-zzKkhJWb3U1p5LD_jQMBO7OSa03lbEP6rOtlFWwM,4919
-pydeen-0.8.0.dist-info/LICENSE,sha256=CmuEMk214D5s53wW6rls5UZ_k3FhotDbhO8qR3o5-u8,1085
-pydeen-0.8.0.dist-info/METADATA,sha256=MhvRTv6bkcr_5acSuFkimRehG5fE0xzIbTWnk7x9XZ4,2950
-pydeen-0.8.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-pydeen-0.8.0.dist-info/top_level.txt,sha256=zYIJhq1Li1HKtFCtGHB-XvfxZ6JYW7CWAkMZKhvhVwY,7
-pydeen-0.8.0.dist-info/RECORD,,
+pydeen-0.9.0.dist-info/LICENSE,sha256=CmuEMk214D5s53wW6rls5UZ_k3FhotDbhO8qR3o5-u8,1085
+pydeen-0.9.0.dist-info/METADATA,sha256=_T3BjoFAdUdg_b-SmJx2okVtlq3vjT6n4vXpncA6DkU,3150
+pydeen-0.9.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+pydeen-0.9.0.dist-info/top_level.txt,sha256=zYIJhq1Li1HKtFCtGHB-XvfxZ6JYW7CWAkMZKhvhVwY,7
+pydeen-0.9.0.dist-info/RECORD,,
```

