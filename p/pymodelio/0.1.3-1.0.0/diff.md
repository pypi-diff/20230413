# Comparing `tmp/pymodelio-0.1.3-py3-none-any.whl.zip` & `tmp/pymodelio-1.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,29 +1,37 @@
-Zip file size: 18309 bytes, number of entries: 27
--rw-r--r--  2.0 unx      401 b- defN 22-Sep-06 22:06 pymodelio/__init__.py
--rw-r--r--  2.0 unx     1053 b- defN 22-Sep-06 22:04 pymodelio/attribute.py
--rw-r--r--  2.0 unx     7290 b- defN 22-Sep-06 22:05 pymodelio/base_model.py
+Zip file size: 21881 bytes, number of entries: 35
+-rw-r--r--  2.0 unx      614 b- defN 23-Apr-13 14:32 pymodelio/__init__.py
+-rw-r--r--  2.0 unx     1744 b- defN 23-Apr-13 15:15 pymodelio/attribute.py
+-rw-r--r--  2.0 unx     8979 b- defN 23-Apr-13 15:04 pymodelio/base_model.py
 -rw-r--r--  2.0 unx       67 b- defN 22-Sep-06 22:04 pymodelio/constants.py
--rw-r--r--  2.0 unx     1632 b- defN 22-Sep-06 22:04 pymodelio/model.py
--rw-r--r--  2.0 unx     1040 b- defN 22-Sep-06 22:04 pymodelio/model_serializer.py
--rw-r--r--  2.0 unx       86 b- defN 22-Sep-06 22:04 pymodelio/undefined.py
+-rw-r--r--  2.0 unx     1489 b- defN 23-Apr-12 22:31 pymodelio/model_serializer.py
+-rw-r--r--  2.0 unx      115 b- defN 23-Apr-13 11:20 pymodelio/shared_vars.py
+-rw-r--r--  2.0 unx       88 b- defN 23-Apr-13 15:15 pymodelio/undefined.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-13 11:20 pymodelio/decorators/__init__.py
+-rw-r--r--  2.0 unx      495 b- defN 23-Apr-12 22:33 pymodelio/decorators/do_not_serialize.py
+-rw-r--r--  2.0 unx     1315 b- defN 23-Apr-13 13:39 pymodelio/decorators/model.py
+-rw-r--r--  2.0 unx      206 b- defN 23-Apr-13 11:21 pymodelio/decorators/overrides_child_always.py
+-rw-r--r--  2.0 unx      230 b- defN 23-Apr-13 11:22 pymodelio/decorators/overrides_child_if_not_implemented.py
 -rw-r--r--  2.0 unx       80 b- defN 22-Sep-06 22:04 pymodelio/exceptions/__init__.py
 -rw-r--r--  2.0 unx       52 b- defN 22-Sep-06 22:04 pymodelio/exceptions/model_validation_exception.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-13 14:15 pymodelio/settings/__init__.py
+-rw-r--r--  2.0 unx      194 b- defN 23-Apr-13 14:14 pymodelio/settings/pymodelio_setting.py
+-rw-r--r--  2.0 unx      854 b- defN 23-Apr-13 15:08 pymodelio/settings/pymodelio_settings.py
 -rw-r--r--  2.0 unx      496 b- defN 22-Sep-06 22:04 pymodelio/validators/__init__.py
 -rw-r--r--  2.0 unx      285 b- defN 22-Sep-06 22:04 pymodelio/validators/bool_validator.py
 -rw-r--r--  2.0 unx      323 b- defN 22-Sep-06 22:04 pymodelio/validators/datetime_validator.py
 -rw-r--r--  2.0 unx      285 b- defN 22-Sep-06 22:04 pymodelio/validators/dict_validator.py
 -rw-r--r--  2.0 unx      752 b- defN 22-Sep-06 22:04 pymodelio/validators/email_validator.py
 -rw-r--r--  2.0 unx      463 b- defN 22-Sep-06 22:04 pymodelio/validators/float_validator.py
 -rw-r--r--  2.0 unx      455 b- defN 22-Sep-06 22:04 pymodelio/validators/int_validator.py
 -rw-r--r--  2.0 unx     1324 b- defN 22-Sep-06 22:04 pymodelio/validators/iterable_validator.py
 -rw-r--r--  2.0 unx      473 b- defN 22-Sep-06 22:04 pymodelio/validators/list_validator.py
 -rw-r--r--  2.0 unx     1007 b- defN 22-Sep-06 22:04 pymodelio/validators/numeric_validator.py
 -rw-r--r--  2.0 unx     1335 b- defN 22-Sep-06 22:04 pymodelio/validators/string_validator.py
 -rw-r--r--  2.0 unx      274 b- defN 22-Sep-06 22:04 pymodelio/validators/validation_patterns.py
 -rw-r--r--  2.0 unx     1368 b- defN 22-Sep-06 22:04 pymodelio/validators/validator.py
--rw-r--r--  2.0 unx     1070 b- defN 22-Sep-06 22:08 pymodelio-0.1.3.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx    18200 b- defN 22-Sep-06 22:08 pymodelio-0.1.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Sep-06 22:08 pymodelio-0.1.3.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 22-Sep-06 22:08 pymodelio-0.1.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2378 b- defN 22-Sep-06 22:08 pymodelio-0.1.3.dist-info/RECORD
-27 files, 42291 bytes uncompressed, 14407 bytes compressed:  65.9%
+-rw-r--r--  2.0 unx     1070 b- defN 23-Apr-13 15:22 pymodelio-1.0.0.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx    19679 b- defN 23-Apr-13 15:22 pymodelio-1.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-13 15:22 pymodelio-1.0.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 23-Apr-13 15:22 pymodelio-1.0.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3142 b- defN 23-Apr-13 15:22 pymodelio-1.0.0.dist-info/RECORD
+35 files, 49355 bytes uncompressed, 16731 bytes compressed:  66.1%
```

## zipnote {}

```diff
@@ -6,29 +6,53 @@
 
 Filename: pymodelio/base_model.py
 Comment: 
 
 Filename: pymodelio/constants.py
 Comment: 
 
-Filename: pymodelio/model.py
+Filename: pymodelio/model_serializer.py
 Comment: 
 
-Filename: pymodelio/model_serializer.py
+Filename: pymodelio/shared_vars.py
 Comment: 
 
 Filename: pymodelio/undefined.py
 Comment: 
 
+Filename: pymodelio/decorators/__init__.py
+Comment: 
+
+Filename: pymodelio/decorators/do_not_serialize.py
+Comment: 
+
+Filename: pymodelio/decorators/model.py
+Comment: 
+
+Filename: pymodelio/decorators/overrides_child_always.py
+Comment: 
+
+Filename: pymodelio/decorators/overrides_child_if_not_implemented.py
+Comment: 
+
 Filename: pymodelio/exceptions/__init__.py
 Comment: 
 
 Filename: pymodelio/exceptions/model_validation_exception.py
 Comment: 
 
+Filename: pymodelio/settings/__init__.py
+Comment: 
+
+Filename: pymodelio/settings/pymodelio_setting.py
+Comment: 
+
+Filename: pymodelio/settings/pymodelio_settings.py
+Comment: 
+
 Filename: pymodelio/validators/__init__.py
 Comment: 
 
 Filename: pymodelio/validators/bool_validator.py
 Comment: 
 
 Filename: pymodelio/validators/datetime_validator.py
@@ -60,23 +84,23 @@
 
 Filename: pymodelio/validators/validation_patterns.py
 Comment: 
 
 Filename: pymodelio/validators/validator.py
 Comment: 
 
-Filename: pymodelio-0.1.3.dist-info/LICENSE.txt
+Filename: pymodelio-1.0.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: pymodelio-0.1.3.dist-info/METADATA
+Filename: pymodelio-1.0.0.dist-info/METADATA
 Comment: 
 
-Filename: pymodelio-0.1.3.dist-info/WHEEL
+Filename: pymodelio-1.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: pymodelio-0.1.3.dist-info/top_level.txt
+Filename: pymodelio-1.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: pymodelio-0.1.3.dist-info/RECORD
+Filename: pymodelio-1.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pymodelio/__init__.py

```diff
@@ -1,18 +1,26 @@
 # flake8: noqa
 
-__version__ = '0.1.3'
+__version__ = '1.0.0'
 
 # constants
 from .constants import UNDEFINED
 
+# Settings
+from .settings.pymodelio_setting import PymodelioSetting
+from .settings.pymodelio_settings import PymodelioSettings
+
+# BaseModel for those who don't like the decorators :'(
+from .base_model import BaseModel
+
 # pymodelio_model decorator
-from .model import pymodelio_model
+from .decorators.model import model
+
+pymodelio_model = model
 
 # Attribute with all aliases
 from .attribute import Attribute
 from .attribute import Attr
 from .attribute import ModelAttribute
 from .attribute import ModelAttr
 
-# BaseModel for those who don't like the decorators :'(
-from .base_model import BaseModel
+from .decorators.do_not_serialize import do_not_serialize
```

## pymodelio/attribute.py

```diff
@@ -1,15 +1,16 @@
 from typing import Generic, Callable, Optional, Any, TypeVar, Type
 
 from pymodelio.validators.validator import Validator
 
 T = TypeVar('T')
 
 
-class Attribute(Generic[T]):
+class GenericAttribute(Generic[T]):
+
     def __init__(self, validator: Optional[Validator] = None, initable: bool = True,
                  default_factory: Callable = None) -> None:
         self._validator = validator
         self._initable = initable
         self._default_factory = default_factory or (lambda: None)
 
     def validate(self, value: Optional[Any], path: str) -> None:
@@ -28,12 +29,31 @@
     def default_factory(self) -> Callable:
         return self._default_factory
 
     @property
     def attr_type(self) -> Type:
         return self.__orig_class__.__args__[0]
 
+    def __getitem__(self, attr_type: T) -> Callable[..., T]:
+        # Only declared for type hinting
+        raise NotImplementedError()
+
+
+# Indirections for type hinting
+class _AttributeRetriever(GenericAttribute):
+    def __getitem__(self, attr_type: T) -> Callable[..., T]:
+        return GenericAttribute[attr_type]
+
+
+PymodelioAttribute = _AttributeRetriever()
+
+# Exposed Attribute and aliases
+"""
+Any of these exposed attributes can be called using this signature:
+
+Attribute(validator: Optional[Validator] = None, initable: bool = True, default_factory: Callable = None)
 
-# Aliases of Attribute class
-Attr = Attribute
-ModelAttribute = Attribute
-ModelAttr = Attribute
+"""
+Attribute: GenericAttribute = PymodelioAttribute
+Attr: GenericAttribute = PymodelioAttribute
+ModelAttribute: GenericAttribute = PymodelioAttribute
+ModelAttr: GenericAttribute = PymodelioAttribute
```

## pymodelio/base_model.py

```diff
@@ -1,12 +1,14 @@
-from typing import List, Any
+from typing import List, Any, Optional
 
-from pymodelio.attribute import Attribute
+from pymodelio import PymodelioSettings, PymodelioSetting
+from pymodelio.attribute import GenericAttribute
 from pymodelio.constants import UNDEFINED
-from pymodelio.model import overrides_child_always, overrides_child_if_not_implemented
+from pymodelio.decorators.overrides_child_always import overrides_child_always
+from pymodelio.decorators.overrides_child_if_not_implemented import overrides_child_if_not_implemented
 from pymodelio.model_serializer import ModelSerializer
 
 
 class BaseModel:
 
     @overrides_child_always
     def __init__(self, *args, auto_validate: bool = True, **kwargs) -> None:
@@ -26,16 +28,16 @@
     @classmethod
     def _is_pymodelio_model(cls) -> bool:
         return True
 
     @overrides_child_always
     def _set_attributes(self, kwargs: dict) -> None:
         for attr_name, model_attr in self._get_model_attrs().items():
-            if not model_attr.initable:
-                if attr_name in kwargs:
+            if not self._is_initable(attr_name, model_attr):
+                if self._get_exposed_attr_name(attr_name) in kwargs:
                     raise NameError(f'{attr_name} attribute is not initable for class {self.__class__.__name__}')
                 continue
             exposed_attr_name = self._get_exposed_attr_name(attr_name)
             attr_value = kwargs.get(exposed_attr_name, model_attr.default_factory())
             if attr_value == UNDEFINED:
                 attr_value = model_attr.default_factory()
             setattr(self, attr_name, attr_value)
@@ -64,18 +66,18 @@
         return annotations
 
     @overrides_child_always
     def _get_model_attrs(self) -> dict:
         validated_attrs = {}
         annotations = self._get_annotations()
         for k, v in annotations.items():
-            if isinstance(v, Attribute):
+            if isinstance(v, GenericAttribute):
                 validated_attrs[k] = v
             # If Validated is a type and not an instance, it instantiates it using default values default
-            elif v.__origin__ == Attribute:
+            elif v.__origin__ == GenericAttribute:
                 validated_attrs[k] = v()
         return validated_attrs
 
     @overrides_child_always
     def _generate_private_attr_prefix(self, cls: type) -> str:
         return f'_{cls.__name__}__'
 
@@ -84,34 +86,68 @@
         # Iterate all the parents
         prefixes = []
         for cls in self.__class__.__bases__:
             prefixes.append(self._generate_private_attr_prefix(cls))
         return prefixes
 
     @overrides_child_always
+    def _get_private_attr_prefixes(self) -> List[str]:
+        return [self._generate_private_attr_prefix(self.__class__)] + self._get_parent_private_attr_prefixes()
+
+    @overrides_child_always
     def _get_exposed_attr_name(self, attr_name: str) -> str:
         # Private attributes
-        private_attr_prefixes = [self._generate_private_attr_prefix(
-            self.__class__)] + self._get_parent_private_attr_prefixes()
-        for private_attr_prefix in private_attr_prefixes:
-            if attr_name.startswith(private_attr_prefix):
-                exposed_attr_name = attr_name[len(private_attr_prefix):]
-                if exposed_attr_name.endswith('__'):
-                    exposed_attr_name = exposed_attr_name[:2]
-                return exposed_attr_name
+        private_attr_prefix = self._get_private_attr_prefix(attr_name)
+        if private_attr_prefix is not None:
+            exposed_attr_name = attr_name[len(private_attr_prefix):]
+            if exposed_attr_name.endswith('__'):
+                exposed_attr_name = exposed_attr_name[:2]
+            return exposed_attr_name
         # Protected attributes
-        if attr_name.startswith('_'):
+        if self._is_protected_attr_name(attr_name, private_checked=True):
             exposed_attr_name = attr_name[1:]
             if exposed_attr_name.endswith('_'):
                 exposed_attr_name = exposed_attr_name[:1]
             return exposed_attr_name
         # Public attributes
         return attr_name
 
     @overrides_child_always
+    def _is_protected_attr_name(self, attr_name: str, private_checked: bool = False) -> bool:
+        if private_checked:
+            is_private = False
+        else:
+            is_private = self._is_private_attr_name(attr_name)
+        return (not is_private) and attr_name.startswith('_')
+
+    @overrides_child_always
+    def _is_private_attr_name(self, attr_name: str) -> bool:
+        return self._get_private_attr_prefix(attr_name) is not None
+
+    @overrides_child_always
+    def _get_private_attr_prefix(self, attr_name: str) -> Optional[str]:
+        private_attr_prefixes = self._get_private_attr_prefixes()
+        for private_attr_prefix in private_attr_prefixes:
+            if attr_name.startswith(private_attr_prefix):
+                return private_attr_prefix
+        return None
+
+    @overrides_child_always
+    def _is_initable(self, attr_name: str, model_attr: GenericAttribute) -> bool:
+        if not model_attr.initable:
+            return False
+        if (not PymodelioSettings.get(PymodelioSetting.INIT_PROTECTED_ATTRS_BY_DEFAULT)) \
+                and self._is_protected_attr_name(attr_name):
+            return False
+        if (not PymodelioSettings.get(PymodelioSetting.INIT_PRIVATE_ATTRS_BY_DEFAULT)) \
+                and self._is_private_attr_name(attr_name):
+            return False
+        return True
+
+    @overrides_child_always
     def validate(self, path: str = None) -> None:
         """
         It must raise ModelValidationException in case of an invalid attribute
         """
         for attr_name, pymodel_attribute in self._get_model_attrs().items():
             attr_value = getattr(self, attr_name)
             exposed_attr_name = self._get_exposed_attr_name(attr_name)
@@ -119,15 +155,15 @@
             attr_path = f'{parent_path}.{exposed_attr_name}'
             self._when_validating_attr(attr_name, exposed_attr_name, attr_value, attr_path, parent_path,
                                        pymodel_attribute)
             pymodel_attribute.validate(attr_value, path=attr_path)
 
     @overrides_child_if_not_implemented
     def _when_validating_attr(self, internal_attr_name: str, exposed_attr_name: str, attr_value: Any, attr_path: str,
-                              parent_path: str, pymodel_attribute: Attribute) -> None:
+                              parent_path: str, pymodel_attribute: GenericAttribute) -> None:
         pass
 
     @overrides_child_if_not_implemented
     @classmethod
     def from_dict(cls, data: dict, auto_validate: bool = True) -> Any:
         instance = cls(from_dict=True)
         attrs = {}
@@ -135,15 +171,15 @@
             exposed_attr_name = instance._get_exposed_attr_name(attr_name)
             if model_attr.initable:
                 attrs[exposed_attr_name] = cls._map_attribute(data, exposed_attr_name, model_attr)
         return cls(**attrs, auto_validate=auto_validate)
 
     @overrides_child_always
     @classmethod
-    def _map_attribute(cls, data: dict, exposed_attr_name: str, model_attr: Attribute) -> Any:
+    def _map_attribute(cls, data: dict, exposed_attr_name: str, model_attr: GenericAttribute) -> Any:
         attr_value = data.get(exposed_attr_name, model_attr.default_factory())
         if attr_value == UNDEFINED:
             return model_attr.default_factory()
         if isinstance(attr_value, dict) and (
                 hasattr(model_attr.attr_type, '_is_pymodelio_model') and model_attr.attr_type._is_pymodelio_model()
         ):
             return model_attr.attr_type.from_dict(attr_value, auto_validate=False)
```

## pymodelio/model_serializer.py

```diff
@@ -1,9 +1,11 @@
 from typing import Any
 
+from pymodelio import shared_vars
+
 
 class ModelSerializer:
 
     @classmethod
     def serialize(cls, value: Any) -> Any:
         if cls._is_model(value):
             return cls._serialize_model(value)
@@ -11,21 +13,30 @@
             return [cls.serialize(x) for x in value]
         return value
 
     @classmethod
     def _serialize_model(cls, model: Any) -> dict:
         serialized = {}
         for attr_name in cls._get_model_attrs(model):
+            if cls._is_marked_as_do_not_serialize(model, attr_name):
+                continue
             attr_value = getattr(model, attr_name)
             # If it is a function, we ignore it
             if callable(attr_value):
                 continue
             serialized[attr_name] = cls.serialize(attr_value)
         return serialized
 
     @classmethod
+    def _is_marked_as_do_not_serialize(cls, model: Any, attr_name: str) -> bool:
+        class_qualname = model.__class__.__qualname__
+        if class_qualname not in shared_vars.to_do_not_serialize:
+            return False
+        return attr_name in shared_vars.to_do_not_serialize[class_qualname]
+
+    @classmethod
     def _get_model_attrs(cls, model: Any) -> dict:
         return [attr_name for attr_name in dir(model) if not attr_name.startswith('_')]
 
     @classmethod
     def _is_model(cls, attr_value: Any) -> bool:
         return hasattr(attr_value, '_is_pymodelio_model') and getattr(attr_value, '_is_pymodelio_model')()
```

## pymodelio/undefined.py

```diff
@@ -1,4 +1,4 @@
 class Undefined:
 
     def __repr__(self) -> str:
-        return 'pymodelio.undefined'
+        return '<pymodelio.UNDEFINED>'
```

## Comparing `pymodelio/model.py` & `pymodelio/decorators/model.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,44 +1,35 @@
-from typing import Callable
+from typing import TypeVar
 
-base_model_overrides_child_always = []
-base_model_overrides_child_if_not_implemented = []
+from pymodelio import shared_vars
 
+T = TypeVar('T')
 
-def overrides_child_always(method: Callable) -> Callable:
-    base_model_overrides_child_always.append(method)
-    return method
 
-
-def overrides_child_if_not_implemented(method: Callable) -> Callable:
-    base_model_overrides_child_if_not_implemented.append(method)
-    return method
-
-
-def pymodelio_model(cls: type) -> type:
+def model(cls: T) -> T:
     """
     Transforms a python class in a pymodelio model.
     Original class constructor is overridden and these methods are allowed to be implemented by the model:
 
     * def __before_init__(self, *args, **kwargs) -> None
     * def __before_validate__(self) -> None
     * def __once_validated__(self) -> None
     * def _when_validating_attr(self, internal_attr_name: str, exposed_attr_name: str, attr_value: Any, attr_path: str,
                               parent_path: str, pymodel_attribute: Attribute) -> None
     * to_dict(self) -> dict:
 
     :param cls: Class to be transformed into a pymodelio model
     """
-    for method in base_model_overrides_child_always:
+    for method in shared_vars.base_model_overrides_child_always:
         if isinstance(method, classmethod):
             method_name = method.__func__.__name__
         else:
             method_name = method.__name__
         setattr(cls, method_name, method)
-    for method in base_model_overrides_child_if_not_implemented:
+    for method in shared_vars.base_model_overrides_child_if_not_implemented:
         if isinstance(method, classmethod):
             method_name = method.__func__.__name__
         else:
             method_name = method.__name__
         if not hasattr(cls, method_name):
             setattr(cls, method_name, method)
```

## Comparing `pymodelio-0.1.3.dist-info/LICENSE.txt` & `pymodelio-1.0.0.dist-info/LICENSE.txt`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 MIT License
 
-Copyright (c) 2022 Gabriel Moran
+Copyright (c) 2023 Gabriel Moran
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
```

## Comparing `pymodelio-0.1.3.dist-info/METADATA` & `pymodelio-1.0.0.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pymodelio
-Version: 0.1.3
+Version: 1.0.0
 Summary: A simple Python module for defining domain models, serializing, deserializing and validating them
 Home-page: https://github.com/GabrielMartinMoran/pymodelio
 Author: Gabriel Martín Moran
 Author-email: moran.gabriel.95@gmail.com
 License: UNKNOWN
 Platform: UNKNOWN
 Description-Content-Type: text/markdown
@@ -40,55 +40,55 @@
 the decorator way it's used for not complicating the inheritance tree, but it would be the same if instead of using the
 decorator in each model, we just declare `Component` class as `class Component(BaseModel)`.
 
 ```py
 import uuid
 from typing import List
 
-from pymodelio.attribute import Attribute
-from pymodelio.model import pymodelio_model
+import pymodelio
+from pymodelio import Attribute
 from pymodelio.validators import ListValidator, StringValidator
 from pymodelio.validators.int_validator import IntValidator
 from pymodelio.validators.validator import Validator
 
 
-@pymodelio_model
+@pymodelio.model
 class Component:
     __serial_no: Attribute[str](
         validator=StringValidator(fixed_len=36, regex=r'^[a-z0-9-]+$'),
         default_factory=lambda: uuid.uuid4().__str__()
     )
 
     @property
     def serial_no(self) -> str:
         return self.__serial_no
 
 
-@pymodelio_model
+@pymodelio.model
 class CPU(Component):
     _frequency: Attribute[int](validator=IntValidator(min_value=0))
     cores: Attribute[int](validator=IntValidator(min_value=0))
 
     @property
     def frequency(self) -> int:
         return self._frequency
 
 
-@pymodelio_model
+@pymodelio.model
 class RAM(Component):
     frequency: Attribute[int](validator=IntValidator(min_value=0))
     size: Attribute[int](validator=IntValidator(min_value=0))
 
 
-@pymodelio_model
+@pymodelio.model
 class Disk(Component):
     size: Attribute[int](validator=IntValidator(min_value=0))
 
 
-@pymodelio_model
+@pymodelio.model
 class Computer(Component):
     _cpu: Attribute[CPU](validator=Validator(expected_type=CPU))
     _rams: Attribute[List[RAM]](validator=ListValidator(elements_type=RAM, allow_empty=False))
     _disks: Attribute[List[Disk]](validator=ListValidator(elements_type=Disk))
 
     @property
     def cpu(self) -> CPU:
@@ -160,19 +160,48 @@
 **Why is it doing that?**
 
 Some known Python modules that do similar things like pymodelio forces you to specify the protected or private
 attributes by passing some parameter in the type or validator description. The idea of pymodelio is to let you use the
 language conventions for defining that without losing the capability of automatically handling initialization if you
 want that.
 
+This module hugs the open/closed principle by allowing you to not define all your attributes public, but also letting
+you initialize them in their public form (based on python code writing conventions).
+
+**Wait! I don't want that! how can I disable it?**
+
 You can always specify which attributes are not exposed by the constructor using their public form by passing the
 parameter `initable=False` to the Attribute constructor.
 
-This module hugs the open/closed principle by allowing you to not define all your attributes public, but also letting
-you initialize them in their public form (based on python code writing conventions).
+Also, there is a global way of disabling this behaviour. You can configure `PymodelioSettings` for avoiding unwanted
+behaviours in this way:
+
+```py
+from pymodelio import PymodelioSettings
+from pymodelio import PymodelioSetting
+
+# This line will disable automatic protected attributes initialization (all attributes that start with '_')
+PymodelioSettings.set(PymodelioSetting.INIT_PROTECTED_ATTRS_BY_DEFAULT, False)
+
+# This line will disable automatic private attributes initialization (all attributes that start with '__')
+PymodelioSettings.set(PymodelioSetting.INIT_PRIVATE_ATTRS_BY_DEFAULT, False)
+```
+
+In case you want to get a value of a `PymodelioSetting`, you can do this:
+
+```py
+from pymodelio import PymodelioSettings
+from pymodelio import PymodelioSetting
+
+PymodelioSettings.get(PymodelioSetting.INIT_PROTECTED_ATTRS_BY_DEFAULT)  # True by default
+
+PymodelioSettings.get(PymodelioSetting.INIT_PRIVATE_ATTRS_BY_DEFAULT)  # True by default
+```
+
+**Let's talk about attribute's validation**
 
 Other great principle where this module is stood on, is that an instance of a domain model shouldn't exist if it is not
 valid. For ensuring that, pymodelio automatically validates the instantiated models if you don't specify the opposite (
 by passing the parameter `auto_validate=False`). So have in mind that for performance improvements, we could disable
 auto validation in nested models initialization when using the constructor way of instantiating the `Computer` because
 when the parent validator is called, it will validate the whole structure. Here you have the modified code:
 
@@ -203,15 +232,15 @@
 initialization methods. If you are interested on this, please scroll down until you find the *validation* section.
 
 ### Customizing the model's initialization workflow
 
 ```py
 @pymodelio_model
 class Model:
-    model_attr: Attribute[str]
+    model_attr: Attribute[str]()
 
     @classmethod
     def __before_init__(cls, *args, **kwargs) -> None:
         # This method is called before everything when the model constructor is called
         # It receives the same parameters the constructor gets
         pass
 
@@ -256,16 +285,16 @@
 When defining a protected or private model attribute with underscore or double underscore respectively, if that property
 can be set by the model constructor, it's value will be obtained from an attribute with the same name but without
 underscores. For instance:
 
 ```py
 @pymodelio_model
 class Component:
-    __serial_no: Attribute[str]
-    _model_name: Attribute[str]
+    __serial_no: Attribute[str]()
+    _model_name: Attribute[str]()
 
     @property
     def serial_no(self) -> str:
         return self.__serial_no
 
     @property
     def model_name(self) -> str:
@@ -425,14 +454,33 @@
 
 ```py
 def to_dict(self) -> dict:
     return {}  # Returns the serialized model
 
 ```
 
+In case of properties (defined using the `property` decorator) that you don't want to serialize, you can use the
+`@do_not_serialize` decorator like this:
+
+```py
+@pymodelio.model
+class Person:
+    _name: Attribute[str]()
+
+    @property
+    def name(self) -> str:
+        return self._name
+
+    @property
+    @pymodelio.do_not_serialize
+    def lowercase_name(self) -> str:
+        # This property won't be automatically serialized
+        return self._name.lower()
+```
+
 For de-serialization, pymodelio models implement a `from_dict()` factory constructor that as it name says, it can be
 used
 for decoding python dictionaries into model instances as used in the first example shown. As `to_dict()`, `from_dict()`
 can also be implemented by a model and in that case, the model one will be used instead. The signature for overriding
 this method should be:
 
 ```py
@@ -497,15 +545,15 @@
         self.child_model_attr.validate()
 
         assert isinstance(self.children_model_attr, list), 'children_model_attr is not a valid list'
         for child_model in self.children_model_attr:
             child_model.validate()
 
         assert isinstance(self.__private_attr, datetime), '__private_attr is not a valid datetime'
-        
+
         assert isinstance(self.optional_attr, dict), 'optional_attr is not a valid dict'
 ```
 
 ### Using pymodelio
 
 pymodelio model validation errors also give more information about the full path of nested structures. In case of lists,
 including the index of the list element where the error occurred.
```

## Comparing `pymodelio-0.1.3.dist-info/RECORD` & `pymodelio-1.0.0.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-pymodelio/__init__.py,sha256=K9xdTac_iRMJk96MywlewiCK-FO-rC8uItRYy6AJJn4,401
-pymodelio/attribute.py,sha256=gf_cGFxzWmq4mxGC1B6FwmoUwW4xhj6UDwu53a3Gd6U,1053
-pymodelio/base_model.py,sha256=v_m3QRcNRkzUNDeW0kZBaB5pc6yUGWui6wtOEDt-OZg,7290
+pymodelio/__init__.py,sha256=vncU2bJl2eB5Vj6V0MdzKJVVZX18ckvHxqtG1y3Q4H0,614
+pymodelio/attribute.py,sha256=thQZtwQYC0fbw5RaTUTONzE8iLLwfURTpyJx_6wpQIw,1744
+pymodelio/base_model.py,sha256=TzaK3bo7ptBFKClxggkJUb1WYybq3TKDb6AepObxB3o,8979
 pymodelio/constants.py,sha256=qDMrr5LAO8nm9yVfWJbCJ6MV9WenSypNm4GBVopNgwY,67
-pymodelio/model.py,sha256=kJfUL8WIOrrE7KKj2ZdKm8sC97cM3gP6QdWXC0TXMg0,1632
-pymodelio/model_serializer.py,sha256=4njPOMCRojHppLij9_9njleSlLq4IylNqA6CN4TCyG8,1040
-pymodelio/undefined.py,sha256=FCCJeartC8NWruPwuFYtJc8mZFhBz9NnH1NGW25K-5I,86
+pymodelio/model_serializer.py,sha256=iRXVXfDCMJlKjsCKBemXwlciLheE6Ojsu0VDU0my4tE,1489
+pymodelio/shared_vars.py,sha256=wRZmgVx1Y49mcwOLdIdkLCfpDlLsk4WhKflTDqlvH8o,115
+pymodelio/undefined.py,sha256=dvmNY7_3EmfidEGomJNzWXkOdbg8VfJski1t05mniH0,88
+pymodelio/decorators/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pymodelio/decorators/do_not_serialize.py,sha256=4XoufTgS3g0HYSPVc-8_oYKMMf3d1XYIJgF5Bz3-kp8,495
+pymodelio/decorators/model.py,sha256=vY29pSXx-GbUS1RZjy5mSR6juxyGoGMRjrWf0mbbo1k,1315
+pymodelio/decorators/overrides_child_always.py,sha256=GluQ3E40hLvjDoE0zmbhV7CI1raGD2J-sBmlyOPpXps,206
+pymodelio/decorators/overrides_child_if_not_implemented.py,sha256=Pc2wNurXWgFxGgQZsFoNhhiRl9iFHbP73TXmiUaViMk,230
 pymodelio/exceptions/__init__.py,sha256=n6flrcyGG9PMIpEzrmV9DdHd4-H4-P-Zmlr__HeYnQM,80
 pymodelio/exceptions/model_validation_exception.py,sha256=JfxWxtfdT3Y6ruigYs8X8usBIJC4dwSte3r7oPGUxb8,52
+pymodelio/settings/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+pymodelio/settings/pymodelio_setting.py,sha256=YpbyfSTT2T1kDUdc55OYtGe5WJMEbSIXP-297jBQ0jE,194
+pymodelio/settings/pymodelio_settings.py,sha256=F21ezhmXJAy7RgxeSnJk76qUy_-fYcvChJm-gJQHx_M,854
 pymodelio/validators/__init__.py,sha256=0pv7D0MoxYiiWjfPt0-g7ydUFhmIjXnJSJagZXkrO5g,496
 pymodelio/validators/bool_validator.py,sha256=KHTd2I0QRUX-8Lcrxvtg1wqLZvsMotlwv1VpCiZi-cc,285
 pymodelio/validators/datetime_validator.py,sha256=TZ9Pt_zJZT49OIhAZyf7U37bKWesHQXpJoy6bg6mCjc,323
 pymodelio/validators/dict_validator.py,sha256=Y_NmLEFdySBbuDcEdbPCVRF3Sf_mrnyUbdROA8zwSTk,285
 pymodelio/validators/email_validator.py,sha256=xFHPHRNoznLWnd8QVuEbH9BSJxnoszR1RgdkOVCXwN0,752
 pymodelio/validators/float_validator.py,sha256=LOy0OEYn7_7FxILFVngYd24gYEeUF6D5IFJCc44PVXI,463
 pymodelio/validators/int_validator.py,sha256=_3TJIKZN9G8wprtizbV4JgBiNX2rvsiZmugHjRcno54,455
 pymodelio/validators/iterable_validator.py,sha256=tiOeDhC_mOFQuFAW9NvA5UgapKRnINIzJI6LeGMcvfQ,1324
 pymodelio/validators/list_validator.py,sha256=T5-7KDGyLsg8o7WFAO7djOkKLGrmqzb9Q8Pv2TcvuvY,473
 pymodelio/validators/numeric_validator.py,sha256=74YJ2cYT-EGMEnk1_1NAmU1dCB-e1QTObEtz2eGfoVM,1007
 pymodelio/validators/string_validator.py,sha256=b3g0H9Z8kaVql2KPzs0JRG2-NDmzvJeCijFfzb9A8G8,1335
 pymodelio/validators/validation_patterns.py,sha256=-gSYH0dt_J-K2A10VeAv6bEIi4TRV8x8OWLkYuLZrk4,274
 pymodelio/validators/validator.py,sha256=kxX8w7nhSf1K460ypwyeEqmPEsHwrxTGax_SRDqgFu8,1368
-pymodelio-0.1.3.dist-info/LICENSE.txt,sha256=p-jB9NJz5GPwRHA9hSwjOhEsFqU9p1p6V27TveVh0wA,1070
-pymodelio-0.1.3.dist-info/METADATA,sha256=x8oIrBYl7U6OAna1Tr0uBHOSPytPDHNTrBPx6HBACh0,18200
-pymodelio-0.1.3.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-pymodelio-0.1.3.dist-info/top_level.txt,sha256=XrPsEjrAMkBQoxcrC6tFQs-EiY6TbHuDV5I68o5ZZyE,10
-pymodelio-0.1.3.dist-info/RECORD,,
+pymodelio-1.0.0.dist-info/LICENSE.txt,sha256=sL92kzk5LocRUegJuJvjbS-U5nceM2IAKHEUIavtJ90,1070
+pymodelio-1.0.0.dist-info/METADATA,sha256=KPwCGL-saUOtFigwMI3TrmFR94W0_5fXe1HQeEYdqes,19679
+pymodelio-1.0.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+pymodelio-1.0.0.dist-info/top_level.txt,sha256=XrPsEjrAMkBQoxcrC6tFQs-EiY6TbHuDV5I68o5ZZyE,10
+pymodelio-1.0.0.dist-info/RECORD,,
```

