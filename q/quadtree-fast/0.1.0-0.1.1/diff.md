# Comparing `tmp/quadtree_fast-0.1.0.tar.gz` & `tmp/quadtree_fast-0.1.1.tar.gz`

## Comparing `quadtree_fast-0.1.0.tar` & `quadtree_fast-0.1.1.tar`

### file list

```diff
@@ -1,10 +1,9 @@
--rw-r--r--   0        0        0      315 1970-01-01 00:00:00.000000 quadtree_fast-0.1.0/Cargo.toml
--rw-r--r--   0        0        0     2929 2023-04-12 00:53:11.000000 quadtree_fast-0.1.0/.github/workflows/CI.yml
--rw-r--r--   0        0        0      756 2023-04-12 00:53:11.000000 quadtree_fast-0.1.0/.gitignore
--rw-r--r--   0        0        0        0 2023-04-12 02:49:51.000000 quadtree_fast-0.1.0/py.typed
--rw-r--r--   0        0        0      391 2023-04-12 03:24:57.000000 quadtree_fast-0.1.0/pyproject.toml
--rw-r--r--   0        0        0     2011 2023-04-12 03:07:59.000000 quadtree_fast-0.1.0/quadtree-fast.pyi
--rw-r--r--   0        0        0     8182 2023-04-12 03:07:04.000000 quadtree_fast-0.1.0/src/lib.rs
--rw-r--r--   0        0        0      528 2023-04-12 03:10:09.000000 quadtree_fast-0.1.0/test.py
--rw-r--r--   0        0        0     7934 2023-04-12 00:53:11.000000 quadtree_fast-0.1.0/Cargo.lock
--rw-r--r--   0        0        0      262 1970-01-01 00:00:00.000000 quadtree_fast-0.1.0/PKG-INFO
+-rw-r--r--   0        0        0      302 1970-01-01 00:00:00.000000 quadtree_fast-0.1.1/Cargo.toml
+-rw-r--r--   0     1001      123     2809 2023-04-13 18:32:03.000000 quadtree_fast-0.1.1/.github/workflows/CI.yml
+-rw-r--r--   0     1001      123      685 2023-04-13 18:32:03.000000 quadtree_fast-0.1.1/.gitignore
+-rw-r--r--   0     1001      123        0 2023-04-13 18:32:03.000000 quadtree_fast-0.1.1/py.typed
+-rw-r--r--   0     1001      123      375 2023-04-13 18:32:03.000000 quadtree_fast-0.1.1/pyproject.toml
+-rw-r--r--   0     1001      123     1948 2023-04-13 18:32:03.000000 quadtree_fast-0.1.1/quadtree-fast.pyi
+-rw-r--r--   0     1001      123     7891 2023-04-13 18:32:03.000000 quadtree_fast-0.1.1/src/lib.rs
+-rw-r--r--   0     1001      123     7652 2023-04-13 18:32:39.000000 quadtree_fast-0.1.1/Cargo.lock
+-rw-r--r--   0        0        0      262 1970-01-01 00:00:00.000000 quadtree_fast-0.1.1/PKG-INFO
```

### Comparing `quadtree_fast-0.1.0/.github/workflows/CI.yml` & `quadtree_fast-0.1.1/.github/workflows/CI.yml`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,120 +1,120 @@
-# This file is autogenerated by maturin v0.14.17
-# To update, run
-#
-#    maturin generate-ci github
-#
-name: CI
-
-on:
-  push:
-    branches:
-      - main
-      - master
-    tags:
-      - '*'
-  pull_request:
-  workflow_dispatch:
-
-permissions:
-  contents: read
-
-jobs:
-  linux:
-    runs-on: ubuntu-latest
-    strategy:
-      matrix:
-        target: [x86_64, x86, aarch64, armv7, s390x, ppc64le]
-    steps:
-      - uses: actions/checkout@v3
-      - uses: actions/setup-python@v4
-        with:
-          python-version: '3.10'
-      - name: Build wheels
-        uses: PyO3/maturin-action@v1
-        with:
-          target: ${{ matrix.target }}
-          args: --release --out dist --find-interpreter
-          sccache: 'true'
-          manylinux: auto
-      - name: Upload wheels
-        uses: actions/upload-artifact@v3
-        with:
-          name: wheels
-          path: dist
-
-  windows:
-    runs-on: windows-latest
-    strategy:
-      matrix:
-        target: [x64, x86]
-    steps:
-      - uses: actions/checkout@v3
-      - uses: actions/setup-python@v4
-        with:
-          python-version: '3.10'
-          architecture: ${{ matrix.target }}
-      - name: Build wheels
-        uses: PyO3/maturin-action@v1
-        with:
-          target: ${{ matrix.target }}
-          args: --release --out dist --find-interpreter
-          sccache: 'true'
-      - name: Upload wheels
-        uses: actions/upload-artifact@v3
-        with:
-          name: wheels
-          path: dist
-
-  macos:
-    runs-on: macos-latest
-    strategy:
-      matrix:
-        target: [x86_64, aarch64]
-    steps:
-      - uses: actions/checkout@v3
-      - uses: actions/setup-python@v4
-        with:
-          python-version: '3.10'
-      - name: Build wheels
-        uses: PyO3/maturin-action@v1
-        with:
-          target: ${{ matrix.target }}
-          args: --release --out dist --find-interpreter
-          sccache: 'true'
-      - name: Upload wheels
-        uses: actions/upload-artifact@v3
-        with:
-          name: wheels
-          path: dist
-
-  sdist:
-    runs-on: ubuntu-latest
-    steps:
-      - uses: actions/checkout@v3
-      - name: Build sdist
-        uses: PyO3/maturin-action@v1
-        with:
-          command: sdist
-          args: --out dist
-      - name: Upload sdist
-        uses: actions/upload-artifact@v3
-        with:
-          name: wheels
-          path: dist
-
-  release:
-    name: Release
-    runs-on: ubuntu-latest
-    if: "startsWith(github.ref, 'refs/tags/')"
-    needs: [linux, windows, macos, sdist]
-    steps:
-      - uses: actions/download-artifact@v3
-        with:
-          name: wheels
-      - name: Publish to PyPI
-        uses: PyO3/maturin-action@v1
-        env:
-          MATURIN_PYPI_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
-        with:
-          command: upload
-          args: --skip-existing *
+# This file is autogenerated by maturin v0.14.17
+# To update, run
+#
+#    maturin generate-ci github
+#
+name: CI
+
+on:
+  push:
+    branches:
+      - main
+      - master
+    tags:
+      - '*'
+  pull_request:
+  workflow_dispatch:
+
+permissions:
+  contents: read
+
+jobs:
+  linux:
+    runs-on: ubuntu-latest
+    strategy:
+      matrix:
+        target: [x86_64, x86, aarch64, armv7, s390x, ppc64le]
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          python-version: '3.10'
+      - name: Build wheels
+        uses: PyO3/maturin-action@v1
+        with:
+          target: ${{ matrix.target }}
+          args: --release --out dist --find-interpreter
+          sccache: 'true'
+          manylinux: auto
+      - name: Upload wheels
+        uses: actions/upload-artifact@v3
+        with:
+          name: wheels
+          path: dist
+
+  windows:
+    runs-on: windows-latest
+    strategy:
+      matrix:
+        target: [x64, x86]
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          python-version: '3.10'
+          architecture: ${{ matrix.target }}
+      - name: Build wheels
+        uses: PyO3/maturin-action@v1
+        with:
+          target: ${{ matrix.target }}
+          args: --release --out dist --find-interpreter
+          sccache: 'true'
+      - name: Upload wheels
+        uses: actions/upload-artifact@v3
+        with:
+          name: wheels
+          path: dist
+
+  macos:
+    runs-on: macos-latest
+    strategy:
+      matrix:
+        target: [x86_64, aarch64]
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-python@v4
+        with:
+          python-version: '3.10'
+      - name: Build wheels
+        uses: PyO3/maturin-action@v1
+        with:
+          target: ${{ matrix.target }}
+          args: --release --out dist --find-interpreter
+          sccache: 'true'
+      - name: Upload wheels
+        uses: actions/upload-artifact@v3
+        with:
+          name: wheels
+          path: dist
+
+  sdist:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - name: Build sdist
+        uses: PyO3/maturin-action@v1
+        with:
+          command: sdist
+          args: --out dist
+      - name: Upload sdist
+        uses: actions/upload-artifact@v3
+        with:
+          name: wheels
+          path: dist
+
+  release:
+    name: Release
+    runs-on: ubuntu-latest
+    if: "startsWith(github.ref, 'refs/tags/')"
+    needs: [linux, windows, macos, sdist]
+    steps:
+      - uses: actions/download-artifact@v3
+        with:
+          name: wheels
+      - name: Publish to PyPI
+        uses: PyO3/maturin-action@v1
+        env:
+          MATURIN_PYPI_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
+        with:
+          command: upload
+          args: --skip-existing *
```

### Comparing `quadtree_fast-0.1.0/quadtree-fast.pyi` & `quadtree_fast-0.1.1/quadtree-fast.pyi`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,64 +1,64 @@
-class Point(object):
-    """
-    2D point with optional data attachment.
-    """
-    x: float
-    y: float
-
-    def __init__(self, x: float, y: float, data: any = None) -> Point: ...
-    def __str__(self) -> str: ...
-    def __repr__(self) -> str: ...
-    def distance_to(self, other: Point) -> float:
-        """
-        Calculates the distance to another Point.
-        """
-
-class Rect(object):
-    """
-    Rectangle.
-    """
-
-    def __init__(self, center_x: float, center_y: float, width: float, height: float) -> Rect:
-        """
-        Creates a new rectangle given the center x and y coordinates and the width and height to expand outwards.
-        """
-    
-    def contains(self, point: Point) -> bool:
-        """
-        Returns whether the point is inside of the rectangle.
-        """
-    
-    def intersects(self, rect: Rect) -> bool:
-        """
-        Returns whether the rectangle intersects another rectangle.
-        """
-
-class QuadTree(object):
-    """
-    Quadtree for spatial indexing based on https://scipython.com/blog/quadtrees-2-implementation-in-python/.
-    """
-
-    def __init__(self, boundary: Rect, max_points: int, depth: int) -> QuadTree:
-        """
-        Creates a new quadtree with the specified boundary and maximum number of points in the node.
-        """
-    
-    def insert(self, point: Point) -> bool:
-        """
-        Attempts to insert the point in the quadtree or a subtree and returns if successful or not.
-        """
-    
-    def query_rect(self, boundary: Rect) -> list[Point]:
-        """
-        Finds and returns all points within the specified rectangular boundary.
-        """
-    
-    def query_radius(self, center_x: float, center_y: float, radius: float) -> list[Point]:
-        """
-        Finds and returns all points within the specified circular boundary.
-        """
-    
-    def __len__(self) -> int:
-        """
-        Returns the number of points in the quadtree.
+class Point(object):
+    """
+    2D point with optional data attachment.
+    """
+    x: float
+    y: float
+
+    def __init__(self, x: float, y: float, data: any = None) -> Point: ...
+    def __str__(self) -> str: ...
+    def __repr__(self) -> str: ...
+    def distance_to(self, other: Point) -> float:
+        """
+        Calculates the distance to another Point.
+        """
+
+class Rect(object):
+    """
+    Rectangle.
+    """
+
+    def __init__(self, center_x: float, center_y: float, width: float, height: float) -> Rect:
+        """
+        Creates a new rectangle given the center x and y coordinates and the width and height to expand outwards.
+        """
+    
+    def contains(self, point: Point) -> bool:
+        """
+        Returns whether the point is inside of the rectangle.
+        """
+    
+    def intersects(self, rect: Rect) -> bool:
+        """
+        Returns whether the rectangle intersects another rectangle.
+        """
+
+class QuadTree(object):
+    """
+    Quadtree for spatial indexing based on https://scipython.com/blog/quadtrees-2-implementation-in-python/.
+    """
+
+    def __init__(self, boundary: Rect, max_points: int, depth: int) -> QuadTree:
+        """
+        Creates a new quadtree with the specified boundary and maximum number of points in the node.
+        """
+    
+    def insert(self, point: Point) -> bool:
+        """
+        Attempts to insert the point in the quadtree or a subtree and returns if successful or not.
+        """
+    
+    def query_rect(self, boundary: Rect) -> list[Point]:
+        """
+        Finds and returns all points within the specified rectangular boundary.
+        """
+    
+    def query_radius(self, center_x: float, center_y: float, radius: float) -> list[Point]:
+        """
+        Finds and returns all points within the specified circular boundary.
+        """
+    
+    def __len__(self) -> int:
+        """
+        Returns the number of points in the quadtree.
         """
```

### Comparing `quadtree_fast-0.1.0/src/lib.rs` & `quadtree_fast-0.1.1/src/lib.rs`

 * *Files 13% similar despite different names*

```diff
@@ -1,290 +1,288 @@
-use std::vec;
-
-use pyo3::prelude::*;
-
-#[pyclass]
-#[derive(Clone)]
-struct Point {
-    #[pyo3(get)]
-    x: f32,
-    #[pyo3(get)]
-    y: f32,
-    #[pyo3(get)]
-    data: Option<PyObject>
-}
-
-#[pyclass]
-#[derive(Clone)]
-struct Rect {
-    center_x: f32,
-    center_y: f32,
-    width: f32,
-    height: f32,
-    west_edge: f32,
-    east_edge: f32,
-    north_edge: f32,
-    south_edge: f32
-}
-
-#[pyclass]
-struct QuadTree {
-    boundary: Rect,
-    max_points: usize,
-    points: Vec<Point>,
-    depth: u32,
-    divided: bool,
-    north_west: Option<Box<Self>>,
-    north_east: Option<Box<Self>>,
-    south_east: Option<Box<Self>>,
-    south_west: Option<Box<Self>>,
-}
-
-#[pymethods]
-impl Point {
-    #[new]
-    fn __new__(x: f32, y: f32, data: Option<PyObject>) -> Self {
-        return Self {
-            x, y, data
-        }
-    }
-
-    fn __repr__(&self) -> String {
-        if let Some(data) = &self.data {
-            std::format!("Point(x={}, y={}, data={})", self.x, self.y, data)
-        } else {
-            std::format!("Point(x={}, y={})", self.x, self.y)
-        }
-    }
-
-    fn __str__(&self) -> String {
-        return self.__repr__()
-    }
-
-    fn distance_to(&self, other: &Point) -> f32 {
-        let x_diff = self.x - other.x;
-        let y_diff = self.y - other.y;
-
-        f32::sqrt(x_diff*x_diff + y_diff*y_diff)
-    }
-}
-
-#[pymethods]
-impl Rect {
-    #[new]
-    fn __new__(center_x: f32, center_y: f32, width: f32, height: f32) -> Self {
-        let west_edge = center_x - (width / 2.);
-        let east_edge = center_x + (width / 2.);
-        let north_edge = center_y - (height / 2.);
-        let south_edge = center_y + (height / 2.);
-
-        Self {
-            center_x,
-            center_y,
-            width,
-            height,
-            west_edge,
-            east_edge,
-            north_edge,
-            south_edge
-        }
-    }
-
-    fn contains(&self, point: &Point) -> bool {
-        point.x >= self.west_edge
-        && point.x < self.east_edge
-        && point.y >= self.north_edge
-        && point.y < self.south_edge
-    }
-
-    fn intersects(&self, rect: &Rect) -> bool {
-        !(
-            rect.west_edge > self.east_edge
-            || rect.east_edge < self.west_edge
-            || rect.north_edge > self.south_edge
-            || rect.south_edge < self.north_edge
-        )
-    }
-}
-
-#[pymethods]
-impl QuadTree {
-    #[new]
-    fn __new__(boundary: Rect, max_points: usize, depth: u32) -> Self {
-        Self {
-            boundary,
-            max_points,
-            depth,
-            divided: false,
-            points: vec![],
-            north_east: None,
-            north_west: None,
-            south_east: None,
-            south_west: None
-        }
-    }
-
-    fn __len__(&self) -> usize {
-        let mut result = self.points.len();
-
-        if self.divided {
-            if let Some(north_east) = &self.north_east {
-                result += north_east.__len__();
-            }
-
-            if let Some(north_west) = &self.north_west {
-                result += north_west.__len__();
-            }
-
-            if let Some(south_east) = &self.south_east {
-                result += south_east.__len__();
-            }
-
-            if let Some(south_west) = &self.south_west {
-                result += south_west.__len__();
-            }
-        }
-
-        result
-    }
-
-    fn divide(&mut self) {
-        let center_x = self.boundary.center_x;
-        let center_y = self.boundary.center_y;
-        let width = self.boundary.width / 2.;
-        let height = self.boundary.height / 2.;
-
-        let boundary = Rect::__new__(
-            center_x - width / 2.,
-            center_y - height / 2.,
-            width, height);
-        let north_west = QuadTree::__new__(
-            boundary,
-            self.max_points, self.depth + 1);
-
-        let boundary = Rect::__new__(
-            center_x + width / 2.,
-            center_y - height / 2.,
-            width, height);
-        let north_east = QuadTree::__new__(
-            boundary,
-            self.max_points, self.depth + 1);
-
-        let boundary = Rect::__new__(
-            center_x + width / 2.,
-            center_y + height / 2.,
-            width, height);
-        let south_east = QuadTree::__new__(
-            boundary,
-            self.max_points, self.depth + 1);
-
-        let boundary = Rect::__new__(
-            center_x - width / 2.,
-            center_y + height / 2.,
-            width, height);
-        let south_west = QuadTree::__new__(
-            boundary,
-            self.max_points, self.depth + 1);
-
-        self.north_west = Some(Box::new(north_west));
-        self.north_east = Some(Box::new(north_east));
-        self.south_east = Some(Box::new(south_east));
-        self.south_west = Some(Box::new(south_west));
-
-        self.divided = true;
-    }
-
-    fn insert(&mut self, point: Point) -> bool {
-        if !self.boundary.contains(&point) {
-            return false;
-        }
-
-        if self.points.len() < self.max_points {
-            self.points.insert(0, point);
-            return true;
-        }
-
-        if !self.divided {
-            self.divide();
-        }
-
-        self.north_east.as_mut().unwrap().insert(point.clone())
-        || self.north_west.as_mut().unwrap().insert(point.clone())
-        || self.south_east.as_mut().unwrap().insert(point.clone())
-        || self.south_west.as_mut().unwrap().insert(point.clone())
-
-
-    }
-
-    fn query_rect(&self, boundary: &Rect) -> Vec<Point> {
-        if !self.boundary.intersects(&boundary) {
-            vec![]
-        } else {
-            let mut result: Vec<Point> =
-                self.points.clone().into_iter()
-                .filter(|p| boundary.contains(p))
-                .collect();
-            
-            if self.divided {
-                if let Some(north_east) = &self.north_east {
-                    result.append(&mut north_east.query_rect(boundary))
-                }
-
-                if let Some(north_west) = &self.north_west {
-                    result.append(&mut north_west.query_rect(boundary))
-                }
-
-                if let Some(south_east) = &self.south_east {
-                    result.append(&mut south_east.query_rect(boundary))
-                }
-
-                if let Some(south_west) = &self.south_west {
-                    result.append(&mut south_west.query_rect(boundary))
-                }
-            }
-
-            result
-        }
-    }
-
-    fn query_radius(&self, center_x: f32, center_y: f32, radius: f32) -> Vec<Point> {
-        let boundary = Rect::__new__(center_x, center_y, 2.*radius, 2.*radius);
-        let center_point = Point::__new__(center_x, center_y, None);
-
-        if !self.boundary.intersects(&boundary) {
-            vec![]
-        } else {
-            let mut result: Vec<Point> =
-                self.points.clone().into_iter()
-                .filter(|p| boundary.contains(p))
-                .filter(|p| p.distance_to(&center_point) < radius)
-                .collect();
-
-                if let Some(north_east) = &self.north_east {
-                    result.append(&mut north_east.query_radius(center_x, center_y, radius))
-                }
-
-                if let Some(north_west) = &self.north_west {
-                    result.append(&mut north_west.query_radius(center_x, center_y, radius))
-                }
-
-                if let Some(south_east) = &self.south_east {
-                    result.append(&mut south_east.query_radius(center_x, center_y, radius))
-                }
-
-                if let Some(south_west) = &self.south_west {
-                    result.append(&mut south_west.query_radius(center_x, center_y, radius))
-                }
-
-            result
-        }
-    }
-}
-
-/// A Python module implemented in Rust.
-#[pymodule]
-fn quadtree(_py: Python, m: &PyModule) -> PyResult<()> {
-    m.add_class::<Point>()?;
-    m.add_class::<Rect>()?;
-    m.add_class::<QuadTree>()?;
-    Ok(())
+use std::vec;
+
+use pyo3::prelude::*;
+
+#[pyclass]
+#[derive(Clone)]
+struct Point {
+    #[pyo3(get)]
+    x: f32,
+    #[pyo3(get)]
+    y: f32,
+    #[pyo3(get)]
+    data: Option<PyObject>
+}
+
+#[pyclass]
+#[derive(Clone)]
+struct Rect {
+    center_x: f32,
+    center_y: f32,
+    width: f32,
+    height: f32,
+    west_edge: f32,
+    east_edge: f32,
+    north_edge: f32,
+    south_edge: f32
+}
+
+#[pyclass]
+struct QuadTree {
+    boundary: Rect,
+    max_points: usize,
+    points: Vec<Point>,
+    depth: u32,
+    divided: bool,
+    north_west: Option<Box<Self>>,
+    north_east: Option<Box<Self>>,
+    south_east: Option<Box<Self>>,
+    south_west: Option<Box<Self>>,
+}
+
+#[pymethods]
+impl Point {
+    #[new]
+    fn __new__(x: f32, y: f32, data: Option<PyObject>) -> Self {
+        return Self {
+            x, y, data
+        }
+    }
+
+    fn __repr__(&self) -> String {
+        if let Some(data) = &self.data {
+            std::format!("Point(x={}, y={}, data={})", self.x, self.y, data)
+        } else {
+            std::format!("Point(x={}, y={})", self.x, self.y)
+        }
+    }
+
+    fn __str__(&self) -> String {
+        return self.__repr__()
+    }
+
+    fn distance_to(&self, other: &Point) -> f32 {
+        let x_diff = self.x - other.x;
+        let y_diff = self.y - other.y;
+
+        f32::sqrt(x_diff*x_diff + y_diff*y_diff)
+    }
+}
+
+#[pymethods]
+impl Rect {
+    #[new]
+    fn __new__(center_x: f32, center_y: f32, width: f32, height: f32) -> Self {
+        let west_edge = center_x - (width / 2.);
+        let east_edge = center_x + (width / 2.);
+        let north_edge = center_y - (height / 2.);
+        let south_edge = center_y + (height / 2.);
+
+        Self {
+            center_x,
+            center_y,
+            width,
+            height,
+            west_edge,
+            east_edge,
+            north_edge,
+            south_edge
+        }
+    }
+
+    fn contains(&self, point: &Point) -> bool {
+        point.x >= self.west_edge
+        && point.x < self.east_edge
+        && point.y >= self.north_edge
+        && point.y < self.south_edge
+    }
+
+    fn intersects(&self, rect: &Rect) -> bool {
+        !(
+            rect.west_edge > self.east_edge
+            || rect.east_edge < self.west_edge
+            || rect.north_edge > self.south_edge
+            || rect.south_edge < self.north_edge
+        )
+    }
+}
+
+#[pymethods]
+impl QuadTree {
+    #[new]
+    fn __new__(boundary: Rect, max_points: usize, depth: u32) -> Self {
+        Self {
+            boundary,
+            max_points,
+            depth,
+            divided: false,
+            points: vec![],
+            north_east: None,
+            north_west: None,
+            south_east: None,
+            south_west: None
+        }
+    }
+
+    fn __len__(&self) -> usize {
+        let mut result = self.points.len();
+
+        if self.divided {
+            if let Some(north_east) = &self.north_east {
+                result += north_east.__len__();
+            }
+
+            if let Some(north_west) = &self.north_west {
+                result += north_west.__len__();
+            }
+
+            if let Some(south_east) = &self.south_east {
+                result += south_east.__len__();
+            }
+
+            if let Some(south_west) = &self.south_west {
+                result += south_west.__len__();
+            }
+        }
+
+        result
+    }
+
+    fn divide(&mut self) {
+        let center_x = self.boundary.center_x;
+        let center_y = self.boundary.center_y;
+        let width = self.boundary.width / 2.;
+        let height = self.boundary.height / 2.;
+
+        let boundary = Rect::__new__(
+            center_x - width / 2.,
+            center_y - height / 2.,
+            width, height);
+        let north_west = QuadTree::__new__(
+            boundary,
+            self.max_points, self.depth + 1);
+
+        let boundary = Rect::__new__(
+            center_x + width / 2.,
+            center_y - height / 2.,
+            width, height);
+        let north_east = QuadTree::__new__(
+            boundary,
+            self.max_points, self.depth + 1);
+
+        let boundary = Rect::__new__(
+            center_x + width / 2.,
+            center_y + height / 2.,
+            width, height);
+        let south_east = QuadTree::__new__(
+            boundary,
+            self.max_points, self.depth + 1);
+
+        let boundary = Rect::__new__(
+            center_x - width / 2.,
+            center_y + height / 2.,
+            width, height);
+        let south_west = QuadTree::__new__(
+            boundary,
+            self.max_points, self.depth + 1);
+
+        self.north_west = Some(Box::new(north_west));
+        self.north_east = Some(Box::new(north_east));
+        self.south_east = Some(Box::new(south_east));
+        self.south_west = Some(Box::new(south_west));
+
+        self.divided = true;
+    }
+
+    fn insert(&mut self, point: Point) -> bool {
+        if !self.boundary.contains(&point) {
+            return false;
+        }
+
+        if self.points.len() < self.max_points {
+            self.points.insert(0, point);
+            return true;
+        }
+
+        if !self.divided {
+            self.divide();
+        }
+
+        self.north_east.as_mut().unwrap().insert(point.clone())
+        || self.north_west.as_mut().unwrap().insert(point.clone())
+        || self.south_east.as_mut().unwrap().insert(point.clone())
+        || self.south_west.as_mut().unwrap().insert(point.clone())
+    }
+
+    fn query_rect(&self, boundary: &Rect) -> Vec<Point> {
+        if !self.boundary.intersects(&boundary) {
+            vec![]
+        } else {
+            let mut result: Vec<Point> =
+                self.points.clone().into_iter()
+                .filter(|p| boundary.contains(p))
+                .collect();
+            
+            if self.divided {
+                if let Some(north_east) = &self.north_east {
+                    result.append(&mut north_east.query_rect(boundary))
+                }
+
+                if let Some(north_west) = &self.north_west {
+                    result.append(&mut north_west.query_rect(boundary))
+                }
+
+                if let Some(south_east) = &self.south_east {
+                    result.append(&mut south_east.query_rect(boundary))
+                }
+
+                if let Some(south_west) = &self.south_west {
+                    result.append(&mut south_west.query_rect(boundary))
+                }
+            }
+
+            result
+        }
+    }
+
+    fn query_radius(&self, center_x: f32, center_y: f32, radius: f32) -> Vec<Point> {
+        let boundary = Rect::__new__(center_x, center_y, 2.*radius, 2.*radius);
+        let center_point = Point::__new__(center_x, center_y, None);
+
+        if !self.boundary.intersects(&boundary) {
+            vec![]
+        } else {
+            let mut result: Vec<Point> =
+                self.points.clone().into_iter()
+                .filter(|p| boundary.contains(p))
+                .filter(|p| p.distance_to(&center_point) < radius)
+                .collect();
+
+                if let Some(north_east) = &self.north_east {
+                    result.append(&mut north_east.query_radius(center_x, center_y, radius))
+                }
+
+                if let Some(north_west) = &self.north_west {
+                    result.append(&mut north_west.query_radius(center_x, center_y, radius))
+                }
+
+                if let Some(south_east) = &self.south_east {
+                    result.append(&mut south_east.query_radius(center_x, center_y, radius))
+                }
+
+                if let Some(south_west) = &self.south_west {
+                    result.append(&mut south_west.query_radius(center_x, center_y, radius))
+                }
+
+            result
+        }
+    }
+}
+
+/// A Python module implemented in Rust.
+#[pymodule]
+fn quadtree(_py: Python, m: &PyModule) -> PyResult<()> {
+    m.add_class::<Point>()?;
+    m.add_class::<Rect>()?;
+    m.add_class::<QuadTree>()?;
+    Ok(())
 }
```

